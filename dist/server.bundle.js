/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./server/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@jimp/bmp/es/index.js":
/*!********************************************!*\
  !*** ./node_modules/@jimp/bmp/es/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var bmp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bmp-js */ "./node_modules/bmp-js/index.js");
/* harmony import */ var bmp_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bmp_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var MIME_TYPE = 'image/bmp';
var MIME_TYPE_SECOND = 'image/x-ms-bmp';

function toAGBR(image) {
  return Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["scan"])(image, 0, 0, image.bitmap.width, image.bitmap.height, function (x, y, index) {
    var red = this.bitmap.data[index + 0];
    var green = this.bitmap.data[index + 1];
    var blue = this.bitmap.data[index + 2];
    var alpha = this.bitmap.data[index + 3];
    this.bitmap.data[index + 0] = alpha;
    this.bitmap.data[index + 1] = blue;
    this.bitmap.data[index + 2] = green;
    this.bitmap.data[index + 3] = red;
  }).bitmap;
}

function fromAGBR(bitmap) {
  return Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["scan"])({
    bitmap: bitmap
  }, 0, 0, bitmap.width, bitmap.height, function (x, y, index) {
    var alpha = this.bitmap.data[index + 0];
    var blue = this.bitmap.data[index + 1];
    var green = this.bitmap.data[index + 2];
    var red = this.bitmap.data[index + 3];
    this.bitmap.data[index + 0] = red;
    this.bitmap.data[index + 1] = green;
    this.bitmap.data[index + 2] = blue;
    this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 0xff;
  }).bitmap;
}

var decode = function decode(data) {
  return fromAGBR(bmp_js__WEBPACK_IMPORTED_MODULE_0___default.a.decode(data));
};

var encode = function encode(image) {
  return bmp_js__WEBPACK_IMPORTED_MODULE_0___default.a.encode(toAGBR(image)).data;
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var _decoders, _encoders;

  return {
    mime: _defineProperty({}, MIME_TYPE, ['bmp']),
    constants: {
      MIME_BMP: MIME_TYPE,
      MIME_X_MS_BMP: MIME_TYPE_SECOND
    },
    decoders: (_decoders = {}, _defineProperty(_decoders, MIME_TYPE, decode), _defineProperty(_decoders, MIME_TYPE_SECOND, decode), _decoders),
    encoders: (_encoders = {}, _defineProperty(_encoders, MIME_TYPE, encode), _defineProperty(_encoders, MIME_TYPE_SECOND, encode), _encoders)
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/composite/composite-modes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@jimp/core/es/composite/composite-modes.js ***!
  \*****************************************************************/
/*! exports provided: srcOver, dstOver, multiply, screen, overlay, darken, lighten, hardLight, difference, exclusion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "srcOver", function() { return srcOver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dstOver", function() { return dstOver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "screen", function() { return screen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "overlay", function() { return overlay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darken", function() { return darken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lighten", function() { return lighten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hardLight", function() { return hardLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return difference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exclusion", function() { return exclusion; });
function srcOver(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
  var g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
  var b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function dstOver(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
  var g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
  var b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function multiply(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  var g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  var b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function screen(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  var g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  var b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function overlay(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
  var g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
  var b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function darken(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  var g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  var b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function lighten(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  var g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  var b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function hardLight(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
  var g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
  var b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function difference(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
  var g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
  var b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function exclusion(src, dst) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  var a = dst.a + src.a - dst.a * src.a;
  var sra = src.r * src.a;
  var sga = src.g * src.a;
  var sba = src.b * src.a;
  var dra = dst.r * dst.a;
  var dga = dst.g * dst.a;
  var dba = dst.b * dst.a;
  var r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  var g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  var b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
//# sourceMappingURL=composite-modes.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/composite/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jimp/core/es/composite/index.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return composite; });
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@jimp/core/es/constants.js");
/* harmony import */ var _composite_modes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./composite-modes */ "./node_modules/@jimp/core/es/composite/composite-modes.js");



/**
 * Composites a source image over to this image respecting alpha channels
 * @param {Jimp} src the source Jimp instance
 * @param {number} x the x position to blit the image
 * @param {number} y the y position to blit the image
 * @param {object} options determine what mode to use
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

function composite(src, x, y) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var cb = arguments.length > 4 ? arguments[4] : undefined;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (!(src instanceof this.constructor)) {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'The source must be a Jimp image', cb);
  }

  if (typeof x !== 'number' || typeof y !== 'number') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'x and y must be numbers', cb);
  }

  var _options = options,
      mode = _options.mode,
      opacitySource = _options.opacitySource,
      opacityDest = _options.opacityDest;

  if (!mode) {
    mode = _constants__WEBPACK_IMPORTED_MODULE_1__["BLEND_SOURCE_OVER"];
  }

  if (typeof opacitySource !== 'number' || opacitySource < 0 || opacitySource > 1) {
    opacitySource = 1.0;
  }

  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {
    opacityDest = 1.0;
  }

  var blendmode = _composite_modes__WEBPACK_IMPORTED_MODULE_2__[mode]; // round input

  x = Math.round(x);
  y = Math.round(y);
  var baseImage = this;

  if (opacityDest !== 1.0) {
    baseImage.opacity(opacityDest);
  }

  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {
    var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, _constants__WEBPACK_IMPORTED_MODULE_1__["EDGE_CROP"]);
    var blended = blendmode({
      r: this.bitmap.data[idx + 0] / 255,
      g: this.bitmap.data[idx + 1] / 255,
      b: this.bitmap.data[idx + 2] / 255,
      a: this.bitmap.data[idx + 3] / 255
    }, {
      r: baseImage.bitmap.data[dstIdx + 0] / 255,
      g: baseImage.bitmap.data[dstIdx + 1] / 255,
      b: baseImage.bitmap.data[dstIdx + 2] / 255,
      a: baseImage.bitmap.data[dstIdx + 3] / 255
    }, opacitySource);
    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);
    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);
    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);
    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);
  });

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
    cb.call(this, null, this);
  }

  return this;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/@jimp/core/es/constants.js ***!
  \*************************************************/
/*! exports provided: AUTO, HORIZONTAL_ALIGN_LEFT, HORIZONTAL_ALIGN_CENTER, HORIZONTAL_ALIGN_RIGHT, VERTICAL_ALIGN_TOP, VERTICAL_ALIGN_MIDDLE, VERTICAL_ALIGN_BOTTOM, BLEND_SOURCE_OVER, BLEND_DESTINATION_OVER, BLEND_MULTIPLY, BLEND_SCREEN, BLEND_OVERLAY, BLEND_DARKEN, BLEND_LIGHTEN, BLEND_HARDLIGHT, BLEND_DIFFERENCE, BLEND_EXCLUSION, EDGE_EXTEND, EDGE_WRAP, EDGE_CROP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTO", function() { return AUTO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL_ALIGN_LEFT", function() { return HORIZONTAL_ALIGN_LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL_ALIGN_CENTER", function() { return HORIZONTAL_ALIGN_CENTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL_ALIGN_RIGHT", function() { return HORIZONTAL_ALIGN_RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL_ALIGN_TOP", function() { return VERTICAL_ALIGN_TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL_ALIGN_MIDDLE", function() { return VERTICAL_ALIGN_MIDDLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL_ALIGN_BOTTOM", function() { return VERTICAL_ALIGN_BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_SOURCE_OVER", function() { return BLEND_SOURCE_OVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_DESTINATION_OVER", function() { return BLEND_DESTINATION_OVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_MULTIPLY", function() { return BLEND_MULTIPLY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_SCREEN", function() { return BLEND_SCREEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_OVERLAY", function() { return BLEND_OVERLAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_DARKEN", function() { return BLEND_DARKEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_LIGHTEN", function() { return BLEND_LIGHTEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_HARDLIGHT", function() { return BLEND_HARDLIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_DIFFERENCE", function() { return BLEND_DIFFERENCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_EXCLUSION", function() { return BLEND_EXCLUSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDGE_EXTEND", function() { return EDGE_EXTEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDGE_WRAP", function() { return EDGE_WRAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDGE_CROP", function() { return EDGE_CROP; });
// used to auto resizing etc.
var AUTO = -1; // Align modes for cover, contain, bit masks

var HORIZONTAL_ALIGN_LEFT = 1;
var HORIZONTAL_ALIGN_CENTER = 2;
var HORIZONTAL_ALIGN_RIGHT = 4;
var VERTICAL_ALIGN_TOP = 8;
var VERTICAL_ALIGN_MIDDLE = 16;
var VERTICAL_ALIGN_BOTTOM = 32; // blend modes

var BLEND_SOURCE_OVER = 'srcOver';
var BLEND_DESTINATION_OVER = 'dstOver';
var BLEND_MULTIPLY = 'multiply';
var BLEND_SCREEN = 'screen';
var BLEND_OVERLAY = 'overlay';
var BLEND_DARKEN = 'darken';
var BLEND_LIGHTEN = 'lighten';
var BLEND_HARDLIGHT = 'hardLight';
var BLEND_DIFFERENCE = 'difference';
var BLEND_EXCLUSION = 'exclusion'; // Edge Handling

var EDGE_EXTEND = 1;
var EDGE_WRAP = 2;
var EDGE_CROP = 3;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@jimp/core/es/index.js ***!
  \*********************************************/
/*! exports provided: addConstants, addJimpMethods, jimpEvMethod, jimpEvChange, addType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addConstants", function() { return addConstants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addJimpMethods", function() { return addJimpMethods; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jimpEvMethod", function() { return jimpEvMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jimpEvChange", function() { return jimpEvChange; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
/* harmony import */ var any_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! any-base */ "./node_modules/any-base/index.js");
/* harmony import */ var any_base__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(any_base__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var mkdirp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mkdirp */ "mkdirp");
/* harmony import */ var mkdirp__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(mkdirp__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var pixelmatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! pixelmatch */ "./node_modules/pixelmatch/index.js");
/* harmony import */ var pixelmatch__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(pixelmatch__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tinycolor2 */ "./node_modules/tinycolor2/tinycolor.js");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(tinycolor2__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _modules_phash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/phash */ "./node_modules/@jimp/core/es/modules/phash.js");
/* harmony import */ var _modules_phash__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_modules_phash__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./request */ "./node_modules/@jimp/core/es/request.js");
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_request__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _composite__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./composite */ "./node_modules/@jimp/core/es/composite/index.js");
/* harmony import */ var _utils_promisify__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/promisify */ "./node_modules/@jimp/core/es/utils/promisify.js");
/* harmony import */ var _utils_mime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/mime */ "./node_modules/@jimp/core/es/utils/mime.js");
/* harmony import */ var _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/image-bitmap */ "./node_modules/@jimp/core/es/utils/image-bitmap.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./constants */ "./node_modules/@jimp/core/es/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addType", function() { return _utils_mime__WEBPACK_IMPORTED_MODULE_12__["addType"]; });

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
















var alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'; // an array storing the maximum string length of hashes at various bases
// 0 and 1 do not exist as possible hash lengths

var maxHashLength = [NaN, NaN];

for (var i = 2; i < 65; i++) {
  var maxHash = any_base__WEBPACK_IMPORTED_MODULE_4___default()(any_base__WEBPACK_IMPORTED_MODULE_4___default.a.BIN, alphabet.slice(0, i))(new Array(64 + 1).join('1'));
  maxHashLength.push(maxHash.length);
} // no operation


function noop() {} // error checking methods


function isArrayBuffer(test) {
  return Object.prototype.toString.call(test).toLowerCase().indexOf('arraybuffer') > -1;
} // Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,
// But this function is not useful when running in node directly


function bufferFromArrayBuffer(arrayBuffer) {
  var buffer = Buffer.alloc(arrayBuffer.byteLength);
  var view = new Uint8Array(arrayBuffer);

  for (var _i = 0; _i < buffer.length; ++_i) {
    buffer[_i] = view[_i];
  }

  return buffer;
}

function loadFromURL(options, cb) {
  _request__WEBPACK_IMPORTED_MODULE_9___default()(options, function (err, response, data) {
    if (err) {
      return cb(err);
    }

    if (_typeof(data) === 'object' && Buffer.isBuffer(data)) {
      return cb(null, data);
    }

    var msg = 'Could not load Buffer from <' + options.url + '> ' + '(HTTP: ' + response.statusCode + ')';
    return new Error(msg);
  });
}

function loadBufferFromPath(src, cb) {
  if (fs__WEBPACK_IMPORTED_MODULE_0___default.a && typeof fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFile === 'function' && !src.match(/^(http|ftp)s?:\/\/./)) {
    fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFile(src, cb);
  } else {
    loadFromURL({
      url: src
    }, cb);
  }
}

function isRawRGBAData(obj) {
  return obj && _typeof(obj) === 'object' && typeof obj.width === 'number' && typeof obj.height === 'number' && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === 'function' && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
}

function makeRGBABufferFromRGB(buffer) {
  if (buffer.length % 3 !== 0) {
    throw new Error('Buffer length is incorrect');
  }

  var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);
  var j = 0;

  for (var _i2 = 0; _i2 < buffer.length; _i2++) {
    rgbaBuffer[j] = buffer[_i2];

    if ((_i2 + 1) % 3 === 0) {
      rgbaBuffer[++j] = 255;
    }

    j++;
  }

  return rgbaBuffer;
}

var emptyBitmap = {
  data: null,
  width: null,
  height: null
};
/**
 * Jimp constructor (from a file)
 * @param path a path to the image
 * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap
 */

/**
 * Jimp constructor (from a url with options)
 * @param options { url, otherOptions}
 * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap
 */

/**
 * Jimp constructor (from another Jimp image or raw image data)
 * @param image a Jimp image to clone
 * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap
 */

/**
 * Jimp constructor (from a Buffer)
 * @param data a Buffer containing the image data
 * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap
 */

/**
 * Jimp constructor (to generate a new image)
 * @param w the width of the image
 * @param h the height of the image
 * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap
 */

/**
 * Jimp constructor (to generate a new image)
 * @param w the width of the image
 * @param h the height of the image
 * @param background color to fill the image with
 * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap
 */

var Jimp =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Jimp, _EventEmitter);

  // An object representing a bitmap in memory, comprising:
  //  - data: a buffer of the bitmap data
  //  - width: the width of the image in pixels
  //  - height: the height of the image in pixels
  // Default colour to use for new pixels
  // Default MIME is PNG
  // Exif data for the image
  // Whether Transparency supporting formats will be exported as RGB or RGBA
  function Jimp() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _classCallCheck(this, Jimp);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Jimp).call(this));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "bitmap", emptyBitmap);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_background", 0x00000000);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_originalMime", Jimp.MIME_PNG);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_exif", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_rgba", true);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "writeAsync", function (path) {
      return Object(_utils_promisify__WEBPACK_IMPORTED_MODULE_11__["default"])(_this.write, _assertThisInitialized(_assertThisInitialized(_this)), path);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getBase64Async", function (mime) {
      return Object(_utils_promisify__WEBPACK_IMPORTED_MODULE_11__["default"])(_this.getBase64, _assertThisInitialized(_assertThisInitialized(_this)), mime);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getBuffer", _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_13__["getBuffer"]);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getBufferAsync", _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_13__["getBufferAsync"]);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getPixelColour", _this.getPixelColor);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setPixelColour", _this.setPixelColor);

    var jimpInstance = _assertThisInitialized(_assertThisInitialized(_this));

    var cb = noop;

    if (isArrayBuffer(args[0])) {
      args[0] = bufferFromArrayBuffer(args[0]);
    }

    function finish() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var err = args[0];
      var evData = err || {};
      evData.methodName = 'constructor';
      setTimeout(function () {
        var _cb;

        // run on next tick.
        if (err && cb === noop) {
          jimpInstance.emitError('constructor', err);
        } else if (!err) {
          jimpInstance.emitMulti('constructor', 'initialized');
        }

        (_cb = cb).call.apply(_cb, [jimpInstance].concat(args));
      }, 1);
    }

    if (typeof args[0] === 'number' && typeof args[1] === 'number' || parseInt(args[0], 10) && parseInt(args[1], 10)) {
      // create a new image
      var w = parseInt(args[0], 10);
      var h = parseInt(args[1], 10);
      cb = args[2]; // with a hex color

      if (typeof args[2] === 'number') {
        _this._background = args[2];
        cb = args[3];
      } // with a css color


      if (typeof args[2] === 'string') {
        _this._background = Jimp.cssColorToHex(args[2]);
        cb = args[3];
      }

      if (typeof cb === 'undefined') {
        cb = noop;
      }

      if (typeof cb !== 'function') {
        return _possibleConstructorReturn(_this, _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), 'cb must be a function', finish));
      }

      _this.bitmap = {
        data: Buffer.alloc(w * h * 4),
        width: w,
        height: h
      };

      for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) {
        _this.bitmap.data.writeUInt32BE(_this._background, _i3);
      }

      finish(null, _assertThisInitialized(_assertThisInitialized(_this)));
    } else if (_typeof(args[0]) === 'object' && args[0].url) {
      cb = args[1] || noop;

      if (typeof cb !== 'function') {
        return _possibleConstructorReturn(_this, _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), 'cb must be a function', finish));
      }

      loadFromURL(args[0], function (err, data) {
        if (err) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), err, finish);
        }

        _this.parseBitmap(data, args[0].url, finish);
      });
    } else if (args[0] instanceof Jimp) {
      // clone an existing Jimp
      var original = args[0];
      cb = args[1];

      if (typeof cb === 'undefined') {
        cb = noop;
      }

      if (typeof cb !== 'function') {
        return _possibleConstructorReturn(_this, _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), 'cb must be a function', finish));
      }

      _this.bitmap = {
        data: Buffer.from(original.bitmap.data),
        width: original.bitmap.width,
        height: original.bitmap.height
      };
      _this._quality = original._quality;
      _this._deflateLevel = original._deflateLevel;
      _this._deflateStrategy = original._deflateStrategy;
      _this._filterType = original._filterType;
      _this._rgba = original._rgba;
      _this._background = original._background;
      _this._originalMime = original._originalMime;
      finish(null, _assertThisInitialized(_assertThisInitialized(_this)));
    } else if (isRawRGBAData(args[0])) {
      var imageData = args[0];
      cb = args[1] || noop;
      var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;
      var buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
      _this.bitmap = {
        data: buffer,
        width: imageData.width,
        height: imageData.height
      };
      finish(null, _assertThisInitialized(_assertThisInitialized(_this)));
    } else if (typeof args[0] === 'string') {
      // read from a path
      var path = args[0];
      cb = args[1];

      if (typeof cb === 'undefined') {
        cb = noop;
      }

      if (typeof cb !== 'function') {
        return _possibleConstructorReturn(_this, _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), 'cb must be a function', finish));
      }

      loadBufferFromPath(path, function (err, data) {
        if (err) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), err, finish);
        }

        _this.parseBitmap(data, path, finish);
      });
    } else if (_typeof(args[0]) === 'object' && Buffer.isBuffer(args[0])) {
      // read from a buffer
      var data = args[0];
      cb = args[1];

      if (typeof cb !== 'function') {
        return _possibleConstructorReturn(_this, _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), 'cb must be a function', finish));
      }

      _this.parseBitmap(data, null, finish);
    } else {
      // Allow client libs to add new ways to build a Jimp object.
      // Extra constructors must be added by `Jimp.appendConstructorOption()`
      cb = args[args.length - 1];

      if (typeof cb !== 'function') {
        // TODO: try to solve the args after cb problem.
        cb = args[args.length - 2];

        if (typeof cb !== 'function') {
          cb = noop;
        }
      }

      var extraConstructor = Jimp.__extraConstructors.find(function (c) {
        return c.test.apply(c, args);
      });

      if (extraConstructor) {
        new Promise(function (resolve, reject) {
          var _extraConstructor$run;

          return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [_assertThisInitialized(_assertThisInitialized(_this)), resolve, reject].concat(args));
        }).then(function () {
          return finish(null, _assertThisInitialized(_assertThisInitialized(_this)));
        }).catch(finish);
      } else {
        return _possibleConstructorReturn(_this, _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_assertThisInitialized(_assertThisInitialized(_this)), 'No matching constructor overloading was found. ' + 'Please see the docs for how to call the Jimp constructor.', finish));
      }
    }

    return _this;
  }
  /**
   * Parse a bitmap with the loaded image types.
   *
   * @param {Buffer} data raw image data
   * @param {string} path optional path to file
   * @param {function(Error, Jimp)} cb (optional) a callback for when complete
   * @memberof Jimp
   */


  _createClass(Jimp, [{
    key: "parseBitmap",
    value: function parseBitmap(data, path, finish) {
      _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_13__["parseBitmap"].call(this, data, null, finish);
    }
    /**
     * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
     * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp} this for chaining of methods
     */

  }, {
    key: "rgba",
    value: function rgba(bool, cb) {
      if (typeof bool !== 'boolean') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'bool must be a boolean, true for RGBA or false for RGB', cb);
      }

      this._rgba = bool;

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
    /**
     * Emit for multiple listeners
     * @param {string} methodName name of the method to emit an error for
     * @param {string} eventName name of the eventName to emit an error for
     * @param {object} data to emit
     */

  }, {
    key: "emitMulti",
    value: function emitMulti(methodName, eventName) {
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      data = Object.assign(data, {
        methodName: methodName,
        eventName: eventName
      });
      this.emit('any', data);

      if (methodName) {
        this.emit(methodName, data);
      }

      this.emit(eventName, data);
    }
  }, {
    key: "emitError",
    value: function emitError(methodName, err) {
      this.emitMulti(methodName, 'error', err);
    }
    /**
     * Get the current height of the image
     * @return {number} height of the image
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.bitmap.height;
    }
    /**
     * Get the current width of the image
     * @return {number} width of the image
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.bitmap.width;
    }
    /**
     * Nicely format Jimp object when sent to the console e.g. console.log(image)
     * @returns {string} pretty printed
     */

  }, {
    key: "inspect",
    value: function inspect() {
      return '<Jimp ' + (this.bitmap === emptyBitmap ? 'pending...' : this.bitmap.width + 'x' + this.bitmap.height) + '>';
    }
    /**
     * Nicely format Jimp object when converted to a string
     * @returns {string} pretty printed
     */

  }, {
    key: "toString",
    value: function toString() {
      return '[object Jimp]';
    }
    /**
     * Returns the original MIME of the image (default: "image/png")
     * @returns {string} the MIME
     */

  }, {
    key: "getMIME",
    value: function getMIME() {
      var mime = this._originalMime || Jimp.MIME_PNG;
      return mime;
    }
    /**
     * Returns the appropriate file extension for the original MIME of the image (default: "png")
     * @returns {string} the file extension
     */

  }, {
    key: "getExtension",
    value: function getExtension() {
      var mime = this.getMIME();
      return _utils_mime__WEBPACK_IMPORTED_MODULE_12__["getExtension"](mime);
    }
    /**
     * Writes the image to a file
     * @param {string} path a path to the destination file
     * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
     * @returns {Jimp} this for chaining of methods
     */

  }, {
    key: "write",
    value: function write(path, cb) {
      var _this2 = this;

      if (!fs__WEBPACK_IMPORTED_MODULE_0___default.a || !fs__WEBPACK_IMPORTED_MODULE_0___default.a.createWriteStream) {
        throw new Error('Cant access the filesystem. You can use the getBase64 method.');
      }

      if (typeof path !== 'string') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'path must be a string', cb);
      }

      if (typeof cb === 'undefined') {
        cb = noop;
      }

      if (typeof cb !== 'function') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'cb must be a function', cb);
      }

      var mime = _utils_mime__WEBPACK_IMPORTED_MODULE_12__["getType"](path) || this.getMIME();
      var pathObj = path__WEBPACK_IMPORTED_MODULE_1___default.a.parse(path);

      if (pathObj.dir) {
        mkdirp__WEBPACK_IMPORTED_MODULE_5___default.a.sync(pathObj.dir);
      }

      this.getBuffer(mime, function (err, buffer) {
        if (err) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_this2, err, cb);
        }

        var stream = fs__WEBPACK_IMPORTED_MODULE_0___default.a.createWriteStream(path);
        stream.on('open', function () {
          stream.write(buffer);
          stream.end();
        }).on('error', function (err) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(_this2, err, cb);
        });
        stream.on('finish', function () {
          cb.call(_this2, null, _this2);
        });
      });
      return this;
    }
  }, {
    key: "getBase64",

    /**
     * Converts the image to a base 64 string
     * @param {string} mime the mime type of the image data to be created
     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
     * @returns {Jimp} this for chaining of methods
     */
    value: function getBase64(mime, cb) {
      if (mime === Jimp.AUTO) {
        // allow auto MIME detection
        mime = this.getMIME();
      }

      if (typeof mime !== 'string') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'mime must be a string', cb);
      }

      if (typeof cb !== 'function') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'cb must be a function', cb);
      }

      this.getBuffer(mime, function (err, data) {
        if (err) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, err, cb);
        }

        var src = 'data:' + mime + ';base64,' + data.toString('base64');
        cb.call(this, null, src);
      });
      return this;
    }
  }, {
    key: "hash",

    /**
     * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
     * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {string} a string representing the hash
     */
    value: function hash(base, cb) {
      base = base || 64;

      if (typeof base === 'function') {
        cb = base;
        base = 64;
      }

      if (typeof base !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'base must be a number', cb);
      }

      if (base < 2 || base > 64) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'base must be a number between 2 and 64', cb);
      }

      var hash = this.pHash();
      hash = any_base__WEBPACK_IMPORTED_MODULE_4___default()(any_base__WEBPACK_IMPORTED_MODULE_4___default.a.BIN, alphabet.slice(0, base))(hash);

      while (hash.length < maxHashLength[base]) {
        hash = '0' + hash; // pad out with leading zeros
      }

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
        cb.call(this, null, hash);
      }

      return hash;
    }
    /**
     * Calculates the perceptual hash
     * @returns {number} the perceptual hash
     */

  }, {
    key: "pHash",
    value: function pHash() {
      var pHash = new _modules_phash__WEBPACK_IMPORTED_MODULE_8___default.a();
      return pHash.getHash(this);
    }
    /**
     * Calculates the hamming distance of the current image and a hash based on their perceptual hash
     * @param {hash} compareHash hash to compare to
     * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
     */

  }, {
    key: "distanceFromHash",
    value: function distanceFromHash(compareHash) {
      var pHash = new _modules_phash__WEBPACK_IMPORTED_MODULE_8___default.a();
      var currentHash = pHash.getHash(this);
      return pHash.distance(currentHash, compareHash);
    }
    /**
     * Converts the image to a buffer
     * @param {string} mime the mime type of the image buffer to be created
     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
     * @returns {Jimp} this for chaining of methods
     */

  }, {
    key: "getPixelIndex",

    /**
     * Returns the offset of a pixel in the bitmap buffer
     * @param {number} x the x coordinate
     * @param {number} y the y coordinate
     * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
     * @param {number} cb (optional) a callback for when complete
     * @returns {number} the index of the pixel or -1 if not found
     */
    value: function getPixelIndex(x, y, edgeHandling, cb) {
      var xi;
      var yi;

      if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {
        cb = edgeHandling;
        edgeHandling = null;
      }

      if (!edgeHandling) {
        edgeHandling = Jimp.EDGE_EXTEND;
      }

      if (typeof x !== 'number' || typeof y !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'x and y must be numbers', cb);
      } // round input


      x = Math.round(x);
      y = Math.round(y);
      xi = x;
      yi = y;

      if (edgeHandling === Jimp.EDGE_EXTEND) {
        if (x < 0) xi = 0;
        if (x >= this.bitmap.width) xi = this.bitmap.width - 1;
        if (y < 0) yi = 0;
        if (y >= this.bitmap.height) yi = this.bitmap.height - 1;
      }

      if (edgeHandling === Jimp.EDGE_WRAP) {
        if (x < 0) {
          xi = this.bitmap.width + x;
        }

        if (x >= this.bitmap.width) {
          xi = x % this.bitmap.width;
        }

        if (y < 0) {
          xi = this.bitmap.height + y;
        }

        if (y >= this.bitmap.height) {
          yi = y % this.bitmap.height;
        }
      }

      var i = this.bitmap.width * yi + xi << 2; // if out of bounds index is -1

      if (xi < 0 || xi >= this.bitmap.width) {
        i = -1;
      }

      if (yi < 0 || yi >= this.bitmap.height) {
        i = -1;
      }

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
        cb.call(this, null, i);
      }

      return i;
    }
    /**
     * Returns the hex colour value of a pixel
     * @param {number} x the x coordinate
     * @param {number} y the y coordinate
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {number} the color of the pixel
     */

  }, {
    key: "getPixelColor",
    value: function getPixelColor(x, y, cb) {
      if (typeof x !== 'number' || typeof y !== 'number') return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'x and y must be numbers', cb); // round input

      x = Math.round(x);
      y = Math.round(y);
      var idx = this.getPixelIndex(x, y);
      var hex = this.bitmap.data.readUInt32BE(idx);

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
        cb.call(this, null, hex);
      }

      return hex;
    }
  }, {
    key: "setPixelColor",

    /**
     * Returns the hex colour value of a pixel
     * @param {number} hex color to set
     * @param {number} x the x coordinate
     * @param {number} y the y coordinate
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {number} the index of the pixel or -1 if not found
     */
    value: function setPixelColor(hex, x, y, cb) {
      if (typeof hex !== 'number' || typeof x !== 'number' || typeof y !== 'number') return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'hex, x and y must be numbers', cb); // round input

      x = Math.round(x);
      y = Math.round(y);
      var idx = this.getPixelIndex(x, y);
      this.bitmap.data.writeUInt32BE(hex, idx);

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  }, {
    key: "hasAlpha",

    /**
     * Determine if the image contains opaque pixels.
     * @return {boolean} hasAlpha whether the image contains opaque pixels
     */
    value: function hasAlpha() {
      for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) {
        for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
          var idx = this.bitmap.width * yIndex + xIndex << 2;
          var alpha = this.bitmap.data[idx + 3];

          if (alpha !== 0xff) {
            return true;
          }
        }
      }

      return false;
    }
  }]);

  return Jimp;
}(events__WEBPACK_IMPORTED_MODULE_2___default.a);

function addConstants(constants) {
  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;
  Object.entries(constants).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        value = _ref2[1];

    jimpInstance[name] = value;
  });
}
function addJimpMethods(methods) {
  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;
  Object.entries(methods).forEach(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        value = _ref4[1];

    jimpInstance.prototype[name] = value;
  });
}
addConstants(_constants__WEBPACK_IMPORTED_MODULE_14__);
addJimpMethods({
  composite: _composite__WEBPACK_IMPORTED_MODULE_10__["default"]
});
Jimp.__extraConstructors = [];
/**
 * Allow client libs to add new ways to build a Jimp object.
 * @param {string} name identify the extra constructor.
 * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.
 * @param {function} run where the magic happens.
 */

Jimp.appendConstructorOption = function (name, test, run) {
  Jimp.__extraConstructors.push({
    name: name,
    test: test,
    run: run
  });
};
/**
 * Read an image from a file or a Buffer. Takes the same args as the constructor
 * @returns {Promise} a promise
 */


Jimp.read = function () {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return new Promise(function (resolve, reject) {
    _construct(Jimp, args.concat([function (err, image) {
      if (err) reject(err);else resolve(image);
    }]));
  });
};

Jimp.create = Jimp.read;
/**
 * A static helper method that converts RGBA values to a single integer value
 * @param {number} r the red value (0-255)
 * @param {number} g the green value (0-255)
 * @param {number} b the blue value (0-255)
 * @param {number} a the alpha value (0-255)
 * @param {function(Error, Jimp)} cb (optional) A callback for when complete
 * @returns {number} an single integer colour value
 */

Jimp.rgbaToInt = function (r, g, b, a, cb) {
  if (typeof r !== 'number' || typeof g !== 'number' || typeof b !== 'number' || typeof a !== 'number') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'r, g, b and a must be numbers', cb);
  }

  if (r < 0 || r > 255) {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'r must be between 0 and 255', cb);
  }

  if (g < 0 || g > 255) {
    _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'g must be between 0 and 255', cb);
  }

  if (b < 0 || b > 255) {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'b must be between 0 and 255', cb);
  }

  if (a < 0 || a > 255) {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'a must be between 0 and 255', cb);
  }

  r = Math.round(r);
  b = Math.round(b);
  g = Math.round(g);
  a = Math.round(a);
  var i = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
    cb.call(this, null, i);
  }

  return i;
};
/**
 * A static helper method that converts RGBA values to a single integer value
 * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)
 * @param {function(Error, Jimp)} cb (optional) A callback for when complete
 * @returns {object} an object with the properties r, g, b and a representing RGBA values
 */


Jimp.intToRGBA = function (i, cb) {
  if (typeof i !== 'number') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'i must be a number', cb);
  }

  var rgba = {};
  rgba.r = Math.floor(i / Math.pow(256, 3));
  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
    cb.call(this, null, rgba);
  }

  return rgba;
};
/**
 * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number
 * @param {string} cssColor a number
 * @returns {number} a hex number representing a color
 */


Jimp.cssColorToHex = function (cssColor) {
  cssColor = cssColor || 0; // 0, null, undefined, NaN

  if (typeof cssColor === 'number') return Number(cssColor);
  return parseInt(tinycolor2__WEBPACK_IMPORTED_MODULE_7___default()(cssColor).toHex8(), 16);
};
/**
 * Limits a number to between 0 or 255
 * @param {number} n a number
 * @returns {number} the number limited to between 0 or 255
 */


Jimp.limit255 = function (n) {
  n = Math.max(n, 0);
  n = Math.min(n, 255);
  return n;
};
/**
 * Diffs two images and returns
 * @param {Jimp} img1 a Jimp image to compare
 * @param {Jimp} img2 a Jimp image to compare
 * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)
 * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }
 */


Jimp.diff = function (img1, img2) {
  var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp)) return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'img1 and img2 must be an Jimp images');
  var bmp1 = img1.bitmap;
  var bmp2 = img2.bitmap;

  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {
    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {
      // img1 is bigger
      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);
    } else {
      // img2 is bigger (or they are the same in area)
      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);
    }
  }

  if (typeof threshold !== 'number' || threshold < 0 || threshold > 1) {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'threshold must be a number between 0 and 1');
  }

  var diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);
  var numDiffPixels = pixelmatch__WEBPACK_IMPORTED_MODULE_6___default()(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
    threshold: threshold
  });
  return {
    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
    image: diff
  };
};
/**
 * Calculates the hamming distance of two images based on their perceptual hash
 * @param {Jimp} img1 a Jimp image to compare
 * @param {Jimp} img2 a Jimp image to compare
 * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
 */


Jimp.distance = function (img1, img2) {
  var phash = new _modules_phash__WEBPACK_IMPORTED_MODULE_8___default.a();
  var hash1 = phash.getHash(img1);
  var hash2 = phash.getHash(img2);
  return phash.distance(hash1, hash2);
};
/**
 * Calculates the hamming distance of two images based on their perceptual hash
 * @param {hash} hash1 a pHash
 * @param {hash} hash2 a pHash
 * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
 */


Jimp.compareHashes = function (hash1, hash2) {
  var phash = new _modules_phash__WEBPACK_IMPORTED_MODULE_8___default.a();
  return phash.distance(hash1, hash2);
};
/**
 * Compute color difference
 * 0 means no difference, 1 means maximum difference.
 * @param {number} rgba1:    first color to compare.
 * @param {number} rgba2:    second color to compare.
 * Both parameters must be an color object {r:val, g:val, b:val, a:val}
 * Where `a` is optional and `val` is an integer between 0 and 255.
 * @returns {number} float between 0 and 1.
 */


Jimp.colorDiff = function (rgba1, rgba2) {
  var pow = function pow(n) {
    return Math.pow(n, 2);
  };

  var max = Math.max;
  var maxVal = 255 * 255 * 3;

  if (rgba1.a !== 0 && !rgba1.a) {
    rgba1.a = 255;
  }

  if (rgba2.a !== 0 && !rgba2.a) {
    rgba2.a = 255;
  }

  return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;
};
/**
 * Helper to create Jimp methods that emit events before and after its execution.
 * @param {string} methodName   The name to be appended to Jimp prototype.
 * @param {string} evName       The event name to be called.
 *                     It will be prefixed by `before-` and emitted when on method call.
 *                     It will be appended by `ed` and emitted after the method run.
 * @param {function} method       A function implementing the method itself.
 * It will also create a quiet version that will not emit events, to not
 * mess the user code with many `changed` event calls. You can call with
 * `methodName + "Quiet"`.
 *
 * The emitted event comes with a object parameter to the listener with the
 * `methodName` as one attribute.
 */


function jimpEvMethod(methodName, evName, method) {
  var evNameBefore = 'before-' + evName;
  var evNameAfter = evName.replace(/e$/, '') + 'ed';

  Jimp.prototype[methodName] = function () {
    var wrappedCb;

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    var cb = args[method.length - 1];
    var jimpInstance = this;

    if (typeof cb === 'function') {
      wrappedCb = function wrappedCb() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        var err = args[0],
            data = args[1];

        if (err) {
          jimpInstance.emitError(methodName, err);
        } else {
          jimpInstance.emitMulti(methodName, evNameAfter, _defineProperty({}, methodName, data));
        }

        cb.apply(this, args);
      };

      args[args.length - 1] = wrappedCb;
    } else {
      wrappedCb = false;
    }

    this.emitMulti(methodName, evNameBefore);
    var result;

    try {
      result = method.apply(this, args);

      if (!wrappedCb) {
        this.emitMulti(methodName, evNameAfter, _defineProperty({}, methodName, result));
      }
    } catch (error) {
      error.methodName = methodName;
      this.emitError(methodName, error);
    }

    return result;
  };

  Jimp.prototype[methodName + 'Quiet'] = method;
}
/**
 * Creates a new image that is a clone of this one.
 * @param {function(Error, Jimp)} cb (optional) A callback for when complete
 * @returns the new image
 */

jimpEvMethod('clone', 'clone', function (cb) {
  var clone = new Jimp(this);

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
    cb.call(clone, null, clone);
  }

  return clone;
});
/**
 * Simplify jimpEvMethod call for the common `change` evName.
 * @param {string} methodName name of the method
 * @param {function} method to watch changes for
 */

function jimpEvChange(methodName, method) {
  jimpEvMethod(methodName, 'change', method);
}
/**
 * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)
 * @param b A Boolean, true to use RGBA or false to use RGB
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

jimpEvChange('background', function (hex, cb) {
  if (typeof hex !== 'number') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'hex must be a hexadecimal rgba value', cb);
  }

  this._background = hex;

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
    cb.call(this, null, this);
  }

  return this;
});
/**
 * Scans through a region of the bitmap, calling a function for each pixel.
 * @param {number} x the x coordinate to begin the scan at
 * @param {number} y the y coordinate to begin the scan at
 * @param w the width of the scan region
 * @param h the height of the scan region
 * @param f a function to call on even pixel; the (x, y) position of the pixel
 * and the index of the pixel in the bitmap buffer are passed to the function
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

jimpEvChange('scan', function (x, y, w, h, f, cb) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'x and y must be numbers', cb);
  }

  if (typeof w !== 'number' || typeof h !== 'number') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'w and h must be numbers', cb);
  }

  if (typeof f !== 'function') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__["throwError"].call(this, 'f must be a function', cb);
  }

  var result = Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["scan"])(this, x, y, w, h, f);

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_3__["isNodePattern"])(cb)) {
    cb.call(this, null, result);
  }

  return result;
});

if (process.env.ENVIRONMENT === 'BROWSER') {
  // For use in a web browser or web worker

  /* global self */
  var gl;

  if (typeof window !== 'undefined' && (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
    gl = window;
  }

  if (typeof self !== 'undefined' && (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object') {
    gl = self;
  }

  gl.Jimp = Jimp;
  gl.Buffer = Buffer;
}


/* harmony default export */ __webpack_exports__["default"] = (Jimp);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/modules/phash.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/core/es/modules/phash.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
Copyright (c) 2011 Elliot Shepherd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
// https://code.google.com/p/ironchef-team21/source/browse/ironchef_team21/src/ImagePHash.java

/*
 * pHash-like image hash.
 * Author: Elliot Shepherd (elliot@jarofworms.com
 * Based On: http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html
 */
function ImagePHash(size, smallerSize) {
  this.size = this.size || size;
  this.smallerSize = this.smallerSize || smallerSize;
  initCoefficients(this.size);
}

ImagePHash.prototype.size = 32;
ImagePHash.prototype.smallerSize = 8;

ImagePHash.prototype.distance = function (s1, s2) {
  var counter = 0;

  for (var k = 0; k < s1.length; k++) {
    if (s1[k] !== s2[k]) {
      counter++;
    }
  }

  return counter / s1.length;
}; // Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.


ImagePHash.prototype.getHash = function (img) {
  /* 1. Reduce size.
     * Like Average Hash, pHash starts with a small image.
     * However, the image is larger than 8x8; 32x32 is a good size.
     * This is really done to simplify the DCT computation and not
     * because it is needed to reduce the high frequencies.
     */
  img = img.clone().resize(this.size, this.size);
  /* 2. Reduce color.
     * The image is reduced to a grayscale just to further simplify
     * the number of computations.
     */

  img.grayscale();
  var vals = [];

  for (var x = 0; x < img.bitmap.width; x++) {
    vals[x] = [];

    for (var y = 0; y < img.bitmap.height; y++) {
      vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
    }
  }
  /* 3. Compute the DCT.
     * The DCT separates the image into a collection of frequencies
     * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses
     * a 32x32 DCT.
     */


  var dctVals = applyDCT(vals, this.size);
  /* 4. Reduce the DCT.
     * This is the magic step. While the DCT is 32x32, just keep the
     * top-left 8x8. Those represent the lowest frequencies in the
     * picture.
     */

  /* 5. Compute the average value.
     * Like the Average Hash, compute the mean DCT value (using only
     * the 8x8 DCT low-frequency values and excluding the first term
     * since the DC coefficient can be significantly different from
     * the other values and will throw off the average).
     */

  var total = 0;

  for (var _x = 0; _x < this.smallerSize; _x++) {
    for (var _y = 0; _y < this.smallerSize; _y++) {
      total += dctVals[_x][_y];
    }
  }

  var avg = total / (this.smallerSize * this.smallerSize);
  /* 6. Further reduce the DCT.
     * This is the magic step. Set the 64 hash bits to 0 or 1
     * depending on whether each of the 64 DCT values is above or
     * below the average value. The result doesn't tell us the
     * actual low frequencies; it just tells us the very-rough
     * relative scale of the frequencies to the mean. The result
     * will not vary as long as the overall structure of the image
     * remains the same; this can survive gamma and color histogram
     * adjustments without a problem.
     */

  var hash = '';

  for (var _x2 = 0; _x2 < this.smallerSize; _x2++) {
    for (var _y2 = 0; _y2 < this.smallerSize; _y2++) {
      hash += dctVals[_x2][_y2] > avg ? '1' : '0';
    }
  }

  return hash;
}; // DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java


function intToRGBA(i) {
  var rgba = {};
  rgba.r = Math.floor(i / Math.pow(256, 3));
  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
  return rgba;
}

var c = [];

function initCoefficients(size) {
  for (var i = 1; i < size; i++) {
    c[i] = 1;
  }

  c[0] = 1 / Math.sqrt(2.0);
}

function applyDCT(f, size) {
  var N = size;
  var F = [];

  for (var u = 0; u < N; u++) {
    F[u] = [];

    for (var v = 0; v < N; v++) {
      var sum = 0;

      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          sum += Math.cos((2 * i + 1) / (2.0 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2.0 * N) * v * Math.PI) * f[i][j];
        }
      }

      sum *= c[u] * c[v] / 4;
      F[u][v] = sum;
    }
  }

  return F;
}

module.exports = ImagePHash;
//# sourceMappingURL=phash.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/request.js":
/*!***********************************************!*\
  !*** ./node_modules/@jimp/core/es/request.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* global XMLHttpRequest */
if (process.browser || process.env.ENVIRONMENT === 'BROWSER' || typeof process.versions.electron !== 'undefined' && process.type === 'renderer' && typeof XMLHttpRequest === 'function') {
  // If we run into a browser or the electron renderer process,
  // use XHR method instead of Request node module.
  module.exports = function (options, cb) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', options.url, true);
    xhr.responseType = 'arraybuffer';
    xhr.addEventListener('load', function () {
      if (xhr.status < 400) {
        try {
          var data = Buffer.from(this.response);
          cb(null, xhr, data);
        } catch (error) {
          return cb(new Error('Response is not a buffer for url ' + options.url + '. Error: ' + error.message));
        }
      } else {
        cb(new Error('HTTP Status ' + xhr.status + ' for url ' + options.url));
      }
    });
    xhr.addEventListener('error', function (e) {
      cb(e);
    });
    xhr.send();
  };
} else {
  module.exports = function (_ref, cb) {
    var options = _extends({}, _ref);

    var p = __webpack_require__(/*! phin */ "./node_modules/phin/lib/phin.compiled.js");

    p(_objectSpread({
      compression: true
    }, options), function (err, res) {
      if (err === null) {
        cb(null, res, res.body);
      } else {
        cb(err);
      }
    });
  };
}
//# sourceMappingURL=request.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/utils/image-bitmap.js":
/*!**********************************************************!*\
  !*** ./node_modules/@jimp/core/es/utils/image-bitmap.js ***!
  \**********************************************************/
/*! exports provided: parseBitmap, getBuffer, getBufferAsync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseBitmap", function() { return parseBitmap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBuffer", function() { return getBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBufferAsync", function() { return getBufferAsync; });
/* harmony import */ var file_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! file-type */ "./node_modules/file-type/index.js");
/* harmony import */ var file_type__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(file_type__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var exif_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! exif-parser */ "./node_modules/exif-parser/index.js");
/* harmony import */ var exif_parser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(exif_parser__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./node_modules/@jimp/core/es/constants.js");
/* harmony import */ var _mime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mime */ "./node_modules/@jimp/core/es/utils/mime.js");
/* harmony import */ var _promisify__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./promisify */ "./node_modules/@jimp/core/es/utils/promisify.js");







function getMIMEFromBuffer(buffer, path) {
  var fileTypeFromBuffer = file_type__WEBPACK_IMPORTED_MODULE_0___default()(buffer);

  if (fileTypeFromBuffer) {
    // If fileType returns something for buffer, then return the mime given
    return fileTypeFromBuffer.mime;
  }

  if (path) {
    // If a path is supplied, and fileType yields no results, then retry with MIME
    // Path can be either a file path or a url
    return _mime__WEBPACK_IMPORTED_MODULE_4__["getType"](path);
  }

  return null;
}
/*
 * Automagically rotates an image based on its EXIF data (if present)
 * @param img a constants object
*/


function exifRotate(img) {
  var exif = img._exif;

  if (exif && exif.tags && exif.tags.Orientation) {
    switch (img._exif.tags.Orientation) {
      case 1:
        // Horizontal (normal)
        // do nothing
        break;

      case 2:
        // Mirror horizontal
        img.mirror(true, false);
        break;

      case 3:
        // Rotate 180
        img.rotate(180, false);
        break;

      case 4:
        // Mirror vertical
        img.mirror(false, true);
        break;

      case 5:
        // Mirror horizontal and rotate 270 CW
        img.rotate(-90, false).mirror(true, false);
        break;

      case 6:
        // Rotate 90 CW
        img.rotate(-90, false);
        break;

      case 7:
        // Mirror horizontal and rotate 90 CW
        img.rotate(90, false).mirror(true, false);
        break;

      case 8:
        // Rotate 270 CW
        img.rotate(-270, false);
        break;

      default:
        break;
    }
  }

  return img;
} // parses a bitmap from the constructor to the JIMP bitmap property


function parseBitmap(data, path, cb) {
  var mime = getMIMEFromBuffer(data, path);

  if (typeof mime !== 'string') {
    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));
  }

  this._originalMime = mime.toLowerCase();

  try {
    var _mime = this.getMIME();

    if (this.constructor.decoders[_mime]) {
      this.bitmap = this.constructor.decoders[_mime](data);
    } else {
      return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'Unsupported MIME type: ' + _mime, cb);
    }
  } catch (error) {
    return cb.call(this, error, this);
  }

  try {
    this._exif = exif_parser__WEBPACK_IMPORTED_MODULE_1___default.a.create(data).parse();
    exifRotate(this); // EXIF data
  } catch (error) {
    /* meh */
  }

  cb.call(this, null, this);
  return this;
}

function compositeBitmapOverBackground(Jimp, image) {
  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;
}
/**
 * Converts the image to a buffer
 * @param {string} mime the mime type of the image buffer to be created
 * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
 * @returns {Jimp} this for chaining of methods
 */


function getBuffer(mime, cb) {
  if (mime === _constants__WEBPACK_IMPORTED_MODULE_3__["AUTO"]) {
    // allow auto MIME detection
    mime = this.getMIME();
  }

  if (typeof mime !== 'string') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'mime must be a string', cb);
  }

  if (typeof cb !== 'function') {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'cb must be a function', cb);
  }

  mime = mime.toLowerCase();

  if (this._rgba && this.constructor.hasAlpha[mime]) {
    this.bitmap.data = Buffer.from(this.bitmap.data);
  } else {
    // when format doesn't support alpha
    // composite onto a new image so that the background shows through alpha channels
    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;
  }

  if (this.constructor.encoders[mime]) {
    var buffer = this.constructor.encoders[mime](this);
    cb.call(this, null, buffer);
  } else {
    cb.call(this, 'Unsupported MIME type: ' + mime);
  }

  return this;
}
function getBufferAsync(mime) {
  return Object(_promisify__WEBPACK_IMPORTED_MODULE_5__["default"])(getBuffer, this, mime);
}
//# sourceMappingURL=image-bitmap.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/utils/mime.js":
/*!**************************************************!*\
  !*** ./node_modules/@jimp/core/es/utils/mime.js ***!
  \**************************************************/
/*! exports provided: addType, getType, getExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addType", function() { return addType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExtension", function() { return getExtension; });
var mimeTypes = {};

var findType = function findType(extension) {
  return Object.entries(mimeTypes).find(function (type) {
    return type[1].includes(extension);
  }) || [];
};

var addType = function addType(mime, extensions) {
  mimeTypes[mime] = extensions;
};
/**
 * Lookup a mime type based on extension
 * @param {string} path path to find extension for
 * @returns {string} mime found mime type
 */

var getType = function getType(path) {
  var pathParts = path.split('/').slice(-1);
  var extension = pathParts[pathParts.length - 1].split('.')[1];
  var type = findType(extension);
  return type[0];
};
/**
 * Return file extension associated with a mime type
 * @param {string} type mime type to look up
 * @returns {string} extension file extension
 */

var getExtension = function getExtension(type) {
  return (mimeTypes[type.toLowerCase()] || [])[0];
};
//# sourceMappingURL=mime.js.map

/***/ }),

/***/ "./node_modules/@jimp/core/es/utils/promisify.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jimp/core/es/utils/promisify.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var promisify = function promisify(fun, ctx) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  return new Promise(function (resolve, reject) {
    args.push(function (err, data) {
      if (err) {
        reject(err);
      }

      resolve(data);
    });
    fun.bind(ctx).apply(void 0, args);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (promisify);
//# sourceMappingURL=promisify.js.map

/***/ }),

/***/ "./node_modules/@jimp/custom/es/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@jimp/custom/es/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return configure; });
/* harmony import */ var _jimp_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/core */ "./node_modules/@jimp/core/es/index.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


function configure(configuration) {
  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _jimp_core__WEBPACK_IMPORTED_MODULE_0__["default"];
  var jimpConfig = {
    hasAlpha: {},
    encoders: {},
    decoders: {},
    class: {},
    constants: {}
  };

  function addToConfig(newConfig) {
    Object.entries(newConfig).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      jimpConfig[key] = _objectSpread({}, jimpConfig[key], value);
    });
  }

  function addImageType(typeModule) {
    var type = typeModule();

    if (Array.isArray(type.mime)) {
      _jimp_core__WEBPACK_IMPORTED_MODULE_0__["addType"].apply(void 0, _toConsumableArray(type.mime));
    } else {
      Object.entries(type.mime).forEach(function (mimeType) {
        return _jimp_core__WEBPACK_IMPORTED_MODULE_0__["addType"].apply(void 0, _toConsumableArray(mimeType));
      });
    }

    delete type.mime;
    addToConfig(type);
  }

  function addPlugin(pluginModule) {
    var plugin = pluginModule(_jimp_core__WEBPACK_IMPORTED_MODULE_0__["jimpEvChange"]) || {};

    if (!plugin.class && !plugin.constants) {
      // Default to class function
      addToConfig({
        class: plugin
      });
    } else {
      addToConfig(plugin);
    }
  }

  if (configuration.types) {
    configuration.types.forEach(addImageType);
    jimpInstance.decoders = _objectSpread({}, jimpInstance.decoders, jimpConfig.decoders);
    jimpInstance.encoders = _objectSpread({}, jimpInstance.encoders, jimpConfig.encoders);
    jimpInstance.hasAlpha = _objectSpread({}, jimpInstance.hasAlpha, jimpConfig.hasAlpha);
  }

  if (configuration.plugins) {
    configuration.plugins.forEach(addPlugin);
  }

  Object(_jimp_core__WEBPACK_IMPORTED_MODULE_0__["addJimpMethods"])(jimpConfig.class, jimpInstance);
  Object(_jimp_core__WEBPACK_IMPORTED_MODULE_0__["addConstants"])(jimpConfig.constants, jimpInstance);
  return _jimp_core__WEBPACK_IMPORTED_MODULE_0__["default"];
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/gif/es/index.js":
/*!********************************************!*\
  !*** ./node_modules/@jimp/gif/es/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var omggif__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! omggif */ "./node_modules/omggif/omggif.js");
/* harmony import */ var omggif__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(omggif__WEBPACK_IMPORTED_MODULE_0__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var MIME_TYPE = 'image/gif';
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    mime: _defineProperty({}, MIME_TYPE, ['gif']),
    constants: {
      MIME_GIF: MIME_TYPE
    },
    decoders: _defineProperty({}, MIME_TYPE, function (data) {
      var gifObj = new omggif__WEBPACK_IMPORTED_MODULE_0___default.a.GifReader(data);
      var gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
      gifObj.decodeAndBlitFrameRGBA(0, gifData);
      return {
        data: gifData,
        width: gifObj.width,
        height: gifObj.height
      };
    })
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/jpeg/es/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@jimp/jpeg/es/index.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jpeg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jpeg-js */ "./node_modules/jpeg-js/index.js");
/* harmony import */ var jpeg_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jpeg_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var MIME_TYPE = 'image/jpeg';
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    mime: _defineProperty({}, MIME_TYPE, ['jpeg', 'jpg', 'jpe']),
    constants: {
      MIME_JPEG: MIME_TYPE
    },
    decoders: _defineProperty({}, MIME_TYPE, jpeg_js__WEBPACK_IMPORTED_MODULE_0___default.a.decode),
    encoders: _defineProperty({}, MIME_TYPE, function (image) {
      return jpeg_js__WEBPACK_IMPORTED_MODULE_0___default.a.encode(image.bitmap, image._quality).data;
    }),
    class: {
      // The quality to be used when saving JPEG images
      _quality: 100,

      /**
       * Sets the quality of the image when saving as JPEG format (default is 100)
       * @param {number} n The quality to use 0-100
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      quality: function quality(n, cb) {
        if (typeof n !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'n must be a number', cb);
        }

        if (n < 0 || n > 100) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'n must be a number 0 - 100', cb);
        }

        this._quality = Math.round(n);

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
          cb.call(this, null, this);
        }

        return this;
      }
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-blit/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-blit/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    /**
     * Blits a source image on to this image
     * @param {Jimp} src the source Jimp instance
     * @param {number} x the x position to blit the image
     * @param {number} y the y position to blit the image
     * @param {number} srcx (optional) the x position from which to crop the source image
     * @param {number} srcy (optional) the y position from which to crop the source image
     * @param {number} srcw (optional) the width to which to crop the source image
     * @param {number} srch (optional) the height to which to crop the source image
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp} this for chaining of methods
     */
    blit: function blit(src, x, y, srcx, srcy, srcw, srch, cb) {
      if (!(src instanceof this.constructor)) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'The source must be a Jimp image', cb);
      }

      if (typeof x !== 'number' || typeof y !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'x and y must be numbers', cb);
      }

      if (typeof srcx === 'function') {
        cb = srcx;
        srcx = 0;
        srcy = 0;
        srcw = src.bitmap.width;
        srch = src.bitmap.height;
      } else if (_typeof(srcx) === _typeof(srcy) && _typeof(srcy) === _typeof(srcw) && _typeof(srcw) === _typeof(srch)) {
        srcx = srcx || 0;
        srcy = srcy || 0;
        srcw = srcw || src.bitmap.width;
        srch = srch || src.bitmap.height;
      } else {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'srcx, srcy, srcw, srch must be numbers', cb);
      } // round input


      x = Math.round(x);
      y = Math.round(y); // round input

      srcx = Math.round(srcx);
      srcy = Math.round(srcy);
      srcw = Math.round(srcw);
      srch = Math.round(srch);
      var maxWidth = this.bitmap.width;
      var maxHeight = this.bitmap.height;
      var baseImage = this;
      src.scanQuiet(srcx, srcy, srcw, srch, function (sx, sy, idx) {
        var xOffset = x + sx - srcx;
        var yOffset = y + sy - srcy;

        if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
          var dstIdx = baseImage.getPixelIndex(xOffset, yOffset);
          var _src = {
            r: this.bitmap.data[idx],
            g: this.bitmap.data[idx + 1],
            b: this.bitmap.data[idx + 2],
            a: this.bitmap.data[idx + 3]
          };
          var dst = {
            r: baseImage.bitmap.data[dstIdx],
            g: baseImage.bitmap.data[dstIdx + 1],
            b: baseImage.bitmap.data[dstIdx + 2],
            a: baseImage.bitmap.data[dstIdx + 3]
          };
          baseImage.bitmap.data[dstIdx] = (_src.a * (_src.r - dst.r) - dst.r + 255 >> 8) + dst.r;
          baseImage.bitmap.data[dstIdx + 1] = (_src.a * (_src.g - dst.g) - dst.g + 255 >> 8) + dst.g;
          baseImage.bitmap.data[dstIdx + 2] = (_src.a * (_src.b - dst.b) - dst.b + 255 >> 8) + dst.b;
          baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + _src.a);
        }
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-blur/es/blur-tables.js":
/*!**********************************************************!*\
  !*** ./node_modules/@jimp/plugin-blur/es/blur-tables.js ***!
  \**********************************************************/
/*! exports provided: mulTable, shgTable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulTable", function() { return mulTable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shgTable", function() { return shgTable; });
var mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
var shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
//# sourceMappingURL=blur-tables.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-blur/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-blur/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
/* harmony import */ var _blur_tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blur-tables */ "./node_modules/@jimp/plugin-blur/es/blur-tables.js");


/*
    Superfast Blur (0.5)
    http://www.quasimondo.com/BoxBlurForCanvas/FastBlur.js

    Copyright (c) 2011 Mario Klingemann

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
*/

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    /**
     * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
     * @param {number} r the pixel radius of the blur
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp} this for chaining of methods
     */
    blur: function blur(r, cb) {
      if (typeof r !== 'number') return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'r must be a number', cb);
      if (r < 1) return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'r must be greater than 0', cb);
      var rsum;
      var gsum;
      var bsum;
      var asum;
      var x;
      var y;
      var i;
      var p;
      var p1;
      var p2;
      var yp;
      var yi;
      var yw;
      var pa;
      var wm = this.bitmap.width - 1;
      var hm = this.bitmap.height - 1; // const wh = this.bitmap.width * this.bitmap.height;

      var rad1 = r + 1;
      var mulSum = _blur_tables__WEBPACK_IMPORTED_MODULE_1__["mulTable"][r];
      var shgSum = _blur_tables__WEBPACK_IMPORTED_MODULE_1__["shgTable"][r];
      var red = [];
      var green = [];
      var blue = [];
      var alpha = [];
      var vmin = [];
      var vmax = [];
      var iterations = 2;

      while (iterations-- > 0) {
        yi = 0;
        yw = 0;

        for (y = 0; y < this.bitmap.height; y++) {
          rsum = this.bitmap.data[yw] * rad1;
          gsum = this.bitmap.data[yw + 1] * rad1;
          bsum = this.bitmap.data[yw + 2] * rad1;
          asum = this.bitmap.data[yw + 3] * rad1;

          for (i = 1; i <= r; i++) {
            p = yw + ((i > wm ? wm : i) << 2);
            rsum += this.bitmap.data[p++];
            gsum += this.bitmap.data[p++];
            bsum += this.bitmap.data[p++];
            asum += this.bitmap.data[p];
          }

          for (x = 0; x < this.bitmap.width; x++) {
            red[yi] = rsum;
            green[yi] = gsum;
            blue[yi] = bsum;
            alpha[yi] = asum;

            if (y === 0) {
              vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
              vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
            }

            p1 = yw + vmin[x];
            p2 = yw + vmax[x];
            rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
            gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
            bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
            asum += this.bitmap.data[p1] - this.bitmap.data[p2];
            yi++;
          }

          yw += this.bitmap.width << 2;
        }

        for (x = 0; x < this.bitmap.width; x++) {
          yp = x;
          rsum = red[yp] * rad1;
          gsum = green[yp] * rad1;
          bsum = blue[yp] * rad1;
          asum = alpha[yp] * rad1;

          for (i = 1; i <= r; i++) {
            yp += i > hm ? 0 : this.bitmap.width;
            rsum += red[yp];
            gsum += green[yp];
            bsum += blue[yp];
            asum += alpha[yp];
          }

          yi = x << 2;

          for (y = 0; y < this.bitmap.height; y++) {
            pa = asum * mulSum >>> shgSum;
            this.bitmap.data[yi + 3] = pa; // normalize alpha

            if (pa > 255) {
              this.bitmap.data[yi + 3] = 255;
            }

            if (pa > 0) {
              pa = 255 / pa;
              this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa;
              this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;
              this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;
            } else {
              this.bitmap.data[yi + 2] = 0;
              this.bitmap.data[yi + 1] = 0;
              this.bitmap.data[yi] = 0;
            }

            if (x === 0) {
              vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;
              vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0;
            }

            p1 = x + vmin[y];
            p2 = x + vmax[y];
            rsum += red[p1] - red[p2];
            gsum += green[p1] - green[p2];
            bsum += blue[p1] - blue[p2];
            asum += alpha[p1] - alpha[p2];
            yi += this.bitmap.width << 2;
          }
        }
      }

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-color/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-color/es/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinycolor2 */ "./node_modules/tinycolor2/tinycolor.js");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tinycolor2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }




function applyKernel(im, kernel, x, y) {
  var value = [0, 0, 0];
  var size = (kernel.length - 1) / 2;

  for (var kx = 0; kx < kernel.length; kx += 1) {
    for (var ky = 0; ky < kernel[kx].length; ky += 1) {
      var idx = im.getPixelIndex(x + kx - size, y + ky - size);
      value[0] += im.bitmap.data[idx] * kernel[kx][ky];
      value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];
      value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
    }
  }

  return value;
}

var isDef = function isDef(v) {
  return typeof v !== 'undefined' && v !== null;
};

function greyscale(cb) {
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
    var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
    this.bitmap.data[idx] = grey;
    this.bitmap.data[idx + 1] = grey;
    this.bitmap.data[idx + 2] = grey;
  });

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
    cb.call(this, null, this);
  }

  return this;
}

function mix(clr, clr2) {
  var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;
  return {
    r: (clr2.r - clr.r) * (p / 100) + clr.r,
    g: (clr2.g - clr.g) * (p / 100) + clr.g,
    b: (clr2.b - clr.b) * (p / 100) + clr.b
  };
}

function colorFn(actions, cb) {
  var _this = this;

  if (!actions || !Array.isArray(actions)) {
    return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'actions must be an array', cb);
  }

  actions = actions.map(function (action) {
    if (action.apply === 'xor' || action.apply === 'mix') {
      action.params[0] = tinycolor2__WEBPACK_IMPORTED_MODULE_0___default()(action.params[0]).toRgb();
    }

    return action;
  });
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
    var clr = {
      r: _this.bitmap.data[idx],
      g: _this.bitmap.data[idx + 1],
      b: _this.bitmap.data[idx + 2]
    };

    var colorModifier = function colorModifier(i, amount) {
      return _this.constructor.limit255(clr[i] + amount);
    };

    actions.forEach(function (action) {
      if (action.apply === 'mix') {
        clr = mix(clr, action.params[0], action.params[1]);
      } else if (action.apply === 'tint') {
        clr = mix(clr, {
          r: 255,
          g: 255,
          b: 255
        }, action.params[0]);
      } else if (action.apply === 'shade') {
        clr = mix(clr, {
          r: 0,
          g: 0,
          b: 0
        }, action.params[0]);
      } else if (action.apply === 'xor') {
        clr = {
          r: clr.r ^ action.params[0].r,
          g: clr.g ^ action.params[0].g,
          b: clr.b ^ action.params[0].b
        };
      } else if (action.apply === 'red') {
        clr.r = colorModifier('r', action.params[0]);
      } else if (action.apply === 'green') {
        clr.g = colorModifier('g', action.params[0]);
      } else if (action.apply === 'blue') {
        clr.b = colorModifier('b', action.params[0]);
      } else {
        var _clr;

        if (action.apply === 'hue') {
          action.apply = 'spin';
        }

        clr = tinycolor2__WEBPACK_IMPORTED_MODULE_0___default()(clr);

        if (!clr[action.apply]) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(_this, 'action ' + action.apply + ' not supported', cb);
        }

        clr = (_clr = clr)[action.apply].apply(_clr, _toConsumableArray(action.params)).toRgb();
      }
    });
    _this.bitmap.data[idx] = clr.r;
    _this.bitmap.data[idx + 1] = clr.g;
    _this.bitmap.data[idx + 2] = clr.b;
  });

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
    cb.call(this, null, this);
  }

  return this;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    /**
     * Adjusts the brightness of the image
     * @param {number} val the amount to adjust the brightness, a number between -1 and +1
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    brightness: function brightness(val, cb) {
      if (typeof val !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'val must be numbers', cb);
      }

      if (val < -1 || val > +1) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'val must be a number between -1 and +1', cb);
      }

      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        if (val < 0.0) {
          this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);
          this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val);
          this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val);
        } else {
          this.bitmap.data[idx] = this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val;
          this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val;
          this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val;
        }
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Adjusts the contrast of the image
     * @param {number} val the amount to adjust the contrast, a number between -1 and +1
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    contrast: function contrast(val, cb) {
      if (typeof val !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'val must be numbers', cb);
      }

      if (val < -1 || val > +1) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'val must be a number between -1 and +1', cb);
      }

      var factor = (val + 1) / (1 - val);

      function adjust(value) {
        value = Math.floor(factor * (value - 127) + 127);
        return value < 0 ? 0 : value > 255 ? 255 : value;
      }

      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);
        this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);
        this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Apply a posterize effect
     * @param {number} n the amount to adjust the contrast, minimum threshold is two
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    posterize: function posterize(n, cb) {
      if (typeof n !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'n must be numbers', cb);
      }

      if (n < 2) {
        n = 2;
      } // minimum of 2 levels


      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;
        this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;
        this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Removes colour from the image using ITU Rec 709 luminance values
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    greyscale: greyscale,
    // Alias of greyscale for our American friends
    grayscale: greyscale,

    /**
     * Multiplies the opacity of each pixel by a factor between 0 and 1
     * @param {number} f A number, the factor by which to multiply the opacity of each pixel
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    opacity: function opacity(f, cb) {
      if (typeof f !== 'number') return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'f must be a number', cb);
      if (f < 0 || f > 1) return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'f must be a number from 0 to 1', cb);
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        var v = this.bitmap.data[idx + 3] * f;
        this.bitmap.data[idx + 3] = v;
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Applies a sepia tone to the image
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    sepia: function sepia(cb) {
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        var red = this.bitmap.data[idx];
        var green = this.bitmap.data[idx + 1];
        var blue = this.bitmap.data[idx + 2];
        red = red * 0.393 + green * 0.769 + blue * 0.189;
        green = red * 0.349 + green * 0.686 + blue * 0.168;
        blue = red * 0.272 + green * 0.534 + blue * 0.131;
        this.bitmap.data[idx] = red < 255 ? red : 255;
        this.bitmap.data[idx + 1] = green < 255 ? green : 255;
        this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Fades each pixel by a factor between 0 and 1
     * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    fade: function fade(f, cb) {
      if (typeof f !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'f must be a number', cb);
      }

      if (f < 0 || f > 1) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'f must be a number from 0 to 1', cb);
      } // this method is an alternative to opacity (which may be deprecated)


      this.opacity(1 - f);

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Adds each element of the image to its local neighbors, weighted by the kernel
     * @param {array} kernel a matrix to weight the neighbors sum
     * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    convolution: function convolution(kernel, edgeHandling, cb) {
      if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {
        cb = edgeHandling;
        edgeHandling = null;
      }

      if (!edgeHandling) {
        edgeHandling = this.constructor.EDGE_EXTEND;
      }

      var newData = Buffer.from(this.bitmap.data);
      var kRows = kernel.length;
      var kCols = kernel[0].length;
      var rowEnd = Math.floor(kRows / 2);
      var colEnd = Math.floor(kCols / 2);
      var rowIni = -rowEnd;
      var colIni = -colEnd;
      var weight;
      var rSum;
      var gSum;
      var bSum;
      var ri;
      var gi;
      var bi;
      var xi;
      var yi;
      var idxi;
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        bSum = 0;
        gSum = 0;
        rSum = 0;

        for (var row = rowIni; row <= rowEnd; row++) {
          for (var col = colIni; col <= colEnd; col++) {
            xi = x + col;
            yi = y + row;
            weight = kernel[row + rowEnd][col + colEnd];
            idxi = this.getPixelIndex(xi, yi, edgeHandling);

            if (idxi === -1) {
              bi = 0;
              gi = 0;
              ri = 0;
            } else {
              ri = this.bitmap.data[idxi + 0];
              gi = this.bitmap.data[idxi + 1];
              bi = this.bitmap.data[idxi + 2];
            }

            rSum += weight * ri;
            gSum += weight * gi;
            bSum += weight * bi;
          }
        }

        if (rSum < 0) {
          rSum = 0;
        }

        if (gSum < 0) {
          gSum = 0;
        }

        if (bSum < 0) {
          bSum = 0;
        }

        if (rSum > 255) {
          rSum = 255;
        }

        if (gSum > 255) {
          gSum = 255;
        }

        if (bSum > 255) {
          bSum = 255;
        }

        newData[idx + 0] = rSum;
        newData[idx + 1] = gSum;
        newData[idx + 2] = bSum;
      });
      this.bitmap.data = newData;

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Set the alpha channel on every pixel to fully opaque
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    opaque: function opaque(cb) {
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        this.bitmap.data[idx + 3] = 255;
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Pixelates the image or a region
     * @param {number} size the size of the pixels
     * @param {number} x (optional) the x position of the region to pixelate
     * @param {number} y (optional) the y position of the region to pixelate
     * @param {number} w (optional) the width of the region to pixelate
     * @param {number} h (optional) the height of the region to pixelate
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    pixelate: function pixelate(size, x, y, w, h, cb) {
      if (typeof x === 'function') {
        cb = x;
        h = null;
        w = null;
        y = null;
        x = null;
      } else {
        if (typeof size !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'size must be a number', cb);
        }

        if (isDef(x) && typeof x !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'x must be a number', cb);
        }

        if (isDef(y) && typeof y !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'y must be a number', cb);
        }

        if (isDef(w) && typeof w !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'w must be a number', cb);
        }

        if (isDef(h) && typeof h !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'h must be a number', cb);
        }
      }

      var kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
      x = x || 0;
      y = y || 0;
      w = isDef(w) ? w : this.bitmap.width - x;
      h = isDef(h) ? h : this.bitmap.height - y;
      var source = this.cloneQuiet();
      this.scanQuiet(x, y, w, h, function (xx, yx, idx) {
        xx = size * Math.floor(xx / size);
        yx = size * Math.floor(yx / size);
        var value = applyKernel(source, kernel, xx, yx);
        this.bitmap.data[idx] = value[0];
        this.bitmap.data[idx + 1] = value[1];
        this.bitmap.data[idx + 2] = value[2];
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Applies a convolution kernel to the image or a region
     * @param {array} kernel the convolution kernel
     * @param {number} x (optional) the x position of the region to apply convolution to
     * @param {number} y (optional) the y position of the region to apply convolution to
     * @param {number} w (optional) the width of the region to apply convolution to
     * @param {number} h (optional) the height of the region to apply convolution to
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    convolute: function convolute(kernel, x, y, w, h, cb) {
      if (!Array.isArray(kernel)) return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'the kernel must be an array', cb);

      if (typeof x === 'function') {
        cb = x;
        x = null;
        y = null;
        w = null;
        h = null;
      } else {
        if (isDef(x) && typeof x !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'x must be a number', cb);
        }

        if (isDef(y) && typeof y !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'y must be a number', cb);
        }

        if (isDef(w) && typeof w !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'w must be a number', cb);
        }

        if (isDef(h) && typeof h !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'h must be a number', cb);
        }
      }

      var ksize = (kernel.length - 1) / 2;
      x = isDef(x) ? x : ksize;
      y = isDef(y) ? y : ksize;
      w = isDef(w) ? w : this.bitmap.width - x;
      h = isDef(h) ? h : this.bitmap.height - y;
      var source = this.cloneQuiet();
      this.scanQuiet(x, y, w, h, function (xx, yx, idx) {
        var value = applyKernel(source, kernel, xx, yx);
        this.bitmap.data[idx] = this.constructor.limit255(value[0]);
        this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);
        this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Apply multiple color modification rules
     * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp }this for chaining of methods
     */
    color: colorFn,
    colour: colorFn
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-contain/es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jimp/plugin-contain/es/index.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/**
 * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.
 * @param {number} w the width to resize the image to
 * @param {number} h the height to resize the image to
 * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment
 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    contain: function contain(w, h, alignBits, mode, cb) {
      if (typeof w !== 'number' || typeof h !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'w and h must be numbers', cb);
      } // permit any sort of optional parameters combination


      if (typeof alignBits === 'string') {
        if (typeof mode === 'function' && typeof cb === 'undefined') cb = mode;
        mode = alignBits;
        alignBits = null;
      }

      if (typeof alignBits === 'function') {
        if (typeof cb === 'undefined') cb = alignBits;
        mode = null;
        alignBits = null;
      }

      if (typeof mode === 'function' && typeof cb === 'undefined') {
        cb = mode;
        mode = null;
      }

      alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
      var hbits = alignBits & (1 << 3) - 1;
      var vbits = alignBits >> 3; // check if more flags than one is in the bit sets

      if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'only use one flag per alignment direction', cb);
      }

      var alignH = hbits >> 1; // 0, 1, 2

      var alignV = vbits >> 1; // 0, 1, 2

      var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
      var c = this.cloneQuiet().scale(f, mode);
      this.resize(w, h, mode);
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        this.bitmap.data.writeUInt32BE(this._background, idx);
      });
      this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-cover/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-cover/es/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/**
 * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.
 * @param {number} w the width to resize the image to
 * @param {number} h the height to resize the image to
 * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment
 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    cover: function cover(w, h, alignBits, mode, cb) {
      if (typeof w !== 'number' || typeof h !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'w and h must be numbers', cb);
      }

      if (alignBits && typeof alignBits === 'function' && typeof cb === 'undefined') {
        cb = alignBits;
        alignBits = null;
        mode = null;
      } else if (typeof mode === 'function' && typeof cb === 'undefined') {
        cb = mode;
        mode = null;
      }

      alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
      var hbits = alignBits & (1 << 3) - 1;
      var vbits = alignBits >> 3; // check if more flags than one is in the bit sets

      if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'only use one flag per alignment direction', cb);
      var alignH = hbits >> 1; // 0, 1, 2

      var alignV = vbits >> 1; // 0, 1, 2

      var f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
      this.scale(f, mode);
      this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-crop/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-crop/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pluginCrop; });
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable no-labels */

function pluginCrop(event) {
  /**
   * Crops the image at a given point to a give size
   * @param {number} x the x coordinate to crop form
   * @param {number} y the y coordinate to crop form
   * @param w the width of the crop region
   * @param h the height of the crop region
   * @param {function(Error, Jimp)} cb (optional) a callback for when complete
   * @returns {Jimp} this for chaining of methods
   */
  event('crop', function (x, y, w, h, cb) {
    if (typeof x !== 'number' || typeof y !== 'number') return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'x and y must be numbers', cb);
    if (typeof w !== 'number' || typeof h !== 'number') return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'w and h must be numbers', cb); // round input

    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);

    if (x === 0 && w === this.bitmap.width) {
      // shortcut
      var start = w * y + x << 2;
      var end = start + h * w << 2 + 1;
      this.bitmap.data = this.bitmap.data.slice(start, end);
    } else {
      var bitmap = Buffer.allocUnsafe(w * h * 4);
      var offset = 0;
      this.scanQuiet(x, y, w, h, function (x, y, idx) {
        var data = this.bitmap.data.readUInt32BE(idx, true);
        bitmap.writeUInt32BE(data, offset, true);
        offset += 4;
      });
      this.bitmap.data = bitmap;
    }

    this.bitmap.width = w;
    this.bitmap.height = h;

    if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
      cb.call(this, null, this);
    }

    return this;
  });
  return {
    class: {
      /**
       * Autocrop same color borders from this image
       * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)
       * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)
       * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)
       * @returns {Jimp} this for chaining of methods
       */
      autocrop: function autocrop() {
        var w = this.bitmap.width;
        var h = this.bitmap.height;
        var minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image

        var cb; // callback

        var leaveBorder = 0; // Amount of pixels in border to leave

        var tolerance = 0.0002; // percent of color difference tolerance (default value)

        var cropOnlyFrames = true; // flag to force cropping only if the image has a real "frame"
        // i.e. all 4 sides have some border (default value)

        var cropSymmetric = false; // flag to force cropping top be symmetric.
        // i.e. north and south / east and west are cropped by the same value
        // parse arguments

        for (var a = 0, len = arguments.length; a < len; a++) {
          if (typeof (a < 0 || arguments.length <= a ? undefined : arguments[a]) === 'number') {
            // tolerance value passed
            tolerance = a < 0 || arguments.length <= a ? undefined : arguments[a];
          }

          if (typeof (a < 0 || arguments.length <= a ? undefined : arguments[a]) === 'boolean') {
            // cropOnlyFrames value passed
            cropOnlyFrames = a < 0 || arguments.length <= a ? undefined : arguments[a];
          }

          if (typeof (a < 0 || arguments.length <= a ? undefined : arguments[a]) === 'function') {
            // callback value passed
            cb = a < 0 || arguments.length <= a ? undefined : arguments[a];
          }

          if (_typeof(a < 0 || arguments.length <= a ? undefined : arguments[a]) === 'object') {
            // config object passed
            var config = a < 0 || arguments.length <= a ? undefined : arguments[a];

            if (typeof config.tolerance !== 'undefined') {
              tolerance = config.tolerance;
            }

            if (typeof config.cropOnlyFrames !== 'undefined') {
              cropOnlyFrames = config.cropOnlyFrames;
            }

            if (typeof config.cropSymmetric !== 'undefined') {
              cropSymmetric = config.cropSymmetric;
            }

            if (typeof config.leaveBorder !== 'undefined') {
              leaveBorder = config.leaveBorder;
            }
          }
        }
        /**
         * All borders must be of the same color as the top left pixel, to be cropped.
         * It should be possible to crop borders each with a different color,
         * but since there are many ways for corners to intersect, it would
         * introduce unnecessary complexity to the algorithm.
         */
        // scan each side for same color borders


        var colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color

        var rgba1 = this.constructor.intToRGBA(colorTarget); // for north and east sides

        var northPixelsToCrop = 0;
        var eastPixelsToCrop = 0;
        var southPixelsToCrop = 0;
        var westPixelsToCrop = 0; // north side (scan rows from north to south)

        colorTarget = this.getPixelColor(0, 0);

        north: for (var y = 0; y < h - minPixelsPerSide; y++) {
          for (var x = 0; x < w; x++) {
            var colorXY = this.getPixelColor(x, y);
            var rgba2 = this.constructor.intToRGBA(colorXY);

            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
              // this pixel is too distant from the first one: abort this side scan
              northPixelsToCrop -= leaveBorder;
              break north;
            }
          } // this row contains all pixels with the same color: increment this side pixels to crop


          northPixelsToCrop++;
        } // east side (scan columns from east to west)


        colorTarget = this.getPixelColor(w, 0);

        east: for (var _x = 0; _x < w - minPixelsPerSide; _x++) {
          for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {
            var _colorXY = this.getPixelColor(_x, _y);

            var _rgba = this.constructor.intToRGBA(_colorXY);

            if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) {
              // this pixel is too distant from the first one: abort this side scan
              eastPixelsToCrop -= leaveBorder;
              break east;
            }
          } // this column contains all pixels with the same color: increment this side pixels to crop


          eastPixelsToCrop++;
        } // south side (scan rows from south to north)


        colorTarget = this.getPixelColor(0, h);

        south: for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {
          for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {
            var _colorXY2 = this.getPixelColor(_x2, _y2);

            var _rgba2 = this.constructor.intToRGBA(_colorXY2);

            if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) {
              // this pixel is too distant from the first one: abort this side scan
              southPixelsToCrop -= leaveBorder;
              break south;
            }
          } // this row contains all pixels with the same color: increment this side pixels to crop


          southPixelsToCrop++;
        } // west side (scan columns from west to east)


        colorTarget = this.getPixelColor(w, h);

        west: for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {
          for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {
            var _colorXY3 = this.getPixelColor(_x3, _y3);

            var _rgba3 = this.constructor.intToRGBA(_colorXY3);

            if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) {
              // this pixel is too distant from the first one: abort this side scan
              westPixelsToCrop -= leaveBorder;
              break west;
            }
          } // this column contains all pixels with the same color: increment this side pixels to crop


          westPixelsToCrop++;
        } // decide if a crop is needed


        var doCrop = false;

        if (cropSymmetric) {
          var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
          var vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
          westPixelsToCrop = horizontal;
          eastPixelsToCrop = horizontal;
          northPixelsToCrop = vertical;
          southPixelsToCrop = vertical;
        } // safety checks


        var widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
        var heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);

        if (cropOnlyFrames) {
          // crop image if all sides should be cropped
          doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
        } else {
          // crop image if at least one side should be cropped
          doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
        }

        if (doCrop) {
          // do the real crop
          this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);
        }

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
          cb.call(this, null, this);
        }

        return this;
      }
    }
  };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-displace/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@jimp/plugin-displace/es/index.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/**
 * Displaces the image based on the provided displacement map
 * @param {object} map the source Jimp instance
 * @param {number} offset the maximum displacement value
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    displace: function displace(map, offset, cb) {
      if (_typeof(map) !== 'object' || map.constructor !== this.constructor) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'The source must be a Jimp image', cb);
      }

      if (typeof offset !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'factor must be a number', cb);
      }

      var source = this.cloneQuiet();
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        var displacement = map.bitmap.data[idx] / 256 * offset;
        displacement = Math.round(displacement);
        var ids = this.getPixelIndex(x + displacement, y);
        this.bitmap.data[ids] = source.bitmap.data[idx];
        this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
        this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-dither/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-dither/es/index.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/**
 * Apply a ordered dithering effect
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

function dither(cb) {
  var rgb565Matrix = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
    var thresholdId = ((y & 3) << 2) + x % 4;
    var dither = rgb565Matrix[thresholdId];
    this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither, 0xff);
    this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither, 0xff);
    this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither, 0xff);
  });

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
    cb.call(this, null, this);
  }

  return this;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    dither565: dither,
    dither16: dither
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-flip/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-flip/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/**
 * Flip the image horizontally
 * @param {boolean} horizontal a Boolean, if true the image will be flipped horizontally
 * @param {boolean} vertical a Boolean, if true the image will be flipped vertically
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

function flipFn(horizontal, vertical, cb) {
  if (typeof horizontal !== 'boolean' || typeof vertical !== 'boolean') return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'horizontal and vertical must be Booleans', cb);

  if (horizontal && vertical) {
    // shortcut
    return this.rotate(180, true, cb);
  }

  var bitmap = Buffer.alloc(this.bitmap.data.length);
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
    var _x = horizontal ? this.bitmap.width - 1 - x : x;

    var _y = vertical ? this.bitmap.height - 1 - y : y;

    var _idx = this.bitmap.width * _y + _x << 2;

    var data = this.bitmap.data.readUInt32BE(idx);
    bitmap.writeUInt32BE(data, _idx);
  });
  this.bitmap.data = Buffer.from(bitmap);

  if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
    cb.call(this, null, this);
  }

  return this;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    flip: flipFn,
    mirror: flipFn
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-gaussian/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@jimp/plugin-gaussian/es/index.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/**
 * Applies a true Gaussian blur to the image (warning: this is VERY slow)
 * @param {number} r the pixel radius of the blur
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    gaussian: function gaussian(r, cb) {
      // http://blog.ivank.net/fastest-gaussian-blur.html
      if (typeof r !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'r must be a number', cb);
      }

      if (r < 1) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'r must be greater than 0', cb);
      }

      var rs = Math.ceil(r * 2.57); // significant radius

      var range = rs * 2 + 1;
      var rr2 = r * r * 2;
      var rr2pi = rr2 * Math.PI;
      var weights = [];

      for (var y = 0; y < range; y++) {
        weights[y] = [];

        for (var x = 0; x < range; x++) {
          var dsq = Math.pow(x - rs, 2) + Math.pow(y - rs, 2);
          weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
        }
      }

      for (var _y = 0; _y < this.bitmap.height; _y++) {
        for (var _x = 0; _x < this.bitmap.width; _x++) {
          var red = 0;
          var green = 0;
          var blue = 0;
          var alpha = 0;
          var wsum = 0;

          for (var iy = 0; iy < range; iy++) {
            for (var ix = 0; ix < range; ix++) {
              var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + _x - rs));
              var y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + _y - rs));
              var weight = weights[iy][ix];

              var _idx = y1 * this.bitmap.width + x1 << 2;

              red += this.bitmap.data[_idx] * weight;
              green += this.bitmap.data[_idx + 1] * weight;
              blue += this.bitmap.data[_idx + 2] * weight;
              alpha += this.bitmap.data[_idx + 3] * weight;
              wsum += weight;
            }

            var idx = _y * this.bitmap.width + _x << 2;
            this.bitmap.data[idx] = Math.round(red / wsum);
            this.bitmap.data[idx + 1] = Math.round(green / wsum);
            this.bitmap.data[idx + 2] = Math.round(blue / wsum);
            this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
          }
        }
      }

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-invert/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-invert/es/index.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/**
 * Inverts the image
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    invert: function invert(cb) {
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        this.bitmap.data[idx] = 255 - this.bitmap.data[idx];
        this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1];
        this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-mask/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-mask/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/**
 * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.
 * @param {Jimp} src the source Jimp instance
 * @param {number} x the horizontal position to blit the image
 * @param {number} y the vertical position to blit the image
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    mask: function mask(src) {
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var cb = arguments.length > 3 ? arguments[3] : undefined;

      if (!(src instanceof this.constructor)) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'The source must be a Jimp image', cb);
      }

      if (typeof x !== 'number' || typeof y !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'x and y must be numbers', cb);
      } // round input


      x = Math.round(x);
      y = Math.round(y);
      var w = this.bitmap.width;
      var h = this.bitmap.height;
      var baseImage = this;
      src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {
        var destX = x + sx;
        var destY = y + sy;

        if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
          var dstIdx = baseImage.getPixelIndex(destX, destY);
          var data = this.bitmap.data;
          var avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
          baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
        }
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-normalize/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@jimp/plugin-normalize/es/index.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
/* eslint-disable no-labels */

/**
 * Get an image's histogram
 * @return {object} An object with an array of color occurrence counts for each channel (r,g,b)
 */

function histogram() {
  var histogram = {
    r: new Array(256).fill(0),
    g: new Array(256).fill(0),
    b: new Array(256).fill(0)
  };
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, index) {
    histogram.r[this.bitmap.data[index + 0]]++;
    histogram.g[this.bitmap.data[index + 1]]++;
    histogram.b[this.bitmap.data[index + 2]]++;
  });
  return histogram;
}
/**
 * Normalize values
 * @param  {integer} value Pixel channel value.
 * @param  {integer} min   Minimum value for channel
 * @param  {integer} max   Maximum value for channel
 * @return {integer} normalized values
 */


var _normalize = function normalize(value, min, max) {
  return (value - min) * 255 / (max - min);
};

var getBounds = function getBounds(histogramChannel) {
  return [histogramChannel.findIndex(function (value) {
    return value > 0;
  }), 255 - histogramChannel.slice().reverse().findIndex(function (value) {
    return value > 0;
  })];
};
/**
 * Normalizes the image
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    normalize: function normalize(cb) {
      var h = histogram.call(this); // store bounds (minimum and maximum values)

      var bounds = {
        r: getBounds(h.r),
        g: getBounds(h.g),
        b: getBounds(h.b)
      }; // apply value transformations

      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
        var r = this.bitmap.data[idx + 0];
        var g = this.bitmap.data[idx + 1];
        var b = this.bitmap.data[idx + 2];
        this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]);
        this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]);
        this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);
      });

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-print/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-print/es/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(__dirname) {/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var load_bmfont__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! load-bmfont */ "./node_modules/load-bmfont/index.js");
/* harmony import */ var load_bmfont__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(load_bmfont__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
/* harmony import */ var _measure_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./measure-text */ "./node_modules/@jimp/plugin-print/es/measure-text.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }






function xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {
  if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {
    return 0;
  }

  if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {
    return (maxWidth - Object(_measure_text__WEBPACK_IMPORTED_MODULE_3__["measureText"])(font, line)) / 2;
  }

  return maxWidth - Object(_measure_text__WEBPACK_IMPORTED_MODULE_3__["measureText"])(font, line);
}

function drawCharacter(image, font, x, y, char) {
  if (char.width > 0 && char.height > 0) {
    var characterPage = font.pages[char.page];
    image.blit(characterPage, x + char.xoffset, y + char.yoffset, char.x, char.y, char.width, char.height);
  }

  return image;
}

function printText(font, x, y, text, defaultCharWidth) {
  for (var i = 0; i < text.length; i++) {
    var char = void 0;

    if (font.chars[text[i]]) {
      char = text[i];
    } else if (/\s/.test(text[i])) {
      char = '';
    } else {
      char = '?';
    }

    var fontChar = font.chars[char] || {};
    var fontKerning = font.kernings[char];
    drawCharacter(this, font, x, y, fontChar || {});
    var kerning = fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0;
    x += kerning + (fontChar.xadvance || defaultCharWidth);
  }
}

function splitLines(font, text, maxWidth) {
  var words = text.split(' ');
  var lines = [];
  var currentLine = [];
  var longestLine = 0;
  words.forEach(function (word) {
    var line = _toConsumableArray(currentLine).concat([word]).join(' ');

    var length = Object(_measure_text__WEBPACK_IMPORTED_MODULE_3__["measureText"])(font, line);

    if (length <= maxWidth) {
      if (length > longestLine) {
        longestLine = length;
      }

      currentLine.push(word);
    } else {
      lines.push(currentLine);
      currentLine = [word];
    }
  });
  lines.push(currentLine);
  return {
    lines: lines,
    longestLine: longestLine
  };
}

function loadPages(Jimp, dir, pages) {
  var newPages = pages.map(function (page) {
    return Jimp.read(dir + '/' + page);
  });
  return Promise.all(newPages);
}

var dir = process.env.DIRNAME || "".concat(__dirname, "/../");
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    constants: {
      measureText: _measure_text__WEBPACK_IMPORTED_MODULE_3__["measureText"],
      measureTextHeight: _measure_text__WEBPACK_IMPORTED_MODULE_3__["measureTextHeight"],
      FONT_SANS_8_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt'),
      FONT_SANS_10_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt'),
      FONT_SANS_12_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt'),
      FONT_SANS_14_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt'),
      FONT_SANS_16_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt'),
      FONT_SANS_32_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt'),
      FONT_SANS_64_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt'),
      FONT_SANS_128_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt'),
      FONT_SANS_8_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt'),
      FONT_SANS_16_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt'),
      FONT_SANS_32_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt'),
      FONT_SANS_64_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt'),
      FONT_SANS_128_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, 'fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt'),

      /**
       * Loads a bitmap font from a file
       * @param {string} file the file path of a .fnt file
       * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded
       * @returns {Promise} a promise
       */
      loadFont: function loadFont(file, cb) {
        var _this = this;

        if (typeof file !== 'string') return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'file must be a string', cb);
        return new Promise(function (resolve, reject) {
          cb = cb || function (err, font) {
            if (err) reject(err);else resolve(font);
          };

          load_bmfont__WEBPACK_IMPORTED_MODULE_1___default()(file, function (err, font) {
            var chars = {};
            var kernings = {};

            if (err) {
              return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(_this, err, cb);
            }

            for (var i = 0; i < font.chars.length; i++) {
              chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];
            }

            for (var _i = 0; _i < font.kernings.length; _i++) {
              var firstString = String.fromCharCode(font.kernings[_i].first);
              kernings[firstString] = kernings[firstString] || {};
              kernings[firstString][String.fromCharCode(font.kernings[_i].second)] = font.kernings[_i].amount;
            }

            loadPages(_this, path__WEBPACK_IMPORTED_MODULE_0___default.a.dirname(file), font.pages).then(function (pages) {
              cb(null, {
                chars: chars,
                kernings: kernings,
                pages: pages,
                common: font.common,
                info: font.info
              });
            });
          });
        });
      }
    },
    class: {
      /**
       * Draws a text on a image on a given boundary
       * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command
       * @param {number} x the x position to start drawing the text
       * @param {number} y the y position to start drawing the text
       * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
       * @param {number} maxWidth (optional) the boundary width to draw in
       * @param {number} maxHeight (optional) the boundary height to draw in
       * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written
       * @returns {Jimp} this for chaining of methods
       */
      print: function print(font, x, y, text, maxWidth, maxHeight, cb) {
        var _this2 = this;

        if (typeof maxWidth === 'function' && typeof cb === 'undefined') {
          cb = maxWidth;
          maxWidth = Infinity;
        }

        if (typeof maxWidth === 'undefined') {
          maxWidth = Infinity;
        }

        if (typeof maxHeight === 'function' && typeof cb === 'undefined') {
          cb = maxHeight;
          maxHeight = Infinity;
        }

        if (typeof maxHeight === 'undefined') {
          maxHeight = Infinity;
        }

        if (_typeof(font) !== 'object') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'font must be a Jimp loadFont', cb);
        }

        if (typeof x !== 'number' || typeof y !== 'number' || typeof maxWidth !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'x, y and maxWidth must be numbers', cb);
        }

        if (typeof maxWidth !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'maxWidth must be a number', cb);
        }

        if (typeof maxHeight !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__["throwError"].call(this, 'maxHeight must be a number', cb);
        }

        var alignmentX;
        var alignmentY;

        if (_typeof(text) === 'object' && text.text !== null && text.text !== undefined) {
          alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;
          alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
          var _text = text;
          text = _text.text;
        } else {
          alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;
          alignmentY = this.constructor.VERTICAL_ALIGN_TOP;
          text = text.toString();
        }

        if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {
          y += maxHeight - Object(_measure_text__WEBPACK_IMPORTED_MODULE_3__["measureTextHeight"])(font, text, maxWidth);
        } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {
          y += maxHeight / 2 - Object(_measure_text__WEBPACK_IMPORTED_MODULE_3__["measureTextHeight"])(font, text, maxWidth) / 2;
        }

        var defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;

        var _splitLines = splitLines(font, text, maxWidth),
            lines = _splitLines.lines,
            longestLine = _splitLines.longestLine;

        lines.forEach(function (line) {
          var lineString = line.join(' ');
          var alignmentWidth = xOffsetBasedOnAlignment(_this2.constructor, font, lineString, maxWidth, alignmentX);
          printText.call(_this2, font, x + alignmentWidth, y, lineString, defaultCharWidth);
          y += font.common.lineHeight;
        });

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_2__["isNodePattern"])(cb)) {
          cb.call(this, null, this, {
            x: x + longestLine,
            y: y
          });
        }

        return this;
      }
    }
  };
});
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/@jimp/plugin-print/es/measure-text.js":
/*!************************************************************!*\
  !*** ./node_modules/@jimp/plugin-print/es/measure-text.js ***!
  \************************************************************/
/*! exports provided: measureText, measureTextHeight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureText", function() { return measureText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextHeight", function() { return measureTextHeight; });
function measureText(font, text) {
  var x = 0;

  for (var i = 0; i < text.length; i++) {
    if (font.chars[text[i]]) {
      var kerning = font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0;
      x += (font.chars[text[i]].xadvance || 0) + kerning;
    }
  }

  return x;
}
function measureTextHeight(font, text, maxWidth) {
  var words = text.split(' ');
  var line = '';
  var textTotalHeight = font.common.lineHeight;

  for (var n = 0; n < words.length; n++) {
    var testLine = line + words[n] + ' ';
    var testWidth = measureText(font, testLine);

    if (testWidth > maxWidth && n > 0) {
      textTotalHeight += font.common.lineHeight;
      line = words[n] + ' ';
    } else {
      line = testLine;
    }
  }

  return textTotalHeight;
}
//# sourceMappingURL=measure-text.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-resize/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-resize/es/index.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
/* harmony import */ var _modules_resize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/resize */ "./node_modules/@jimp/plugin-resize/es/modules/resize.js");
/* harmony import */ var _modules_resize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_modules_resize__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _modules_resize2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/resize2 */ "./node_modules/@jimp/plugin-resize/es/modules/resize2.js");
/* harmony import */ var _modules_resize2__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_modules_resize2__WEBPACK_IMPORTED_MODULE_2__);



/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    constants: {
      RESIZE_NEAREST_NEIGHBOR: 'nearestNeighbor',
      RESIZE_BILINEAR: 'bilinearInterpolation',
      RESIZE_BICUBIC: 'bicubicInterpolation',
      RESIZE_HERMITE: 'hermiteInterpolation',
      RESIZE_BEZIER: 'bezierInterpolation'
    },
    class: {
      /**
       * Resizes the image to a set width and height using a 2-pass bilinear algorithm
       * @param {number} w the width to resize the image to (or Jimp.AUTO)
       * @param {number} h the height to resize the image to (or Jimp.AUTO)
       * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      resize: function resize(w, h, mode, cb) {
        if (typeof w !== 'number' || typeof h !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'w and h must be numbers', cb);
        }

        if (typeof mode === 'function' && typeof cb === 'undefined') {
          cb = mode;
          mode = null;
        }

        if (w === this.constructor.AUTO && h === this.constructor.AUTO) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'w and h cannot both be set to auto', cb);
        }

        if (w === this.constructor.AUTO) {
          w = this.bitmap.width * (h / this.bitmap.height);
        }

        if (h === this.constructor.AUTO) {
          h = this.bitmap.height * (w / this.bitmap.width);
        }

        if (w < 0 || h < 0) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'w and h must be positive numbers', cb);
        } // round inputs


        w = Math.round(w);
        h = Math.round(h);

        if (typeof _modules_resize2__WEBPACK_IMPORTED_MODULE_2___default.a[mode] === 'function') {
          var dst = {
            data: Buffer.alloc(w * h * 4),
            width: w,
            height: h
          };
          _modules_resize2__WEBPACK_IMPORTED_MODULE_2___default.a[mode](this.bitmap, dst);
          this.bitmap = dst;
        } else {
          var image = this;
          var resize = new _modules_resize__WEBPACK_IMPORTED_MODULE_1___default.a(this.bitmap.width, this.bitmap.height, w, h, true, true, function (buffer) {
            image.bitmap.data = Buffer.from(buffer);
            image.bitmap.width = w;
            image.bitmap.height = h;
          });
          resize.resize(this.bitmap.data);
        }

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
          cb.call(this, null, this);
        }

        return this;
      }
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-resize/es/modules/resize.js":
/*!***************************************************************!*\
  !*** ./node_modules/@jimp/plugin-resize/es/modules/resize.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// JavaScript Image Resizer (c) 2012 - Grant Galitz
// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4
function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
  this.colorChannels = blendAlpha ? 4 : 3;
  this.interpolationPass = Boolean(interpolationPass);
  this.resizeCallback = typeof resizeCallback === 'function' ? resizeCallback : function () {};
  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
  this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
  this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
  this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
  this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
  this.initialize();
}

Resize.prototype.initialize = function () {
  // Perform some checks:
  if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
    this.configurePasses();
  } else {
    throw new Error('Invalid settings specified for the resizer.');
  }
};

Resize.prototype.configurePasses = function () {
  if (this.widthOriginal === this.targetWidth) {
    // Bypass the width resizer pass:
    this.resizeWidth = this.bypassResizer;
  } else {
    // Setup the width resizer pass:
    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;

    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
      this.initializeFirstPassBuffers(true);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
    } else {
      this.initializeFirstPassBuffers(false);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
    }
  }

  if (this.heightOriginal === this.targetHeight) {
    // Bypass the height resizer pass:
    this.resizeHeight = this.bypassResizer;
  } else {
    // Setup the height resizer pass:
    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;

    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
      this.initializeSecondPassBuffers(true);
      this.resizeHeight = this.resizeHeightInterpolated;
    } else {
      this.initializeSecondPassBuffers(false);
      this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
    }
  }
};

Resize.prototype._resizeWidthInterpolatedRGBChannels = function (buffer, fourthChannel) {
  var channelsNum = fourthChannel ? 4 : 3;
  var ratioWeight = this.ratioWeightWidthPass;
  var outputBuffer = this.widthBuffer;
  var weight = 0;
  var finalOffset = 0;
  var pixelOffset = 0;
  var firstWeight = 0;
  var secondWeight = 0;
  var targetPosition; // Handle for only one interpolation input being valid for start calculation:

  for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
    for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  } // Adjust for overshoot of the last pass's counter:


  weight -= 1 / 3;
  var interpolationWidthSourceReadStop;

  for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
    // Calculate weightings:
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight; // Interpolate:

    for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
    }
  } // Handle for only one interpolation input being valid for end calculation:


  for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
    for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  }

  return outputBuffer;
};

Resize.prototype._resizeWidthRGBChannels = function (buffer, fourthChannel) {
  var channelsNum = fourthChannel ? 4 : 3;
  var ratioWeight = this.ratioWeightWidthPass;
  var ratioWeightDivisor = 1 / ratioWeight;
  var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
  var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
  var output = this.outputWidthWorkBench;
  var outputBuffer = this.widthBuffer;
  var trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
  var weight = 0;
  var amountToNext = 0;
  var actualPosition = 0;
  var currentPosition = 0;
  var line = 0;
  var pixelOffset = 0;
  var outputOffset = 0;
  var multiplier = 1;
  var r = 0;
  var g = 0;
  var b = 0;
  var a = 0;

  do {
    for (line = 0; line < this.originalHeightMultipliedByChannels;) {
      output[line++] = 0;
      output[line++] = 0;
      output[line++] = 0;

      if (fourthChannel) {
        output[line++] = 0;
        trustworthyColorsCount[line / channelsNum - 1] = 0;
      }
    }

    weight = ratioWeight;

    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);

      for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
        r = buffer[pixelOffset];
        g = buffer[++pixelOffset];
        b = buffer[++pixelOffset];
        a = fourthChannel ? buffer[++pixelOffset] : 255; // Ignore RGB values if pixel is completely transparent

        output[line++] += (a ? r : 0) * multiplier;
        output[line++] += (a ? g : 0) * multiplier;
        output[line++] += (a ? b : 0) * multiplier;

        if (fourthChannel) {
          output[line++] += a * multiplier;
          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
        }
      }

      if (weight >= amountToNext) {
        actualPosition += channelsNum;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);

    for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      if (fourthChannel) outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
    }

    outputOffset += channelsNum;
  } while (outputOffset < this.targetWidthMultipliedByChannels);

  return outputBuffer;
};

Resize.prototype._resizeHeightRGBChannels = function (buffer, fourthChannel) {
  var ratioWeight = this.ratioWeightHeightPass;
  var ratioWeightDivisor = 1 / ratioWeight;
  var output = this.outputHeightWorkBench;
  var outputBuffer = this.heightBuffer;
  var trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
  var weight = 0;
  var amountToNext = 0;
  var actualPosition = 0;
  var currentPosition = 0;
  var pixelOffset = 0;
  var outputOffset = 0;
  var caret = 0;
  var multiplier = 1;
  var r = 0;
  var g = 0;
  var b = 0;
  var a = 0;

  do {
    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;

      if (fourthChannel) {
        output[pixelOffset++] = 0;
        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
      }
    }

    weight = ratioWeight;

    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);
      caret = actualPosition;

      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
        r = buffer[caret++];
        g = buffer[caret++];
        b = buffer[caret++];
        a = fourthChannel ? buffer[caret++] : 255; // Ignore RGB values if pixel is completely transparent

        output[pixelOffset++] += (a ? r : 0) * multiplier;
        output[pixelOffset++] += (a ? g : 0) * multiplier;
        output[pixelOffset++] += (a ? b : 0) * multiplier;

        if (fourthChannel) {
          output[pixelOffset++] += a * multiplier;
          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
        }
      }

      if (weight >= amountToNext) {
        actualPosition = caret;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.widthPassResultSize);

    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);

      if (fourthChannel) {
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
      }
    }
  } while (outputOffset < this.finalResultSize);

  return outputBuffer;
};

Resize.prototype.resizeWidthInterpolatedRGB = function (buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, false);
};

Resize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, true);
};

Resize.prototype.resizeWidthRGB = function (buffer) {
  return this._resizeWidthRGBChannels(buffer, false);
};

Resize.prototype.resizeWidthRGBA = function (buffer) {
  return this._resizeWidthRGBChannels(buffer, true);
};

Resize.prototype.resizeHeightInterpolated = function (buffer) {
  var ratioWeight = this.ratioWeightHeightPass;
  var outputBuffer = this.heightBuffer;
  var weight = 0;
  var finalOffset = 0;
  var pixelOffset = 0;
  var pixelOffsetAccumulated = 0;
  var pixelOffsetAccumulated2 = 0;
  var firstWeight = 0;
  var secondWeight = 0;
  var interpolationHeightSourceReadStop; // Handle for only one interpolation input being valid for start calculation:

  for (; weight < 1 / 3; weight += ratioWeight) {
    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
    }
  } // Adjust for overshoot of the last pass's counter:


  weight -= 1 / 3;

  for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
    // Calculate weightings:
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight; // Interpolate:

    pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
    pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;

    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
    }
  } // Handle for only one interpolation input being valid for end calculation:


  while (finalOffset < this.finalResultSize) {
    for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
    }
  }

  return outputBuffer;
};

Resize.prototype.resizeHeightRGB = function (buffer) {
  return this._resizeHeightRGBChannels(buffer, false);
};

Resize.prototype.resizeHeightRGBA = function (buffer) {
  return this._resizeHeightRGBChannels(buffer, true);
};

Resize.prototype.resize = function (buffer) {
  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
};

Resize.prototype.bypassResizer = function (buffer) {
  // Just return the buffer passed:
  return buffer;
};

Resize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {
  // Initialize the internal width pass buffers:
  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);

  if (!BILINEARAlgo) {
    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);

    if (this.colorChannels > 3) {
      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
    }
  }
};

Resize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {
  // Initialize the internal height pass buffers:
  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);

  if (!BILINEARAlgo) {
    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);

    if (this.colorChannels > 3) {
      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
    }
  }
};

Resize.prototype.generateFloatBuffer = function (bufferLength) {
  // Generate a float32 typed array buffer:
  try {
    return new Float32Array(bufferLength);
  } catch (error) {
    return [];
  }
};

Resize.prototype.generateFloat64Buffer = function (bufferLength) {
  // Generate a float64 typed array buffer:
  try {
    return new Float64Array(bufferLength);
  } catch (error) {
    return [];
  }
};

Resize.prototype.generateUint8Buffer = function (bufferLength) {
  // Generate a uint8 typed array buffer:
  try {
    return new Uint8Array(bufferLength);
  } catch (error) {
    return [];
  }
};

module.exports = Resize;
//# sourceMappingURL=resize.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-resize/es/modules/resize2.js":
/*!****************************************************************!*\
  !*** ./node_modules/@jimp/plugin-resize/es/modules/resize2.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2015 Guyon Roche
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
module.exports = {
  nearestNeighbor: function nearestNeighbor(src, dst) {
    var wSrc = src.width;
    var hSrc = src.height;
    var wDst = dst.width;
    var hDst = dst.height;
    var bufSrc = src.data;
    var bufDst = dst.data;

    for (var i = 0; i < hDst; i++) {
      for (var j = 0; j < wDst; j++) {
        var posDst = (i * wDst + j) * 4;
        var iSrc = Math.floor(i * hSrc / hDst);
        var jSrc = Math.floor(j * wSrc / wDst);
        var posSrc = (iSrc * wSrc + jSrc) * 4;
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
      }
    }
  },
  bilinearInterpolation: function bilinearInterpolation(src, dst) {
    var wSrc = src.width;
    var hSrc = src.height;
    var wDst = dst.width;
    var hDst = dst.height;
    var bufSrc = src.data;
    var bufDst = dst.data;

    var interpolate = function interpolate(k, kMin, vMin, kMax, vMax) {
      // special case - k is integer
      if (kMin === kMax) {
        return vMin;
      }

      return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
    };

    var assign = function assign(pos, offset, x, xMin, xMax, y, yMin, yMax) {
      var posMin = (yMin * wSrc + xMin) * 4 + offset;
      var posMax = (yMin * wSrc + xMax) * 4 + offset;
      var vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]); // special case, y is integer

      if (yMax === yMin) {
        bufDst[pos + offset] = vMin;
      } else {
        posMin = (yMax * wSrc + xMin) * 4 + offset;
        posMax = (yMax * wSrc + xMax) * 4 + offset;
        var vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
        bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
      }
    };

    for (var i = 0; i < hDst; i++) {
      for (var j = 0; j < wDst; j++) {
        var posDst = (i * wDst + j) * 4; // x & y in src coordinates

        var x = j * wSrc / wDst;
        var xMin = Math.floor(x);
        var xMax = Math.min(Math.ceil(x), wSrc - 1);
        var y = i * hSrc / hDst;
        var yMin = Math.floor(y);
        var yMax = Math.min(Math.ceil(y), hSrc - 1);
        assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
      }
    }
  },
  _interpolate2D: function _interpolate2D(src, dst, options, interpolate) {
    var bufSrc = src.data;
    var bufDst = dst.data;
    var wSrc = src.width;
    var hSrc = src.height;
    var wDst = dst.width;
    var hDst = dst.height; // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares

    var wM = Math.max(1, Math.floor(wSrc / wDst));
    var wDst2 = wDst * wM;
    var hM = Math.max(1, Math.floor(hSrc / hDst));
    var hDst2 = hDst * hM; // ===========================================================
    // Pass 1 - interpolate rows
    // buf1 has width of dst2 and height of src

    var buf1 = Buffer.alloc(wDst2 * hSrc * 4);

    for (var i = 0; i < hSrc; i++) {
      for (var j = 0; j < wDst2; j++) {
        // i in src coords, j in dst coords
        // calculate x in src coords
        // this interpolation requires 4 sample points and the two inner ones must be real
        // the outer points can be fudged for the edges.
        // therefore (wSrc-1)/wDst2
        var x = j * (wSrc - 1) / wDst2;
        var xPos = Math.floor(x);
        var t = x - xPos;
        var srcPos = (i * wSrc + xPos) * 4;
        var buf1Pos = (i * wDst2 + j) * 4;

        for (var k = 0; k < 4; k++) {
          var kPos = srcPos + k;
          var x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
          var x1 = bufSrc[kPos];
          var x2 = bufSrc[kPos + 4];
          var x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
          buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
        }
      }
    } // this._writeFile(wDst2, hSrc, buf1, "out/buf1.jpg");
    // ===========================================================
    // Pass 2 - interpolate columns
    // buf2 has width and height of dst2


    var buf2 = Buffer.alloc(wDst2 * hDst2 * 4);

    for (var _i = 0; _i < hDst2; _i++) {
      for (var _j = 0; _j < wDst2; _j++) {
        // i&j in dst2 coords
        // calculate y in buf1 coords
        // this interpolation requires 4 sample points and the two inner ones must be real
        // the outer points can be fudged for the edges.
        // therefore (hSrc-1)/hDst2
        var y = _i * (hSrc - 1) / hDst2;
        var yPos = Math.floor(y);

        var _t = y - yPos;

        var _buf1Pos = (yPos * wDst2 + _j) * 4;

        var buf2Pos = (_i * wDst2 + _j) * 4;

        for (var _k = 0; _k < 4; _k++) {
          var _kPos = _buf1Pos + _k;

          var y0 = yPos > 0 ? buf1[_kPos - wDst2 * 4] : 2 * buf1[_kPos] - buf1[_kPos + wDst2 * 4];
          var y1 = buf1[_kPos];
          var y2 = buf1[_kPos + wDst2 * 4];
          var y3 = yPos < hSrc - 2 ? buf1[_kPos + wDst2 * 8] : 2 * buf1[_kPos + wDst2 * 4] - buf1[_kPos];
          buf2[buf2Pos + _k] = interpolate(y0, y1, y2, y3, _t);
        }
      }
    } // this._writeFile(wDst2, hDst2, buf2, "out/buf2.jpg");
    // ===========================================================
    // Pass 3 - scale to dst


    var m = wM * hM;

    if (m > 1) {
      for (var _i2 = 0; _i2 < hDst; _i2++) {
        for (var _j2 = 0; _j2 < wDst; _j2++) {
          // i&j in dst bounded coords
          var r = 0;
          var g = 0;
          var b = 0;
          var a = 0;
          var realColors = 0;

          for (var _y = 0; _y < hM; _y++) {
            var _yPos = _i2 * hM + _y;

            for (var _x = 0; _x < wM; _x++) {
              var _xPos = _j2 * wM + _x;

              var xyPos = (_yPos * wDst2 + _xPos) * 4;
              var pixelAlpha = buf2[xyPos + 3];

              if (pixelAlpha) {
                r += buf2[xyPos];
                g += buf2[xyPos + 1];
                b += buf2[xyPos + 2];
                realColors++;
              }

              a += pixelAlpha;
            }
          }

          var pos = (_i2 * wDst + _j2) * 4;
          bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
          bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
          bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
          bufDst[pos + 3] = Math.round(a / m);
        }
      }
    } else {
      // replace dst buffer with buf2
      dst.data = buf2;
    }
  },
  bicubicInterpolation: function bicubicInterpolation(src, dst, options) {
    var interpolateCubic = function interpolateCubic(x0, x1, x2, x3, t) {
      var a0 = x3 - x2 - x0 + x1;
      var a1 = x0 - x1 - a0;
      var a2 = x2 - x0;
      var a3 = x1;
      return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
    };

    return this._interpolate2D(src, dst, options, interpolateCubic);
  },
  hermiteInterpolation: function hermiteInterpolation(src, dst, options) {
    var interpolateHermite = function interpolateHermite(x0, x1, x2, x3, t) {
      var c0 = x1;
      var c1 = 0.5 * (x2 - x0);
      var c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
      var c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
      return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
    };

    return this._interpolate2D(src, dst, options, interpolateHermite);
  },
  bezierInterpolation: function bezierInterpolation(src, dst, options) {
    // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)
    // to predict control points (a & b) to be placed at n+0.5
    //  ya(n) = y(n) + (y(n+1)-y(n-1))/4
    //  yb(n) = y(n+1) - (y(n+2)-y(n))/4
    // then use std bezier to interpolate [n,n+1)
    //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3
    //  note the 3* factor for the two control points
    // for edge cases, can choose:
    //  y(-1) = y(0) - 2*(y(1)-y(0))
    //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))
    // but can go with y(-1) = y(0) and y(w) = y(w-1)
    var interpolateBezier = function interpolateBezier(x0, x1, x2, x3, t) {
      // x1, x2 are the knots, use x0 and x3 to calculate control points
      var cp1 = x1 + (x2 - x0) / 4;
      var cp2 = x2 - (x3 - x1) / 4;
      var nt = 1 - t;
      var c0 = x1 * nt * nt * nt;
      var c1 = 3 * cp1 * nt * nt * t;
      var c2 = 3 * cp2 * nt * t * t;
      var c3 = x2 * t * t * t;
      return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
    };

    return this._interpolate2D(src, dst, options, interpolateBezier);
  }
};
//# sourceMappingURL=resize2.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-rotate/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-rotate/es/index.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");


function rotate90degrees(bitmap, dstBuffer, clockwise) {
  var dstOffsetStep = clockwise ? -4 : 4;
  var dstOffset = clockwise ? dstBuffer.length - 4 : 0;
  var tmp;
  var x;
  var y;
  var srcOffset;

  for (x = 0; x < bitmap.width; x++) {
    for (y = bitmap.height - 1; y >= 0; y--) {
      srcOffset = bitmap.width * y + x << 2;
      tmp = bitmap.data.readUInt32BE(srcOffset, true);
      dstBuffer.writeUInt32BE(tmp, dstOffset, true);
      dstOffset += dstOffsetStep;
    }
  }
}
/**
 * Rotates an image clockwise by a number of degrees rounded to the nearest 90 degrees. NB: 'this' must be a Jimp object.
 * @param {number} deg the number of degrees to rotate the image by
 */


function simpleRotate(deg) {
  var steps = Math.round(deg / 90) % 4;
  steps += steps < 0 ? 4 : 0;
  if (steps === 0) return;
  var srcBuffer = this.bitmap.data;
  var len = srcBuffer.length;
  var dstBuffer = Buffer.allocUnsafe(len);
  var tmp;

  if (steps === 2) {
    // Upside-down
    for (var srcOffset = 0; srcOffset < len; srcOffset += 4) {
      tmp = srcBuffer.readUInt32BE(srcOffset, true);
      dstBuffer.writeUInt32BE(tmp, len - srcOffset - 4, true);
    }
  } else {
    // Clockwise or counter-clockwise rotation by 90 degree
    rotate90degrees(this.bitmap, dstBuffer, steps === 1);
    tmp = this.bitmap.width;
    this.bitmap.width = this.bitmap.height;
    this.bitmap.height = tmp;
  }

  this.bitmap.data = dstBuffer;
}
/**
 * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.
 * @param {number} deg the number of degrees to rotate the image by
 * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
 */


function advancedRotate(deg, mode) {
  deg %= 360;
  var rad = deg * Math.PI / 180;
  var cosine = Math.cos(rad);
  var sine = Math.sin(rad); // the final width and height will change if resize == true

  var w = this.bitmap.width;
  var h = this.bitmap.height;

  if (mode === true || typeof mode === 'string') {
    // resize the image to it maximum dimension and blit the existing image
    // onto the center so that when it is rotated the image is kept in bounds
    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle
    // Plus 1 border pixel to ensure to show all rotated result for some cases.
    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;
    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1; // Ensure destination to have even size to a better result.

    if (w % 2 !== 0) {
      w++;
    }

    if (h % 2 !== 0) {
      h++;
    }

    var c = this.cloneQuiet();
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {
      this.bitmap.data.writeUInt32BE(this._background, idx);
    });
    var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
    this.resize(max, max, mode);
    this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
  }

  var bW = this.bitmap.width;
  var bH = this.bitmap.height;
  var dstBuffer = Buffer.alloc(this.bitmap.data.length);

  function createTranslationFunction(deltaX, deltaY) {
    return function (x, y) {
      return {
        x: x + deltaX,
        y: y + deltaY
      };
    };
  }

  var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
  var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);

  for (var y = 1; y <= bH; y++) {
    for (var x = 1; x <= bW; x++) {
      var cartesian = translate2Cartesian(x, y);
      var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
      var dstIdx = bW * (y - 1) + x - 1 << 2;

      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
        var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
        var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
      } else {
        // reset off-image pixels
        dstBuffer.writeUInt32BE(this._background, dstIdx);
      }
    }
  }

  this.bitmap.data = dstBuffer;

  if (mode === true || typeof mode === 'string') {
    // now crop the image to the final size
    var _x = bW / 2 - w / 2;

    var _y = bH / 2 - h / 2;

    this.crop(_x, _y, w, h);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    /**
     * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
     * @param {number} deg the number of degrees to rotate the image by
     * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp} this for chaining of methods
     */
    rotate: function rotate(deg, mode, cb) {
      // enable overloading
      if (typeof mode === 'undefined' || mode === null) {
        // e.g. image.resize(120);
        // e.g. image.resize(120, null, cb);
        // e.g. image.resize(120, undefined, cb);
        mode = true;
      }

      if (typeof mode === 'function' && typeof cb === 'undefined') {
        // e.g. image.resize(120, cb);
        cb = mode;
        mode = true;
      }

      if (typeof deg !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'deg must be a number', cb);
      }

      if (typeof mode !== 'boolean' && typeof mode !== 'string') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'mode must be a boolean or a string', cb);
      }

      if (deg % 90 === 0 && Boolean(mode) === false) {
        simpleRotate.call(this, deg, cb);
      } else {
        advancedRotate.call(this, deg, mode, cb);
      }

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugin-scale/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-scale/es/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    /**
     * Uniformly scales the image by a factor.
     * @param {number} f the factor to scale the image by
     * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp} this for chaining of methods
     */
    scale: function scale(f, mode, cb) {
      if (typeof f !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'f must be a number', cb);
      }

      if (f < 0) {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'f must be a positive number', cb);
      }

      if (typeof mode === 'function' && typeof cb === 'undefined') {
        cb = mode;
        mode = null;
      }

      var w = this.bitmap.width * f;
      var h = this.bitmap.height * f;
      this.resize(w, h, mode);

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    },

    /**
     * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
     * @param {number} w the width to resize the image to
     * @param {number} h the height to resize the image to
     * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
     * @returns {Jimp} this for chaining of methods
     */
    scaleToFit: function scaleToFit(w, h, mode, cb) {
      if (typeof w !== 'number' || typeof h !== 'number') {
        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__["throwError"].call(this, 'w and h must be numbers', cb);
      }

      if (typeof mode === 'function' && typeof cb === 'undefined') {
        cb = mode;
        mode = null;
      }

      var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
      this.scale(f, mode);

      if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_0__["isNodePattern"])(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/plugins/es/index.js":
/*!************************************************!*\
  !*** ./node_modules/@jimp/plugins/es/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var timm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timm */ "./node_modules/timm/lib/timm.js");
/* harmony import */ var timm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(timm__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jimp_plugin_dither__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/plugin-dither */ "./node_modules/@jimp/plugin-dither/es/index.js");
/* harmony import */ var _jimp_plugin_resize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/plugin-resize */ "./node_modules/@jimp/plugin-resize/es/index.js");
/* harmony import */ var _jimp_plugin_blit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jimp/plugin-blit */ "./node_modules/@jimp/plugin-blit/es/index.js");
/* harmony import */ var _jimp_plugin_rotate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jimp/plugin-rotate */ "./node_modules/@jimp/plugin-rotate/es/index.js");
/* harmony import */ var _jimp_plugin_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jimp/plugin-color */ "./node_modules/@jimp/plugin-color/es/index.js");
/* harmony import */ var _jimp_plugin_print__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jimp/plugin-print */ "./node_modules/@jimp/plugin-print/es/index.js");
/* harmony import */ var _jimp_plugin_blur__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jimp/plugin-blur */ "./node_modules/@jimp/plugin-blur/es/index.js");
/* harmony import */ var _jimp_plugin_crop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jimp/plugin-crop */ "./node_modules/@jimp/plugin-crop/es/index.js");
/* harmony import */ var _jimp_plugin_normalize__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @jimp/plugin-normalize */ "./node_modules/@jimp/plugin-normalize/es/index.js");
/* harmony import */ var _jimp_plugin_invert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @jimp/plugin-invert */ "./node_modules/@jimp/plugin-invert/es/index.js");
/* harmony import */ var _jimp_plugin_gaussian__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @jimp/plugin-gaussian */ "./node_modules/@jimp/plugin-gaussian/es/index.js");
/* harmony import */ var _jimp_plugin_flip__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @jimp/plugin-flip */ "./node_modules/@jimp/plugin-flip/es/index.js");
/* harmony import */ var _jimp_plugin_mask__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @jimp/plugin-mask */ "./node_modules/@jimp/plugin-mask/es/index.js");
/* harmony import */ var _jimp_plugin_scale__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @jimp/plugin-scale */ "./node_modules/@jimp/plugin-scale/es/index.js");
/* harmony import */ var _jimp_plugin_displace__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @jimp/plugin-displace */ "./node_modules/@jimp/plugin-displace/es/index.js");
/* harmony import */ var _jimp_plugin_contain__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @jimp/plugin-contain */ "./node_modules/@jimp/plugin-contain/es/index.js");
/* harmony import */ var _jimp_plugin_cover__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @jimp/plugin-cover */ "./node_modules/@jimp/plugin-cover/es/index.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }



















var plugins = [_jimp_plugin_dither__WEBPACK_IMPORTED_MODULE_1__["default"], _jimp_plugin_resize__WEBPACK_IMPORTED_MODULE_2__["default"], _jimp_plugin_blit__WEBPACK_IMPORTED_MODULE_3__["default"], _jimp_plugin_rotate__WEBPACK_IMPORTED_MODULE_4__["default"], _jimp_plugin_color__WEBPACK_IMPORTED_MODULE_5__["default"], _jimp_plugin_print__WEBPACK_IMPORTED_MODULE_6__["default"], _jimp_plugin_blur__WEBPACK_IMPORTED_MODULE_7__["default"], _jimp_plugin_crop__WEBPACK_IMPORTED_MODULE_8__["default"], _jimp_plugin_normalize__WEBPACK_IMPORTED_MODULE_9__["default"], _jimp_plugin_invert__WEBPACK_IMPORTED_MODULE_10__["default"], _jimp_plugin_gaussian__WEBPACK_IMPORTED_MODULE_11__["default"], _jimp_plugin_flip__WEBPACK_IMPORTED_MODULE_12__["default"], _jimp_plugin_mask__WEBPACK_IMPORTED_MODULE_13__["default"], _jimp_plugin_scale__WEBPACK_IMPORTED_MODULE_14__["default"], _jimp_plugin_displace__WEBPACK_IMPORTED_MODULE_15__["default"], _jimp_plugin_contain__WEBPACK_IMPORTED_MODULE_16__["default"], _jimp_plugin_cover__WEBPACK_IMPORTED_MODULE_17__["default"]];
/* harmony default export */ __webpack_exports__["default"] = (function (jimpEvChange) {
  var initializedPlugins = plugins.map(function (pluginModule) {
    var plugin = pluginModule(jimpEvChange) || {};

    if (!plugin.class && !plugin.constants) {
      // Default to class function
      plugin = {
        class: plugin
      };
    }

    return plugin;
  });
  return timm__WEBPACK_IMPORTED_MODULE_0__["mergeDeep"].apply(void 0, _toConsumableArray(initializedPlugins));
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/png/es/index.js":
/*!********************************************!*\
  !*** ./node_modules/@jimp/png/es/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var pngjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pngjs */ "./node_modules/pngjs/lib/png.js");
/* harmony import */ var pngjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pngjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ "./node_modules/@jimp/utils/es/index.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var MIME_TYPE = 'image/png'; // PNG filter types

var PNG_FILTER_AUTO = -1;
var PNG_FILTER_NONE = 0;
var PNG_FILTER_SUB = 1;
var PNG_FILTER_UP = 2;
var PNG_FILTER_AVERAGE = 3;
var PNG_FILTER_PATH = 4;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    mime: _defineProperty({}, MIME_TYPE, ['png']),
    constants: {
      MIME_PNG: MIME_TYPE,
      PNG_FILTER_AUTO: PNG_FILTER_AUTO,
      PNG_FILTER_NONE: PNG_FILTER_NONE,
      PNG_FILTER_SUB: PNG_FILTER_SUB,
      PNG_FILTER_UP: PNG_FILTER_UP,
      PNG_FILTER_AVERAGE: PNG_FILTER_AVERAGE,
      PNG_FILTER_PATH: PNG_FILTER_PATH
    },
    hasAlpha: _defineProperty({}, MIME_TYPE, true),
    decoders: _defineProperty({}, MIME_TYPE, pngjs__WEBPACK_IMPORTED_MODULE_0__["PNG"].sync.read),
    encoders: _defineProperty({}, MIME_TYPE, function (data) {
      var png = new pngjs__WEBPACK_IMPORTED_MODULE_0__["PNG"]({
        width: data.bitmap.width,
        height: data.bitmap.height
      });
      png.data = data.bitmap.data;
      return pngjs__WEBPACK_IMPORTED_MODULE_0__["PNG"].sync.write(png, {
        width: data.bitmap.width,
        height: data.bitmap.height,
        deflateLevel: data._deflateLevel,
        deflateStrategy: data._deflateStrategy,
        filterType: data._filterType,
        colorType: typeof data._colorType === 'number' ? data._colorType : data._rgba ? 6 : 2,
        inputHasAlpha: data._rgba
      });
    }),
    class: {
      _deflateLevel: 9,
      _deflateStrategy: 3,
      _filterType: PNG_FILTER_AUTO,
      _colorType: null,

      /**
       * Sets the deflate level used when saving as PNG format (default is 9)
       * @param {number} l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      deflateLevel: function deflateLevel(l, cb) {
        if (typeof l !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'l must be a number', cb);
        }

        if (l < 0 || l > 9) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'l must be a number 0 - 9', cb);
        }

        this._deflateLevel = Math.round(l);

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
          cb.call(this, null, this);
        }

        return this;
      },

      /**
       * Sets the deflate strategy used when saving as PNG format (default is 3)
       * @param {number} s Deflate strategy to use 0-3.
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      deflateStrategy: function deflateStrategy(s, cb) {
        if (typeof s !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 's must be a number', cb);
        }

        if (s < 0 || s > 3) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 's must be a number 0 - 3', cb);
        }

        this._deflateStrategy = Math.round(s);

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
          cb.call(this, null, this);
        }

        return this;
      },

      /**
       * Sets the filter type used when saving as PNG format (default is automatic filters)
       * @param {number} f The quality to use -1-4.
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      filterType: function filterType(f, cb) {
        if (typeof f !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'n must be a number', cb);
        }

        if (f < -1 || f > 4) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 'n must be -1 (auto) or a number 0 - 4', cb);
        }

        this._filterType = Math.round(f);

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
          cb.call(this, null, this);
        }

        return this;
      },

      /**
       * Sets the color type used when saving as PNG format
       * @param {number} s color type to use 0, 2, 4, 6.
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      colorType: function colorType(s, cb) {
        if (typeof s !== 'number') {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 's must be a number', cb);
        }

        if (s !== 0 && s !== 2 && s !== 4 && s !== 6) {
          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__["throwError"].call(this, 's must be a number 0, 2, 4, 6.', cb);
        }

        this._colorType = Math.round(s);

        if (Object(_jimp_utils__WEBPACK_IMPORTED_MODULE_1__["isNodePattern"])(cb)) {
          cb.call(this, null, this);
        }

        return this;
      }
    }
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/tiff/es/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@jimp/tiff/es/index.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var utif__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utif */ "./node_modules/utif/UTIF.js");
/* harmony import */ var utif__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(utif__WEBPACK_IMPORTED_MODULE_0__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var MIME_TYPE = 'image/tiff';
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    mime: _defineProperty({}, MIME_TYPE, ['tiff', 'tif']),
    constants: {
      MIME_TIFF: MIME_TYPE
    },
    decoders: _defineProperty({}, MIME_TYPE, function (data) {
      var ifds = utif__WEBPACK_IMPORTED_MODULE_0___default.a.decode(data);
      var page = ifds[0];
      utif__WEBPACK_IMPORTED_MODULE_0___default.a.decodeImages(data, ifds);
      var rgba = utif__WEBPACK_IMPORTED_MODULE_0___default.a.toRGBA8(page);
      return {
        data: Buffer.from(rgba),
        width: page.t256[0],
        height: page.t257[0]
      };
    }),
    encoders: _defineProperty({}, MIME_TYPE, function (image) {
      var tiff = utif__WEBPACK_IMPORTED_MODULE_0___default.a.encodeImage(image.bitmap.data, image.bitmap.width, image.bitmap.height);
      return Buffer.from(tiff);
    })
  };
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/types/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@jimp/types/es/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var timm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timm */ "./node_modules/timm/lib/timm.js");
/* harmony import */ var timm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(timm__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jimp_jpeg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/jpeg */ "./node_modules/@jimp/jpeg/es/index.js");
/* harmony import */ var _jimp_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/png */ "./node_modules/@jimp/png/es/index.js");
/* harmony import */ var _jimp_bmp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jimp/bmp */ "./node_modules/@jimp/bmp/es/index.js");
/* harmony import */ var _jimp_tiff__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jimp/tiff */ "./node_modules/@jimp/tiff/es/index.js");
/* harmony import */ var _jimp_gif__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jimp/gif */ "./node_modules/@jimp/gif/es/index.js");






/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(timm__WEBPACK_IMPORTED_MODULE_0__["mergeDeep"])(Object(_jimp_jpeg__WEBPACK_IMPORTED_MODULE_1__["default"])(), Object(_jimp_png__WEBPACK_IMPORTED_MODULE_2__["default"])(), Object(_jimp_bmp__WEBPACK_IMPORTED_MODULE_3__["default"])(), Object(_jimp_tiff__WEBPACK_IMPORTED_MODULE_4__["default"])(), Object(_jimp_gif__WEBPACK_IMPORTED_MODULE_5__["default"])());
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jimp/utils/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@jimp/utils/es/index.js ***!
  \**********************************************/
/*! exports provided: isNodePattern, throwError, scan */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNodePattern", function() { return isNodePattern; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwError", function() { return throwError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return scan; });
function isNodePattern(cb) {
  if (typeof cb === 'undefined') {
    return false;
  }

  if (typeof cb !== 'function') {
    throw new TypeError('Callback must be a function');
  }

  return true;
}
function throwError(error, cb) {
  if (typeof error === 'string') {
    error = new Error(error);
  }

  if (typeof cb === 'function') {
    return cb.call(this, error);
  }

  throw error;
}
function scan(image, x, y, w, h, f) {
  // round input
  x = Math.round(x);
  y = Math.round(y);
  w = Math.round(w);
  h = Math.round(h);

  for (var _y = y; _y < y + h; _y++) {
    for (var _x = x; _x < x + w; _x++) {
      var idx = image.bitmap.width * _y + _x << 2;
      f.call(image, _x, _y, idx);
    }
  }

  return image;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/any-base/index.js":
/*!****************************************!*\
  !*** ./node_modules/any-base/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Converter = __webpack_require__(/*! ./src/converter */ "./node_modules/any-base/src/converter.js");

/**
 * Function get source and destination alphabet and return convert function
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 *
 * @returns {function(number|Array)}
 */
function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    /**
     * Convert function
     *
     * @param {string|Array} number
     *
     * @return {string|Array} number
     */
    return function (number) {
        return converter.convert(number);
    }
};

anyBase.BIN = '01';
anyBase.OCT = '01234567';
anyBase.DEC = '0123456789';
anyBase.HEX = '0123456789abcdef';

module.exports = anyBase;

/***/ }),

/***/ "./node_modules/any-base/src/converter.js":
/*!************************************************!*\
  !*** ./node_modules/any-base/src/converter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converter
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 * @constructor
 */
function Converter(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error('Bad alphabet');
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
}

/**
 * Convert number from source alphabet to destination alphabet
 *
 * @param {string|Array} number - number represented as a string or array of points
 *
 * @returns {string|Array}
 */
Converter.prototype.convert = function(number) {
    var i, divide, newlen,
    numberMap = {},
    fromBase = this.srcAlphabet.length,
    toBase = this.dstAlphabet.length,
    length = number.length,
    result = typeof number === 'string' ? '' : [];

    if (!this.isValid(number)) {
        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
    }

    if (this.srcAlphabet === this.dstAlphabet) {
        return number;
    }

    for (i = 0; i < length; i++) {
        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
    }
    do {
        divide = 0;
        newlen = 0;
        for (i = 0; i < length; i++) {
            divide = divide * fromBase + numberMap[i];
            if (divide >= toBase) {
                numberMap[newlen++] = parseInt(divide / toBase, 10);
                divide = divide % toBase;
            } else if (newlen > 0) {
                numberMap[newlen++] = 0;
            }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);

    return result;
};

/**
 * Valid number with source alphabet
 *
 * @param {number} number
 *
 * @returns {boolean}
 */
Converter.prototype.isValid = function(number) {
    var i = 0;
    for (; i < number.length; ++i) {
        if (this.srcAlphabet.indexOf(number[i]) === -1) {
            return false;
        }
    }
    return true;
};

module.exports = Converter;

/***/ }),

/***/ "./node_modules/bmp-js/index.js":
/*!**************************************!*\
  !*** ./node_modules/bmp-js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @author shaozilee
 *
 * support 1bit 4bit 8bit 24bit decode
 * encode with 24bit
 * 
 */

var encode = __webpack_require__(/*! ./lib/encoder */ "./node_modules/bmp-js/lib/encoder.js"),
    decode = __webpack_require__(/*! ./lib/decoder */ "./node_modules/bmp-js/lib/decoder.js");

module.exports = {
  encode: encode,
  decode: decode
};


/***/ }),

/***/ "./node_modules/bmp-js/lib/decoder.js":
/*!********************************************!*\
  !*** ./node_modules/bmp-js/lib/decoder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @author shaozilee
 *
 * Bmp format decoder,support 1bit 4bit 8bit 24bit bmp
 *
 */

function BmpDecoder(buffer,is_with_alpha) {
  this.pos = 0;
  this.buffer = buffer;
  this.is_with_alpha = !!is_with_alpha;
  this.bottom_up = true;
  this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
  if (this.flag != "BM") throw new Error("Invalid BMP File");
  this.parseHeader();
  this.parseRGBA();
}

BmpDecoder.prototype.parseHeader = function() {
  this.fileSize = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.reserved = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.offset = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.headerSize = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.width = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.height = this.buffer.readInt32LE(this.pos);
  this.pos += 4;
  this.planes = this.buffer.readUInt16LE(this.pos);
  this.pos += 2;
  this.bitPP = this.buffer.readUInt16LE(this.pos);
  this.pos += 2;
  this.compress = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.rawSize = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.hr = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.vr = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.colors = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;
  this.importantColors = this.buffer.readUInt32LE(this.pos);
  this.pos += 4;

  if(this.bitPP === 16 && this.is_with_alpha){
    this.bitPP = 15
  }
  if (this.bitPP < 15) {
    var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(len);
    for (var i = 0; i < len; i++) {
      var blue = this.buffer.readUInt8(this.pos++);
      var green = this.buffer.readUInt8(this.pos++);
      var red = this.buffer.readUInt8(this.pos++);
      var quad = this.buffer.readUInt8(this.pos++);
      this.palette[i] = {
        red: red,
        green: green,
        blue: blue,
        quad: quad
      };
    }
  }
  if(this.height < 0) {
    this.height *= -1;
    this.bottom_up = false;
  }

}

BmpDecoder.prototype.parseRGBA = function() {
    var bitn = "bit" + this.bitPP;
    var len = this.width * this.height * 4;
    this.data = new Buffer(len);
    this[bitn]();
};

BmpDecoder.prototype.bit1 = function() {
  var xlen = Math.ceil(this.width / 8);
  var mode = xlen%4;
  var y = this.height >= 0 ? this.height - 1 : -this.height
  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y
    for (var x = 0; x < xlen; x++) {
      var b = this.buffer.readUInt8(this.pos++);
      var location = line * this.width * 4 + x*8*4;
      for (var i = 0; i < 8; i++) {
        if(x*8+i<this.width){
          var rgb = this.palette[((b>>(7-i))&0x1)];

          this.data[location+i*4] = 0;
          this.data[location+i*4 + 1] = rgb.blue;
          this.data[location+i*4 + 2] = rgb.green;
          this.data[location+i*4 + 3] = rgb.red;

        }else{
          break;
        }
      }
    }

    if (mode != 0){
      this.pos+=(4 - mode);
    }
  }
};

BmpDecoder.prototype.bit4 = function() {
    //RLE-4
    if(this.compress == 2){
        this.data.fill(0xff);

        var location = 0;
        var lines = this.bottom_up?this.height-1:0;
        var low_nibble = false;//for all count of pixel

        while(location<this.data.length){
            var a = this.buffer.readUInt8(this.pos++);
            var b = this.buffer.readUInt8(this.pos++);
            //absolute mode
            if(a == 0){
                if(b == 0){//line end
                    if(this.bottom_up){
                        lines--;
                    }else{
                        lines++;
                    }
                    location = lines*this.width*4;
                    low_nibble = false;
                    continue;
                }else if(b == 1){//image end
                    break;
                }else if(b ==2){
                    //offset x,y
                    var x = this.buffer.readUInt8(this.pos++);
                    var y = this.buffer.readUInt8(this.pos++);
                    if(this.bottom_up){
                        lines-=y;
                    }else{
                        lines+=y;
                    }

                    location +=(y*this.width*4+x*4);
                }else{
                    var c = this.buffer.readUInt8(this.pos++);
                    for(var i=0;i<b;i++){
                        if (low_nibble) {
                            setPixelData.call(this, (c & 0x0f));
                        } else {
                            setPixelData.call(this, (c & 0xf0)>>4);
                        }

                        if ((i & 1) && (i+1 < b)){
                            c = this.buffer.readUInt8(this.pos++);
                        }

                        low_nibble = !low_nibble;
                    }

                    if ((((b+1) >> 1) & 1 ) == 1){
                        this.pos++
                    }
                }

            }else{//encoded mode
                for (var i = 0; i < a; i++) {
                    if (low_nibble) {
                        setPixelData.call(this, (b & 0x0f));
                    } else {
                        setPixelData.call(this, (b & 0xf0)>>4);
                    }
                    low_nibble = !low_nibble;
                }
            }

        }




        function setPixelData(rgbIndex){
            var rgb = this.palette[rgbIndex];
            this.data[location] = 0;
            this.data[location + 1] = rgb.blue;
            this.data[location + 2] = rgb.green;
            this.data[location + 3] = rgb.red;
            location+=4;
        }
    }else{

      var xlen = Math.ceil(this.width/2);
      var mode = xlen%4;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y
        for (var x = 0; x < xlen; x++) {
          var b = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x*2*4;

          var before = b>>4;
          var after = b&0x0F;

          var rgb = this.palette[before];
          this.data[location] = 0;
          this.data[location + 1] = rgb.blue;
          this.data[location + 2] = rgb.green;
          this.data[location + 3] = rgb.red;


          if(x*2+1>=this.width)break;

          rgb = this.palette[after];

          this.data[location+4] = 0;
          this.data[location+4 + 1] = rgb.blue;
          this.data[location+4 + 2] = rgb.green;
          this.data[location+4 + 3] = rgb.red;

        }

        if (mode != 0){
          this.pos+=(4 - mode);
        }
      }

    }

};

BmpDecoder.prototype.bit8 = function() {
    //RLE-8
    if(this.compress == 1){
        this.data.fill(0xff);

        var location = 0;
        var lines = this.bottom_up?this.height-1:0;

        while(location<this.data.length){
            var a = this.buffer.readUInt8(this.pos++);
            var b = this.buffer.readUInt8(this.pos++);
            //absolute mode
            if(a == 0){
                if(b == 0){//line end
                    if(this.bottom_up){
                        lines--;
                    }else{
                        lines++;
                    }
                    location = lines*this.width*4;
                    continue;
                }else if(b == 1){//image end
                    break;
                }else if(b ==2){
                    //offset x,y
                    var x = this.buffer.readUInt8(this.pos++);
                    var y = this.buffer.readUInt8(this.pos++);
                    if(this.bottom_up){
                        lines-=y;
                    }else{
                        lines+=y;
                    }

                    location +=(y*this.width*4+x*4);
                }else{
                    for(var i=0;i<b;i++){
                        var c = this.buffer.readUInt8(this.pos++);
                        setPixelData.call(this, c);
                    }
                    if(b&1 == 1){
                        this.pos++;
                    }

                }

            }else{//encoded mode
                for (var i = 0; i < a; i++) {
                    setPixelData.call(this, b);
                }
            }

        }




        function setPixelData(rgbIndex){
            var rgb = this.palette[rgbIndex];
            this.data[location] = 0;
            this.data[location + 1] = rgb.blue;
            this.data[location + 2] = rgb.green;
            this.data[location + 3] = rgb.red;
            location+=4;
        }
    }else {
        var mode = this.width % 4;
        for (var y = this.height - 1; y >= 0; y--) {
            var line = this.bottom_up ? y : this.height - 1 - y
            for (var x = 0; x < this.width; x++) {
                var b = this.buffer.readUInt8(this.pos++);
                var location = line * this.width * 4 + x * 4;
                if (b < this.palette.length) {
                    var rgb = this.palette[b];

                    this.data[location] = 0;
                    this.data[location + 1] = rgb.blue;
                    this.data[location + 2] = rgb.green;
                    this.data[location + 3] = rgb.red;

                } else {
                    this.data[location] = 0;
                    this.data[location + 1] = 0xFF;
                    this.data[location + 2] = 0xFF;
                    this.data[location + 3] = 0xFF;
                }
            }
            if (mode != 0) {
                this.pos += (4 - mode);
            }
        }
    }
};

BmpDecoder.prototype.bit15 = function() {
  var dif_w =this.width % 3;
  var _11111 = parseInt("11111", 2),_1_5 = _11111;
  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y
    for (var x = 0; x < this.width; x++) {

      var B = this.buffer.readUInt16LE(this.pos);
      this.pos+=2;
      var blue = (B & _1_5) / _1_5 * 255 | 0;
      var green = (B >> 5 & _1_5 ) / _1_5 * 255 | 0;
      var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
      var alpha = (B>>15)?0xFF:0x00;

      var location = line * this.width * 4 + x * 4;

      this.data[location] = alpha;
      this.data[location + 1] = blue;
      this.data[location + 2] = green;
      this.data[location + 3] = red;
    }
    //skip extra bytes
    this.pos += dif_w;
  }
};

BmpDecoder.prototype.bit16 = function() {
  var dif_w =(this.width % 2)*2;
  //default xrgb555
  this.maskRed = 0x7C00;
  this.maskGreen = 0x3E0;
  this.maskBlue =0x1F;
  this.mask0 = 0;

  if(this.compress == 3){
    this.maskRed = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
    this.maskGreen = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
    this.maskBlue = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
    this.mask0 = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
  }


  var ns=[0,0,0];
  for (var i=0;i<16;i++){
    if ((this.maskRed>>i)&0x01) ns[0]++;
    if ((this.maskGreen>>i)&0x01) ns[1]++;
    if ((this.maskBlue>>i)&0x01) ns[2]++;
  }
  ns[1]+=ns[0]; ns[2]+=ns[1];	ns[0]=8-ns[0]; ns[1]-=8; ns[2]-=8;

  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y;
    for (var x = 0; x < this.width; x++) {

      var B = this.buffer.readUInt16LE(this.pos);
      this.pos+=2;

      var blue = (B&this.maskBlue)<<ns[0];
      var green = (B&this.maskGreen)>>ns[1];
      var red = (B&this.maskRed)>>ns[2];

      var location = line * this.width * 4 + x * 4;

      this.data[location] = 0;
      this.data[location + 1] = blue;
      this.data[location + 2] = green;
      this.data[location + 3] = red;
    }
    //skip extra bytes
    this.pos += dif_w;
  }
};

BmpDecoder.prototype.bit24 = function() {
  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y
    for (var x = 0; x < this.width; x++) {
      //Little Endian rgb
      var blue = this.buffer.readUInt8(this.pos++);
      var green = this.buffer.readUInt8(this.pos++);
      var red = this.buffer.readUInt8(this.pos++);
      var location = line * this.width * 4 + x * 4;
      this.data[location] = 0;
      this.data[location + 1] = blue;
      this.data[location + 2] = green;
      this.data[location + 3] = red;
    }
    //skip extra bytes
    this.pos += (this.width % 4);
  }

};

/**
 * add 32bit decode func
 * @author soubok
 */
BmpDecoder.prototype.bit32 = function() {
  //BI_BITFIELDS
  if(this.compress == 3){
    this.maskRed = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
    this.maskGreen = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
    this.maskBlue = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
    this.mask0 = this.buffer.readUInt32LE(this.pos);
    this.pos+=4;
      for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
              //Little Endian rgba
              var alpha = this.buffer.readUInt8(this.pos++);
              var blue = this.buffer.readUInt8(this.pos++);
              var green = this.buffer.readUInt8(this.pos++);
              var red = this.buffer.readUInt8(this.pos++);
              var location = line * this.width * 4 + x * 4;
              this.data[location] = alpha;
              this.data[location + 1] = blue;
              this.data[location + 2] = green;
              this.data[location + 3] = red;
          }
      }

  }else{
      for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
              //Little Endian argb
              var blue = this.buffer.readUInt8(this.pos++);
              var green = this.buffer.readUInt8(this.pos++);
              var red = this.buffer.readUInt8(this.pos++);
              var alpha = this.buffer.readUInt8(this.pos++);
              var location = line * this.width * 4 + x * 4;
              this.data[location] = alpha;
              this.data[location + 1] = blue;
              this.data[location + 2] = green;
              this.data[location + 3] = red;
          }
      }

  }




};

BmpDecoder.prototype.getData = function() {
  return this.data;
};

module.exports = function(bmpData) {
  var decoder = new BmpDecoder(bmpData);
  return decoder;
};


/***/ }),

/***/ "./node_modules/bmp-js/lib/encoder.js":
/*!********************************************!*\
  !*** ./node_modules/bmp-js/lib/encoder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @author shaozilee
 *
 * BMP format encoder,encode 24bit BMP
 * Not support quality compression
 *
 */

function BmpEncoder(imgData){
	this.buffer = imgData.data;
	this.width = imgData.width;
	this.height = imgData.height;
	this.extraBytes = this.width%4;
	this.rgbSize = this.height*(3*this.width+this.extraBytes);
	this.headerInfoSize = 40;

	this.data = [];
	/******************header***********************/
	this.flag = "BM";
	this.reserved = 0;
	this.offset = 54;
	this.fileSize = this.rgbSize+this.offset;
	this.planes = 1;
	this.bitPP = 24;
	this.compress = 0;
	this.hr = 0;
	this.vr = 0;
	this.colors = 0;
	this.importantColors = 0;
}

BmpEncoder.prototype.encode = function() {
	var tempBuffer = new Buffer(this.offset+this.rgbSize);
	this.pos = 0;
	tempBuffer.write(this.flag,this.pos,2);this.pos+=2;
	tempBuffer.writeUInt32LE(this.fileSize,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.reserved,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.offset,this.pos);this.pos+=4;

	tempBuffer.writeUInt32LE(this.headerInfoSize,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.width,this.pos);this.pos+=4;
	tempBuffer.writeInt32LE(-this.height,this.pos);this.pos+=4;
	tempBuffer.writeUInt16LE(this.planes,this.pos);this.pos+=2;
	tempBuffer.writeUInt16LE(this.bitPP,this.pos);this.pos+=2;
	tempBuffer.writeUInt32LE(this.compress,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.rgbSize,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.hr,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.vr,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.colors,this.pos);this.pos+=4;
	tempBuffer.writeUInt32LE(this.importantColors,this.pos);this.pos+=4;

	var i=0;
	var rowBytes = 3*this.width+this.extraBytes;

	for (var y = 0; y <this.height; y++){
		for (var x = 0; x < this.width; x++){
			var p = this.pos+y*rowBytes+x*3;
			i++;//a
			tempBuffer[p]= this.buffer[i++];//b
			tempBuffer[p+1] = this.buffer[i++];//g
			tempBuffer[p+2]  = this.buffer[i++];//r
		}
		if(this.extraBytes>0){
			var fillOffset = this.pos+y*rowBytes+this.width*3;
			tempBuffer.fill(0,fillOffset,fillOffset+this.extraBytes);
		}
	}

	return tempBuffer;
};

module.exports = function(imgData, quality) {
  if (typeof quality === 'undefined') quality = 100;
 	var encoder = new BmpEncoder(imgData);
	var data = encoder.encode();
  return {
    data: data,
    width: imgData.width,
    height: imgData.height
  };
};


/***/ }),

/***/ "./node_modules/buffer-equal/index.js":
/*!********************************************!*\
  !*** ./node_modules/buffer-equal/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! buffer */ "buffer").Buffer; // for use with browserify

module.exports = function (a, b) {
    if (!Buffer.isBuffer(a)) return undefined;
    if (!Buffer.isBuffer(b)) return undefined;
    if (typeof a.equals === 'function') return a.equals(b);
    if (a.length !== b.length) return false;
    
    for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
    }
    
    return true;
};


/***/ }),

/***/ "./node_modules/exif-parser/index.js":
/*!*******************************************!*\
  !*** ./node_modules/exif-parser/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Parser = __webpack_require__(/*! ./lib/parser */ "./node_modules/exif-parser/lib/parser.js");

function getGlobal() {
	return (1,eval)('this');
}

module.exports = {
	create: function(buffer, global) {
		global = global || getGlobal();
		if(buffer instanceof global.ArrayBuffer) {
			var DOMBufferStream = __webpack_require__(/*! ./lib/dom-bufferstream */ "./node_modules/exif-parser/lib/dom-bufferstream.js");
			return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global));
		} else {
			var NodeBufferStream = __webpack_require__(/*! ./lib/bufferstream */ "./node_modules/exif-parser/lib/bufferstream.js");
			return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
		}
	}
};


/***/ }),

/***/ "./node_modules/exif-parser/lib/bufferstream.js":
/*!******************************************************!*\
  !*** ./node_modules/exif-parser/lib/bufferstream.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function BufferStream(buffer, offset, length, bigEndian) {
	this.buffer = buffer;
	this.offset = offset || 0;
	length = typeof length === 'number' ? length : buffer.length;
	this.endPosition = this.offset + length;
	this.setBigEndian(bigEndian);
}

BufferStream.prototype = {
	setBigEndian: function(bigEndian) {
		this.bigEndian = !!bigEndian;
	},
	nextUInt8: function() {
		var value = this.buffer.readUInt8(this.offset);
		this.offset += 1;
		return value;
	},
	nextInt8: function() {
		var value = this.buffer.readInt8(this.offset);
		this.offset += 1;
		return value;
	},
	nextUInt16: function() {
		var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
		this.offset += 2;
		return value;
	},
	nextUInt32: function() {
		var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
		this.offset += 4;
		return value;
	},
	nextInt16: function() {
		var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
		this.offset += 2;
		return value;
	},
	nextInt32: function() {
		var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
		this.offset += 4;
		return value;
	},
	nextFloat: function() {
		var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
		this.offset += 4;
		return value;
	},
	nextDouble: function() {
		var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
		this.offset += 8;
		return value;
	},
	nextBuffer: function(length) {
		var value = this.buffer.slice(this.offset, this.offset + length);
		this.offset += length;
		return value;
	},
	remainingLength: function() {
		return this.endPosition - this.offset;
	},
	nextString: function(length) {
		var value = this.buffer.toString('utf8', this.offset, this.offset + length);
		this.offset += length;
		return value;
	},
	mark: function() {
		var self = this;
		return {
			openWithOffset: function(offset) {
				offset = (offset || 0) + this.offset;
				return new BufferStream(self.buffer, offset, self.endPosition - offset, self.bigEndian);
			},
			offset: this.offset
		};
	},
	offsetFrom: function(marker) {
		return this.offset - marker.offset;
	},
	skip: function(amount) {
		this.offset += amount;
	},
	branch: function(offset, length) {
		length = typeof length === 'number' ? length : this.endPosition - (this.offset + offset);
		return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
	}
};

module.exports = BufferStream;


/***/ }),

/***/ "./node_modules/exif-parser/lib/date.js":
/*!**********************************************!*\
  !*** ./node_modules/exif-parser/lib/date.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function parseNumber(s) {
	return parseInt(s, 10);
}

//in seconds
var hours = 3600;
var minutes = 60;

//take date (year, month, day) and time (hour, minutes, seconds) digits in UTC
//and return a timestamp in seconds
function parseDateTimeParts(dateParts, timeParts) {
	dateParts = dateParts.map(parseNumber);
	timeParts = timeParts.map(parseNumber);
	var year = dateParts[0];
	var month = dateParts[1] - 1;
	var day = dateParts[2];
	var hours = timeParts[0];
	var minutes = timeParts[1];
	var seconds = timeParts[2];
	var date = Date.UTC(year, month, day, hours, minutes, seconds, 0);
	var timestamp = date / 1000;
	return timestamp;
}

//parse date with "2004-09-04T23:39:06-08:00" format,
//one of the formats supported by ISO 8601, and
//convert to utc timestamp in seconds
function parseDateWithTimezoneFormat(dateTimeStr) {

	var dateParts = dateTimeStr.substr(0, 10).split('-');
	var timeParts = dateTimeStr.substr(11, 8).split(':');
	var timezoneStr = dateTimeStr.substr(19, 6);
	var timezoneParts = timezoneStr.split(':').map(parseNumber);
	var timezoneOffset = (timezoneParts[0] * hours) +
		(timezoneParts[1] * minutes);

	var timestamp = parseDateTimeParts(dateParts, timeParts);
	//minus because the timezoneOffset describes
	//how much the described time is ahead of UTC
	timestamp -= timezoneOffset;

	if(typeof timestamp === 'number' && !isNaN(timestamp)) {
		return timestamp;
	}
}

//parse date with "YYYY:MM:DD hh:mm:ss" format, convert to utc timestamp in seconds
function parseDateWithSpecFormat(dateTimeStr) {
	var parts = dateTimeStr.split(' '),
		dateParts = parts[0].split(':'),
		timeParts = parts[1].split(':');

	var timestamp = parseDateTimeParts(dateParts, timeParts);

	if(typeof timestamp === 'number' && !isNaN(timestamp)) {
		return timestamp;
	}
}

function parseExifDate(dateTimeStr) {
	//some easy checks to determine two common date formats

	//is the date in the standard "YYYY:MM:DD hh:mm:ss" format?
	var isSpecFormat = dateTimeStr.length === 19 &&
		dateTimeStr.charAt(4) === ':';
	//is the date in the non-standard format,
	//"2004-09-04T23:39:06-08:00" to include a timezone?
	var isTimezoneFormat = dateTimeStr.length === 25 &&
		dateTimeStr.charAt(10) === 'T';
	var timestamp;

	if(isTimezoneFormat) {
		return parseDateWithTimezoneFormat(dateTimeStr);
	}
	else if(isSpecFormat) {
		return parseDateWithSpecFormat(dateTimeStr);
	}
}

module.exports = {
	parseDateWithSpecFormat: parseDateWithSpecFormat,
	parseDateWithTimezoneFormat: parseDateWithTimezoneFormat,
	parseExifDate: parseExifDate
};


/***/ }),

/***/ "./node_modules/exif-parser/lib/dom-bufferstream.js":
/*!**********************************************************!*\
  !*** ./node_modules/exif-parser/lib/dom-bufferstream.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
	this.global = global;
	offset = offset || 0;
	length = length || (arrayBuffer.byteLength - offset);
	this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
	this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
	this.setBigEndian(bigEndian);
	this.offset = 0;
	this.parentOffset = (parentOffset || 0) + offset;
}

DOMBufferStream.prototype = {
	setBigEndian: function(bigEndian) {
		this.littleEndian = !bigEndian;
	},
	nextUInt8: function() {
		var value = this.view.getUint8(this.offset);
		this.offset += 1;
		return value;
	},
	nextInt8: function() {
		var value = this.view.getInt8(this.offset);
		this.offset += 1;
		return value;
	},
	nextUInt16: function() {
		var value = this.view.getUint16(this.offset, this.littleEndian);
		this.offset += 2;
		return value;
	},
	nextUInt32: function() {
		var value = this.view.getUint32(this.offset, this.littleEndian);
		this.offset += 4;
		return value;
	},
	nextInt16: function() {
		var value = this.view.getInt16(this.offset, this.littleEndian);
		this.offset += 2;
		return value;
	},
	nextInt32: function() {
		var value = this.view.getInt32(this.offset, this.littleEndian);
		this.offset += 4;
		return value;
	},
	nextFloat: function() {
		var value = this.view.getFloat32(this.offset, this.littleEndian);
		this.offset += 4;
		return value;
	},
	nextDouble: function() {
		var value = this.view.getFloat64(this.offset, this.littleEndian);
		this.offset += 8;
		return value;
	},
	nextBuffer: function(length) {
		//this won't work in IE10
		var value = this.arrayBuffer.slice(this.offset, this.offset + length);
		this.offset += length;
		return value;
	},
	remainingLength: function() {
		return this.arrayBuffer.byteLength - this.offset;
	},
	nextString: function(length) {
		var value = this.arrayBuffer.slice(this.offset, this.offset + length);
		value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
		this.offset += length;
		return value;
	},
	mark: function() {
		var self = this;
		return {
			openWithOffset: function(offset) {
				offset = (offset || 0) + this.offset;
				return new DOMBufferStream(self.arrayBuffer, offset, self.arrayBuffer.byteLength - offset, !self.littleEndian, self.global, self.parentOffset);
			},
			offset: this.offset,
			getParentOffset: function() {
				return self.parentOffset;
			}
		};
	},
	offsetFrom: function(marker) {
		return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
	},
	skip: function(amount) {
		this.offset += amount;
	},
	branch: function(offset, length) {
		length = typeof length === 'number' ? length : this.arrayBuffer.byteLength - (this.offset + offset);
		return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
	}
};

module.exports = DOMBufferStream;


/***/ }),

/***/ "./node_modules/exif-parser/lib/exif-tags.js":
/*!***************************************************!*\
  !*** ./node_modules/exif-parser/lib/exif-tags.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
	exif : {
		0x0001 : "InteropIndex",
		0x0002 : "InteropVersion",
		0x000B : "ProcessingSoftware",
		0x00FE : "SubfileType",
		0x00FF : "OldSubfileType",
		0x0100 : "ImageWidth",
		0x0101 : "ImageHeight",
		0x0102 : "BitsPerSample",
		0x0103 : "Compression",
		0x0106 : "PhotometricInterpretation",
		0x0107 : "Thresholding",
		0x0108 : "CellWidth",
		0x0109 : "CellLength",
		0x010A : "FillOrder",
		0x010D : "DocumentName",
		0x010E : "ImageDescription",
		0x010F : "Make",
		0x0110 : "Model",
		0x0111 : "StripOffsets",
		0x0112 : "Orientation",
		0x0115 : "SamplesPerPixel",
		0x0116 : "RowsPerStrip",
		0x0117 : "StripByteCounts",
		0x0118 : "MinSampleValue",
		0x0119 : "MaxSampleValue",
		0x011A : "XResolution",
		0x011B : "YResolution",
		0x011C : "PlanarConfiguration",
		0x011D : "PageName",
		0x011E : "XPosition",
		0x011F : "YPosition",
		0x0120 : "FreeOffsets",
		0x0121 : "FreeByteCounts",
		0x0122 : "GrayResponseUnit",
		0x0123 : "GrayResponseCurve",
		0x0124 : "T4Options",
		0x0125 : "T6Options",
		0x0128 : "ResolutionUnit",
		0x0129 : "PageNumber",
		0x012C : "ColorResponseUnit",
		0x012D : "TransferFunction",
		0x0131 : "Software",
		0x0132 : "ModifyDate",
		0x013B : "Artist",
		0x013C : "HostComputer",
		0x013D : "Predictor",
		0x013E : "WhitePoint",
		0x013F : "PrimaryChromaticities",
		0x0140 : "ColorMap",
		0x0141 : "HalftoneHints",
		0x0142 : "TileWidth",
		0x0143 : "TileLength",
		0x0144 : "TileOffsets",
		0x0145 : "TileByteCounts",
		0x0146 : "BadFaxLines",
		0x0147 : "CleanFaxData",
		0x0148 : "ConsecutiveBadFaxLines",
		0x014A : "SubIFD",
		0x014C : "InkSet",
		0x014D : "InkNames",
		0x014E : "NumberofInks",
		0x0150 : "DotRange",
		0x0151 : "TargetPrinter",
		0x0152 : "ExtraSamples",
		0x0153 : "SampleFormat",
		0x0154 : "SMinSampleValue",
		0x0155 : "SMaxSampleValue",
		0x0156 : "TransferRange",
		0x0157 : "ClipPath",
		0x0158 : "XClipPathUnits",
		0x0159 : "YClipPathUnits",
		0x015A : "Indexed",
		0x015B : "JPEGTables",
		0x015F : "OPIProxy",
		0x0190 : "GlobalParametersIFD",
		0x0191 : "ProfileType",
		0x0192 : "FaxProfile",
		0x0193 : "CodingMethods",
		0x0194 : "VersionYear",
		0x0195 : "ModeNumber",
		0x01B1 : "Decode",
		0x01B2 : "DefaultImageColor",
		0x01B3 : "T82Options",
		0x01B5 : "JPEGTables",
		0x0200 : "JPEGProc",
		0x0201 : "ThumbnailOffset",
		0x0202 : "ThumbnailLength",
		0x0203 : "JPEGRestartInterval",
		0x0205 : "JPEGLosslessPredictors",
		0x0206 : "JPEGPointTransforms",
		0x0207 : "JPEGQTables",
		0x0208 : "JPEGDCTables",
		0x0209 : "JPEGACTables",
		0x0211 : "YCbCrCoefficients",
		0x0212 : "YCbCrSubSampling",
		0x0213 : "YCbCrPositioning",
		0x0214 : "ReferenceBlackWhite",
		0x022F : "StripRowCounts",
		0x02BC : "ApplicationNotes",
		0x03E7 : "USPTOMiscellaneous",
		0x1000 : "RelatedImageFileFormat",
		0x1001 : "RelatedImageWidth",
		0x1002 : "RelatedImageHeight",
		0x4746 : "Rating",
		0x4747 : "XP_DIP_XML",
		0x4748 : "StitchInfo",
		0x4749 : "RatingPercent",
		0x800D : "ImageID",
		0x80A3 : "WangTag1",
		0x80A4 : "WangAnnotation",
		0x80A5 : "WangTag3",
		0x80A6 : "WangTag4",
		0x80E3 : "Matteing",
		0x80E4 : "DataType",
		0x80E5 : "ImageDepth",
		0x80E6 : "TileDepth",
		0x827D : "Model2",
		0x828D : "CFARepeatPatternDim",
		0x828E : "CFAPattern2",
		0x828F : "BatteryLevel",
		0x8290 : "KodakIFD",
		0x8298 : "Copyright",
		0x829A : "ExposureTime",
		0x829D : "FNumber",
		0x82A5 : "MDFileTag",
		0x82A6 : "MDScalePixel",
		0x82A7 : "MDColorTable",
		0x82A8 : "MDLabName",
		0x82A9 : "MDSampleInfo",
		0x82AA : "MDPrepDate",
		0x82AB : "MDPrepTime",
		0x82AC : "MDFileUnits",
		0x830E : "PixelScale",
		0x8335 : "AdventScale",
		0x8336 : "AdventRevision",
		0x835C : "UIC1Tag",
		0x835D : "UIC2Tag",
		0x835E : "UIC3Tag",
		0x835F : "UIC4Tag",
		0x83BB : "IPTC-NAA",
		0x847E : "IntergraphPacketData",
		0x847F : "IntergraphFlagRegisters",
		0x8480 : "IntergraphMatrix",
		0x8481 : "INGRReserved",
		0x8482 : "ModelTiePoint",
		0x84E0 : "Site",
		0x84E1 : "ColorSequence",
		0x84E2 : "IT8Header",
		0x84E3 : "RasterPadding",
		0x84E4 : "BitsPerRunLength",
		0x84E5 : "BitsPerExtendedRunLength",
		0x84E6 : "ColorTable",
		0x84E7 : "ImageColorIndicator",
		0x84E8 : "BackgroundColorIndicator",
		0x84E9 : "ImageColorValue",
		0x84EA : "BackgroundColorValue",
		0x84EB : "PixelIntensityRange",
		0x84EC : "TransparencyIndicator",
		0x84ED : "ColorCharacterization",
		0x84EE : "HCUsage",
		0x84EF : "TrapIndicator",
		0x84F0 : "CMYKEquivalent",
		0x8546 : "SEMInfo",
		0x8568 : "AFCP_IPTC",
		0x85B8 : "PixelMagicJBIGOptions",
		0x85D8 : "ModelTransform",
		0x8602 : "WB_GRGBLevels",
		0x8606 : "LeafData",
		0x8649 : "PhotoshopSettings",
		0x8769 : "ExifOffset",
		0x8773 : "ICC_Profile",
		0x877F : "TIFF_FXExtensions",
		0x8780 : "MultiProfiles",
		0x8781 : "SharedData",
		0x8782 : "T88Options",
		0x87AC : "ImageLayer",
		0x87AF : "GeoTiffDirectory",
		0x87B0 : "GeoTiffDoubleParams",
		0x87B1 : "GeoTiffAsciiParams",
		0x8822 : "ExposureProgram",
		0x8824 : "SpectralSensitivity",
		0x8825 : "GPSInfo",
		0x8827 : "ISO",
		0x8828 : "Opto-ElectricConvFactor",
		0x8829 : "Interlace",
		0x882A : "TimeZoneOffset",
		0x882B : "SelfTimerMode",
		0x8830 : "SensitivityType",
		0x8831 : "StandardOutputSensitivity",
		0x8832 : "RecommendedExposureIndex",
		0x8833 : "ISOSpeed",
		0x8834 : "ISOSpeedLatitudeyyy",
		0x8835 : "ISOSpeedLatitudezzz",
		0x885C : "FaxRecvParams",
		0x885D : "FaxSubAddress",
		0x885E : "FaxRecvTime",
		0x888A : "LeafSubIFD",
		0x9000 : "ExifVersion",
		0x9003 : "DateTimeOriginal",
		0x9004 : "CreateDate",
		0x9101 : "ComponentsConfiguration",
		0x9102 : "CompressedBitsPerPixel",
		0x9201 : "ShutterSpeedValue",
		0x9202 : "ApertureValue",
		0x9203 : "BrightnessValue",
		0x9204 : "ExposureCompensation",
		0x9205 : "MaxApertureValue",
		0x9206 : "SubjectDistance",
		0x9207 : "MeteringMode",
		0x9208 : "LightSource",
		0x9209 : "Flash",
		0x920A : "FocalLength",
		0x920B : "FlashEnergy",
		0x920C : "SpatialFrequencyResponse",
		0x920D : "Noise",
		0x920E : "FocalPlaneXResolution",
		0x920F : "FocalPlaneYResolution",
		0x9210 : "FocalPlaneResolutionUnit",
		0x9211 : "ImageNumber",
		0x9212 : "SecurityClassification",
		0x9213 : "ImageHistory",
		0x9214 : "SubjectArea",
		0x9215 : "ExposureIndex",
		0x9216 : "TIFF-EPStandardID",
		0x9217 : "SensingMethod",
		0x923A : "CIP3DataFile",
		0x923B : "CIP3Sheet",
		0x923C : "CIP3Side",
		0x923F : "StoNits",
		0x927C : "MakerNote",
		0x9286 : "UserComment",
		0x9290 : "SubSecTime",
		0x9291 : "SubSecTimeOriginal",
		0x9292 : "SubSecTimeDigitized",
		0x932F : "MSDocumentText",
		0x9330 : "MSPropertySetStorage",
		0x9331 : "MSDocumentTextPosition",
		0x935C : "ImageSourceData",
		0x9C9B : "XPTitle",
		0x9C9C : "XPComment",
		0x9C9D : "XPAuthor",
		0x9C9E : "XPKeywords",
		0x9C9F : "XPSubject",
		0xA000 : "FlashpixVersion",
		0xA001 : "ColorSpace",
		0xA002 : "ExifImageWidth",
		0xA003 : "ExifImageHeight",
		0xA004 : "RelatedSoundFile",
		0xA005 : "InteropOffset",
		0xA20B : "FlashEnergy",
		0xA20C : "SpatialFrequencyResponse",
		0xA20D : "Noise",
		0xA20E : "FocalPlaneXResolution",
		0xA20F : "FocalPlaneYResolution",
		0xA210 : "FocalPlaneResolutionUnit",
		0xA211 : "ImageNumber",
		0xA212 : "SecurityClassification",
		0xA213 : "ImageHistory",
		0xA214 : "SubjectLocation",
		0xA215 : "ExposureIndex",
		0xA216 : "TIFF-EPStandardID",
		0xA217 : "SensingMethod",
		0xA300 : "FileSource",
		0xA301 : "SceneType",
		0xA302 : "CFAPattern",
		0xA401 : "CustomRendered",
		0xA402 : "ExposureMode",
		0xA403 : "WhiteBalance",
		0xA404 : "DigitalZoomRatio",
		0xA405 : "FocalLengthIn35mmFormat",
		0xA406 : "SceneCaptureType",
		0xA407 : "GainControl",
		0xA408 : "Contrast",
		0xA409 : "Saturation",
		0xA40A : "Sharpness",
		0xA40B : "DeviceSettingDescription",
		0xA40C : "SubjectDistanceRange",
		0xA420 : "ImageUniqueID",
		0xA430 : "OwnerName",
		0xA431 : "SerialNumber",
		0xA432 : "LensInfo",
		0xA433 : "LensMake",
		0xA434 : "LensModel",
		0xA435 : "LensSerialNumber",
		0xA480 : "GDALMetadata",
		0xA481 : "GDALNoData",
		0xA500 : "Gamma",
		0xAFC0 : "ExpandSoftware",
		0xAFC1 : "ExpandLens",
		0xAFC2 : "ExpandFilm",
		0xAFC3 : "ExpandFilterLens",
		0xAFC4 : "ExpandScanner",
		0xAFC5 : "ExpandFlashLamp",
		0xBC01 : "PixelFormat",
		0xBC02 : "Transformation",
		0xBC03 : "Uncompressed",
		0xBC04 : "ImageType",
		0xBC80 : "ImageWidth",
		0xBC81 : "ImageHeight",
		0xBC82 : "WidthResolution",
		0xBC83 : "HeightResolution",
		0xBCC0 : "ImageOffset",
		0xBCC1 : "ImageByteCount",
		0xBCC2 : "AlphaOffset",
		0xBCC3 : "AlphaByteCount",
		0xBCC4 : "ImageDataDiscard",
		0xBCC5 : "AlphaDataDiscard",
		0xC427 : "OceScanjobDesc",
		0xC428 : "OceApplicationSelector",
		0xC429 : "OceIDNumber",
		0xC42A : "OceImageLogic",
		0xC44F : "Annotations",
		0xC4A5 : "PrintIM",
		0xC580 : "USPTOOriginalContentType",
		0xC612 : "DNGVersion",
		0xC613 : "DNGBackwardVersion",
		0xC614 : "UniqueCameraModel",
		0xC615 : "LocalizedCameraModel",
		0xC616 : "CFAPlaneColor",
		0xC617 : "CFALayout",
		0xC618 : "LinearizationTable",
		0xC619 : "BlackLevelRepeatDim",
		0xC61A : "BlackLevel",
		0xC61B : "BlackLevelDeltaH",
		0xC61C : "BlackLevelDeltaV",
		0xC61D : "WhiteLevel",
		0xC61E : "DefaultScale",
		0xC61F : "DefaultCropOrigin",
		0xC620 : "DefaultCropSize",
		0xC621 : "ColorMatrix1",
		0xC622 : "ColorMatrix2",
		0xC623 : "CameraCalibration1",
		0xC624 : "CameraCalibration2",
		0xC625 : "ReductionMatrix1",
		0xC626 : "ReductionMatrix2",
		0xC627 : "AnalogBalance",
		0xC628 : "AsShotNeutral",
		0xC629 : "AsShotWhiteXY",
		0xC62A : "BaselineExposure",
		0xC62B : "BaselineNoise",
		0xC62C : "BaselineSharpness",
		0xC62D : "BayerGreenSplit",
		0xC62E : "LinearResponseLimit",
		0xC62F : "CameraSerialNumber",
		0xC630 : "DNGLensInfo",
		0xC631 : "ChromaBlurRadius",
		0xC632 : "AntiAliasStrength",
		0xC633 : "ShadowScale",
		0xC634 : "DNGPrivateData",
		0xC635 : "MakerNoteSafety",
		0xC640 : "RawImageSegmentation",
		0xC65A : "CalibrationIlluminant1",
		0xC65B : "CalibrationIlluminant2",
		0xC65C : "BestQualityScale",
		0xC65D : "RawDataUniqueID",
		0xC660 : "AliasLayerMetadata",
		0xC68B : "OriginalRawFileName",
		0xC68C : "OriginalRawFileData",
		0xC68D : "ActiveArea",
		0xC68E : "MaskedAreas",
		0xC68F : "AsShotICCProfile",
		0xC690 : "AsShotPreProfileMatrix",
		0xC691 : "CurrentICCProfile",
		0xC692 : "CurrentPreProfileMatrix",
		0xC6BF : "ColorimetricReference",
		0xC6D2 : "PanasonicTitle",
		0xC6D3 : "PanasonicTitle2",
		0xC6F3 : "CameraCalibrationSig",
		0xC6F4 : "ProfileCalibrationSig",
		0xC6F5 : "ProfileIFD",
		0xC6F6 : "AsShotProfileName",
		0xC6F7 : "NoiseReductionApplied",
		0xC6F8 : "ProfileName",
		0xC6F9 : "ProfileHueSatMapDims",
		0xC6FA : "ProfileHueSatMapData1",
		0xC6FB : "ProfileHueSatMapData2",
		0xC6FC : "ProfileToneCurve",
		0xC6FD : "ProfileEmbedPolicy",
		0xC6FE : "ProfileCopyright",
		0xC714 : "ForwardMatrix1",
		0xC715 : "ForwardMatrix2",
		0xC716 : "PreviewApplicationName",
		0xC717 : "PreviewApplicationVersion",
		0xC718 : "PreviewSettingsName",
		0xC719 : "PreviewSettingsDigest",
		0xC71A : "PreviewColorSpace",
		0xC71B : "PreviewDateTime",
		0xC71C : "RawImageDigest",
		0xC71D : "OriginalRawFileDigest",
		0xC71E : "SubTileBlockSize",
		0xC71F : "RowInterleaveFactor",
		0xC725 : "ProfileLookTableDims",
		0xC726 : "ProfileLookTableData",
		0xC740 : "OpcodeList1",
		0xC741 : "OpcodeList2",
		0xC74E : "OpcodeList3",
		0xC761 : "NoiseProfile",
		0xC763 : "TimeCodes",
		0xC764 : "FrameRate",
		0xC772 : "TStop",
		0xC789 : "ReelName",
		0xC791 : "OriginalDefaultFinalSize",
		0xC792 : "OriginalBestQualitySize",
		0xC793 : "OriginalDefaultCropSize",
		0xC7A1 : "CameraLabel",
		0xC7A3 : "ProfileHueSatMapEncoding",
		0xC7A4 : "ProfileLookTableEncoding",
		0xC7A5 : "BaselineExposureOffset",
		0xC7A6 : "DefaultBlackRender",
		0xC7A7 : "NewRawImageDigest",
		0xC7A8 : "RawToPreviewGain",
		0xC7B5 : "DefaultUserCrop",
		0xEA1C : "Padding",
		0xEA1D : "OffsetSchema",
		0xFDE8 : "OwnerName",
		0xFDE9 : "SerialNumber",
		0xFDEA : "Lens",
		0xFE00 : "KDC_IFD",
		0xFE4C : "RawFile",
		0xFE4D : "Converter",
		0xFE4E : "WhiteBalance",
		0xFE51 : "Exposure",
		0xFE52 : "Shadows",
		0xFE53 : "Brightness",
		0xFE54 : "Contrast",
		0xFE55 : "Saturation",
		0xFE56 : "Sharpness",
		0xFE57 : "Smoothness",
		0xFE58 : "MoireFilter"
		
	},
	gps : {	
		0x0000 : 'GPSVersionID',
		0x0001 : 'GPSLatitudeRef',
		0x0002 : 'GPSLatitude',
		0x0003 : 'GPSLongitudeRef',
		0x0004 : 'GPSLongitude',
		0x0005 : 'GPSAltitudeRef',
		0x0006 : 'GPSAltitude',
		0x0007 : 'GPSTimeStamp',
		0x0008 : 'GPSSatellites',
		0x0009 : 'GPSStatus',
		0x000A : 'GPSMeasureMode',
		0x000B : 'GPSDOP',
		0x000C : 'GPSSpeedRef',
		0x000D : 'GPSSpeed',
		0x000E : 'GPSTrackRef',
		0x000F : 'GPSTrack',
		0x0010 : 'GPSImgDirectionRef',
		0x0011 : 'GPSImgDirection',
		0x0012 : 'GPSMapDatum',
		0x0013 : 'GPSDestLatitudeRef',
		0x0014 : 'GPSDestLatitude',
		0x0015 : 'GPSDestLongitudeRef',
		0x0016 : 'GPSDestLongitude',
		0x0017 : 'GPSDestBearingRef',
		0x0018 : 'GPSDestBearing',
		0x0019 : 'GPSDestDistanceRef',
		0x001A : 'GPSDestDistance',
		0x001B : 'GPSProcessingMethod',
		0x001C : 'GPSAreaInformation',
		0x001D : 'GPSDateStamp',
		0x001E : 'GPSDifferential',
		0x001F : 'GPSHPositioningError'
	}
};

/***/ }),

/***/ "./node_modules/exif-parser/lib/exif.js":
/*!**********************************************!*\
  !*** ./node_modules/exif-parser/lib/exif.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

function readExifValue(format, stream) {
	switch(format) {
		case 1: return stream.nextUInt8();
		case 3: return stream.nextUInt16();
		case 4: return stream.nextUInt32();
		case 5: return [stream.nextUInt32(), stream.nextUInt32()];
		case 6: return stream.nextInt8();
		case 8: return stream.nextUInt16();
		case 9: return stream.nextUInt32();
		case 10: return [stream.nextInt32(), stream.nextInt32()];
		case 11: return stream.nextFloat();
		case 12: return stream.nextDouble();
		default: throw new Error('Invalid format while decoding: ' + format);
	}
}

function getBytesPerComponent(format) {
	switch(format) {
		case 1:
		case 2:
		case 6:
		case 7:
			return 1;
		case 3:
		case 8:
			return 2;
		case 4:
		case 9:
		case 11:
			return 4;
		case 5:
		case 10:
		case 12:
			return 8;
		default:
			return 0;
	}
}

function readExifTag(tiffMarker, stream) {
	var tagType = stream.nextUInt16(),
		format = stream.nextUInt16(),
		bytesPerComponent = getBytesPerComponent(format),
		components = stream.nextUInt32(),
		valueBytes = bytesPerComponent * components,
		values,
		value,
		c;

	/* if the value is bigger then 4 bytes, the value is in the data section of the IFD
	and the value present in the tag is the offset starting from the tiff header. So we replace the stream
	with a stream that is located at the given offset in the data section. s*/
	if(valueBytes > 4) {
		stream = tiffMarker.openWithOffset(stream.nextUInt32());
	}
	//we don't want to read strings as arrays
	if(format === 2) {
		values = stream.nextString(components);
		//cut off \0 characters
		var lastNull = values.indexOf('\0');
		if(lastNull !== -1) {
			values = values.substr(0, lastNull);
		}
	}
	else if(format === 7) {
		values = stream.nextBuffer(components);
	}
	else if(format !== 0) {
		values = [];
		for(c = 0; c < components; ++c) {
			values.push(readExifValue(format, stream));
		}
	}
	//since our stream is a stateful object, we need to skip remaining bytes
	//so our offset stays correct
	if(valueBytes < 4) {
		stream.skip(4 - valueBytes);
	}

	return [tagType, values, format];
}

function readIFDSection(tiffMarker, stream, iterator) {
	var numberOfEntries = stream.nextUInt16(), tag, i;
	for(i = 0; i < numberOfEntries; ++i) {
		tag = readExifTag(tiffMarker, stream);
		iterator(tag[0], tag[1], tag[2]);
	}
}

function readHeader(stream) {
	var exifHeader = stream.nextString(6);
	if(exifHeader !== 'Exif\0\0') {
		throw new Error('Invalid EXIF header');
	}

	var tiffMarker = stream.mark();
	var tiffHeader = stream.nextUInt16();
	if(tiffHeader === 0x4949) {
		stream.setBigEndian(false);
	} else if(tiffHeader === 0x4D4D) {
		stream.setBigEndian(true);
	} else {
		throw new Error('Invalid TIFF header');
	}
	if(stream.nextUInt16() !== 0x002A) {
		throw new Error('Invalid TIFF data');
	}
	return tiffMarker;
}

module.exports = {
	IFD0: 1,
	IFD1: 2,
	GPSIFD: 3,
	SubIFD: 4,
	InteropIFD: 5,
	parseTags: function(stream, iterator) {
		var tiffMarker;
		try {
			tiffMarker = readHeader(stream);
		} catch(e) {
			return false;	//ignore APP1 sections with invalid headers
		}
		var subIfdOffset, gpsOffset, interopOffset;
		var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()),
			IFD0 = this.IFD0;
		readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format) {
			switch(tagType) {
				case 0x8825: gpsOffset = value[0]; break;
				case 0x8769: subIfdOffset = value[0]; break;
				default: iterator(IFD0, tagType, value, format); break;
			}
		});
		var ifd1Offset = ifd0Stream.nextUInt32();
		if(ifd1Offset !== 0) {
			var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
			readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
		}

		if(gpsOffset) {
			var gpsStream = tiffMarker.openWithOffset(gpsOffset);
			readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
		}

		if(subIfdOffset) {
			var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
			readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format) {
				if(tagType === 0xA005) {
					interopOffset = value[0];
				} else {
					iterator(InteropIFD, tagType, value, format);
				}
			});
		}

		if(interopOffset) {
			var interopStream = tiffMarker.openWithOffset(interopOffset);
			readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
		}
		return true;
	}
};

/***/ }),

/***/ "./node_modules/exif-parser/lib/jpeg.js":
/*!**********************************************!*\
  !*** ./node_modules/exif-parser/lib/jpeg.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

module.exports = {
	parseSections: function(stream, iterator) {
		var len, markerType;
		stream.setBigEndian(true);
		//stop reading the stream at the SOS (Start of Stream) marker,
		//because its length is not stored in the header so we can't
		//know where to jump to. The only marker after that is just EOI (End Of Image) anyway
		while(stream.remainingLength() > 0 && markerType !== 0xDA) {
			if(stream.nextUInt8() !== 0xFF) {
				throw new Error('Invalid JPEG section offset');
			}
			markerType = stream.nextUInt8();
			//don't read size from markers that have no datas
			if((markerType >= 0xD0 && markerType <= 0xD9) || markerType === 0xDA) {
				len = 0;
			} else {
				len = stream.nextUInt16() - 2;
			}
			iterator(markerType, stream.branch(0, len));
			stream.skip(len);
		}
	},
	//stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
	getSizeFromSOFSection: function(stream) {
		stream.skip(1);
		return {
			height: stream.nextUInt16(),
			width: stream.nextUInt16()
		};
	},
	getSectionName: function(markerType) {
		var name, index;
		switch(markerType) {
			case 0xD8: name = 'SOI'; break;
			case 0xC4: name = 'DHT'; break;
			case 0xDB: name = 'DQT'; break;
			case 0xDD: name = 'DRI'; break;
			case 0xDA: name = 'SOS'; break;
			case 0xFE: name = 'COM'; break;
			case 0xD9: name = 'EOI'; break;
			default:
				if(markerType >= 0xE0 && markerType <= 0xEF) {
					name = 'APP';
					index = markerType - 0xE0;
				}
				else if(markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {
					name = 'SOF';
					index = markerType - 0xC0;
				}
				else if(markerType >= 0xD0 && markerType <= 0xD7) {
					name = 'RST';
					index = markerType - 0xD0;
				}
				break;
		}
		var nameStruct = {
			name: name
		};
		if(typeof index === 'number') {
			nameStruct.index = index;
		}
		return nameStruct;
	}
};

/***/ }),

/***/ "./node_modules/exif-parser/lib/parser.js":
/*!************************************************!*\
  !*** ./node_modules/exif-parser/lib/parser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var jpeg = __webpack_require__(/*! ./jpeg */ "./node_modules/exif-parser/lib/jpeg.js"),
	exif = __webpack_require__(/*! ./exif */ "./node_modules/exif-parser/lib/exif.js"),
	simplify = __webpack_require__(/*! ./simplify */ "./node_modules/exif-parser/lib/simplify.js");

function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
	this.startMarker = startMarker;
	this.tags = tags;
	this.imageSize = imageSize;
	this.thumbnailOffset = thumbnailOffset;
	this.thumbnailLength = thumbnailLength;
	this.thumbnailType = thumbnailType;
	this.app1Offset = app1Offset;
}

ExifResult.prototype = {
	hasThumbnail: function(mime) {
		if(!this.thumbnailOffset || !this.thumbnailLength) {
			return false;
		}
		if(typeof mime !== 'string') {
			return true;
		}
		if(mime.toLowerCase().trim() === 'image/jpeg') {
			return this.thumbnailType === 6;
		}
		if(mime.toLowerCase().trim() === 'image/tiff') {
			return this.thumbnailType === 1;
		}
		return false;
	},
	getThumbnailOffset: function() {
		return this.app1Offset + 6 + this.thumbnailOffset;
	},
	getThumbnailLength: function() {
		return this.thumbnailLength;
	},
	getThumbnailBuffer: function() {
		return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
	},
	_getThumbnailStream: function() {
		return this.startMarker.openWithOffset(this.getThumbnailOffset());
	},
	getImageSize: function() {
		return this.imageSize;
	},
	getThumbnailSize: function() {
		var stream = this._getThumbnailStream(), size;
		jpeg.parseSections(stream, function(sectionType, sectionStream) {
			if(jpeg.getSectionName(sectionType).name === 'SOF') {
				size = jpeg.getSizeFromSOFSection(sectionStream);
			}
		});
		return size;
	}
};

function Parser(stream) {
	this.stream = stream;
	this.flags = {
		readBinaryTags: false,
		resolveTagNames: true,
		simplifyValues: true,
		imageSize: true,
		hidePointers: true,
		returnTags: true
	};
}

Parser.prototype = {
	enableBinaryFields: function(enable) {
		this.flags.readBinaryTags = !!enable;
		return this;
	},
	enablePointers: function(enable) {
		this.flags.hidePointers = !enable;
		return this;
	},
	enableTagNames: function(enable) {
		this.flags.resolveTagNames = !!enable;
		return this;
	},
	enableImageSize: function(enable) {
		this.flags.imageSize = !!enable;
		return this;
	},
	enableReturnTags: function(enable) {
		this.flags.returnTags = !!enable;
		return this;
	},
	enableSimpleValues: function(enable) {
		this.flags.simplifyValues = !!enable;
		return this;
	},
	parse: function() {
		var start = this.stream.mark(),
			stream = start.openWithOffset(0),
			flags = this.flags,
			tags,
			imageSize,
			thumbnailOffset,
			thumbnailLength,
			thumbnailType,
			app1Offset,
			tagNames,
			getTagValue, setTagValue;
		if(flags.resolveTagNames) {
			tagNames = __webpack_require__(/*! ./exif-tags */ "./node_modules/exif-parser/lib/exif-tags.js");
		}
		if(flags.resolveTagNames) {
			tags = {};
			getTagValue = function(t) {
				return tags[t.name];
			};
			setTagValue = function(t, value) {
				tags[t.name] = value;
			};
		} else {
			tags = [];
			getTagValue = function(t) {
				var i;
				for(i = 0; i < tags.length; ++i) {
					if(tags[i].type === t.type && tags[i].section === t.section) {
						return tags.value;
					}
				}
			};
			setTagValue = function(t, value) {
				var i;
				for(i = 0; i < tags.length; ++i) {
					if(tags[i].type === t.type && tags[i].section === t.section) {
						tags.value = value;
						return;
					}
				}
			};
		}

		jpeg.parseSections(stream, function(sectionType, sectionStream) {
			var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
			if(sectionType === 0xE1) {
				validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format) {
					//ignore binary fields if disabled
					if(!flags.readBinaryTags && format === 7) {
						return;
					}

					if(tagType === 0x0201) {
						thumbnailOffset = value[0];
						if(flags.hidePointers) {return;}
					} else if(tagType === 0x0202) {
						thumbnailLength = value[0];
						if(flags.hidePointers) {return;}
					} else if(tagType === 0x0103) {
						thumbnailType = value[0];
						if(flags.hidePointers) {return;}
					}
					//if flag is set to not store tags, return here after storing pointers
					if(!flags.returnTags) {
						return;
					}

					if(flags.simplifyValues) {
						value = simplify.simplifyValue(value, format);
					}
					if(flags.resolveTagNames) {
						var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
						var name = sectionTagNames[tagType];
						if(!name) {
							name = tagNames.exif[tagType];
						}
						if (!tags.hasOwnProperty(name)) {
							tags[name] = value;
						}
					} else {
						tags.push({
							section: ifdSection,
							type: tagType,
							value: value
						});
					}
				});
				if(validExifHeaders) {
					app1Offset = sectionOffset;
				}
			}
			else if(flags.imageSize && jpeg.getSectionName(sectionType).name === 'SOF') {
				imageSize = jpeg.getSizeFromSOFSection(sectionStream);
			}
		});

		if(flags.simplifyValues) {
			simplify.castDegreeValues(getTagValue, setTagValue);
			simplify.castDateValues(getTagValue, setTagValue);
		}

		return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
	}
};



module.exports = Parser;


/***/ }),

/***/ "./node_modules/exif-parser/lib/simplify.js":
/*!**************************************************!*\
  !*** ./node_modules/exif-parser/lib/simplify.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exif = __webpack_require__(/*! ./exif */ "./node_modules/exif-parser/lib/exif.js");
var date = __webpack_require__(/*! ./date */ "./node_modules/exif-parser/lib/date.js");

var degreeTags = [{
	section: exif.GPSIFD,
	type: 0x0002,
	name: 'GPSLatitude',
	refType: 0x0001,
	refName: 'GPSLatitudeRef',
	posVal: 'N'
},
{
	section: exif.GPSIFD,
	type: 0x0004,
	name: 'GPSLongitude',
	refType: 0x0003,
	refName: 'GPSLongitudeRef',
	posVal: 'E'
}];
var dateTags = [{
	section: exif.SubIFD,
	type: 0x0132,
	name: 'ModifyDate'
},
{
	section: exif.SubIFD,
	type: 0x9003,
	name: 'DateTimeOriginal'
},
{
	section: exif.SubIFD,
	type: 0x9004,
	name: 'CreateDate'
},
{
	section: exif.SubIFD,
	type: 0x0132,
	name : 'ModifyDate',
}];

module.exports = {
	castDegreeValues: function(getTagValue, setTagValue) {
		degreeTags.forEach(function(t) {
			var degreeVal = getTagValue(t);
			if(degreeVal) {
				var degreeRef = getTagValue({section: t.section, type: t.refType, name: t.refName});
				var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
				var degree = (degreeVal[0] + (degreeVal[1] / 60) + (degreeVal[2] / 3600)) * degreeNumRef;
				setTagValue(t, degree);
			}
		});
	},
	castDateValues: function(getTagValue, setTagValue) {
		dateTags.forEach(function(t) {
			var dateStrVal = getTagValue(t);
			if(dateStrVal) {
				//some easy checks to determine two common date formats
				var timestamp = date.parseExifDate(dateStrVal);
				if(typeof timestamp !== 'undefined') {
					setTagValue(t, timestamp);
				}
			}
		});
	},
	simplifyValue: function(values, format) {
		if(Array.isArray(values)) {
			values = values.map(function(value) {
				if(format === 10 || format === 5) {
					return value[0] / value[1];
				}
				return value;
			});
			if(values.length === 1) {
				values = values[0];
			}
		}
		return values;
	}
};


/***/ }),

/***/ "./node_modules/file-type/index.js":
/*!*****************************************!*\
  !*** ./node_modules/file-type/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const toBytes = s => [...s].map(c => c.charCodeAt(0));
const xpiZipFilename = toBytes('META-INF/mozilla.rsa');
const oxmlContentTypes = toBytes('[Content_Types].xml');
const oxmlRels = toBytes('_rels/.rels');

module.exports = input => {
	const buf = input instanceof Uint8Array ? input : new Uint8Array(input);

	if (!(buf && buf.length > 1)) {
		return null;
	}

	const check = (header, options) => {
		options = Object.assign({
			offset: 0
		}, options);

		for (let i = 0; i < header.length; i++) {
			// If a bitmask is set
			if (options.mask) {
				// If header doesn't equal `buf` with bits masked off
				if (header[i] !== (options.mask[i] & buf[i + options.offset])) {
					return false;
				}
			} else if (header[i] !== buf[i + options.offset]) {
				return false;
			}
		}

		return true;
	};

	const checkString = (header, options) => check(toBytes(header), options);

	if (check([0xFF, 0xD8, 0xFF])) {
		return {
			ext: 'jpg',
			mime: 'image/jpeg'
		};
	}

	if (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
		return {
			ext: 'png',
			mime: 'image/png'
		};
	}

	if (check([0x47, 0x49, 0x46])) {
		return {
			ext: 'gif',
			mime: 'image/gif'
		};
	}

	if (check([0x57, 0x45, 0x42, 0x50], {offset: 8})) {
		return {
			ext: 'webp',
			mime: 'image/webp'
		};
	}

	if (check([0x46, 0x4C, 0x49, 0x46])) {
		return {
			ext: 'flif',
			mime: 'image/flif'
		};
	}

	// Needs to be before `tif` check
	if (
		(check([0x49, 0x49, 0x2A, 0x0]) || check([0x4D, 0x4D, 0x0, 0x2A])) &&
		check([0x43, 0x52], {offset: 8})
	) {
		return {
			ext: 'cr2',
			mime: 'image/x-canon-cr2'
		};
	}

	if (
		check([0x49, 0x49, 0x2A, 0x0]) ||
		check([0x4D, 0x4D, 0x0, 0x2A])
	) {
		return {
			ext: 'tif',
			mime: 'image/tiff'
		};
	}

	if (check([0x42, 0x4D])) {
		return {
			ext: 'bmp',
			mime: 'image/bmp'
		};
	}

	if (check([0x49, 0x49, 0xBC])) {
		return {
			ext: 'jxr',
			mime: 'image/vnd.ms-photo'
		};
	}

	if (check([0x38, 0x42, 0x50, 0x53])) {
		return {
			ext: 'psd',
			mime: 'image/vnd.adobe.photoshop'
		};
	}

	// Zip-based file formats
	// Need to be before the `zip` check
	if (check([0x50, 0x4B, 0x3, 0x4])) {
		if (
			check([0x6D, 0x69, 0x6D, 0x65, 0x74, 0x79, 0x70, 0x65, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x65, 0x70, 0x75, 0x62, 0x2B, 0x7A, 0x69, 0x70], {offset: 30})
		) {
			return {
				ext: 'epub',
				mime: 'application/epub+zip'
			};
		}

		// Assumes signed `.xpi` from addons.mozilla.org
		if (check(xpiZipFilename, {offset: 30})) {
			return {
				ext: 'xpi',
				mime: 'application/x-xpinstall'
			};
		}

		if (checkString('mimetypeapplication/vnd.oasis.opendocument.text', {offset: 30})) {
			return {
				ext: 'odt',
				mime: 'application/vnd.oasis.opendocument.text'
			};
		}

		if (checkString('mimetypeapplication/vnd.oasis.opendocument.spreadsheet', {offset: 30})) {
			return {
				ext: 'ods',
				mime: 'application/vnd.oasis.opendocument.spreadsheet'
			};
		}

		if (checkString('mimetypeapplication/vnd.oasis.opendocument.presentation', {offset: 30})) {
			return {
				ext: 'odp',
				mime: 'application/vnd.oasis.opendocument.presentation'
			};
		}

		// The docx, xlsx and pptx file types extend the Office Open XML file format:
		// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
		// We look for:
		// - one entry named '[Content_Types].xml' or '_rels/.rels',
		// - one entry indicating specific type of file.
		// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
		const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr) => i >= startAt && arr[i] === 0x50 && arr[i + 1] === 0x4B && arr[i + 2] === 0x3 && arr[i + 3] === 0x4);

		let zipHeaderIndex = 0; // The first zip header was already found at index 0
		let oxmlFound = false;
		let type = null;

		do {
			const offset = zipHeaderIndex + 30;

			if (!oxmlFound) {
				oxmlFound = (check(oxmlContentTypes, {offset}) || check(oxmlRels, {offset}));
			}

			if (!type) {
				if (checkString('word/', {offset})) {
					type = {
						ext: 'docx',
						mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
					};
				} else if (checkString('ppt/', {offset})) {
					type = {
						ext: 'pptx',
						mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
					};
				} else if (checkString('xl/', {offset})) {
					type = {
						ext: 'xlsx',
						mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
					};
				}
			}

			if (oxmlFound && type) {
				return type;
			}

			zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
		} while (zipHeaderIndex >= 0);

		// No more zip parts available in the buffer, but maybe we are almost certain about the type?
		if (type) {
			return type;
		}
	}

	if (
		check([0x50, 0x4B]) &&
		(buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) &&
		(buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)
	) {
		return {
			ext: 'zip',
			mime: 'application/zip'
		};
	}

	if (check([0x75, 0x73, 0x74, 0x61, 0x72], {offset: 257})) {
		return {
			ext: 'tar',
			mime: 'application/x-tar'
		};
	}

	if (
		check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&
		(buf[6] === 0x0 || buf[6] === 0x1)
	) {
		return {
			ext: 'rar',
			mime: 'application/x-rar-compressed'
		};
	}

	if (check([0x1F, 0x8B, 0x8])) {
		return {
			ext: 'gz',
			mime: 'application/gzip'
		};
	}

	if (check([0x42, 0x5A, 0x68])) {
		return {
			ext: 'bz2',
			mime: 'application/x-bzip2'
		};
	}

	if (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
		return {
			ext: '7z',
			mime: 'application/x-7z-compressed'
		};
	}

	if (check([0x78, 0x01])) {
		return {
			ext: 'dmg',
			mime: 'application/x-apple-diskimage'
		};
	}

	if (check([0x33, 0x67, 0x70, 0x35]) || // 3gp5
		(
			check([0x0, 0x0, 0x0]) && check([0x66, 0x74, 0x79, 0x70], {offset: 4}) &&
				(
					check([0x6D, 0x70, 0x34, 0x31], {offset: 8}) || // MP41
					check([0x6D, 0x70, 0x34, 0x32], {offset: 8}) || // MP42
					check([0x69, 0x73, 0x6F, 0x6D], {offset: 8}) || // ISOM
					check([0x69, 0x73, 0x6F, 0x32], {offset: 8}) || // ISO2
					check([0x6D, 0x6D, 0x70, 0x34], {offset: 8}) || // MMP4
					check([0x4D, 0x34, 0x56], {offset: 8}) || // M4V
					check([0x64, 0x61, 0x73, 0x68], {offset: 8}) // DASH
				)
		)) {
		return {
			ext: 'mp4',
			mime: 'video/mp4'
		};
	}

	if (check([0x4D, 0x54, 0x68, 0x64])) {
		return {
			ext: 'mid',
			mime: 'audio/midi'
		};
	}

	// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
	if (check([0x1A, 0x45, 0xDF, 0xA3])) {
		const sliced = buf.subarray(4, 4 + 4096);
		const idPos = sliced.findIndex((el, i, arr) => arr[i] === 0x42 && arr[i + 1] === 0x82);

		if (idPos !== -1) {
			const docTypePos = idPos + 3;
			const findDocType = type => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));

			if (findDocType('matroska')) {
				return {
					ext: 'mkv',
					mime: 'video/x-matroska'
				};
			}

			if (findDocType('webm')) {
				return {
					ext: 'webm',
					mime: 'video/webm'
				};
			}
		}
	}

	if (check([0x0, 0x0, 0x0, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20]) ||
		check([0x66, 0x72, 0x65, 0x65], {offset: 4}) ||
		check([0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20], {offset: 4}) ||
		check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // MJPEG
		check([0x77, 0x69, 0x64, 0x65], {offset: 4})) {
		return {
			ext: 'mov',
			mime: 'video/quicktime'
		};
	}

	// RIFF file format which might be AVI, WAV, QCP, etc
	if (check([0x52, 0x49, 0x46, 0x46])) {
		if (check([0x41, 0x56, 0x49], {offset: 8})) {
			return {
				ext: 'avi',
				mime: 'video/vnd.avi'
			};
		}
		if (check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {
			return {
				ext: 'wav',
				mime: 'audio/vnd.wave'
			};
		}
		// QLCM, QCP file
		if (check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {
			return {
				ext: 'qcp',
				mime: 'audio/qcelp'
			};
		}
	}

	if (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
		return {
			ext: 'wmv',
			mime: 'video/x-ms-wmv'
		};
	}

	if (
		check([0x0, 0x0, 0x1, 0xBA]) ||
		check([0x0, 0x0, 0x1, 0xB3])
	) {
		return {
			ext: 'mpg',
			mime: 'video/mpeg'
		};
	}

	if (check([0x66, 0x74, 0x79, 0x70, 0x33, 0x67], {offset: 4})) {
		return {
			ext: '3gp',
			mime: 'video/3gpp'
		};
	}

	// Check for MPEG header at different starting offsets
	for (let start = 0; start < 2 && start < (buf.length - 16); start++) {
		if (
			check([0x49, 0x44, 0x33], {offset: start}) || // ID3 header
			check([0xFF, 0xE2], {offset: start, mask: [0xFF, 0xE2]}) // MPEG 1 or 2 Layer 3 header
		) {
			return {
				ext: 'mp3',
				mime: 'audio/mpeg'
			};
		}

		if (
			check([0xFF, 0xE4], {offset: start, mask: [0xFF, 0xE4]}) // MPEG 1 or 2 Layer 2 header
		) {
			return {
				ext: 'mp2',
				mime: 'audio/mpeg'
			};
		}

		if (
			check([0xFF, 0xF8], {offset: start, mask: [0xFF, 0xFC]}) // MPEG 2 layer 0 using ADTS
		) {
			return {
				ext: 'mp2',
				mime: 'audio/mpeg'
			};
		}

		if (
			check([0xFF, 0xF0], {offset: start, mask: [0xFF, 0xFC]}) // MPEG 4 layer 0 using ADTS
		) {
			return {
				ext: 'mp4',
				mime: 'audio/mpeg'
			};
		}
	}

	if (
		check([0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x41], {offset: 4}) ||
		check([0x4D, 0x34, 0x41, 0x20])
	) {
		return { // MPEG-4 layer 3 (audio)
			ext: 'm4a',
			mime: 'audio/mp4' // RFC 4337
		};
	}

	// Needs to be before `ogg` check
	if (check([0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64], {offset: 28})) {
		return {
			ext: 'opus',
			mime: 'audio/opus'
		};
	}

	// If 'OggS' in first  bytes, then OGG container
	if (check([0x4F, 0x67, 0x67, 0x53])) {
		// This is a OGG container

		// If ' theora' in header.
		if (check([0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61], {offset: 28})) {
			return {
				ext: 'ogv',
				mime: 'video/ogg'
			};
		}
		// If '\x01video' in header.
		if (check([0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00], {offset: 28})) {
			return {
				ext: 'ogm',
				mime: 'video/ogg'
			};
		}
		// If ' FLAC' in header  https://xiph.org/flac/faq.html
		if (check([0x7F, 0x46, 0x4C, 0x41, 0x43], {offset: 28})) {
			return {
				ext: 'oga',
				mime: 'audio/ogg'
			};
		}

		// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
		if (check([0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20], {offset: 28})) {
			return {
				ext: 'spx',
				mime: 'audio/ogg'
			};
		}

		// If '\x01vorbis' in header
		if (check([0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73], {offset: 28})) {
			return {
				ext: 'ogg',
				mime: 'audio/ogg'
			};
		}

		// Default OGG container https://www.iana.org/assignments/media-types/application/ogg
		return {
			ext: 'ogx',
			mime: 'application/ogg'
		};
	}

	if (check([0x66, 0x4C, 0x61, 0x43])) {
		return {
			ext: 'flac',
			mime: 'audio/x-flac'
		};
	}

	if (check([0x4D, 0x41, 0x43, 0x20])) { // 'MAC '
		return {
			ext: 'ape',
			mime: 'audio/ape'
		};
	}

	if (check([0x77, 0x76, 0x70, 0x6B])) { // 'wvpk'
		return {
			ext: 'wv',
			mime: 'audio/wavpack'
		};
	}

	if (check([0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A])) {
		return {
			ext: 'amr',
			mime: 'audio/amr'
		};
	}

	if (check([0x25, 0x50, 0x44, 0x46])) {
		return {
			ext: 'pdf',
			mime: 'application/pdf'
		};
	}

	if (check([0x4D, 0x5A])) {
		return {
			ext: 'exe',
			mime: 'application/x-msdownload'
		};
	}

	if (
		(buf[0] === 0x43 || buf[0] === 0x46) &&
		check([0x57, 0x53], {offset: 1})
	) {
		return {
			ext: 'swf',
			mime: 'application/x-shockwave-flash'
		};
	}

	if (check([0x7B, 0x5C, 0x72, 0x74, 0x66])) {
		return {
			ext: 'rtf',
			mime: 'application/rtf'
		};
	}

	if (check([0x00, 0x61, 0x73, 0x6D])) {
		return {
			ext: 'wasm',
			mime: 'application/wasm'
		};
	}

	if (
		check([0x77, 0x4F, 0x46, 0x46]) &&
		(
			check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
			check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
		)
	) {
		return {
			ext: 'woff',
			mime: 'font/woff'
		};
	}

	if (
		check([0x77, 0x4F, 0x46, 0x32]) &&
		(
			check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
			check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
		)
	) {
		return {
			ext: 'woff2',
			mime: 'font/woff2'
		};
	}

	if (
		check([0x4C, 0x50], {offset: 34}) &&
		(
			check([0x00, 0x00, 0x01], {offset: 8}) ||
			check([0x01, 0x00, 0x02], {offset: 8}) ||
			check([0x02, 0x00, 0x02], {offset: 8})
		)
	) {
		return {
			ext: 'eot',
			mime: 'application/vnd.ms-fontobject'
		};
	}

	if (check([0x00, 0x01, 0x00, 0x00, 0x00])) {
		return {
			ext: 'ttf',
			mime: 'font/ttf'
		};
	}

	if (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
		return {
			ext: 'otf',
			mime: 'font/otf'
		};
	}

	if (check([0x00, 0x00, 0x01, 0x00])) {
		return {
			ext: 'ico',
			mime: 'image/x-icon'
		};
	}

	if (check([0x00, 0x00, 0x02, 0x00])) {
		return {
			ext: 'cur',
			mime: 'image/x-icon'
		};
	}

	if (check([0x46, 0x4C, 0x56, 0x01])) {
		return {
			ext: 'flv',
			mime: 'video/x-flv'
		};
	}

	if (check([0x25, 0x21])) {
		return {
			ext: 'ps',
			mime: 'application/postscript'
		};
	}

	if (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
		return {
			ext: 'xz',
			mime: 'application/x-xz'
		};
	}

	if (check([0x53, 0x51, 0x4C, 0x69])) {
		return {
			ext: 'sqlite',
			mime: 'application/x-sqlite3'
		};
	}

	if (check([0x4E, 0x45, 0x53, 0x1A])) {
		return {
			ext: 'nes',
			mime: 'application/x-nintendo-nes-rom'
		};
	}

	if (check([0x43, 0x72, 0x32, 0x34])) {
		return {
			ext: 'crx',
			mime: 'application/x-google-chrome-extension'
		};
	}

	if (
		check([0x4D, 0x53, 0x43, 0x46]) ||
		check([0x49, 0x53, 0x63, 0x28])
	) {
		return {
			ext: 'cab',
			mime: 'application/vnd.ms-cab-compressed'
		};
	}

	// Needs to be before `ar` check
	if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A, 0x64, 0x65, 0x62, 0x69, 0x61, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79])) {
		return {
			ext: 'deb',
			mime: 'application/x-deb'
		};
	}

	if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E])) {
		return {
			ext: 'ar',
			mime: 'application/x-unix-archive'
		};
	}

	if (check([0xED, 0xAB, 0xEE, 0xDB])) {
		return {
			ext: 'rpm',
			mime: 'application/x-rpm'
		};
	}

	if (
		check([0x1F, 0xA0]) ||
		check([0x1F, 0x9D])
	) {
		return {
			ext: 'Z',
			mime: 'application/x-compress'
		};
	}

	if (check([0x4C, 0x5A, 0x49, 0x50])) {
		return {
			ext: 'lz',
			mime: 'application/x-lzip'
		};
	}

	if (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
		return {
			ext: 'msi',
			mime: 'application/x-msi'
		};
	}

	if (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
		return {
			ext: 'mxf',
			mime: 'application/mxf'
		};
	}

	if (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {
		return {
			ext: 'mts',
			mime: 'video/mp2t'
		};
	}

	if (check([0x42, 0x4C, 0x45, 0x4E, 0x44, 0x45, 0x52])) {
		return {
			ext: 'blend',
			mime: 'application/x-blender'
		};
	}

	if (check([0x42, 0x50, 0x47, 0xFB])) {
		return {
			ext: 'bpg',
			mime: 'image/bpg'
		};
	}

	if (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
		// JPEG-2000 family

		if (check([0x6A, 0x70, 0x32, 0x20], {offset: 20})) {
			return {
				ext: 'jp2',
				mime: 'image/jp2'
			};
		}

		if (check([0x6A, 0x70, 0x78, 0x20], {offset: 20})) {
			return {
				ext: 'jpx',
				mime: 'image/jpx'
			};
		}

		if (check([0x6A, 0x70, 0x6D, 0x20], {offset: 20})) {
			return {
				ext: 'jpm',
				mime: 'image/jpm'
			};
		}

		if (check([0x6D, 0x6A, 0x70, 0x32], {offset: 20})) {
			return {
				ext: 'mj2',
				mime: 'image/mj2'
			};
		}
	}

	if (check([0x46, 0x4F, 0x52, 0x4D, 0x00])) {
		return {
			ext: 'aif',
			mime: 'audio/aiff'
		};
	}

	if (checkString('<?xml ')) {
		return {
			ext: 'xml',
			mime: 'application/xml'
		};
	}

	if (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {
		return {
			ext: 'mobi',
			mime: 'application/x-mobipocket-ebook'
		};
	}

	// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
	if (check([0x66, 0x74, 0x79, 0x70], {offset: 4})) {
		if (check([0x6D, 0x69, 0x66, 0x31], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heif'
			};
		}

		if (check([0x6D, 0x73, 0x66, 0x31], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heif-sequence'
			};
		}

		if (check([0x68, 0x65, 0x69, 0x63], {offset: 8}) || check([0x68, 0x65, 0x69, 0x78], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heic'
			};
		}

		if (check([0x68, 0x65, 0x76, 0x63], {offset: 8}) || check([0x68, 0x65, 0x76, 0x78], {offset: 8})) {
			return {
				ext: 'heic',
				mime: 'image/heic-sequence'
			};
		}
	}

	if (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
		return {
			ext: 'ktx',
			mime: 'image/ktx'
		};
	}

	return null;
};


/***/ }),

/***/ "./node_modules/jimp/es/index.js":
/*!***************************************!*\
  !*** ./node_modules/jimp/es/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _jimp_custom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/custom */ "./node_modules/@jimp/custom/es/index.js");
/* harmony import */ var _jimp_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/types */ "./node_modules/@jimp/types/es/index.js");
/* harmony import */ var _jimp_plugins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/plugins */ "./node_modules/@jimp/plugins/es/index.js");



/* harmony default export */ __webpack_exports__["default"] = (Object(_jimp_custom__WEBPACK_IMPORTED_MODULE_0__["default"])({
  types: [_jimp_types__WEBPACK_IMPORTED_MODULE_1__["default"]],
  plugins: [_jimp_plugins__WEBPACK_IMPORTED_MODULE_2__["default"]]
}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/jpeg-js/index.js":
/*!***************************************!*\
  !*** ./node_modules/jpeg-js/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var encode = __webpack_require__(/*! ./lib/encoder */ "./node_modules/jpeg-js/lib/encoder.js"),
    decode = __webpack_require__(/*! ./lib/decoder */ "./node_modules/jpeg-js/lib/decoder.js");

module.exports = {
  encode: encode,
  decode: decode
};


/***/ }),

/***/ "./node_modules/jpeg-js/lib/decoder.js":
/*!*********************************************!*\
  !*** ./node_modules/jpeg-js/lib/decoder.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
   Copyright 2011 notmasteryet

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
     0,
     1,  8,
    16,  9,  2,
     3, 10, 17, 24,
    32, 25, 18, 11, 4,
     5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13,  6,
     7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1  =  4017   // cos(pi/16)
  var dctSin1  =   799   // sin(pi/16)
  var dctCos3  =  3406   // cos(3*pi/16)
  var dctSin3  =  2276   // sin(3*pi/16)
  var dctCos6  =  1567   // cos(6*pi/16)
  var dctSin6  =  3784   // sin(6*pi/16)
  var dctSqrt2 =  5793   // sqrt(2)
  var dctSqrt1d2 = 2896  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;
    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw new Error("unexpected marker: " + ((bitsData << 8) | nextByte).toString(16));
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }
    function decodeHuffman(tree) {
      var node = tree, bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw new Error("invalid huffman sequence");
      }
      return null;
    }
    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null) return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }
    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }
    function decodeBaseline(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      zz[0]= (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s);
        k++;
      }
    }
    function decodeDCFirst(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      zz[0] = (component.pred += diff);
    }
    function decodeDCSuccessive(component, zz) {
      zz[0] |= readBit() << successive;
    }
    var eobrun = 0;
    function decodeACFirst(component, zz) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }
    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, zz) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        var direction = zz[z] < 0 ? -1 : 1;
        switch (successiveACState) {
        case 0: // initial state
          var rs = decodeHuffman(component.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1)
              throw new Error("invalid ACn encoding");
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1: // skipping r zero items
        case 2:
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          else {
            r--;
            if (r === 0)
              successiveACState = successiveACState == 2 ? 3 : 0;
          }
          break;
        case 3: // set value for a zero item
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          else {
            zz[z] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4: // eob
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }
    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      decode(component, component.blocks[blockRow][blockCol]);
    }
    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      decode(component, component.blocks[blockRow][blockCol]);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) resetInterval = mcuExpected;

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++)
        components[i].pred = 0;
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;

          // If we've reached our expected MCU's, stop decoding
          if (mcu === mcuExpected) break;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker < 0xFF00) {
        throw new Error("marker was not found");
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      }
      else
        break;
    }

    return offset - startOffset;
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    var R = new Int32Array(64), r = new Uint8Array(64);

    // A port of poppler's IDCT method which in turn is taken from:
    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
    //   988-991.
    function quantizeAndInverse(zz, dataOut, dataIn) {
      var qt = component.quantizationTable;
      var v0, v1, v2, v3, v4, v5, v6, v7, t;
      var p = dataIn;
      var i;

      // dequant
      for (i = 0; i < 64; i++)
        p[i] = zz[i] * qt[i];

      // inverse DCT on rows
      for (i = 0; i < 8; ++i) {
        var row = 8 * i;

        // check for all-zero AC coefficients
        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
            p[7 + row] == 0) {
          t = (dctSqrt2 * p[0 + row] + 512) >> 10;
          p[0 + row] = t;
          p[1 + row] = t;
          p[2 + row] = t;
          p[3 + row] = t;
          p[4 + row] = t;
          p[5 + row] = t;
          p[6 + row] = t;
          p[7 + row] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
        v2 = p[2 + row];
        v3 = p[6 + row];
        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
        v5 = p[3 + row] << 4;
        v6 = p[5 + row] << 4;

        // stage 3
        t = (v0 - v1+ 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0 + row] = v0 + v7;
        p[7 + row] = v0 - v7;
        p[1 + row] = v1 + v6;
        p[6 + row] = v1 - v6;
        p[2 + row] = v2 + v5;
        p[5 + row] = v2 - v5;
        p[3 + row] = v3 + v4;
        p[4 + row] = v3 - v4;
      }

      // inverse DCT on columns
      for (i = 0; i < 8; ++i) {
        var col = i;

        // check for all-zero AC coefficients
        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
            p[7*8 + col] == 0) {
          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
          p[0*8 + col] = t;
          p[1*8 + col] = t;
          p[2*8 + col] = t;
          p[3*8 + col] = t;
          p[4*8 + col] = t;
          p[5*8 + col] = t;
          p[6*8 + col] = t;
          p[7*8 + col] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
        v2 = p[2*8 + col];
        v3 = p[6*8 + col];
        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
        v5 = p[3*8 + col];
        v6 = p[5*8 + col];

        // stage 3
        t = (v0 - v1 + 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0*8 + col] = v0 + v7;
        p[7*8 + col] = v0 - v7;
        p[1*8 + col] = v1 + v6;
        p[6*8 + col] = v1 - v6;
        p[2*8 + col] = v2 + v5;
        p[5*8 + col] = v2 - v5;
        p[3*8 + col] = v3 + v4;
        p[4*8 + col] = v3 - v4;
      }

      // convert to 8-bit integers
      for (i = 0; i < 64; ++i) {
        var sample = 128 + ((p[i] + 8) >> 4);
        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
      }
    }

    var i, j;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      var scanLine = blockRow << 3;
      for (i = 0; i < 8; i++)
        lines.push(new Uint8Array(samplesPerLine));
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

        var offset = 0, sample = blockCol << 3;
        for (j = 0; j < 8; j++) {
          var line = lines[scanLine + j];
          for (i = 0; i < 8; i++)
            line[sample + i] = r[offset++];
        }
      }
    }
    return lines;
  }

  function clampTo8bit(a) {
    return a < 0 ? 0 : a > 255 ? 255 : a;
  }

  constructor.prototype = {
    load: function load(path) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = (function() {
        // TODO catch parse error
        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);
      xhr.send(null);
    },
    parse: function parse(data) {
      var offset = 0, length = data.length;
      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }
      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }
      function prepareComponents(frame) {
        var maxH = 0, maxV = 0;
        var component, componentId;
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            if (maxH < component.h) maxH = component.h;
            if (maxV < component.v) maxV = component.v;
          }
        }
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
            var blocksPerLineForMcu = mcusPerLine * component.h;
            var blocksPerColumnForMcu = mcusPerColumn * component.v;
            var blocks = [];
            for (var i = 0; i < blocksPerColumnForMcu; i++) {
              var row = [];
              for (var j = 0; j < blocksPerLineForMcu; j++)
                row.push(new Int32Array(64));
              blocks.push(row);
            }
            component.blocksPerLine = blocksPerLine;
            component.blocksPerColumn = blocksPerColumn;
            component.blocks = blocks;
          }
        }
        frame.maxH = maxH;
        frame.maxV = maxV;
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [], frames = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw new Error("SOI not found");
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch(fileMarker) {
          case 0xFF00: break;
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: { major: appData[5], minor: appData[6] },
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = readUint16();
                }
              } else
                throw new Error("DQT: invalid table spec");
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = {};
            frame.componentsOrder = [];
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              var qId = data[offset + 2];
              frame.componentsOrder.push(componentId);
              frame.components[componentId] = {
                h: h,
                v: v,
                quantizationIdx: qId
              };
              offset += 3;
            }
            prepareComponents(frame);
            frames.push(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              component = frame.components[data[offset++]];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;

          case 0xFFFF: // Fill bytes
            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
              offset--;
            }
            break;

          default:
            if (data[offset - 3] == 0xFF &&
                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw new Error("unknown JPEG marker " + fileMarker.toString(16));
        }
        fileMarker = readUint16();
      }
      if (frames.length != 1)
        throw new Error("only single frame JPEGs supported");

      // set each frame's components quantization table
      for (var i = 0; i < frames.length; i++) {
        var cp = frames[i].components;
        for (var j in cp) {
          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
          delete cp[j].quantizationIdx;
        }
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      for (var i = 0; i < frame.componentsOrder.length; i++) {
        var component = frame.components[frame.componentsOrder[i]];
        this.components.push({
          lines: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV
        });
      }
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component1, component2, component3, component4;
      var component1Line, component2Line, component3Line, component4Line;
      var x, y;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var dataLength = width * height * this.components.length;
      var data = new Uint8Array(dataLength);
      switch (this.components.length) {
        case 1:
          component1 = this.components[0];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];

              data[offset++] = Y;
            }
          }
          break;
        case 2:
          // PDF might compress two component data in custom colorspace
          component1 = this.components[0];
          component2 = this.components[1];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];
              data[offset++] = Y;
              Y = component2Line[0 | (x * component2.scaleX * scaleX)];
              data[offset++] = Y;
            }
          }
          break;
        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                R = component1Line[0 | (x * component1.scaleX * scaleX)];
                G = component2Line[0 | (x * component2.scaleX * scaleX)];
                B = component3Line[0 | (x * component3.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];

                R = clampTo8bit(Y + 1.402 * (Cr - 128));
                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                B = clampTo8bit(Y + 1.772 * (Cb - 128));
              }

              data[offset++] = R;
              data[offset++] = G;
              data[offset++] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          component4 = this.components[3];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                C = component1Line[0 | (x * component1.scaleX * scaleX)];
                M = component2Line[0 | (x * component2.scaleX * scaleX)];
                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];

                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
              }
              data[offset++] = 255-C;
              data[offset++] = 255-M;
              data[offset++] = 255-Ye;
              data[offset++] = 255-K;
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      return data;
    },
    copyToImageData: function copyToImageData(imageData) {
      var width = imageData.width, height = imageData.height;
      var imageDataArray = imageData.data;
      var data = this.getData(width, height);
      var i = 0, j = 0, x, y;
      var Y, K, C, M, R, G, B;
      switch (this.components.length) {
        case 1:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              Y = data[i++];

              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              imageDataArray[j++] = 255;
            }
          }
          break;
        case 3:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              R = data[i++];
              G = data[i++];
              B = data[i++];

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              imageDataArray[j++] = 255;
            }
          }
          break;
        case 4:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              C = data[i++];
              M = data[i++];
              Y = data[i++];
              K = data[i++];

              R = 255 - clampTo8bit(C * (1 - K / 255) + K);
              G = 255 - clampTo8bit(M * (1 - K / 255) + K);
              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              imageDataArray[j++] = 255;
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
    }
  };

  return constructor;
})();
module.exports = decode;

function decode(jpegData, useTArray) {
  var arr = new Uint8Array(jpegData);
  var decoder = new JpegImage();
  decoder.parse(arr);

  var image = {
    width: decoder.width,
    height: decoder.height,
    data: useTArray ?
      new Uint8Array(decoder.width * decoder.height * 4) :
      new Buffer(decoder.width * decoder.height * 4)
  };

  decoder.copyToImageData(image);

  return image;
}


/***/ }),

/***/ "./node_modules/jpeg-js/lib/encoder.js":
/*!*********************************************!*\
  !*** ./node_modules/jpeg-js/lib/encoder.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009

Basic GUI blocking jpeg encoder
*/

var btoa = btoa || function(buf) {
  return new Buffer(buf).toString('base64');
};

function JPEGEncoder(quality) {
  var self = this;
	var fround = Math.round;
	var ffloor = Math.floor;
	var YTable = new Array(64);
	var UVTable = new Array(64);
	var fdtbl_Y = new Array(64);
	var fdtbl_UV = new Array(64);
	var YDC_HT;
	var UVDC_HT;
	var YAC_HT;
	var UVAC_HT;
	
	var bitcode = new Array(65535);
	var category = new Array(65535);
	var outputfDCTQuant = new Array(64);
	var DU = new Array(64);
	var byteout = [];
	var bytenew = 0;
	var bytepos = 7;
	
	var YDU = new Array(64);
	var UDU = new Array(64);
	var VDU = new Array(64);
	var clt = new Array(256);
	var RGB_YUV_TABLE = new Array(2048);
	var currentQuality;
	
	var ZigZag = [
			 0, 1, 5, 6,14,15,27,28,
			 2, 4, 7,13,16,26,29,42,
			 3, 8,12,17,25,30,41,43,
			 9,11,18,24,31,40,44,53,
			10,19,23,32,39,45,52,54,
			20,22,33,38,46,51,55,60,
			21,34,37,47,50,56,59,61,
			35,36,48,49,57,58,62,63
		];
	
	var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
	var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
	var std_ac_luminance_values = [
			0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
			0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
			0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
			0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
			0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
			0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
			0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
			0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
			0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
			0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
			0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
			0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
			0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
			0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
			0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
			0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
			0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
			0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
			0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
			0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
	var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
	var std_ac_chrominance_values = [
			0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
			0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
			0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
			0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
			0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
			0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
			0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
			0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
			0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
			0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
			0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
			0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
			0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
			0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
			0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
			0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
			0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
			0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
			0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
			0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	function initQuantTables(sf){
			var YQT = [
				16, 11, 10, 16, 24, 40, 51, 61,
				12, 12, 14, 19, 26, 58, 60, 55,
				14, 13, 16, 24, 40, 57, 69, 56,
				14, 17, 22, 29, 51, 87, 80, 62,
				18, 22, 37, 56, 68,109,103, 77,
				24, 35, 55, 64, 81,104,113, 92,
				49, 64, 78, 87,103,121,120,101,
				72, 92, 95, 98,112,100,103, 99
			];
			
			for (var i = 0; i < 64; i++) {
				var t = ffloor((YQT[i]*sf+50)/100);
				if (t < 1) {
					t = 1;
				} else if (t > 255) {
					t = 255;
				}
				YTable[ZigZag[i]] = t;
			}
			var UVQT = [
				17, 18, 24, 47, 99, 99, 99, 99,
				18, 21, 26, 66, 99, 99, 99, 99,
				24, 26, 56, 99, 99, 99, 99, 99,
				47, 66, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99
			];
			for (var j = 0; j < 64; j++) {
				var u = ffloor((UVQT[j]*sf+50)/100);
				if (u < 1) {
					u = 1;
				} else if (u > 255) {
					u = 255;
				}
				UVTable[ZigZag[j]] = u;
			}
			var aasf = [
				1.0, 1.387039845, 1.306562965, 1.175875602,
				1.0, 0.785694958, 0.541196100, 0.275899379
			];
			var k = 0;
			for (var row = 0; row < 8; row++)
			{
				for (var col = 0; col < 8; col++)
				{
					fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					k++;
				}
			}
		}
		
		function computeHuffmanTbl(nrcodes, std_table){
			var codevalue = 0;
			var pos_in_table = 0;
			var HT = new Array();
			for (var k = 1; k <= 16; k++) {
				for (var j = 1; j <= nrcodes[k]; j++) {
					HT[std_table[pos_in_table]] = [];
					HT[std_table[pos_in_table]][0] = codevalue;
					HT[std_table[pos_in_table]][1] = k;
					pos_in_table++;
					codevalue++;
				}
				codevalue*=2;
			}
			return HT;
		}
		
		function initHuffmanTbl()
		{
			YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
			UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
			YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
			UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
		}
	
		function initCategoryNumber()
		{
			var nrlower = 1;
			var nrupper = 2;
			for (var cat = 1; cat <= 15; cat++) {
				//Positive numbers
				for (var nr = nrlower; nr<nrupper; nr++) {
					category[32767+nr] = cat;
					bitcode[32767+nr] = [];
					bitcode[32767+nr][1] = cat;
					bitcode[32767+nr][0] = nr;
				}
				//Negative numbers
				for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
					category[32767+nrneg] = cat;
					bitcode[32767+nrneg] = [];
					bitcode[32767+nrneg][1] = cat;
					bitcode[32767+nrneg][0] = nrupper-1+nrneg;
				}
				nrlower <<= 1;
				nrupper <<= 1;
			}
		}
		
		function initRGBYUVTable() {
			for(var i = 0; i < 256;i++) {
				RGB_YUV_TABLE[i]      		=  19595 * i;
				RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
				RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
				RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
				RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
				RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
				RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
				RGB_YUV_TABLE[(i+1792)>>0] 	= - 5329 * i;
			}
		}
		
		// IO functions
		function writeBits(bs)
		{
			var value = bs[0];
			var posval = bs[1]-1;
			while ( posval >= 0 ) {
				if (value & (1 << posval) ) {
					bytenew |= (1 << bytepos);
				}
				posval--;
				bytepos--;
				if (bytepos < 0) {
					if (bytenew == 0xFF) {
						writeByte(0xFF);
						writeByte(0);
					}
					else {
						writeByte(bytenew);
					}
					bytepos=7;
					bytenew=0;
				}
			}
		}
	
		function writeByte(value)
		{
			//byteout.push(clt[value]); // write char directly instead of converting later
      byteout.push(value);
		}
	
		function writeWord(value)
		{
			writeByte((value>>8)&0xFF);
			writeByte((value   )&0xFF);
		}
		
		// DCT & quantization core
		function fDCTQuant(data, fdtbl)
		{
			var d0, d1, d2, d3, d4, d5, d6, d7;
			/* Pass 1: process rows. */
			var dataOff=0;
			var i;
			var I8 = 8;
			var I64 = 64;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff+1];
				d2 = data[dataOff+2];
				d3 = data[dataOff+3];
				d4 = data[dataOff+4];
				d5 = data[dataOff+5];
				d6 = data[dataOff+6];
				d7 = data[dataOff+7];
				
				var tmp0 = d0 + d7;
				var tmp7 = d0 - d7;
				var tmp1 = d1 + d6;
				var tmp6 = d1 - d6;
				var tmp2 = d2 + d5;
				var tmp5 = d2 - d5;
				var tmp3 = d3 + d4;
				var tmp4 = d3 - d4;
	
				/* Even part */
				var tmp10 = tmp0 + tmp3;	/* phase 2 */
				var tmp13 = tmp0 - tmp3;
				var tmp11 = tmp1 + tmp2;
				var tmp12 = tmp1 - tmp2;
	
				data[dataOff] = tmp10 + tmp11; /* phase 3 */
				data[dataOff+4] = tmp10 - tmp11;
	
				var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
				data[dataOff+2] = tmp13 + z1; /* phase 5 */
				data[dataOff+6] = tmp13 - z1;
	
				/* Odd part */
				tmp10 = tmp4 + tmp5; /* phase 2 */
				tmp11 = tmp5 + tmp6;
				tmp12 = tmp6 + tmp7;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
				var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
				var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
				var z3 = tmp11 * 0.707106781; /* c4 */
	
				var z11 = tmp7 + z3;	/* phase 5 */
				var z13 = tmp7 - z3;
	
				data[dataOff+5] = z13 + z2;	/* phase 6 */
				data[dataOff+3] = z13 - z2;
				data[dataOff+1] = z11 + z4;
				data[dataOff+7] = z11 - z4;
	
				dataOff += 8; /* advance pointer to next row */
			}
	
			/* Pass 2: process columns. */
			dataOff = 0;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff + 8];
				d2 = data[dataOff + 16];
				d3 = data[dataOff + 24];
				d4 = data[dataOff + 32];
				d5 = data[dataOff + 40];
				d6 = data[dataOff + 48];
				d7 = data[dataOff + 56];
				
				var tmp0p2 = d0 + d7;
				var tmp7p2 = d0 - d7;
				var tmp1p2 = d1 + d6;
				var tmp6p2 = d1 - d6;
				var tmp2p2 = d2 + d5;
				var tmp5p2 = d2 - d5;
				var tmp3p2 = d3 + d4;
				var tmp4p2 = d3 - d4;
	
				/* Even part */
				var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
				var tmp13p2 = tmp0p2 - tmp3p2;
				var tmp11p2 = tmp1p2 + tmp2p2;
				var tmp12p2 = tmp1p2 - tmp2p2;
	
				data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
				data[dataOff+32] = tmp10p2 - tmp11p2;
	
				var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
				data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
				data[dataOff+48] = tmp13p2 - z1p2;
	
				/* Odd part */
				tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
				tmp11p2 = tmp5p2 + tmp6p2;
				tmp12p2 = tmp6p2 + tmp7p2;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
				var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
				var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
				var z3p2 = tmp11p2 * 0.707106781; /* c4 */
	
				var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
				var z13p2 = tmp7p2 - z3p2;
	
				data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
				data[dataOff+24] = z13p2 - z2p2;
				data[dataOff+ 8] = z11p2 + z4p2;
				data[dataOff+56] = z11p2 - z4p2;
	
				dataOff++; /* advance pointer to next column */
			}
	
			// Quantize/descale the coefficients
			var fDCTQuant;
			for (i=0; i<I64; ++i)
			{
				// Apply the quantization and scaling factor & Round to nearest integer
				fDCTQuant = data[i]*fdtbl[i];
				outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
				//outputfDCTQuant[i] = fround(fDCTQuant);

			}
			return outputfDCTQuant;
		}
		
		function writeAPP0()
		{
			writeWord(0xFFE0); // marker
			writeWord(16); // length
			writeByte(0x4A); // J
			writeByte(0x46); // F
			writeByte(0x49); // I
			writeByte(0x46); // F
			writeByte(0); // = "JFIF",'\0'
			writeByte(1); // versionhi
			writeByte(1); // versionlo
			writeByte(0); // xyunits
			writeWord(1); // xdensity
			writeWord(1); // ydensity
			writeByte(0); // thumbnwidth
			writeByte(0); // thumbnheight
		}
	
		function writeSOF0(width, height)
		{
			writeWord(0xFFC0); // marker
			writeWord(17);   // length, truecolor YUV JPG
			writeByte(8);    // precision
			writeWord(height);
			writeWord(width);
			writeByte(3);    // nrofcomponents
			writeByte(1);    // IdY
			writeByte(0x11); // HVY
			writeByte(0);    // QTY
			writeByte(2);    // IdU
			writeByte(0x11); // HVU
			writeByte(1);    // QTU
			writeByte(3);    // IdV
			writeByte(0x11); // HVV
			writeByte(1);    // QTV
		}
	
		function writeDQT()
		{
			writeWord(0xFFDB); // marker
			writeWord(132);	   // length
			writeByte(0);
			for (var i=0; i<64; i++) {
				writeByte(YTable[i]);
			}
			writeByte(1);
			for (var j=0; j<64; j++) {
				writeByte(UVTable[j]);
			}
		}
	
		function writeDHT()
		{
			writeWord(0xFFC4); // marker
			writeWord(0x01A2); // length
	
			writeByte(0); // HTYDCinfo
			for (var i=0; i<16; i++) {
				writeByte(std_dc_luminance_nrcodes[i+1]);
			}
			for (var j=0; j<=11; j++) {
				writeByte(std_dc_luminance_values[j]);
			}
	
			writeByte(0x10); // HTYACinfo
			for (var k=0; k<16; k++) {
				writeByte(std_ac_luminance_nrcodes[k+1]);
			}
			for (var l=0; l<=161; l++) {
				writeByte(std_ac_luminance_values[l]);
			}
	
			writeByte(1); // HTUDCinfo
			for (var m=0; m<16; m++) {
				writeByte(std_dc_chrominance_nrcodes[m+1]);
			}
			for (var n=0; n<=11; n++) {
				writeByte(std_dc_chrominance_values[n]);
			}
	
			writeByte(0x11); // HTUACinfo
			for (var o=0; o<16; o++) {
				writeByte(std_ac_chrominance_nrcodes[o+1]);
			}
			for (var p=0; p<=161; p++) {
				writeByte(std_ac_chrominance_values[p]);
			}
		}
	
		function writeSOS()
		{
			writeWord(0xFFDA); // marker
			writeWord(12); // length
			writeByte(3); // nrofcomponents
			writeByte(1); // IdY
			writeByte(0); // HTY
			writeByte(2); // IdU
			writeByte(0x11); // HTU
			writeByte(3); // IdV
			writeByte(0x11); // HTV
			writeByte(0); // Ss
			writeByte(0x3f); // Se
			writeByte(0); // Bf
		}
		
		function processDU(CDU, fdtbl, DC, HTDC, HTAC){
			var EOB = HTAC[0x00];
			var M16zeroes = HTAC[0xF0];
			var pos;
			var I16 = 16;
			var I63 = 63;
			var I64 = 64;
			var DU_DCT = fDCTQuant(CDU, fdtbl);
			//ZigZag reorder
			for (var j=0;j<I64;++j) {
				DU[ZigZag[j]]=DU_DCT[j];
			}
			var Diff = DU[0] - DC; DC = DU[0];
			//Encode DC
			if (Diff==0) {
				writeBits(HTDC[0]); // Diff might be 0
			} else {
				pos = 32767+Diff;
				writeBits(HTDC[category[pos]]);
				writeBits(bitcode[pos]);
			}
			//Encode ACs
			var end0pos = 63; // was const... which is crazy
			for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};
			//end0pos = first element in reverse order !=0
			if ( end0pos == 0) {
				writeBits(EOB);
				return DC;
			}
			var i = 1;
			var lng;
			while ( i <= end0pos ) {
				var startpos = i;
				for (; (DU[i]==0) && (i<=end0pos); ++i) {}
				var nrzeroes = i-startpos;
				if ( nrzeroes >= I16 ) {
					lng = nrzeroes>>4;
					for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
						writeBits(M16zeroes);
					nrzeroes = nrzeroes&0xF;
				}
				pos = 32767+DU[i];
				writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
				writeBits(bitcode[pos]);
				i++;
			}
			if ( end0pos != I63 ) {
				writeBits(EOB);
			}
			return DC;
		}

		function initCharLookupTable(){
			var sfcc = String.fromCharCode;
			for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
				clt[i] = sfcc(i);
			}
		}
		
		this.encode = function(image,quality) // image data object
		{
			var time_start = new Date().getTime();
			
			if(quality) setQuality(quality);
			
			// Initialize bit writer
			byteout = new Array();
			bytenew=0;
			bytepos=7;
	
			// Add JPEG headers
			writeWord(0xFFD8); // SOI
			writeAPP0();
			writeDQT();
			writeSOF0(image.width,image.height);
			writeDHT();
			writeSOS();

	
			// Encode 8x8 macroblocks
			var DCY=0;
			var DCU=0;
			var DCV=0;
			
			bytenew=0;
			bytepos=7;
			
			
			this.encode.displayName = "_encode_";

			var imageData = image.data;
			var width = image.width;
			var height = image.height;

			var quadWidth = width*4;
			var tripleWidth = width*3;
			
			var x, y = 0;
			var r, g, b;
			var start,p, col,row,pos;
			while(y < height){
				x = 0;
				while(x < quadWidth){
				start = quadWidth * y + x;
				p = start;
				col = -1;
				row = 0;
				
				for(pos=0; pos < 64; pos++){
					row = pos >> 3;// /8
					col = ( pos & 7 ) * 4; // %8
					p = start + ( row * quadWidth ) + col;		
					
					if(y+row >= height){ // padding bottom
						p-= (quadWidth*(y+1+row-height));
					}

					if(x+col >= quadWidth){ // padding right	
						p-= ((x+col) - quadWidth +4)
					}
					
					r = imageData[ p++ ];
					g = imageData[ p++ ];
					b = imageData[ p++ ];
					
					
					/* // calculate YUV values dynamically
					YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
					UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
					VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
					*/
					
					// use lookup table (slightly faster)
					YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
					UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
					VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

				}
				
				DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
				DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
				DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
				x+=32;
				}
				y+=8;
			}
			
			
			////////////////////////////////////////////////////////////////
	
			// Do the bit alignment of the EOI marker
			if ( bytepos >= 0 ) {
				var fillbits = [];
				fillbits[1] = bytepos+1;
				fillbits[0] = (1<<(bytepos+1))-1;
				writeBits(fillbits);
			}
	
			writeWord(0xFFD9); //EOI

      //return new Uint8Array(byteout);
      return new Buffer(byteout);

			var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));
			
			byteout = [];
			
			// benchmarking
			var duration = new Date().getTime() - time_start;
    		//console.log('Encoding time: '+ duration + 'ms');
    		//
			
			return jpegDataUri			
	}
	
	function setQuality(quality){
		if (quality <= 0) {
			quality = 1;
		}
		if (quality > 100) {
			quality = 100;
		}
		
		if(currentQuality == quality) return // don't recalc if unchanged
		
		var sf = 0;
		if (quality < 50) {
			sf = Math.floor(5000 / quality);
		} else {
			sf = Math.floor(200 - quality*2);
		}
		
		initQuantTables(sf);
		currentQuality = quality;
		//console.log('Quality set to: '+quality +'%');
	}
	
	function init(){
		var time_start = new Date().getTime();
		if(!quality) quality = 50;
		// Create tables
		initCharLookupTable()
		initHuffmanTbl();
		initCategoryNumber();
		initRGBYUVTable();
		
		setQuality(quality);
		var duration = new Date().getTime() - time_start;
    	//console.log('Initialization '+ duration + 'ms');
	}
	
	init();
	
};
module.exports = encode;

function encode(imgData, qu) {
  if (typeof qu === 'undefined') qu = 50;
  var encoder = new JPEGEncoder(qu);
	var data = encoder.encode(imgData, qu);
  return {
    data: data,
    width: imgData.width,
    height: imgData.height
  };
}

// helper function to get the imageData of an existing image on the current page.
function getImageDataFromImage(idOrElement){
	var theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;
	var cvs = document.createElement('canvas');
	cvs.width = theImg.width;
	cvs.height = theImg.height;
	var ctx = cvs.getContext("2d");
	ctx.drawImage(theImg,0,0);
	
	return (ctx.getImageData(0, 0, cvs.width, cvs.height));
}


/***/ }),

/***/ "./node_modules/load-bmfont/index.js":
/*!*******************************************!*\
  !*** ./node_modules/load-bmfont/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(/*! fs */ "fs")
var url = __webpack_require__(/*! url */ "url")
var path = __webpack_require__(/*! path */ "path")
var request = __webpack_require__(/*! phin */ "./node_modules/phin/lib/phin.compiled.js")
var parseASCII = __webpack_require__(/*! parse-bmfont-ascii */ "./node_modules/parse-bmfont-ascii/index.js")
var parseXML = __webpack_require__(/*! parse-bmfont-xml */ "./node_modules/parse-bmfont-xml/lib/index.js")
var readBinary = __webpack_require__(/*! parse-bmfont-binary */ "./node_modules/parse-bmfont-binary/index.js")
var mime = __webpack_require__(/*! mime */ "mime")
var noop = function() {}
var isBinary = __webpack_require__(/*! ./lib/is-binary */ "./node_modules/load-bmfont/lib/is-binary.js")

function parseFont(file, data, cb) {
  var result, binary

  if (isBinary(data)) {
    if (typeof data === 'string') data = new Buffer(data, 'binary')
    binary = true
  } else data = data.toString().trim()

  try {
    if (binary) result = readBinary(data)
    else if (/json/.test(mime.lookup(file)) || data.charAt(0) === '{')
      result = JSON.parse(data)
    else if (/xml/.test(mime.lookup(file)) || data.charAt(0) === '<')
      result = parseXML(data)
    else result = parseASCII(data)
  } catch (e) {
    cb(e)
    cb = noop
  }

  cb(null, result)
}

module.exports = function loadFont(opt, cb) {
  cb = typeof cb === 'function' ? cb : noop

  if (typeof opt === 'string') opt = { uri: opt, url: opt }
  else if (!opt) opt = {}

  var file = opt.uri || opt.url
  
  function handleData(err, data) {
    if (err) return cb(err)
    parseFont(file, data.body || data, cb)
  }

  if (url.parse(file).host) {
    request(opt, handleData)
  } else {
    fs.readFile(file, opt, handleData)
  }
}


/***/ }),

/***/ "./node_modules/load-bmfont/lib/is-binary.js":
/*!***************************************************!*\
  !*** ./node_modules/load-bmfont/lib/is-binary.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var equal = __webpack_require__(/*! buffer-equal */ "./node_modules/buffer-equal/index.js")
var HEADER = new Buffer([66, 77, 70, 3])

module.exports = function(buf) {
  if (typeof buf === 'string')
    return buf.substring(0, 3) === 'BMF'
  return buf.length > 4 && equal(buf.slice(0, 4), HEADER)
}

/***/ }),

/***/ "./node_modules/omggif/omggif.js":
/*!***************************************!*\
  !*** ./node_modules/omggif/omggif.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.



function GifWriter(buf, width, height, gopts) {
  var p = 0;

  var gopts = gopts === undefined ? { } : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;

  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
    throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;
    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
      throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256.");
    }
    return num_colors;
  }

  // - Header.
  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

  // Handling of Global Color Table (palette) and background index.
  var gp_num_colors_pow2 = 0;
  var background = 0;
  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);
    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;
    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors)
        throw new Error("Background index out of range.");
      // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).
      if (background === 0)
        throw new Error("Background index explicitly passed as 0.");
    }
  }

  // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
  // NOTE: Indicates 0-bpp original color resolution (unused?).
  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
  buf[p++] = background;  // Background Color Index.
  buf[p++] = 0;  // Pixel aspect ratio (unused?).

  // - Global Color Table
  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {  // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535)
      throw new Error("Loop count invalid.")
    // Extension code, label, and length.
    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
    // NETSCAPE2.0
    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
    // Sub-block
    buf[p++] = 0x03; buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00;  // Terminator.
  }


  var ended = false;

  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
    if (ended === true) { --p; ended = false; }  // Un-end.

    opts = opts === undefined ? { } : opts;

    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?
    if (x < 0 || y < 0 || x > 65535 || y > 65535)
      throw new Error("x/y invalid.")

    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
      throw new Error("Width/Height invalid.")

    if (indexed_pixels.length < w * h)
      throw new Error("Not enough pixels for the frame size.");

    var using_local_palette = true;
    var palette = opts.palette;
    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null)
      throw new Error("Must supply either a local or global palette.");

    var num_colors = check_palette_and_num_colors(palette);

    // Compute the min_code_size (power of 2), destroying num_colors.
    var min_code_size = 0;
    while (num_colors >>= 1) ++min_code_size;
    num_colors = 1 << min_code_size;  // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay;

    // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.
    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
      throw new Error("Disposal out of range.");

    var use_transparency = false;
    var transparent_index = 0;
    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors)
        throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
      buf[p++] = 4;  // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index;  // Transparent color index.
      buf[p++] = 0;  // Block Terminator.
    }

    // - Image Descriptor
    buf[p++] = 0x2c;  // Image Seperator.
    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
    // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.
    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

    // - Local Color Table
    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(
            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

    return p;
  };

  this.end = function() {
    if (ended === false) {
      buf[p++] = 0x3b;  // Trailer.
      ended = true;
    }
    return p;
  };

  this.getOutputBuffer = function() { return buf; };
  this.setOutputBuffer = function(v) { buf = v; };
  this.getOutputBufferPosition = function() { return p; };
  this.setOutputBufferPosition = function(v) { p = v; };
}

// Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.
function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++;  // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  var cur_shift = 0;
  // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).
  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8; cur_shift -= 8;
      if (p === cur_subblock + 256) {  // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  }

  // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.

  // Output code for the current contents of the index buffer.
  var ib_code = index_stream[0] & code_mask;  // Load first input index.
  var code_table = { };  // Key'd on our 20-bit "tuple".

  emit_code(clear_code);  // Spec says first code should be a clear code.

  // First index already loaded, process the rest of the stream.
  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
    var cur_code = code_table[cur_key];  // buffer + k.

    // Check if we have to create a new code table entry.
    if (cur_code === undefined) {  // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;
      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8; cur_shift -= 8;
        if (p === cur_subblock + 256) {  // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {  // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = { };
      } else {  // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
        code_table[cur_key] = next_code++;  // Insert into code table.
      }

      ib_code = k;  // Index buffer to single input k.
    } else {
      ib_code = cur_code;  // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code);  // There will still be something in the index buffer.
  emit_code(eoi_code);  // End Of Information.

  // Flush / finalize the sub-blocks stream to the buffer.
  emit_bytes_to_buffer(1);

  // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.
  if (cur_subblock + 1 === p) {  // Started but unused.
    buf[cur_subblock] = 0;
  } else {  // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }
  return p;
}

function GifReader(buf) {
  var p = 0;

  // - Header (GIF87a or GIF89a).
  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  }

  // - Logical Screen Descriptor.
  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++];  // <Packed Fields>.
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
  var background = buf[p++];
  buf[p++];  // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size   = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3;  // Seek past palette.
  }

  var no_eof = true;

  var frames = [ ];

  var delay = 0;
  var transparent_index = null;
  var disposal = 0;  // 0 - No disposal specified.
  var loop_count = null;

  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:  // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:  // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
                // Sub-block
                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++;  // Skip terminator.
            } else {  // We don't know what it is, just try to get past it.
              p += 12;
              while (true) {  // Seek through subblocks.
                var block_size = buf[p++];
                // Bad block size (ex: undefined from an out of bounds read).
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;  // 0 size is terminator
                p += block_size;
              }
            }
            break;

          case 0xf9:  // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++;  // Skip terminator.
            break;

          case 0xfe:  // Comment Extension.
            while (true) {  // Seek through subblocks.
              var block_size = buf[p++];
              // Bad block size (ex: undefined from an out of bounds read).
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;  // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));
              p += block_size;
            }
            break;

          default:
            throw new Error(
                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
        }
        break;

      case 0x2c:  // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p;  // Override with local palette.
          palette_size = num_local_colors;
          p += num_local_colors * 3;  // Seek past palette.
        }

        var data_offset = p;

        p++;  // codesize
        while (true) {
          var block_size = buf[p++];
          // Bad block size (ex: undefined from an out of bounds read).
          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break;  // 0 size is terminator
          p += block_size;
        }

        frames.push({x: x, y: y, width: w, height: h,
                     has_local_palette: has_local_palette,
                     palette_offset: palette_offset,
                     palette_size: palette_size,
                     data_offset: data_offset,
                     data_length: p - data_offset,
                     transparent_index: transparent_index,
                     interlaced: !!interlace_flag,
                     delay: delay,
                     disposal: disposal});
        break;

      case 0x3b:  // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
        break;
    }
  }

  this.numFrames = function() {
    return frames.length;
  };

  this.loopCount = function() {
    return loop_count;
  };

  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  }

  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };

  // I will go to copy and paste hell one day...
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];

  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;

  var op = 0;  // Output pointer.

  var subblock_size = code_stream[p++];

  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);
  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

  var prev_code = null;  // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break;  // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++];  // Next subblock.
      } else {
        --subblock_size;
      }
    }

    // TODO(deanm): We should never really get here, we should have received
    // and EOI.
    if (cur_shift < cur_code_size)
      break;

    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;

    // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.
    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.

      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;

      // Don't update prev_code ?
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }

    // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.

    var chase_code = code < next_code ? code : prev_code;

    // Chase what we will output, either {CODE} or {CODE-1}.
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;

    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    }

    // Already have the first byte from the chase, might as well write it fast.
    output[op++] = k;

    op += chase_length;
    var b = op;  // Track pointer, writing backwards.

    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
      output[op++] = k;

    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff;  // Write backwards.
      chase >>= 8;  // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).
      if (next_code >= code_mask+1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
}

// CommonJS.
try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}


/***/ }),

/***/ "./node_modules/parse-bmfont-ascii/index.js":
/*!**************************************************!*\
  !*** ./node_modules/parse-bmfont-ascii/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function parseBMFontAscii(data) {
  if (!data)
    throw new Error('no data provided')
  data = data.toString().trim()

  var output = {
    pages: [],
    chars: [],
    kernings: []
  }

  var lines = data.split(/\r\n?|\n/g)

  if (lines.length === 0)
    throw new Error('no data in BMFont file')

  for (var i = 0; i < lines.length; i++) {
    var lineData = splitLine(lines[i], i)
    if (!lineData) //skip empty lines
      continue

    if (lineData.key === 'page') {
      if (typeof lineData.data.id !== 'number')
        throw new Error('malformed file at line ' + i + ' -- needs page id=N')
      if (typeof lineData.data.file !== 'string')
        throw new Error('malformed file at line ' + i + ' -- needs page file="path"')
      output.pages[lineData.data.id] = lineData.data.file
    } else if (lineData.key === 'chars' || lineData.key === 'kernings') {
      //... do nothing for these two ...
    } else if (lineData.key === 'char') {
      output.chars.push(lineData.data)
    } else if (lineData.key === 'kerning') {
      output.kernings.push(lineData.data)
    } else {
      output[lineData.key] = lineData.data
    }
  }

  return output
}

function splitLine(line, idx) {
  line = line.replace(/\t+/g, ' ').trim()
  if (!line)
    return null

  var space = line.indexOf(' ')
  if (space === -1) 
    throw new Error("no named row at line " + idx)

  var key = line.substring(0, space)

  line = line.substring(space + 1)
  //clear "letter" field as it is non-standard and
  //requires additional complexity to parse " / = symbols
  line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, '')  
  line = line.split("=")
  line = line.map(function(str) {
    return str.trim().match((/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g))
  })

  var data = []
  for (var i = 0; i < line.length; i++) {
    var dt = line[i]
    if (i === 0) {
      data.push({
        key: dt[0],
        data: ""
      })
    } else if (i === line.length - 1) {
      data[data.length - 1].data = parseData(dt[0])
    } else {
      data[data.length - 1].data = parseData(dt[0])
      data.push({
        key: dt[1],
        data: ""
      })
    }
  }

  var out = {
    key: key,
    data: {}
  }

  data.forEach(function(v) {
    out.data[v.key] = v.data;
  })

  return out
}

function parseData(data) {
  if (!data || data.length === 0)
    return ""

  if (data.indexOf('"') === 0 || data.indexOf("'") === 0)
    return data.substring(1, data.length - 1)
  if (data.indexOf(',') !== -1)
    return parseIntList(data)
  return parseInt(data, 10)
}

function parseIntList(data) {
  return data.split(',').map(function(val) {
    return parseInt(val, 10)
  })
}

/***/ }),

/***/ "./node_modules/parse-bmfont-binary/index.js":
/*!***************************************************!*\
  !*** ./node_modules/parse-bmfont-binary/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var HEADER = [66, 77, 70]

module.exports = function readBMFontBinary(buf) {
  if (buf.length < 6)
    throw new Error('invalid buffer length for BMFont')

  var header = HEADER.every(function(byte, i) {
    return buf.readUInt8(i) === byte
  })

  if (!header)
    throw new Error('BMFont missing BMF byte header')

  var i = 3
  var vers = buf.readUInt8(i++)
  if (vers > 3)
    throw new Error('Only supports BMFont Binary v3 (BMFont App v1.10)')
  
  var target = { kernings: [], chars: [] }
  for (var b=0; b<5; b++)
    i += readBlock(target, buf, i)
  return target
}

function readBlock(target, buf, i) {
  if (i > buf.length-1)
    return 0

  var blockID = buf.readUInt8(i++)
  var blockSize = buf.readInt32LE(i)
  i += 4

  switch(blockID) {
    case 1: 
      target.info = readInfo(buf, i)
      break
    case 2:
      target.common = readCommon(buf, i)
      break
    case 3:
      target.pages = readPages(buf, i, blockSize)
      break
    case 4:
      target.chars = readChars(buf, i, blockSize)
      break
    case 5:
      target.kernings = readKernings(buf, i, blockSize)
      break
  }
  return 5 + blockSize
}

function readInfo(buf, i) {
  var info = {}
  info.size = buf.readInt16LE(i)

  var bitField = buf.readUInt8(i+2)
  info.smooth = (bitField >> 7) & 1
  info.unicode = (bitField >> 6) & 1
  info.italic = (bitField >> 5) & 1
  info.bold = (bitField >> 4) & 1
  
  //fixedHeight is only mentioned in binary spec 
  if ((bitField >> 3) & 1)
    info.fixedHeight = 1
  
  info.charset = buf.readUInt8(i+3) || ''
  info.stretchH = buf.readUInt16LE(i+4)
  info.aa = buf.readUInt8(i+6)
  info.padding = [
    buf.readInt8(i+7),
    buf.readInt8(i+8),
    buf.readInt8(i+9),
    buf.readInt8(i+10)
  ]
  info.spacing = [
    buf.readInt8(i+11),
    buf.readInt8(i+12)
  ]
  info.outline = buf.readUInt8(i+13)
  info.face = readStringNT(buf, i+14)
  return info
}

function readCommon(buf, i) {
  var common = {}
  common.lineHeight = buf.readUInt16LE(i)
  common.base = buf.readUInt16LE(i+2)
  common.scaleW = buf.readUInt16LE(i+4)
  common.scaleH = buf.readUInt16LE(i+6)
  common.pages = buf.readUInt16LE(i+8)
  var bitField = buf.readUInt8(i+10)
  common.packed = 0
  common.alphaChnl = buf.readUInt8(i+11)
  common.redChnl = buf.readUInt8(i+12)
  common.greenChnl = buf.readUInt8(i+13)
  common.blueChnl = buf.readUInt8(i+14)
  return common
}

function readPages(buf, i, size) {
  var pages = []
  var text = readNameNT(buf, i)
  var len = text.length+1
  var count = size / len
  for (var c=0; c<count; c++) {
    pages[c] = buf.slice(i, i+text.length).toString('utf8')
    i += len
  }
  return pages
}

function readChars(buf, i, blockSize) {
  var chars = []

  var count = blockSize / 20
  for (var c=0; c<count; c++) {
    var char = {}
    var off = c*20
    char.id = buf.readUInt32LE(i + 0 + off)
    char.x = buf.readUInt16LE(i + 4 + off)
    char.y = buf.readUInt16LE(i + 6 + off)
    char.width = buf.readUInt16LE(i + 8 + off)
    char.height = buf.readUInt16LE(i + 10 + off)
    char.xoffset = buf.readInt16LE(i + 12 + off)
    char.yoffset = buf.readInt16LE(i + 14 + off)
    char.xadvance = buf.readInt16LE(i + 16 + off)
    char.page = buf.readUInt8(i + 18 + off)
    char.chnl = buf.readUInt8(i + 19 + off)
    chars[c] = char
  }
  return chars
}

function readKernings(buf, i, blockSize) {
  var kernings = []
  var count = blockSize / 10
  for (var c=0; c<count; c++) {
    var kern = {}
    var off = c*10
    kern.first = buf.readUInt32LE(i + 0 + off)
    kern.second = buf.readUInt32LE(i + 4 + off)
    kern.amount = buf.readInt16LE(i + 8 + off)
    kernings[c] = kern
  }
  return kernings
}

function readNameNT(buf, offset) {
  var pos=offset
  for (; pos<buf.length; pos++) {
    if (buf[pos] === 0x00) 
      break
  }
  return buf.slice(offset, pos)
}

function readStringNT(buf, offset) {
  return readNameNT(buf, offset).toString('utf8')
}

/***/ }),

/***/ "./node_modules/parse-bmfont-xml/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/parse-bmfont-xml/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xml2js = __webpack_require__(/*! xml2js */ "xml2js")
var parseAttributes = __webpack_require__(/*! ./parse-attribs */ "./node_modules/parse-bmfont-xml/lib/parse-attribs.js")

module.exports = function parseBMFontXML(data) {
  data = data.toString().trim()

  var output = {
    pages: [],
    chars: [],
    kernings: []
  }

  xml2js.parseString(data, function(err, result) {
    if (err)
      throw err
    if (!result.font)
      throw "XML bitmap font doesn't have <font> root"
    result = result.font

    output.common = parseAttributes(result.common[0].$)
    output.info = parseAttributes(result.info[0].$)

    for (var i = 0; i < result.pages.length; i++) {
      var p = result.pages[i].page[0].$

      if (typeof p.id === "undefined")
        throw new Error("malformed file -- needs page id=N")
      if (typeof p.file !== "string")
        throw new Error("malformed file -- needs page file=\"path\"")

      output.pages[parseInt(p.id, 10)] = p.file
    }

    if (result.chars) {
      var chrArray = result.chars[0]['char'] || []
      for (var i = 0; i < chrArray.length; i++) {
        output.chars.push(parseAttributes(chrArray[i].$))
      }
    }

    if (result.kernings) {
      var kernArray = result.kernings[0]['kerning'] || []
      for (var i = 0; i < kernArray.length; i++) {
        output.kernings.push(parseAttributes(kernArray[i].$))
      }
    }
  })
  return output
}


/***/ }),

/***/ "./node_modules/parse-bmfont-xml/lib/parse-attribs.js":
/*!************************************************************!*\
  !*** ./node_modules/parse-bmfont-xml/lib/parse-attribs.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//Some versions of GlyphDesigner have a typo
//that causes some bugs with parsing. 
//Need to confirm with recent version of the software
//to see whether this is still an issue or not.
var GLYPH_DESIGNER_ERROR = 'chasrset'

module.exports = function parseAttributes(obj) {
  if (GLYPH_DESIGNER_ERROR in obj) {
    obj['charset'] = obj[GLYPH_DESIGNER_ERROR]
    delete obj[GLYPH_DESIGNER_ERROR]
  }

  for (var k in obj) {
    if (k === 'face' || k === 'charset') 
      continue
    else if (k === 'padding' || k === 'spacing')
      obj[k] = parseIntList(obj[k])
    else
      obj[k] = parseInt(obj[k], 10) 
  }
  return obj
}

function parseIntList(data) {
  return data.split(',').map(function(val) {
    return parseInt(val, 10)
  })
}

/***/ }),

/***/ "./node_modules/phin/lib/phin.compiled.js":
/*!************************************************!*\
  !*** ./node_modules/phin/lib/phin.compiled.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var _typeof=typeof Symbol==='function'&&typeof Symbol.iterator==='symbol'?function(obj){return typeof obj}:function(obj){return obj&&typeof Symbol==='function'&&obj.constructor===Symbol&&obj!==Symbol.prototype?'symbol':typeof obj};var http=__webpack_require__(/*! http */ "http");var https=__webpack_require__(/*! https */ "https");var url=__webpack_require__(/*! url */ "url");var qs=__webpack_require__(/*! querystring */ "querystring");var zlib=__webpack_require__(/*! zlib */ "zlib");var util=__webpack_require__(/*! util */ "util");var phin=function phin(opts,cb){if(typeof opts!=='string'){if(!opts.hasOwnProperty('url')){throw new Error('Missing url option from options for request method.')}}var addr=(typeof opts==='undefined'?'undefined':_typeof(opts))==='object'?url.parse(opts.url):url.parse(opts);var options={'hostname':addr.hostname,'port':addr.port||(addr.protocol.toLowerCase()==='http:'?80:443),'path':addr.path,'method':'GET','headers':{},'auth':addr.auth||null,'parse':'none','stream':false};if((typeof opts==='undefined'?'undefined':_typeof(opts))==='object'){options=Object.assign(options,opts)}options.port=Number(options.port);if(options.hasOwnProperty('timeout'))delete options.timeout;if(options.compressed===true){options.headers['accept-encoding']='gzip, deflate'}if(opts.hasOwnProperty('form')){if(_typeof(opts.form)!=='object'){throw new Error('phin \'form\' option must be of type Object if present.')}var formDataString=qs.stringify(opts.form);options.headers['Content-Type']='application/x-www-form-urlencoded';options.headers['Content-Length']=Buffer.byteLength(formDataString);opts.data=formDataString}var req=void 0;var resHandler=function resHandler(res){var stream=res;if(options.compressed===true){if(res.headers['content-encoding']==='gzip'){stream=res.pipe(zlib.createGunzip())}else if(res.headers['content-encoding']==='deflate'){stream=res.pipe(zlib.createInflate())}}if(options.stream===true){res.stream=stream;if(cb)cb(null,res)}else{res.body=new Buffer([]);stream.on('data',function(chunk){res.body=Buffer.concat([res.body,chunk])});stream.on('end',function(){if(cb){if(options.parse==='json'){try{res.body=JSON.parse(res.body.toString())}catch(err){cb('Invalid JSON received.',res);return}}cb(null,res)}})}};switch(addr.protocol.toLowerCase()){case'http:':req=http.request(options,resHandler);break;case'https:':req=https.request(options,resHandler);break;default:if(cb)cb(new Error('Invalid / unknown URL protocol. Expected HTTP or HTTPS.'),null);return;}if(typeof opts.timeout==='number'){req.setTimeout(opts.timeout,function(){req.abort();if(cb)cb(new Error('Timeout has been reached.'),null);cb=null})}req.on('error',function(err){if(cb)cb(err,null)});if(opts.hasOwnProperty('data')){var postData=opts.data;if(!(opts.data instanceof Buffer)&&_typeof(opts.data)==='object'){var contentType=options.headers['content-type']||options.headers['Content-Type'];if(contentType==='application/x-www-form-urlencoded'){postData=qs.stringify(opts.data)}else{try{postData=JSON.stringify(opts.data)}catch(err){if(cb)cb(new Error('Couldn\'t stringify object. (Likely due to a circular reference.)'),null)}}}req.write(postData)}req.end()};phin.promisified=function(opts,http){return new Promise(function(resolve,reject){phin(opts,function(err,res){if(err){reject(err)}else{resolve(res)}},http)})};if(util.promisify){phin[util.promisify.custom]=phin.promisified}module.exports=phin;


/***/ }),

/***/ "./node_modules/pixelmatch/index.js":
/*!******************************************!*\
  !*** ./node_modules/pixelmatch/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = pixelmatch;

function pixelmatch(img1, img2, output, width, height, options) {

    if (!options) options = {};

    var threshold = options.threshold === undefined ? 0.1 : options.threshold;

    // maximum acceptable square distance between two colors;
    // 35215 is the maximum possible value for the YIQ difference metric
    var maxDelta = 35215 * threshold * threshold,
        diff = 0;

    // compare each pixel of one image against the other one
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {

            var pos = (y * width + x) * 4;

            // squared YUV distance between colors at this pixel position
            var delta = colorDelta(img1, img2, pos, pos);

            // the color difference is above the threshold
            if (delta > maxDelta) {
                // check it's a real rendering difference or just anti-aliasing
                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||
                                   antialiased(img2, x, y, width, height, img1))) {
                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference
                    if (output) drawPixel(output, pos, 255, 255, 0);

                } else {
                    // found substantial difference not caused by anti-aliasing; draw it as red
                    if (output) drawPixel(output, pos, 255, 0, 0);
                    diff++;
                }

            } else if (output) {
                // pixels are similar; draw background as grayscale image blended with white
                var val = blend(grayPixel(img1, pos), 0.1);
                drawPixel(output, pos, val, val, val);
            }
        }
    }

    // return the number of different pixels
    return diff;
}

// check if a pixel is likely a part of anti-aliasing;
// based on "Anti-aliased Pixel and Intensity Slope Detector" paper by V. Vysniauskas, 2009

function antialiased(img, x1, y1, width, height, img2) {
    var x0 = Math.max(x1 - 1, 0),
        y0 = Math.max(y1 - 1, 0),
        x2 = Math.min(x1 + 1, width - 1),
        y2 = Math.min(y1 + 1, height - 1),
        pos = (y1 * width + x1) * 4,
        zeroes = 0,
        positives = 0,
        negatives = 0,
        min = 0,
        max = 0,
        minX, minY, maxX, maxY;

    // go through 8 adjacent pixels
    for (var x = x0; x <= x2; x++) {
        for (var y = y0; y <= y2; y++) {
            if (x === x1 && y === y1) continue;

            // brightness delta between the center pixel and adjacent one
            var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);

            // count the number of equal, darker and brighter adjacent pixels
            if (delta === 0) zeroes++;
            else if (delta < 0) negatives++;
            else if (delta > 0) positives++;

            // if found more than 2 equal siblings, it's definitely not anti-aliasing
            if (zeroes > 2) return false;

            if (!img2) continue;

            // remember the darkest pixel
            if (delta < min) {
                min = delta;
                minX = x;
                minY = y;
            }
            // remember the brightest pixel
            if (delta > max) {
                max = delta;
                maxX = x;
                maxY = y;
            }
        }
    }

    if (!img2) return true;

    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing
    if (negatives === 0 || positives === 0) return false;

    // if either the darkest or the brightest pixel has more than 2 equal siblings in both images
    // (definitely not anti-aliased), this pixel is anti-aliased
    return (!antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height)) ||
           (!antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height));
}

// calculate color difference according to the paper "Measuring perceived color difference
// using YIQ NTSC transmission color space in mobile applications" by Y. Kotsarenko and F. Ramos

function colorDelta(img1, img2, k, m, yOnly) {
    var a1 = img1[k + 3] / 255,
        a2 = img2[m + 3] / 255,

        r1 = blend(img1[k + 0], a1),
        g1 = blend(img1[k + 1], a1),
        b1 = blend(img1[k + 2], a1),

        r2 = blend(img2[m + 0], a2),
        g2 = blend(img2[m + 1], a2),
        b2 = blend(img2[m + 2], a2),

        y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);

    if (yOnly) return y; // brightness difference only

    var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2),
        q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);

    return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
}

function rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }
function rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }
function rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }

// blend semi-transparent color with white
function blend(c, a) {
    return 255 + (c - 255) * a;
}

function drawPixel(output, pos, r, g, b) {
    output[pos + 0] = r;
    output[pos + 1] = g;
    output[pos + 2] = b;
    output[pos + 3] = 255;
}

function grayPixel(img, i) {
    var a = img[i + 3] / 255,
        r = blend(img[i + 0], a),
        g = blend(img[i + 1], a),
        b = blend(img[i + 2], a);
    return rgb2y(r, g, b);
}


/***/ }),

/***/ "./node_modules/pngjs/lib/bitmapper.js":
/*!*********************************************!*\
  !*** ./node_modules/pngjs/lib/bitmapper.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var interlaceUtils = __webpack_require__(/*! ./interlace */ "./node_modules/pngjs/lib/interlace.js");

var pixelBppMap = {
  1: { // L
    0: 0,
    1: 0,
    2: 0,
    3: 0xff
  },
  2: { // LA
    0: 0,
    1: 0,
    2: 0,
    3: 1
  },
  3: { // RGB
    0: 0,
    1: 1,
    2: 2,
    3: 0xff
  },
  4: { // RGBA
    0: 0,
    1: 1,
    2: 2,
    3: 3
  }
};

function bitRetriever(data, depth) {

  var leftOver = [];
  var i = 0;

  function split() {
    if (i === data.length) {
      throw new Error('Ran out of data');
    }
    var byte = data[i];
    i++;
    var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
    switch (depth) {
      default:
        throw new Error('unrecognised depth');
      case 16:
        byte2 = data[i];
        i++;
        leftOver.push(((byte << 8) + byte2));
        break;
      case 4:
        byte2 = byte & 0x0f;
        byte1 = byte >> 4;
        leftOver.push(byte1, byte2);
        break;
      case 2:
        byte4 = byte & 3;
        byte3 = byte >> 2 & 3;
        byte2 = byte >> 4 & 3;
        byte1 = byte >> 6 & 3;
        leftOver.push(byte1, byte2, byte3, byte4);
        break;
      case 1:
        byte8 = byte & 1;
        byte7 = byte >> 1 & 1;
        byte6 = byte >> 2 & 1;
        byte5 = byte >> 3 & 1;
        byte4 = byte >> 4 & 1;
        byte3 = byte >> 5 & 1;
        byte2 = byte >> 6 & 1;
        byte1 = byte >> 7 & 1;
        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
        break;
    }
  }

  return {
    get: function(count) {
      while (leftOver.length < count) {
        split();
      }
      var returner = leftOver.slice(0, count);
      leftOver = leftOver.slice(count);
      return returner;
    },
    resetAfterLine: function() {
      leftOver.length = 0;
    },
    end: function() {
      if (i !== data.length) {
        throw new Error('extra data found');
      }
    }
  };
}

function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) { // eslint-disable-line max-params
  var imageWidth = image.width;
  var imageHeight = image.height;
  var imagePass = image.index;
  for (var y = 0; y < imageHeight; y++) {
    for (var x = 0; x < imageWidth; x++) {
      var pxPos = getPxPos(x, y, imagePass);

      for (var i = 0; i < 4; i++) {
        var idx = pixelBppMap[bpp][i];
        if (idx === 0xff) {
          pxData[pxPos + i] = 0xff;
        } else {
          var dataPos = idx + rawPos;
          if (dataPos === data.length) {
            throw new Error('Ran out of data');
          }
          pxData[pxPos + i] = data[dataPos];
        }
      }
      rawPos += bpp; //eslint-disable-line no-param-reassign
    }
  }
  return rawPos;
}

function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) { // eslint-disable-line max-params
  var imageWidth = image.width;
  var imageHeight = image.height;
  var imagePass = image.index;
  for (var y = 0; y < imageHeight; y++) {
    for (var x = 0; x < imageWidth; x++) {
      var pixelData = bits.get(bpp);
      var pxPos = getPxPos(x, y, imagePass);

      for (var i = 0; i < 4; i++) {
        var idx = pixelBppMap[bpp][i];
        pxData[pxPos + i] = idx !== 0xff ? pixelData[idx] : maxBit;
      }
    }
    bits.resetAfterLine();
  }
}

exports.dataToBitMap = function(data, bitmapInfo) {

  var width = bitmapInfo.width;
  var height = bitmapInfo.height;
  var depth = bitmapInfo.depth;
  var bpp = bitmapInfo.bpp;
  var interlace = bitmapInfo.interlace;

  if (depth !== 8) {
    var bits = bitRetriever(data, depth);
  }
  var pxData;
  if (depth <= 8) {
    pxData = new Buffer(width * height * 4);
  }
  else {
    pxData = new Uint16Array(width * height * 4);
  }
  var maxBit = Math.pow(2, depth) - 1;
  var rawPos = 0;
  var images;
  var getPxPos;

  if (interlace) {
    images = interlaceUtils.getImagePasses(width, height);
    getPxPos = interlaceUtils.getInterlaceIterator(width, height);
  }
  else {
    var nonInterlacedPxPos = 0;
    getPxPos = function() {
      var returner = nonInterlacedPxPos;
      nonInterlacedPxPos += 4;
      return returner;
    };
    images = [{ width: width, height: height }];
  }

  for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
    if (depth === 8) {
      rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
    }
    else {
      mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
    }
  }
  if (depth === 8) {
    if (rawPos !== data.length) {
      throw new Error('extra data found');
    }
  }
  else {
    bits.end();
  }

  return pxData;
};


/***/ }),

/***/ "./node_modules/pngjs/lib/bitpacker.js":
/*!*********************************************!*\
  !*** ./node_modules/pngjs/lib/bitpacker.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(/*! ./constants */ "./node_modules/pngjs/lib/constants.js");

module.exports = function(dataIn, width, height, options) {
  var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
  if (options.colorType === options.inputColorType) {
    var bigEndian = (function() {
      var buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
      // Int16Array uses the platform's endianness.
      return new Int16Array(buffer)[0] !== 256;
    })();
    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route
     if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)){
         return dataIn;
    }
  }

  // map to a UInt16 array if data is 16bit, fix endianness below
  var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);

  var maxValue = 255;
  var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
  if (inBpp == 4 && !options.inputHasAlpha) inBpp = 3;
  var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
  if (options.bitDepth === 16) {
    maxValue = 65535;
    outBpp *= 2;
  }
  var outData = new Buffer(width * height * outBpp);

  var inIndex = 0;
  var outIndex = 0;

  var bgColor = options.bgColor || {};
  if (bgColor.red === undefined) {
    bgColor.red = maxValue;
  }
  if (bgColor.green === undefined) {
    bgColor.green = maxValue;
  }
  if (bgColor.blue === undefined) {
    bgColor.blue = maxValue;
  }

  function getRGBA(data, inIndex) {
    var red, green, blue, alpha = maxValue;
    switch (options.inputColorType) {
      case constants.COLORTYPE_COLOR_ALPHA:
        alpha = data[inIndex + 3];
        red = data[inIndex];
        green = data[inIndex+1];
        blue = data[inIndex+2];
        break;
      case constants.COLORTYPE_COLOR:
        red = data[inIndex];
        green = data[inIndex+1];
        blue = data[inIndex+2];
        break;
      case constants.COLORTYPE_ALPHA:
        alpha = data[inIndex + 1];
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      case constants.COLORTYPE_GRAYSCALE:
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      default:
        throw new Error('input color type:' + options.inputColorType + ' is not supported at present');
    }

    if (options.inputHasAlpha) {
      if (!outHasAlpha) {
        alpha /= maxValue;
        red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
      }
    }
    return {red: red, green: green, blue: blue, alpha: alpha};
  }

  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var rgba = getRGBA(data, inIndex);

      switch (options.colorType) {
        case constants.COLORTYPE_COLOR_ALPHA:
        case constants.COLORTYPE_COLOR:
          if (options.bitDepth === 8) {
            outData[outIndex] = rgba.red;
            outData[outIndex + 1] = rgba.green;
            outData[outIndex + 2] = rgba.blue;
            if (outHasAlpha) {
              outData[outIndex + 3] = rgba.alpha;
            }
          } else {
            outData.writeUInt16BE(rgba.red, outIndex);
            outData.writeUInt16BE(rgba.green, outIndex + 2);
            outData.writeUInt16BE(rgba.blue, outIndex + 4);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 6);
            }
          }
          break;
        case constants.COLORTYPE_ALPHA:
        case constants.COLORTYPE_GRAYSCALE:
          // Convert to grayscale and alpha
          var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
          if (options.bitDepth === 8) {
            outData[outIndex] = grayscale;
            if (outHasAlpha) {
              outData[outIndex + 1] = rgba.alpha;
            }
          } else {
            outData.writeUInt16BE(grayscale, outIndex);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 2);
            }
          }
          break;
      }

      inIndex += inBpp;
      outIndex += outBpp;
    }
  }

  return outData;
};


/***/ }),

/***/ "./node_modules/pngjs/lib/chunkstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pngjs/lib/chunkstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var util = __webpack_require__(/*! util */ "util");
var Stream = __webpack_require__(/*! stream */ "stream");


var ChunkStream = module.exports = function() {
  Stream.call(this);

  this._buffers = [];
  this._buffered = 0;

  this._reads = [];
  this._paused = false;

  this._encoding = 'utf8';
  this.writable = true;
};
util.inherits(ChunkStream, Stream);


ChunkStream.prototype.read = function(length, callback) {

  this._reads.push({
    length: Math.abs(length),  // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback
  });

  process.nextTick(function() {
    this._process();

    // its paused and there is not enought data then ask for more
    if (this._paused && this._reads.length > 0) {
      this._paused = false;

      this.emit('drain');
    }
  }.bind(this));
};

ChunkStream.prototype.write = function(data, encoding) {

  if (!this.writable) {
    this.emit('error', new Error('Stream not writable'));
    return false;
  }

  var dataBuffer;
  if (Buffer.isBuffer(data)) {
    dataBuffer = data;
  }
  else {
    dataBuffer = new Buffer(data, encoding || this._encoding);
  }

  this._buffers.push(dataBuffer);
  this._buffered += dataBuffer.length;

  this._process();

  // ok if there are no more read requests
  if (this._reads && this._reads.length === 0) {
    this._paused = true;
  }

  return this.writable && !this._paused;
};

ChunkStream.prototype.end = function(data, encoding) {

  if (data) {
    this.write(data, encoding);
  }

  this.writable = false;

  // already destroyed
  if (!this._buffers) {
    return;
  }

  // enqueue or handle end
  if (this._buffers.length === 0) {
    this._end();
  }
  else {
    this._buffers.push(null);
    this._process();
  }
};

ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;

ChunkStream.prototype._end = function() {

  if (this._reads.length > 0) {
    this.emit('error',
      new Error('There are some read requests waiting on finished stream')
    );
  }

  this.destroy();
};

ChunkStream.prototype.destroy = function() {

  if (!this._buffers) {
    return;
  }

  this.writable = false;
  this._reads = null;
  this._buffers = null;

  this.emit('close');
};

ChunkStream.prototype._processReadAllowingLess = function(read) {
  // ok there is any data so that we can satisfy this request
  this._reads.shift(); // == read

  // first we need to peek into first buffer
  var smallerBuf = this._buffers[0];

  // ok there is more data than we need
  if (smallerBuf.length > read.length) {

    this._buffered -= read.length;
    this._buffers[0] = smallerBuf.slice(read.length);

    read.func.call(this, smallerBuf.slice(0, read.length));

  }
  else {
    // ok this is less than maximum length so use it all
    this._buffered -= smallerBuf.length;
    this._buffers.shift(); // == smallerBuf

    read.func.call(this, smallerBuf);
  }
};

ChunkStream.prototype._processRead = function(read) {
  this._reads.shift(); // == read

  var pos = 0;
  var count = 0;
  var data = new Buffer(read.length);

  // create buffer for all data
  while (pos < read.length) {

    var buf = this._buffers[count++];
    var len = Math.min(buf.length, read.length - pos);

    buf.copy(data, pos, 0, len);
    pos += len;

    // last buffer wasn't used all so just slice it and leave
    if (len !== buf.length) {
      this._buffers[--count] = buf.slice(len);
    }
  }

  // remove all used buffers
  if (count > 0) {
    this._buffers.splice(0, count);
  }

  this._buffered -= read.length;

  read.func.call(this, data);
};

ChunkStream.prototype._process = function() {

  try {
    // as long as there is any data and read requests
    while (this._buffered > 0 && this._reads && this._reads.length > 0) {

      var read = this._reads[0];

      // read any data (but no more than length)
      if (read.allowLess) {
        this._processReadAllowingLess(read);

      }
      else if (this._buffered >= read.length) {
        // ok we can meet some expectations

        this._processRead(read);
      }
      else {
        // not enought data to satisfy first request in queue
        // so we need to wait for more
        break;
      }
    }

    if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {
      this._end();
    }
  }
  catch (ex) {
    this.emit('error', ex);
  }
};


/***/ }),

/***/ "./node_modules/pngjs/lib/constants.js":
/*!*********************************************!*\
  !*** ./node_modules/pngjs/lib/constants.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = {

  PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],

  TYPE_IHDR: 0x49484452,
  TYPE_IEND: 0x49454e44,
  TYPE_IDAT: 0x49444154,
  TYPE_PLTE: 0x504c5445,
  TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase
  TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase

  // color-type bits
  COLORTYPE_GRAYSCALE: 0,
  COLORTYPE_PALETTE: 1,
  COLORTYPE_COLOR: 2,
  COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha

  // color-type combinations
  COLORTYPE_PALETTE_COLOR: 3,
  COLORTYPE_COLOR_ALPHA: 6,

  COLORTYPE_TO_BPP_MAP: {
    0: 1,
    2: 3,
    3: 1,
    4: 2,
    6: 4
  },

  GAMMA_DIVISION: 100000
};


/***/ }),

/***/ "./node_modules/pngjs/lib/crc.js":
/*!***************************************!*\
  !*** ./node_modules/pngjs/lib/crc.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var crcTable = [];

(function() {
  for (var i = 0; i < 256; i++) {
    var currentCrc = i;
    for (var j = 0; j < 8; j++) {
      if (currentCrc & 1) {
        currentCrc = 0xedb88320 ^ (currentCrc >>> 1);
      }
      else {
        currentCrc = currentCrc >>> 1;
      }
    }
    crcTable[i] = currentCrc;
  }
}());

var CrcCalculator = module.exports = function() {
  this._crc = -1;
};

CrcCalculator.prototype.write = function(data) {

  for (var i = 0; i < data.length; i++) {
    this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);
  }
  return true;
};

CrcCalculator.prototype.crc32 = function() {
  return this._crc ^ -1;
};


CrcCalculator.crc32 = function(buf) {

  var crc = -1;
  for (var i = 0; i < buf.length; i++) {
    crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);
  }
  return crc ^ -1;
};


/***/ }),

/***/ "./node_modules/pngjs/lib/filter-pack.js":
/*!***********************************************!*\
  !*** ./node_modules/pngjs/lib/filter-pack.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var paethPredictor = __webpack_require__(/*! ./paeth-predictor */ "./node_modules/pngjs/lib/paeth-predictor.js");

function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {

  for (var x = 0; x < byteWidth; x++) {    
    rawData[rawPos + x] = pxData[pxPos + x];
  }
}

function filterSumNone(pxData, pxPos, byteWidth) {

  var sum = 0;
  var length = pxPos + byteWidth;

  for (var i = pxPos; i < length; i++) {
    sum += Math.abs(pxData[i]);
  }
  return sum;
}

function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {

  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var val = pxData[pxPos + x] - left;

    rawData[rawPos + x] = val;
  }
}

function filterSumSub(pxData, pxPos, byteWidth, bpp) {

  var sum = 0;
  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var val = pxData[pxPos + x] - left;

    sum += Math.abs(val);
  }

  return sum;
}

function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {

  for (var x = 0; x < byteWidth; x++) {

    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var val = pxData[pxPos + x] - up;

    rawData[rawPos + x] = val;
  }
}

function filterSumUp(pxData, pxPos, byteWidth) {

  var sum = 0;
  var length = pxPos + byteWidth;
  for (var x = pxPos; x < length; x++) {

    var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
    var val = pxData[x] - up;

    sum += Math.abs(val);
  }

  return sum;
}

function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {

  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var val = pxData[pxPos + x] - ((left + up) >> 1);

    rawData[rawPos + x] = val;
  }
}

function filterSumAvg(pxData, pxPos, byteWidth, bpp) {

  var sum = 0;
  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var val = pxData[pxPos + x] - ((left + up) >> 1);

    sum += Math.abs(val);
  }

  return sum;
}

function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {

  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

    rawData[rawPos + x] = val;
  }
}

function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
  var sum = 0;
  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

    sum += Math.abs(val);
  }

  return sum;
}

var filters = {
  0: filterNone,
  1: filterSub,
  2: filterUp,
  3: filterAvg,
  4: filterPaeth
};

var filterSums = {
  0: filterSumNone,
  1: filterSumSub,
  2: filterSumUp,
  3: filterSumAvg,
  4: filterSumPaeth
};

module.exports = function(pxData, width, height, options, bpp) {

  var filterTypes;
  if (!('filterType' in options) || options.filterType === -1) {
    filterTypes = [0, 1, 2, 3, 4];
  }
  else if (typeof options.filterType === 'number') {
    filterTypes = [options.filterType];
  }
  else {
    throw new Error('unrecognised filter types');
  }

  if (options.bitDepth === 16) bpp *= 2;
  var byteWidth = width * bpp;
  var rawPos = 0;
  var pxPos = 0;
  var rawData = new Buffer((byteWidth + 1) * height);

  var sel = filterTypes[0];

  for (var y = 0; y < height; y++) {

    if (filterTypes.length > 1) {
      // find best filter for this line (with lowest sum of values)
      var min = Infinity;

      for (var i = 0; i < filterTypes.length; i++) {
        var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
        if (sum < min) {
          sel = filterTypes[i];
          min = sum;
        }
      }
    }

    rawData[rawPos] = sel;
    rawPos++;
    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
    rawPos += byteWidth;
    pxPos += byteWidth;
  }
  return rawData;
};


/***/ }),

/***/ "./node_modules/pngjs/lib/filter-parse-async.js":
/*!******************************************************!*\
  !*** ./node_modules/pngjs/lib/filter-parse-async.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! util */ "util");
var ChunkStream = __webpack_require__(/*! ./chunkstream */ "./node_modules/pngjs/lib/chunkstream.js");
var Filter = __webpack_require__(/*! ./filter-parse */ "./node_modules/pngjs/lib/filter-parse.js");


var FilterAsync = module.exports = function(bitmapInfo) {
  ChunkStream.call(this);

  var buffers = [];
  var that = this;
  this._filter = new Filter(bitmapInfo, {
    read: this.read.bind(this),
    write: function(buffer) {
      buffers.push(buffer);
    },
    complete: function() {
      that.emit('complete', Buffer.concat(buffers));
    }
  });

  this._filter.start();
};
util.inherits(FilterAsync, ChunkStream);


/***/ }),

/***/ "./node_modules/pngjs/lib/filter-parse-sync.js":
/*!*****************************************************!*\
  !*** ./node_modules/pngjs/lib/filter-parse-sync.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SyncReader = __webpack_require__(/*! ./sync-reader */ "./node_modules/pngjs/lib/sync-reader.js");
var Filter = __webpack_require__(/*! ./filter-parse */ "./node_modules/pngjs/lib/filter-parse.js");


exports.process = function(inBuffer, bitmapInfo) {

  var outBuffers = [];
  var reader = new SyncReader(inBuffer);
  var filter = new Filter(bitmapInfo, {
    read: reader.read.bind(reader),
    write: function(bufferPart) {
      outBuffers.push(bufferPart);
    },
    complete: function() {
    }
  });

  filter.start();
  reader.process();

  return Buffer.concat(outBuffers);
};

/***/ }),

/***/ "./node_modules/pngjs/lib/filter-parse.js":
/*!************************************************!*\
  !*** ./node_modules/pngjs/lib/filter-parse.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var interlaceUtils = __webpack_require__(/*! ./interlace */ "./node_modules/pngjs/lib/interlace.js");
var paethPredictor = __webpack_require__(/*! ./paeth-predictor */ "./node_modules/pngjs/lib/paeth-predictor.js");

function getByteWidth(width, bpp, depth) {
  var byteWidth = width * bpp;
  if (depth !== 8) {
    byteWidth = Math.ceil(byteWidth / (8 / depth));
  }
  return byteWidth;
}

var Filter = module.exports = function(bitmapInfo, dependencies) {

  var width = bitmapInfo.width;
  var height = bitmapInfo.height;
  var interlace = bitmapInfo.interlace;
  var bpp = bitmapInfo.bpp;
  var depth = bitmapInfo.depth;

  this.read = dependencies.read;
  this.write = dependencies.write;
  this.complete = dependencies.complete;

  this._imageIndex = 0;
  this._images = [];
  if (interlace) {
    var passes = interlaceUtils.getImagePasses(width, height);
    for (var i = 0; i < passes.length; i++) {
      this._images.push({
        byteWidth: getByteWidth(passes[i].width, bpp, depth),
        height: passes[i].height,
        lineIndex: 0
      });
    }
  }
  else {
    this._images.push({
      byteWidth: getByteWidth(width, bpp, depth),
      height: height,
      lineIndex: 0
    });
  }

  // when filtering the line we look at the pixel to the left
  // the spec also says it is done on a byte level regardless of the number of pixels
  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back
  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.
  if (depth === 8) {
    this._xComparison = bpp;
  }
  else if (depth === 16) {
    this._xComparison = bpp * 2;
  }
  else {
    this._xComparison = 1;
  }
};

Filter.prototype.start = function() {
  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
};

Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {

  var xComparison = this._xComparison;
  var xBiggerThan = xComparison - 1;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    unfilteredLine[x] = rawByte + f1Left;
  }
};

Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {

  var lastLine = this._lastLine;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f2Up = lastLine ? lastLine[x] : 0;
    unfilteredLine[x] = rawByte + f2Up;
  }
};

Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {

  var xComparison = this._xComparison;
  var xBiggerThan = xComparison - 1;
  var lastLine = this._lastLine;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f3Up = lastLine ? lastLine[x] : 0;
    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    var f3Add = Math.floor((f3Left + f3Up) / 2);
    unfilteredLine[x] = rawByte + f3Add;
  }
};

Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {

  var xComparison = this._xComparison;
  var xBiggerThan = xComparison - 1;
  var lastLine = this._lastLine;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f4Up = lastLine ? lastLine[x] : 0;
    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
    unfilteredLine[x] = rawByte + f4Add;
  }
};

Filter.prototype._reverseFilterLine = function(rawData) {

  var filter = rawData[0];
  var unfilteredLine;
  var currentImage = this._images[this._imageIndex];
  var byteWidth = currentImage.byteWidth;

  if (filter === 0) {
    unfilteredLine = rawData.slice(1, byteWidth + 1);
  }
  else {

    unfilteredLine = new Buffer(byteWidth);

    switch (filter) {
      case 1:
        this._unFilterType1(rawData, unfilteredLine, byteWidth);
        break;
      case 2:
        this._unFilterType2(rawData, unfilteredLine, byteWidth);
        break;
      case 3:
        this._unFilterType3(rawData, unfilteredLine, byteWidth);
        break;
      case 4:
        this._unFilterType4(rawData, unfilteredLine, byteWidth);
        break;
      default:
        throw new Error('Unrecognised filter type - ' + filter);
    }
  }

  this.write(unfilteredLine);

  currentImage.lineIndex++;
  if (currentImage.lineIndex >= currentImage.height) {
    this._lastLine = null;
    this._imageIndex++;
    currentImage = this._images[this._imageIndex];
  }
  else {
    this._lastLine = unfilteredLine;
  }

  if (currentImage) {
    // read, using the byte width that may be from the new current image
    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
  }
  else {
    this._lastLine = null;
    this.complete();
  }
};


/***/ }),

/***/ "./node_modules/pngjs/lib/format-normaliser.js":
/*!*****************************************************!*\
  !*** ./node_modules/pngjs/lib/format-normaliser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function dePalette(indata, outdata, width, height, palette) {
  var pxPos = 0;
  // use values from palette
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var color = palette[indata[pxPos]];

      if (!color) {
        throw new Error('index ' + indata[pxPos] + ' not in palette');
      }

      for (var i = 0; i < 4; i++) {
        outdata[pxPos + i] = color[i];
      }
      pxPos += 4;
    }
  }
}

function replaceTransparentColor(indata, outdata, width, height, transColor) {
  var pxPos = 0;
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var makeTrans = false;

      if (transColor.length === 1) {
        if (transColor[0] === indata[pxPos]) {
          makeTrans = true;
        }
      }
      else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
        makeTrans = true;
      }
      if (makeTrans) {
        for (var i = 0; i < 4; i++) {
          outdata[pxPos + i] = 0;
        }
      }
      pxPos += 4;
    }
  }
}

function scaleDepth(indata, outdata, width, height, depth) {
  var maxOutSample = 255;
  var maxInSample = Math.pow(2, depth) - 1;
  var pxPos = 0;

  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      for (var i = 0; i < 4; i++) {
        outdata[pxPos + i] = Math.floor((indata[pxPos + i] * maxOutSample) / maxInSample + 0.5);
      }
      pxPos += 4;
    }
  }
}

module.exports = function(indata, imageData) {

  var depth = imageData.depth;
  var width = imageData.width;
  var height = imageData.height;
  var colorType = imageData.colorType;
  var transColor = imageData.transColor;
  var palette = imageData.palette;

  var outdata = indata; // only different for 16 bits

  if (colorType === 3) { // paletted
    dePalette(indata, outdata, width, height, palette);
  }
  else {
    if (transColor) {
      replaceTransparentColor(indata, outdata, width, height, transColor);
    }
    // if it needs scaling
    if (depth !== 8) {
      // if we need to change the buffer size
      if (depth === 16) {
        outdata = new Buffer(width * height * 4);
      }
      scaleDepth(indata, outdata, width, height, depth);
    }
  }
  return outdata;
};


/***/ }),

/***/ "./node_modules/pngjs/lib/interlace.js":
/*!*********************************************!*\
  !*** ./node_modules/pngjs/lib/interlace.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Adam 7
//   0 1 2 3 4 5 6 7
// 0 x 6 4 6 x 6 4 6
// 1 7 7 7 7 7 7 7 7
// 2 5 6 5 6 5 6 5 6
// 3 7 7 7 7 7 7 7 7
// 4 3 6 4 6 3 6 4 6
// 5 7 7 7 7 7 7 7 7
// 6 5 6 5 6 5 6 5 6
// 7 7 7 7 7 7 7 7 7


var imagePasses = [
  { // pass 1 - 1px
    x: [0],
    y: [0]
  },
  { // pass 2 - 1px
    x: [4],
    y: [0]
  },
  { // pass 3 - 2px
    x: [0, 4],
    y: [4]
  },
  { // pass 4 - 4px
    x: [2, 6],
    y: [0, 4]
  },
  { // pass 5 - 8px
    x: [0, 2, 4, 6],
    y: [2, 6]
  },
  { // pass 6 - 16px
    x: [1, 3, 5, 7],
    y: [0, 2, 4, 6]
  },
  { // pass 7 - 32px
    x: [0, 1, 2, 3, 4, 5, 6, 7],
    y: [1, 3, 5, 7]
  }
];

exports.getImagePasses = function(width, height) {
  var images = [];
  var xLeftOver = width % 8;
  var yLeftOver = height % 8;
  var xRepeats = (width - xLeftOver) / 8;
  var yRepeats = (height - yLeftOver) / 8;
  for (var i = 0; i < imagePasses.length; i++) {
    var pass = imagePasses[i];
    var passWidth = xRepeats * pass.x.length;
    var passHeight = yRepeats * pass.y.length;
    for (var j = 0; j < pass.x.length; j++) {
      if (pass.x[j] < xLeftOver) {
        passWidth++;
      }
      else {
        break;
      }
    }
    for (j = 0; j < pass.y.length; j++) {
      if (pass.y[j] < yLeftOver) {
        passHeight++;
      }
      else {
        break;
      }
    }
    if (passWidth > 0 && passHeight > 0) {
      images.push({ width: passWidth, height: passHeight, index: i });
    }
  }
  return images;
};

exports.getInterlaceIterator = function(width) {
  return function(x, y, pass) {
    var outerXLeftOver = x % imagePasses[pass].x.length;
    var outerX = (((x - outerXLeftOver) / imagePasses[pass].x.length) * 8) + imagePasses[pass].x[outerXLeftOver];
    var outerYLeftOver = y % imagePasses[pass].y.length;
    var outerY = (((y - outerYLeftOver) / imagePasses[pass].y.length) * 8) + imagePasses[pass].y[outerYLeftOver];
    return (outerX * 4) + (outerY * width * 4);
  };
};

/***/ }),

/***/ "./node_modules/pngjs/lib/packer-async.js":
/*!************************************************!*\
  !*** ./node_modules/pngjs/lib/packer-async.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! util */ "util");
var Stream = __webpack_require__(/*! stream */ "stream");
var constants = __webpack_require__(/*! ./constants */ "./node_modules/pngjs/lib/constants.js");
var Packer = __webpack_require__(/*! ./packer */ "./node_modules/pngjs/lib/packer.js");

var PackerAsync = module.exports = function(opt) {
  Stream.call(this);

  var options = opt || {};

  this._packer = new Packer(options);
  this._deflate = this._packer.createDeflate();

  this.readable = true;
};
util.inherits(PackerAsync, Stream);


PackerAsync.prototype.pack = function(data, width, height, gamma) {
  // Signature
  this.emit('data', new Buffer(constants.PNG_SIGNATURE));
  this.emit('data', this._packer.packIHDR(width, height));

  if (gamma) {
    this.emit('data', this._packer.packGAMA(gamma));
  }

  var filteredData = this._packer.filterData(data, width, height);

  // compress it
  this._deflate.on('error', this.emit.bind(this, 'error'));

  this._deflate.on('data', function(compressedData) {
    this.emit('data', this._packer.packIDAT(compressedData));
  }.bind(this));

  this._deflate.on('end', function() {
    this.emit('data', this._packer.packIEND());
    this.emit('end');
  }.bind(this));

  this._deflate.end(filteredData);
};


/***/ }),

/***/ "./node_modules/pngjs/lib/packer-sync.js":
/*!***********************************************!*\
  !*** ./node_modules/pngjs/lib/packer-sync.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasSyncZlib = true;
var zlib = __webpack_require__(/*! zlib */ "zlib");
if (!zlib.deflateSync) {
  hasSyncZlib = false;
}
var constants = __webpack_require__(/*! ./constants */ "./node_modules/pngjs/lib/constants.js");
var Packer = __webpack_require__(/*! ./packer */ "./node_modules/pngjs/lib/packer.js");

module.exports = function(metaData, opt) {

  if (!hasSyncZlib) {
    throw new Error('To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0');
  }

  var options = opt || {};

  var packer = new Packer(options);

  var chunks = [];

  // Signature
  chunks.push(new Buffer(constants.PNG_SIGNATURE));

  // Header
  chunks.push(packer.packIHDR(metaData.width, metaData.height));

  if (metaData.gamma) {
    chunks.push(packer.packGAMA(metaData.gamma));
  }

  var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);

  // compress it
  var compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
  filteredData = null;

  if (!compressedData || !compressedData.length) {
    throw new Error('bad png - invalid compressed data response');
  }
  chunks.push(packer.packIDAT(compressedData));

  // End
  chunks.push(packer.packIEND());

  return Buffer.concat(chunks);
};


/***/ }),

/***/ "./node_modules/pngjs/lib/packer.js":
/*!******************************************!*\
  !*** ./node_modules/pngjs/lib/packer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(/*! ./constants */ "./node_modules/pngjs/lib/constants.js");
var CrcStream = __webpack_require__(/*! ./crc */ "./node_modules/pngjs/lib/crc.js");
var bitPacker = __webpack_require__(/*! ./bitpacker */ "./node_modules/pngjs/lib/bitpacker.js");
var filter = __webpack_require__(/*! ./filter-pack */ "./node_modules/pngjs/lib/filter-pack.js");
var zlib = __webpack_require__(/*! zlib */ "zlib");

var Packer = module.exports = function(options) {
  this._options = options;

  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
  options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
  options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
  options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
  options.deflateFactory = options.deflateFactory || zlib.createDeflate;
  options.bitDepth = options.bitDepth || 8;
  // This is outputColorType
  options.colorType = (typeof options.colorType === 'number') ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
  options.inputColorType = (typeof options.inputColorType === 'number') ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;

  if ([
    constants.COLORTYPE_GRAYSCALE,
    constants.COLORTYPE_COLOR,
    constants.COLORTYPE_COLOR_ALPHA,
    constants.COLORTYPE_ALPHA
  ].indexOf(options.colorType) === -1) {
    throw new Error('option color type:' + options.colorType + ' is not supported at present');
  }
  if ([
    constants.COLORTYPE_GRAYSCALE,
    constants.COLORTYPE_COLOR,
    constants.COLORTYPE_COLOR_ALPHA,
    constants.COLORTYPE_ALPHA
  ].indexOf(options.inputColorType) === -1) {
    throw new Error('option input color type:' + options.inputColorType + ' is not supported at present');
  }
  if (options.bitDepth !== 8 && options.bitDepth !== 16) {
    throw new Error('option bit depth:' + options.bitDepth + ' is not supported at present');
  }
};

Packer.prototype.getDeflateOptions = function() {
  return {
    chunkSize: this._options.deflateChunkSize,
    level: this._options.deflateLevel,
    strategy: this._options.deflateStrategy
  };
};

Packer.prototype.createDeflate = function() {
  return this._options.deflateFactory(this.getDeflateOptions());
};

Packer.prototype.filterData = function(data, width, height) {
  // convert to correct format for filtering (e.g. right bpp and bit depth)
  var packedData = bitPacker(data, width, height, this._options);

  // filter pixel data
  var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
  var filteredData = filter(packedData, width, height, this._options, bpp);
  return filteredData;
};

Packer.prototype._packChunk = function(type, data) {

  var len = (data ? data.length : 0);
  var buf = new Buffer(len + 12);

  buf.writeUInt32BE(len, 0);
  buf.writeUInt32BE(type, 4);

  if (data) {
    data.copy(buf, 8);
  }

  buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
  return buf;
};

Packer.prototype.packGAMA = function(gamma) {
  var buf = new Buffer(4);
  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
  return this._packChunk(constants.TYPE_gAMA, buf);
};

Packer.prototype.packIHDR = function(width, height) {

  var buf = new Buffer(13);
  buf.writeUInt32BE(width, 0);
  buf.writeUInt32BE(height, 4);
  buf[8] = this._options.bitDepth; // Bit depth
  buf[9] = this._options.colorType; // colorType
  buf[10] = 0; // compression
  buf[11] = 0; // filter
  buf[12] = 0; // interlace

  return this._packChunk(constants.TYPE_IHDR, buf);
};

Packer.prototype.packIDAT = function(data) {
  return this._packChunk(constants.TYPE_IDAT, data);
};

Packer.prototype.packIEND = function() {
  return this._packChunk(constants.TYPE_IEND, null);
};


/***/ }),

/***/ "./node_modules/pngjs/lib/paeth-predictor.js":
/*!***************************************************!*\
  !*** ./node_modules/pngjs/lib/paeth-predictor.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function paethPredictor(left, above, upLeft) {

  var paeth = left + above - upLeft;
  var pLeft = Math.abs(paeth - left);
  var pAbove = Math.abs(paeth - above);
  var pUpLeft = Math.abs(paeth - upLeft);

  if (pLeft <= pAbove && pLeft <= pUpLeft) {
    return left;
  }
  if (pAbove <= pUpLeft) {
    return above;
  }
  return upLeft;
};

/***/ }),

/***/ "./node_modules/pngjs/lib/parser-async.js":
/*!************************************************!*\
  !*** ./node_modules/pngjs/lib/parser-async.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! util */ "util");
var zlib = __webpack_require__(/*! zlib */ "zlib");
var ChunkStream = __webpack_require__(/*! ./chunkstream */ "./node_modules/pngjs/lib/chunkstream.js");
var FilterAsync = __webpack_require__(/*! ./filter-parse-async */ "./node_modules/pngjs/lib/filter-parse-async.js");
var Parser = __webpack_require__(/*! ./parser */ "./node_modules/pngjs/lib/parser.js");
var bitmapper = __webpack_require__(/*! ./bitmapper */ "./node_modules/pngjs/lib/bitmapper.js");
var formatNormaliser = __webpack_require__(/*! ./format-normaliser */ "./node_modules/pngjs/lib/format-normaliser.js");

var ParserAsync = module.exports = function(options) {
  ChunkStream.call(this);

  this._parser = new Parser(options, {
    read: this.read.bind(this),
    error: this._handleError.bind(this),
    metadata: this._handleMetaData.bind(this),
    gamma: this.emit.bind(this, 'gamma'),
    palette: this._handlePalette.bind(this),
    transColor: this._handleTransColor.bind(this),
    finished: this._finished.bind(this),
    inflateData: this._inflateData.bind(this)
  });
  this._options = options;
  this.writable = true;

  this._parser.start();
};
util.inherits(ParserAsync, ChunkStream);


ParserAsync.prototype._handleError = function(err) {

  this.emit('error', err);

  this.writable = false;

  this.destroy();

  if (this._inflate && this._inflate.destroy) {
    this._inflate.destroy();
  }

  if (this._filter) {
    this._filter.destroy();
    // For backward compatibility with Node 7 and below.
    // Suppress errors due to _inflate calling write() even after
    // it's destroy()'ed.
    this._filter.on('error', function() {});
  }

  this.errord = true;
};

ParserAsync.prototype._inflateData = function(data) {
  if (!this._inflate) {
    if (this._bitmapInfo.interlace) {
      this._inflate = zlib.createInflate();

      this._inflate.on('error', this.emit.bind(this, 'error'));
      this._filter.on('complete', this._complete.bind(this));

      this._inflate.pipe(this._filter);
    } else {
      var rowSize = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7) >> 3) + 1;
      var imageSize = rowSize * this._bitmapInfo.height;
      var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
      
      this._inflate = zlib.createInflate({ chunkSize: chunkSize });
      var leftToInflate = imageSize;

      var emitError = this.emit.bind(this, 'error');
      this._inflate.on('error', function(err) {
        if (!leftToInflate) {
          return;
        }

        emitError(err);
      });
      this._filter.on('complete', this._complete.bind(this));

      var filterWrite = this._filter.write.bind(this._filter);
      this._inflate.on('data', function(chunk) {
        if (!leftToInflate) {
          return;
        }

        if (chunk.length > leftToInflate) {
          chunk = chunk.slice(0, leftToInflate);
        }

        leftToInflate -= chunk.length;

        filterWrite(chunk);
      });

      this._inflate.on('end', this._filter.end.bind(this._filter));
    }
  }
  this._inflate.write(data);
};

ParserAsync.prototype._handleMetaData = function(metaData) {

  this.emit('metadata', metaData);

  this._bitmapInfo = Object.create(metaData);

  this._filter = new FilterAsync(this._bitmapInfo);
};

ParserAsync.prototype._handleTransColor = function(transColor) {
  this._bitmapInfo.transColor = transColor;
};

ParserAsync.prototype._handlePalette = function(palette) {
  this._bitmapInfo.palette = palette;
};


ParserAsync.prototype._finished = function() {
  if (this.errord) {
    return;
  }

  if (!this._inflate) {
    this.emit('error', 'No Inflate block');
  }
  else {
    // no more data to inflate
    this._inflate.end();
  }
  this.destroySoon();
};

ParserAsync.prototype._complete = function(filteredData) {

  if (this.errord) {
    return;
  }

  try {
    var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);

    var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
    bitmapData = null;
  }
  catch (ex) {
    this._handleError(ex);
    return;
  }

  this.emit('parsed', normalisedBitmapData);
};


/***/ }),

/***/ "./node_modules/pngjs/lib/parser-sync.js":
/*!***********************************************!*\
  !*** ./node_modules/pngjs/lib/parser-sync.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasSyncZlib = true;
var zlib = __webpack_require__(/*! zlib */ "zlib");
var inflateSync = __webpack_require__(/*! ./sync-inflate */ "./node_modules/pngjs/lib/sync-inflate.js");
if (!zlib.deflateSync) {
  hasSyncZlib = false;
}
var SyncReader = __webpack_require__(/*! ./sync-reader */ "./node_modules/pngjs/lib/sync-reader.js");
var FilterSync = __webpack_require__(/*! ./filter-parse-sync */ "./node_modules/pngjs/lib/filter-parse-sync.js");
var Parser = __webpack_require__(/*! ./parser */ "./node_modules/pngjs/lib/parser.js");
var bitmapper = __webpack_require__(/*! ./bitmapper */ "./node_modules/pngjs/lib/bitmapper.js");
var formatNormaliser = __webpack_require__(/*! ./format-normaliser */ "./node_modules/pngjs/lib/format-normaliser.js");


module.exports = function(buffer, options) {

  if (!hasSyncZlib) {
    throw new Error('To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0');
  }

  var err;
  function handleError(_err_) {
    err = _err_;
  }

  var metaData;
  function handleMetaData(_metaData_) {
    metaData = _metaData_;
  }

  function handleTransColor(transColor) {
    metaData.transColor = transColor;
  }

  function handlePalette(palette) {
    metaData.palette = palette;
  }

  var gamma;
  function handleGamma(_gamma_) {
    gamma = _gamma_;
  }

  var inflateDataList = [];
  function handleInflateData(inflatedData) {
    inflateDataList.push(inflatedData);
  }

  var reader = new SyncReader(buffer);

  var parser = new Parser(options, {
    read: reader.read.bind(reader),
    error: handleError,
    metadata: handleMetaData,
    gamma: handleGamma,
    palette: handlePalette,
    transColor: handleTransColor,
    inflateData: handleInflateData
  });

  parser.start();
  reader.process();

  if (err) {
    throw err;
  }

  //join together the inflate datas
  var inflateData = Buffer.concat(inflateDataList);
  inflateDataList.length = 0;

  var inflatedData;
  if (metaData.interlace) {
    inflatedData = zlib.inflateSync(inflateData);
  } else {
    var rowSize = ((metaData.width * metaData.bpp * metaData.depth + 7) >> 3) + 1;
    var imageSize = rowSize * metaData.height;
    inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });
  }
  inflateData = null;

  if (!inflatedData || !inflatedData.length) {
    throw new Error('bad png - invalid inflate data response');
  }

  var unfilteredData = FilterSync.process(inflatedData, metaData);
  inflateData = null;

  var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
  unfilteredData = null;

  var normalisedBitmapData = formatNormaliser(bitmapData, metaData);

  metaData.data = normalisedBitmapData;
  metaData.gamma = gamma || 0;

  return metaData;
};


/***/ }),

/***/ "./node_modules/pngjs/lib/parser.js":
/*!******************************************!*\
  !*** ./node_modules/pngjs/lib/parser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(/*! ./constants */ "./node_modules/pngjs/lib/constants.js");
var CrcCalculator = __webpack_require__(/*! ./crc */ "./node_modules/pngjs/lib/crc.js");


var Parser = module.exports = function(options, dependencies) {

  this._options = options;
  options.checkCRC = options.checkCRC !== false;

  this._hasIHDR = false;
  this._hasIEND = false;

  // input flags/metadata
  this._palette = [];
  this._colorType = 0;

  this._chunks = {};
  this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
  this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
  this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
  this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
  this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
  this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);

  this.read = dependencies.read;
  this.error = dependencies.error;
  this.metadata = dependencies.metadata;
  this.gamma = dependencies.gamma;
  this.transColor = dependencies.transColor;
  this.palette = dependencies.palette;
  this.parsed = dependencies.parsed;
  this.inflateData = dependencies.inflateData;
  this.finished = dependencies.finished;
};

Parser.prototype.start = function() {
  this.read(constants.PNG_SIGNATURE.length,
    this._parseSignature.bind(this)
  );
};

Parser.prototype._parseSignature = function(data) {

  var signature = constants.PNG_SIGNATURE;

  for (var i = 0; i < signature.length; i++) {
    if (data[i] !== signature[i]) {
      this.error(new Error('Invalid file signature'));
      return;
    }
  }
  this.read(8, this._parseChunkBegin.bind(this));
};

Parser.prototype._parseChunkBegin = function(data) {

  // chunk content length
  var length = data.readUInt32BE(0);

  // chunk type
  var type = data.readUInt32BE(4);
  var name = '';
  for (var i = 4; i < 8; i++) {
    name += String.fromCharCode(data[i]);
  }

  //console.log('chunk ', name, length);

  // chunk flags
  var ancillary = Boolean(data[4] & 0x20); // or critical
//    priv = Boolean(data[5] & 0x20), // or public
//    safeToCopy = Boolean(data[7] & 0x20); // or unsafe

  if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
    this.error(new Error('Expected IHDR on beggining'));
    return;
  }

  this._crc = new CrcCalculator();
  this._crc.write(new Buffer(name));

  if (this._chunks[type]) {
    return this._chunks[type](length);
  }

  if (!ancillary) {
    this.error(new Error('Unsupported critical chunk type ' + name));
    return;
  }

  this.read(length + 4, this._skipChunk.bind(this));
};

Parser.prototype._skipChunk = function(/*data*/) {
  this.read(8, this._parseChunkBegin.bind(this));
};

Parser.prototype._handleChunkEnd = function() {
  this.read(4, this._parseChunkEnd.bind(this));
};

Parser.prototype._parseChunkEnd = function(data) {

  var fileCrc = data.readInt32BE(0);
  var calcCrc = this._crc.crc32();

  // check CRC
  if (this._options.checkCRC && calcCrc !== fileCrc) {
    this.error(new Error('Crc error - ' + fileCrc + ' - ' + calcCrc));
    return;
  }

  if (!this._hasIEND) {
    this.read(8, this._parseChunkBegin.bind(this));
  }
};

Parser.prototype._handleIHDR = function(length) {
  this.read(length, this._parseIHDR.bind(this));
};
Parser.prototype._parseIHDR = function(data) {

  this._crc.write(data);

  var width = data.readUInt32BE(0);
  var height = data.readUInt32BE(4);
  var depth = data[8];
  var colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha
  var compr = data[10];
  var filter = data[11];
  var interlace = data[12];

  // console.log('    width', width, 'height', height,
  //     'depth', depth, 'colorType', colorType,
  //     'compr', compr, 'filter', filter, 'interlace', interlace
  // );

  if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
    this.error(new Error('Unsupported bit depth ' + depth));
    return;
  }
  if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
    this.error(new Error('Unsupported color type'));
    return;
  }
  if (compr !== 0) {
    this.error(new Error('Unsupported compression method'));
    return;
  }
  if (filter !== 0) {
    this.error(new Error('Unsupported filter method'));
    return;
  }
  if (interlace !== 0 && interlace !== 1) {
    this.error(new Error('Unsupported interlace method'));
    return;
  }

  this._colorType = colorType;

  var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];

  this._hasIHDR = true;

  this.metadata({
    width: width,
    height: height,
    depth: depth,
    interlace: Boolean(interlace),
    palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
    color: Boolean(colorType & constants.COLORTYPE_COLOR),
    alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
    bpp: bpp,
    colorType: colorType
  });

  this._handleChunkEnd();
};


Parser.prototype._handlePLTE = function(length) {
  this.read(length, this._parsePLTE.bind(this));
};
Parser.prototype._parsePLTE = function(data) {

  this._crc.write(data);

  var entries = Math.floor(data.length / 3);
  // console.log('Palette:', entries);

  for (var i = 0; i < entries; i++) {
    this._palette.push([
      data[i * 3],
      data[i * 3 + 1],
      data[i * 3 + 2],
      0xff
    ]);
  }

  this.palette(this._palette);

  this._handleChunkEnd();
};

Parser.prototype._handleTRNS = function(length) {
  this.read(length, this._parseTRNS.bind(this));
};
Parser.prototype._parseTRNS = function(data) {

  this._crc.write(data);

  // palette
  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
    if (this._palette.length === 0) {
      this.error(new Error('Transparency chunk must be after palette'));
      return;
    }
    if (data.length > this._palette.length) {
      this.error(new Error('More transparent colors than palette size'));
      return;
    }
    for (var i = 0; i < data.length; i++) {
      this._palette[i][3] = data[i];
    }
    this.palette(this._palette);
  }

  // for colorType 0 (grayscale) and 2 (rgb)
  // there might be one gray/color defined as transparent
  if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
    // grey, 2 bytes
    this.transColor([data.readUInt16BE(0)]);
  }
  if (this._colorType === constants.COLORTYPE_COLOR) {
    this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
  }

  this._handleChunkEnd();
};

Parser.prototype._handleGAMA = function(length) {
  this.read(length, this._parseGAMA.bind(this));
};
Parser.prototype._parseGAMA = function(data) {

  this._crc.write(data);
  this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);

  this._handleChunkEnd();
};

Parser.prototype._handleIDAT = function(length) {
  this.read(-length, this._parseIDAT.bind(this, length));
};
Parser.prototype._parseIDAT = function(length, data) {

  this._crc.write(data);

  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
    throw new Error('Expected palette not found');
  }

  this.inflateData(data);
  var leftOverLength = length - data.length;

  if (leftOverLength > 0) {
    this._handleIDAT(leftOverLength);
  }
  else {
    this._handleChunkEnd();
  }
};

Parser.prototype._handleIEND = function(length) {
  this.read(length, this._parseIEND.bind(this));
};
Parser.prototype._parseIEND = function(data) {

  this._crc.write(data);

  this._hasIEND = true;
  this._handleChunkEnd();

  if (this.finished) {
    this.finished();
  }
};


/***/ }),

/***/ "./node_modules/pngjs/lib/png-sync.js":
/*!********************************************!*\
  !*** ./node_modules/pngjs/lib/png-sync.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var parse = __webpack_require__(/*! ./parser-sync */ "./node_modules/pngjs/lib/parser-sync.js");
var pack = __webpack_require__(/*! ./packer-sync */ "./node_modules/pngjs/lib/packer-sync.js");


exports.read = function(buffer, options) {

  return parse(buffer, options || {});
};

exports.write = function(png, options) {

  return pack(png, options);
};


/***/ }),

/***/ "./node_modules/pngjs/lib/png.js":
/*!***************************************!*\
  !*** ./node_modules/pngjs/lib/png.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! util */ "util");
var Stream = __webpack_require__(/*! stream */ "stream");
var Parser = __webpack_require__(/*! ./parser-async */ "./node_modules/pngjs/lib/parser-async.js");
var Packer = __webpack_require__(/*! ./packer-async */ "./node_modules/pngjs/lib/packer-async.js");
var PNGSync = __webpack_require__(/*! ./png-sync */ "./node_modules/pngjs/lib/png-sync.js");


var PNG = exports.PNG = function(options) {
  Stream.call(this);

  options = options || {}; // eslint-disable-line no-param-reassign

  // coerce pixel dimensions to integers (also coerces undefined -> 0):
  this.width = options.width | 0;
  this.height = options.height | 0;

  this.data = this.width > 0 && this.height > 0 ?
    new Buffer(4 * this.width * this.height) : null;

  if (options.fill && this.data) {
    this.data.fill(0);
  }

  this.gamma = 0;
  this.readable = this.writable = true;

  this._parser = new Parser(options);

  this._parser.on('error', this.emit.bind(this, 'error'));
  this._parser.on('close', this._handleClose.bind(this));
  this._parser.on('metadata', this._metadata.bind(this));
  this._parser.on('gamma', this._gamma.bind(this));
  this._parser.on('parsed', function(data) {
    this.data = data;
    this.emit('parsed', data);
  }.bind(this));

  this._packer = new Packer(options);
  this._packer.on('data', this.emit.bind(this, 'data'));
  this._packer.on('end', this.emit.bind(this, 'end'));
  this._parser.on('close', this._handleClose.bind(this));
  this._packer.on('error', this.emit.bind(this, 'error'));

};
util.inherits(PNG, Stream);

PNG.sync = PNGSync;

PNG.prototype.pack = function() {

  if (!this.data || !this.data.length) {
    this.emit('error', 'No data provided');
    return this;
  }

  process.nextTick(function() {
    this._packer.pack(this.data, this.width, this.height, this.gamma);
  }.bind(this));

  return this;
};


PNG.prototype.parse = function(data, callback) {

  if (callback) {
    var onParsed, onError;

    onParsed = function(parsedData) {
      this.removeListener('error', onError);

      this.data = parsedData;
      callback(null, this);
    }.bind(this);

    onError = function(err) {
      this.removeListener('parsed', onParsed);

      callback(err, null);
    }.bind(this);

    this.once('parsed', onParsed);
    this.once('error', onError);
  }

  this.end(data);
  return this;
};

PNG.prototype.write = function(data) {
  this._parser.write(data);
  return true;
};

PNG.prototype.end = function(data) {
  this._parser.end(data);
};

PNG.prototype._metadata = function(metadata) {
  this.width = metadata.width;
  this.height = metadata.height;

  this.emit('metadata', metadata);
};

PNG.prototype._gamma = function(gamma) {
  this.gamma = gamma;
};

PNG.prototype._handleClose = function() {
  if (!this._parser.writable && !this._packer.readable) {
    this.emit('close');
  }
};


PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params
  // coerce pixel dimensions to integers (also coerces undefined -> 0):
  /* eslint-disable no-param-reassign */
  srcX |= 0;
  srcY |= 0;
  width |= 0;
  height |= 0;
  deltaX |= 0;
  deltaY |= 0;
  /* eslint-enable no-param-reassign */

  if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
    throw new Error('bitblt reading outside image');
  }

  if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
    throw new Error('bitblt writing outside image');
  }

  for (var y = 0; y < height; y++) {
    src.data.copy(dst.data,
      ((deltaY + y) * dst.width + deltaX) << 2,
      ((srcY + y) * src.width + srcX) << 2,
      ((srcY + y) * src.width + srcX + width) << 2
    );
  }
};


PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params

  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
  return this;
};

PNG.adjustGamma = function(src) {
  if (src.gamma) {
    for (var y = 0; y < src.height; y++) {
      for (var x = 0; x < src.width; x++) {
        var idx = (src.width * y + x) << 2;

        for (var i = 0; i < 3; i++) {
          var sample = src.data[idx + i] / 255;
          sample = Math.pow(sample, 1 / 2.2 / src.gamma);
          src.data[idx + i] = Math.round(sample * 255);
        }
      }
    }
    src.gamma = 0;
  }
};

PNG.prototype.adjustGamma = function() {
  PNG.adjustGamma(this);
};


/***/ }),

/***/ "./node_modules/pngjs/lib/sync-inflate.js":
/*!************************************************!*\
  !*** ./node_modules/pngjs/lib/sync-inflate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! assert */ "assert").ok;
var zlib = __webpack_require__(/*! zlib */ "zlib");
var util = __webpack_require__(/*! util */ "util");

var kMaxLength = __webpack_require__(/*! buffer */ "buffer").kMaxLength;

function Inflate(opts) {
  if (!(this instanceof Inflate)) {
    return new Inflate(opts);
  }

  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
    opts.chunkSize = zlib.Z_MIN_CHUNK;
  }

  zlib.Inflate.call(this, opts);

  // Node 8 --> 9 compatibility check
  this._offset = this._offset === undefined ? this._outOffset : this._offset;
  this._buffer = this._buffer || this._outBuffer;

  if (opts && opts.maxLength != null) {
    this._maxLength = opts.maxLength;
  }
}

function createInflate(opts) {
  return new Inflate(opts);
}

function _close(engine, callback) {
  if (callback) {
    process.nextTick(callback);
  }

  // Caller may invoke .close after a zlib error (which will null _handle).
  if (!engine._handle) {
    return;
  }

  engine._handle.close();
  engine._handle = null;
}

Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
  if (typeof asyncCb === 'function') {
    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
  }

  var self = this;

  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var leftToInflate = this._maxLength;
  var inOff = 0;

  var buffers = [];
  var nread = 0;

  var error;
  this.on('error', function(err) {
    error = err;
  });

  function handleChunk(availInAfter, availOutAfter) {
    if (self._hadError) {
      return;
    }

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;

      if (out.length > leftToInflate) {
        out = out.slice(0, leftToInflate);
      }

      buffers.push(out);
      nread += out.length;
      leftToInflate -= out.length;

      if (leftToInflate === 0) {
        return false;
      }
    }

    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      return true;
    }

    return false;
  }

  assert(this._handle, 'zlib binding closed');
  do {
    var res = this._handle.writeSync(flushFlag,
                                     chunk, // in
                                     inOff, // in_off
                                     availInBefore, // in_len
                                     this._buffer, // out
                                     this._offset, //out_off
                                     availOutBefore); // out_len
    // Node 8 --> 9 compatibility check
    res = res || this._writeState;
  } while (!this._hadError && handleChunk(res[0], res[1]));

  if (this._hadError) {
    throw error;
  }

  if (nread >= kMaxLength) {
    _close(this);
    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');
  }

  var buf = Buffer.concat(buffers, nread);
  _close(this);

  return buf;
};

util.inherits(Inflate, zlib.Inflate);

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer);
  }
  if (!(buffer instanceof Buffer)) {
    throw new TypeError('Not a string or buffer');
  }

  var flushFlag = engine._finishFlushFlag;
  if (flushFlag == null) {
    flushFlag = zlib.Z_FINISH;
  }

  return engine._processChunk(buffer, flushFlag);
}

function inflateSync(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
}

module.exports = exports = inflateSync;
exports.Inflate = Inflate;
exports.createInflate = createInflate;
exports.inflateSync = inflateSync;


/***/ }),

/***/ "./node_modules/pngjs/lib/sync-reader.js":
/*!***********************************************!*\
  !*** ./node_modules/pngjs/lib/sync-reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SyncReader = module.exports = function(buffer) {

  this._buffer = buffer;
  this._reads = [];
};

SyncReader.prototype.read = function(length, callback) {

  this._reads.push({
    length: Math.abs(length),  // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback
  });
};

SyncReader.prototype.process = function() {

  // as long as there is any data and read requests
  while (this._reads.length > 0 && this._buffer.length) {

    var read = this._reads[0];

    if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {

      // ok there is any data so that we can satisfy this request
      this._reads.shift(); // == read

      var buf = this._buffer;

      this._buffer = buf.slice(read.length);

      read.func.call(this, buf.slice(0, read.length));

    }
    else {
      break;
    }

  }

  if (this._reads.length > 0) {
    return new Error('There are some read requests waitng on finished stream');
  }

  if (this._buffer.length > 0) {
    return new Error('unrecognised content at end of stream');
  }

};


/***/ }),

/***/ "./node_modules/timm/lib/timm.js":
/*!***************************************!*\
  !*** ./node_modules/timm/lib/timm.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.clone = clone;
exports.addLast = addLast;
exports.addFirst = addFirst;
exports.removeLast = removeLast;
exports.removeFirst = removeFirst;
exports.insert = insert;
exports.removeAt = removeAt;
exports.replaceAt = replaceAt;
exports.getIn = getIn;
exports.set = set;
exports.setIn = setIn;
exports.update = update;
exports.updateIn = updateIn;
exports.merge = merge;
exports.mergeDeep = mergeDeep;
exports.mergeIn = mergeIn;
exports.omit = omit;
exports.addDefaults = addDefaults;


/*!
 * Timm
 *
 * Immutability helpers with fast reads and acceptable writes.
 *
 * @copyright Guillermo Grau Panea 2016
 * @license MIT
 */

var INVALID_ARGS = 'INVALID_ARGS';

// ===============================================
// ### Helpers
// ===============================================


function throwStr(msg) {
  throw new Error(msg);
}

function getKeysAndSymbols(obj) {
  var keys = Object.keys(obj);
  if (Object.getOwnPropertySymbols) {
    return keys.concat(Object.getOwnPropertySymbols(obj));
  }
  return keys;
}

var hasOwnProperty = {}.hasOwnProperty;

function clone(obj) {
  if (Array.isArray(obj)) return obj.slice();
  var keys = getKeysAndSymbols(obj);
  var out = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    out[key] = obj[key];
  }
  return out;
}

function doMerge(fAddDefaults, fDeep, first) {
  var out = first;
  !(out != null) && throwStr( true ? 'At least one object should be provided to merge()' : undefined);
  var fChanged = false;

  for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    rest[_key - 3] = arguments[_key];
  }

  for (var idx = 0; idx < rest.length; idx++) {
    var obj = rest[idx];
    if (obj == null) continue;
    var keys = getKeysAndSymbols(obj);
    if (!keys.length) continue;
    for (var j = 0; j <= keys.length; j++) {
      var key = keys[j];
      if (fAddDefaults && out[key] !== undefined) continue;
      var nextVal = obj[key];
      if (fDeep && isObject(out[key]) && isObject(nextVal)) {
        nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);
      }
      if (nextVal === undefined || nextVal === out[key]) continue;
      if (!fChanged) {
        fChanged = true;
        out = clone(out);
      }
      out[key] = nextVal;
    }
  }
  return out;
}

function isObject(o) {
  var type = typeof o === 'undefined' ? 'undefined' : _typeof(o);
  return o != null && type === 'object';
}

// _deepFreeze = (obj) ->
//   Object.freeze obj
//   for key in Object.getOwnPropertyNames obj
//     val = obj[key]
//     if isObject(val) and not Object.isFrozen val
//       _deepFreeze val
//   obj

// ===============================================
// -- ### Arrays
// ===============================================

// -- #### addLast()
// -- Returns a new array with an appended item or items.
// --
// -- Usage: `addLast<T>(array: Array<T>, val: Array<T>|T): Array<T>`
// --
// -- ```js
// -- arr = ['a', 'b']
// -- arr2 = addLast(arr, 'c')
// -- // ['a', 'b', 'c']
// -- arr2 === arr
// -- // false
// -- arr3 = addLast(arr, ['c', 'd'])
// -- // ['a', 'b', 'c', 'd']
// -- ```
// `array.concat(val)` also handles the scalar case,
// but is apparently very slow
function addLast(array, val) {
  if (Array.isArray(val)) return array.concat(val);
  return array.concat([val]);
}

// -- #### addFirst()
// -- Returns a new array with a prepended item or items.
// --
// -- Usage: `addFirst<T>(array: Array<T>, val: Array<T>|T): Array<T>`
// --
// -- ```js
// -- arr = ['a', 'b']
// -- arr2 = addFirst(arr, 'c')
// -- // ['c', 'a', 'b']
// -- arr2 === arr
// -- // false
// -- arr3 = addFirst(arr, ['c', 'd'])
// -- // ['c', 'd', 'a', 'b']
// -- ```
function addFirst(array, val) {
  if (Array.isArray(val)) return val.concat(array);
  return [val].concat(array);
}

// -- #### removeLast()
// -- Returns a new array removing the last item.
// --
// -- Usage: `removeLast<T>(array: Array<T>): Array<T>`
// --
// -- ```js
// -- arr = ['a', 'b']
// -- arr2 = removeLast(arr)
// -- // ['a']
// -- arr2 === arr
// -- // false
// --
// -- // The same array is returned if there are no changes:
// -- arr3 = []
// -- removeLast(arr3) === arr3
// -- // true
// -- ```
function removeLast(array) {
  if (!array.length) return array;
  return array.slice(0, array.length - 1);
}

// -- #### removeFirst()
// -- Returns a new array removing the first item.
// --
// -- Usage: `removeFirst<T>(array: Array<T>): Array<T>`
// --
// -- ```js
// -- arr = ['a', 'b']
// -- arr2 = removeFirst(arr)
// -- // ['b']
// -- arr2 === arr
// -- // false
// --
// -- // The same array is returned if there are no changes:
// -- arr3 = []
// -- removeFirst(arr3) === arr3
// -- // true
// -- ```
function removeFirst(array) {
  if (!array.length) return array;
  return array.slice(1);
}

// -- #### insert()
// -- Returns a new array obtained by inserting an item or items
// -- at a specified index.
// --
// -- Usage: `insert<T>(array: Array<T>, idx: number, val: Array<T>|T): Array<T>`
// --
// -- ```js
// -- arr = ['a', 'b', 'c']
// -- arr2 = insert(arr, 1, 'd')
// -- // ['a', 'd', 'b', 'c']
// -- arr2 === arr
// -- // false
// -- insert(arr, 1, ['d', 'e'])
// -- // ['a', 'd', 'e', 'b', 'c']
// -- ```
function insert(array, idx, val) {
  return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));
}

// -- #### removeAt()
// -- Returns a new array obtained by removing an item at
// -- a specified index.
// --
// -- Usage: `removeAt<T>(array: Array<T>, idx: number): Array<T>`
// --
// -- ```js
// -- arr = ['a', 'b', 'c']
// -- arr2 = removeAt(arr, 1)
// -- // ['a', 'c']
// -- arr2 === arr
// -- // false
// --
// -- // The same array is returned if there are no changes:
// -- removeAt(arr, 4) === arr
// -- // true
// -- ```
function removeAt(array, idx) {
  if (idx >= array.length || idx < 0) return array;
  return array.slice(0, idx).concat(array.slice(idx + 1));
}

// -- #### replaceAt()
// -- Returns a new array obtained by replacing an item at
// -- a specified index. If the provided item is the same as
// -- (*referentially equal to*) the previous item at that position,
// -- the original array is returned.
// --
// -- Usage: `replaceAt<T>(array: Array<T>, idx: number, newItem: T): Array<T>`
// --
// -- ```js
// -- arr = ['a', 'b', 'c']
// -- arr2 = replaceAt(arr, 1, 'd')
// -- // ['a', 'd', 'c']
// -- arr2 === arr
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- replaceAt(arr, 1, 'b') === arr
// -- // true
// -- ```
function replaceAt(array, idx, newItem) {
  if (array[idx] === newItem) return array;
  var len = array.length;
  var result = Array(len);
  for (var i = 0; i < len; i++) {
    result[i] = array[i];
  }
  result[idx] = newItem;
  return result;
}

// ===============================================
// -- ### Collections (objects and arrays)
// ===============================================
// -- The following types are used throughout this section
// -- ```js
// -- type ArrayOrObject = Array<any>|Object;
// -- type Key = number|string;
// -- ```

// -- #### getIn()
// -- Returns a value from an object at a given path. Works with
// -- nested arrays and objects. If the path does not exist, it returns
// -- `undefined`.
// --
// -- Usage: `getIn(obj: ?ArrayOrObject, path: Array<Key>): any`
// --
// -- ```js
// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }
// -- getIn(obj, ['d', 'd1'])
// -- // 3
// -- getIn(obj, ['e', 1])
// -- // 'b'
// -- ```
function getIn(obj, path) {
  !Array.isArray(path) && throwStr( true ? 'A path array should be provided when calling getIn()' : undefined);
  if (obj == null) return undefined;
  var ptr = obj;
  for (var i = 0; i < path.length; i++) {
    var key = path[i];
    ptr = ptr != null ? ptr[key] : undefined;
    if (ptr === undefined) return ptr;
  }
  return ptr;
}

// -- #### set()
// -- Returns a new object with a modified attribute.
// -- If the provided value is the same as (*referentially equal to*)
// -- the previous value, the original object is returned.
// --
// -- Usage: `set<T>(obj: ?T, key: Key, val: any): T`
// --
// -- ```js
// -- obj = { a: 1, b: 2, c: 3 }
// -- obj2 = set(obj, 'b', 5)
// -- // { a: 1, b: 5, c: 3 }
// -- obj2 === obj
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- set(obj, 'b', 2) === obj
// -- // true
// -- ```
function set(obj, key, val) {
  var fallback = typeof key === 'number' ? [] : {};
  var finalObj = obj == null ? fallback : obj;
  if (finalObj[key] === val) return finalObj;
  var obj2 = clone(finalObj);
  obj2[key] = val;
  return obj2;
}

// -- #### setIn()
// -- Returns a new object with a modified **nested** attribute.
// --
// -- Notes:
// --
// -- * If the provided value is the same as (*referentially equal to*)
// -- the previous value, the original object is returned.
// -- * If the path does not exist, it will be created before setting
// -- the new value.
// --
// -- Usage: `setIn<T: ArrayOrObject>(obj: T, path: Array<Key>, val: any): T`
// --
// -- ```js
// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }
// -- obj2 = setIn(obj, ['d', 'd1'], 4)
// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }
// -- obj2 === obj
// -- // false
// -- obj2.d === obj.d
// -- // false
// -- obj2.e === obj.e
// -- // true
// --
// -- // The same object is returned if there are no changes:
// -- obj3 = setIn(obj, ['d', 'd1'], 3)
// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }
// -- obj3 === obj
// -- // true
// -- obj3.d === obj.d
// -- // true
// -- obj3.e === obj.e
// -- // true
// --
// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:
// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)
// -- // { a: 3, unknown: [{ path: 4 }] }
// -- ```
function doSetIn(obj, path, val, idx) {
  var newValue = void 0;
  var key = path[idx];
  if (idx === path.length - 1) {
    newValue = val;
  } else {
    var nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === 'number' ? [] : {};
    newValue = doSetIn(nestedObj, path, val, idx + 1);
  }
  return set(obj, key, newValue);
}

function setIn(obj, path, val) {
  if (!path.length) return val;
  return doSetIn(obj, path, val, 0);
}

// -- #### update()
// -- Returns a new object with a modified attribute,
// -- calculated via a user-provided callback based on the current value.
// -- If the calculated value is the same as (*referentially equal to*)
// -- the previous value, the original object is returned.
// --
// -- Usage: `update<T: ArrayOrObject>(obj: T, key: Key,
// -- fnUpdate: (prevValue: any) => any): T`
// --
// -- ```js
// -- obj = { a: 1, b: 2, c: 3 }
// -- obj2 = update(obj, 'b', (val) => val + 1)
// -- // { a: 1, b: 3, c: 3 }
// -- obj2 === obj
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- update(obj, 'b', (val) => val) === obj
// -- // true
// -- ```
function update(obj, key, fnUpdate) {
  var prevVal = obj == null ? undefined : obj[key];
  var nextVal = fnUpdate(prevVal);
  return set(obj, key, nextVal);
}

// -- #### updateIn()
// -- Returns a new object with a modified **nested** attribute,
// -- calculated via a user-provided callback based on the current value.
// -- If the calculated value is the same as (*referentially equal to*)
// -- the previous value, the original object is returned.
// --
// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,
// -- fnUpdate: (prevValue: any) => any): T`
// --
// -- ```js
// -- obj = { a: 1, d: { d1: 3, d2: 4 } }
// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)
// -- // { a: 1, d: { d1: 4, d2: 4 } }
// -- obj2 === obj
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)
// -- // { a: 1, d: { d1: 3, d2: 4 } }
// -- obj3 === obj
// -- // true
// -- ```
function updateIn(obj, path, fnUpdate) {
  var prevVal = getIn(obj, path);
  var nextVal = fnUpdate(prevVal);
  return setIn(obj, path, nextVal);
}

// -- #### merge()
// -- Returns a new object built as follows: the overlapping keys from the
// -- second one overwrite the corresponding entries from the first one.
// -- Similar to `Object.assign()`, but immutable.
// --
// -- Usage:
// --
// -- * `merge(obj1: Object, obj2: ?Object): Object`
// -- * `merge(obj1: Object, ...objects: Array<?Object>): Object`
// --
// -- The unmodified `obj1` is returned if `obj2` does not *provide something
// -- new to* `obj1`, i.e. if either of the following
// -- conditions are true:
// --
// -- * `obj2` is `null` or `undefined`
// -- * `obj2` is an object, but it is empty
// -- * All attributes of `obj2` are `undefined`
// -- * All attributes of `obj2` are referentially equal to the
// --   corresponding attributes of `obj1`
// --
// -- Note that `undefined` attributes in `obj2` do not modify the
// -- corresponding attributes in `obj1`.
// --
// -- ```js
// -- obj1 = { a: 1, b: 2, c: 3 }
// -- obj2 = { c: 4, d: 5 }
// -- obj3 = merge(obj1, obj2)
// -- // { a: 1, b: 2, c: 4, d: 5 }
// -- obj3 === obj1
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- merge(obj1, { c: 3 }) === obj1
// -- // true
// -- ```
function merge(a, b, c, d, e, f) {
  for (var _len2 = arguments.length, rest = Array(_len2 > 6 ? _len2 - 6 : 0), _key2 = 6; _key2 < _len2; _key2++) {
    rest[_key2 - 6] = arguments[_key2];
  }

  return rest.length ? doMerge.call.apply(doMerge, [null, false, false, a, b, c, d, e, f].concat(rest)) : doMerge(false, false, a, b, c, d, e, f);
}

// -- #### mergeDeep()
// -- Returns a new object built as follows: the overlapping keys from the
// -- second one overwrite the corresponding entries from the first one.
// -- If both the first and second entries are objects they are merged recursively.
// -- Similar to `Object.assign()`, but immutable, and deeply merging.
// --
// -- Usage:
// --
// -- * `mergeDeep(obj1: Object, obj2: ?Object): Object`
// -- * `mergeDeep(obj1: Object, ...objects: Array<?Object>): Object`
// --
// -- The unmodified `obj1` is returned if `obj2` does not *provide something
// -- new to* `obj1`, i.e. if either of the following
// -- conditions are true:
// --
// -- * `obj2` is `null` or `undefined`
// -- * `obj2` is an object, but it is empty
// -- * All attributes of `obj2` are `undefined`
// -- * All attributes of `obj2` are referentially equal to the
// --   corresponding attributes of `obj1`
// --
// -- Note that `undefined` attributes in `obj2` do not modify the
// -- corresponding attributes in `obj1`.
// --
// -- ```js
// -- obj1 = { a: 1, b: 2, c: { a: 1 } }
// -- obj2 = { b: 3, c: { b: 2 } }
// -- obj3 = mergeDeep(obj1, obj2)
// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }
// -- obj3 === obj1
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1
// -- // true
// -- ```
function mergeDeep(a, b, c, d, e, f) {
  for (var _len3 = arguments.length, rest = Array(_len3 > 6 ? _len3 - 6 : 0), _key3 = 6; _key3 < _len3; _key3++) {
    rest[_key3 - 6] = arguments[_key3];
  }

  return rest.length ? doMerge.call.apply(doMerge, [null, false, true, a, b, c, d, e, f].concat(rest)) : doMerge(false, true, a, b, c, d, e, f);
}

// -- #### mergeIn()
// -- Similar to `merge()`, but merging the value at a given nested path.
// -- Note that the returned type is the same as that of the first argument.
// --
// -- Usage:
// --
// -- * `mergeIn<T: ArrayOrObject>(obj1: T, path: Array<Key>, obj2: ?Object): T`
// -- * `mergeIn<T: ArrayOrObject>(obj1: T, path: Array<Key>,
// -- ...objects: Array<?Object>): T`
// --
// -- ```js
// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }
// -- obj2 = { d3: 5 }
// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)
// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }
// -- obj3 === obj1
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1
// -- // true
// -- ```
function mergeIn(a, path, b, c, d, e, f) {
  var prevVal = getIn(a, path);
  if (prevVal == null) prevVal = {};
  var nextVal = void 0;

  for (var _len4 = arguments.length, rest = Array(_len4 > 7 ? _len4 - 7 : 0), _key4 = 7; _key4 < _len4; _key4++) {
    rest[_key4 - 7] = arguments[_key4];
  }

  if (rest.length) {
    nextVal = doMerge.call.apply(doMerge, [null, false, false, prevVal, b, c, d, e, f].concat(rest));
  } else {
    nextVal = doMerge(false, false, prevVal, b, c, d, e, f);
  }
  return setIn(a, path, nextVal);
}

// -- #### omit()
// -- Returns an object excluding one or several attributes.
// --
// -- Usage: `omit(obj: Object, attrs: Array<string>|string): Object`
//
// -- ```js
// -- obj = { a: 1, b: 2, c: 3, d: 4 }
// -- omit(obj, 'a')
// -- // { b: 2, c: 3, d: 4 }
// -- omit(obj, ['b', 'c'])
// -- // { a: 1, d: 4 }
// --
// -- // The same object is returned if there are no changes:
// -- omit(obj, 'z') === obj1
// -- // true
// -- ```
function omit(obj, attrs) {
  var omitList = Array.isArray(attrs) ? attrs : [attrs];
  var fDoSomething = false;
  for (var i = 0; i < omitList.length; i++) {
    if (hasOwnProperty.call(obj, omitList[i])) {
      fDoSomething = true;
      break;
    }
  }
  if (!fDoSomething) return obj;
  var out = {};
  var keys = getKeysAndSymbols(obj);
  for (var _i = 0; _i < keys.length; _i++) {
    var key = keys[_i];
    if (omitList.indexOf(key) >= 0) continue;
    out[key] = obj[key];
  }
  return out;
}

// -- #### addDefaults()
// -- Returns a new object built as follows: `undefined` keys in the first one
// -- are filled in with the corresponding values from the second one
// -- (even if they are `null`).
// --
// -- Usage:
// --
// -- * `addDefaults(obj: Object, defaults: Object): Object`
// -- * `addDefaults(obj: Object, ...defaultObjects: Array<?Object>): Object`
// --
// -- ```js
// -- obj1 = { a: 1, b: 2, c: 3 }
// -- obj2 = { c: 4, d: 5, e: null }
// -- obj3 = addDefaults(obj1, obj2)
// -- // { a: 1, b: 2, c: 3, d: 5, e: null }
// -- obj3 === obj1
// -- // false
// --
// -- // The same object is returned if there are no changes:
// -- addDefaults(obj1, { c: 4 }) === obj1
// -- // true
// -- ```
function addDefaults(a, b, c, d, e, f) {
  for (var _len5 = arguments.length, rest = Array(_len5 > 6 ? _len5 - 6 : 0), _key5 = 6; _key5 < _len5; _key5++) {
    rest[_key5 - 6] = arguments[_key5];
  }

  return rest.length ? doMerge.call.apply(doMerge, [null, true, false, a, b, c, d, e, f].concat(rest)) : doMerge(true, false, a, b, c, d, e, f);
}

// ===============================================
// ### Public API
// ===============================================
var timm = {
  clone: clone,
  addLast: addLast,
  addFirst: addFirst,
  removeLast: removeLast,
  removeFirst: removeFirst,
  insert: insert,
  removeAt: removeAt,
  replaceAt: replaceAt,

  getIn: getIn,
  // eslint-disable-next-line object-shorthand
  set: set, // so that flow doesn't complain
  setIn: setIn,
  update: update,
  updateIn: updateIn,
  merge: merge,
  mergeDeep: mergeDeep,
  mergeIn: mergeIn,
  omit: omit,
  addDefaults: addDefaults
};

exports.default = timm;


/***/ }),

/***/ "./node_modules/tinycolor2/tinycolor.js":
/*!**********************************************!*\
  !*** ./node_modules/tinycolor2/tinycolor.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if ( true && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
// Browser: Expose to window
else {}

})(Math);


/***/ }),

/***/ "./node_modules/utif/UTIF.js":
/*!***********************************!*\
  !*** ./node_modules/utif/UTIF.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {





;(function(){
var UTIF = {};

// Make available for import by `require()`
if (true) {module.exports = UTIF;}
else {}

var pako;
if (true) {pako = __webpack_require__(/*! pako */ "pako");}
else {}

function log() { if (typeof process=="undefined" || "development"=="development") console.log.apply(console, arguments);  }

(function(UTIF, pako){
	
// Following lines add a JPEG decoder  to UTIF.JpegDecoder
(function(){var V="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(g){return typeof g}:function(g){return g&&"function"===typeof Symbol&&g.constructor===Symbol&&g!==Symbol.prototype?"symbol":typeof g},D=function(){function g(g){this.message="JPEG error: "+g}g.prototype=Error();g.prototype.name="JpegError";return g.constructor=g}(),P=function(){function g(g,D){this.message=g;this.g=D}g.prototype=Error();g.prototype.name="DNLMarkerError";return g.constructor=g}();(function(){function g(){this.M=
null;this.B=-1}function W(a,d){for(var f=0,e=[],b,B,k=16;0<k&&!a[k-1];)k--;e.push({children:[],index:0});var l=e[0],r;for(b=0;b<k;b++){for(B=0;B<a[b];B++){l=e.pop();for(l.children[l.index]=d[f];0<l.index;)l=e.pop();l.index++;for(e.push(l);e.length<=b;)e.push(r={children:[],index:0}),l.children[l.index]=r.children,l=r;f++}b+1<k&&(e.push(r={children:[],index:0}),l.children[l.index]=r.children,l=r)}return e[0].children}function X(a,d,f,e,b,B,k,l,r){function n(){if(0<x)return x--,z>>x&1;z=a[d++];if(255===
z){var c=a[d++];if(c){if(220===c&&g){d+=2;var b=a[d++]<<8|a[d++];if(0<b&&b!==f.g)throw new P("Found DNL marker (0xFFDC) while parsing scan data",b);}throw new D("unexpected marker "+(z<<8|c).toString(16));}}x=7;return z>>>7}function q(a){for(;;){a=a[n()];if("number"===typeof a)return a;if("object"!==("undefined"===typeof a?"undefined":V(a)))throw new D("invalid huffman sequence");}}function h(a){for(var c=0;0<a;)c=c<<1|n(),a--;return c}function c(a){if(1===a)return 1===n()?1:-1;var c=h(a);return c>=
1<<a-1?c:c+(-1<<a)+1}function C(a,b){var d=q(a.D);d=0===d?0:c(d);a.a[b]=a.m+=d;for(d=1;64>d;){var h=q(a.o),k=h&15;h>>=4;if(0===k){if(15>h)break;d+=16}else d+=h,a.a[b+J[d]]=c(k),d++}}function w(a,d){var b=q(a.D);b=0===b?0:c(b)<<r;a.a[d]=a.m+=b}function p(a,c){a.a[c]|=n()<<r}function m(a,b){if(0<A)A--;else for(var d=B;d<=k;){var e=q(a.o),f=e&15;e>>=4;if(0===f){if(15>e){A=h(e)+(1<<e)-1;break}d+=16}else d+=e,a.a[b+J[d]]=c(f)*(1<<r),d++}}function t(a,d){for(var b=B,e=0,f;b<=k;){f=d+J[b];var l=0>a.a[f]?
-1:1;switch(E){case 0:e=q(a.o);f=e&15;e>>=4;if(0===f)15>e?(A=h(e)+(1<<e),E=4):(e=16,E=1);else{if(1!==f)throw new D("invalid ACn encoding");Q=c(f);E=e?2:3}continue;case 1:case 2:a.a[f]?a.a[f]+=l*(n()<<r):(e--,0===e&&(E=2===E?3:0));break;case 3:a.a[f]?a.a[f]+=l*(n()<<r):(a.a[f]=Q<<r,E=0);break;case 4:a.a[f]&&(a.a[f]+=l*(n()<<r))}b++}4===E&&(A--,0===A&&(E=0))}var g=9<arguments.length&&void 0!==arguments[9]?arguments[9]:!1,u=f.P,v=d,z=0,x=0,A=0,E=0,Q,K=e.length,F,L,M,I;var R=f.S?0===B?0===l?w:p:0===l?
m:t:C;var G=0;var O=1===K?e[0].c*e[0].l:u*f.O;for(var S,T;G<O;){var U=b?Math.min(O-G,b):O;for(F=0;F<K;F++)e[F].m=0;A=0;if(1===K){var y=e[0];for(I=0;I<U;I++)R(y,64*((y.c+1)*(G/y.c|0)+G%y.c)),G++}else for(I=0;I<U;I++){for(F=0;F<K;F++)for(y=e[F],S=y.h,T=y.j,L=0;L<T;L++)for(M=0;M<S;M++)R(y,64*((y.c+1)*((G/u|0)*y.j+L)+(G%u*y.h+M)));G++}x=0;(y=N(a,d))&&y.f&&((0,_util.warn)("decodeScan - unexpected MCU data, current marker is: "+y.f),d=y.offset);y=y&&y.F;if(!y||65280>=y)throw new D("marker was not found");
if(65488<=y&&65495>=y)d+=2;else break}(y=N(a,d))&&y.f&&((0,_util.warn)("decodeScan - unexpected Scan data, current marker is: "+y.f),d=y.offset);return d-v}function Y(a,d){for(var f=d.c,e=d.l,b=new Int16Array(64),B=0;B<e;B++)for(var k=0;k<f;k++){var l=64*((d.c+1)*B+k),r=b,n=d.G,q=d.a;if(!n)throw new D("missing required Quantization Table.");for(var h=0;64>h;h+=8){var c=q[l+h];var C=q[l+h+1];var w=q[l+h+2];var p=q[l+h+3];var m=q[l+h+4];var t=q[l+h+5];var g=q[l+h+6];var u=q[l+h+7];c*=n[h];if(0===(C|
w|p|m|t|g|u))c=5793*c+512>>10,r[h]=c,r[h+1]=c,r[h+2]=c,r[h+3]=c,r[h+4]=c,r[h+5]=c,r[h+6]=c,r[h+7]=c;else{C*=n[h+1];w*=n[h+2];p*=n[h+3];m*=n[h+4];t*=n[h+5];g*=n[h+6];u*=n[h+7];var v=5793*c+128>>8;var z=5793*m+128>>8;var x=w;var A=g;m=2896*(C-u)+128>>8;u=2896*(C+u)+128>>8;p<<=4;t<<=4;v=v+z+1>>1;z=v-z;c=3784*x+1567*A+128>>8;x=1567*x-3784*A+128>>8;A=c;m=m+t+1>>1;t=m-t;u=u+p+1>>1;p=u-p;v=v+A+1>>1;A=v-A;z=z+x+1>>1;x=z-x;c=2276*m+3406*u+2048>>12;m=3406*m-2276*u+2048>>12;u=c;c=799*p+4017*t+2048>>12;p=4017*
p-799*t+2048>>12;t=c;r[h]=v+u;r[h+7]=v-u;r[h+1]=z+t;r[h+6]=z-t;r[h+2]=x+p;r[h+5]=x-p;r[h+3]=A+m;r[h+4]=A-m}}for(n=0;8>n;++n)c=r[n],C=r[n+8],w=r[n+16],p=r[n+24],m=r[n+32],t=r[n+40],g=r[n+48],u=r[n+56],0===(C|w|p|m|t|g|u)?(c=5793*c+8192>>14,c=-2040>c?0:2024<=c?255:c+2056>>4,q[l+n]=c,q[l+n+8]=c,q[l+n+16]=c,q[l+n+24]=c,q[l+n+32]=c,q[l+n+40]=c,q[l+n+48]=c,q[l+n+56]=c):(v=5793*c+2048>>12,z=5793*m+2048>>12,x=w,A=g,m=2896*(C-u)+2048>>12,u=2896*(C+u)+2048>>12,v=(v+z+1>>1)+4112,z=v-z,c=3784*x+1567*A+2048>>
12,x=1567*x-3784*A+2048>>12,A=c,m=m+t+1>>1,t=m-t,u=u+p+1>>1,p=u-p,v=v+A+1>>1,A=v-A,z=z+x+1>>1,x=z-x,c=2276*m+3406*u+2048>>12,m=3406*m-2276*u+2048>>12,u=c,c=799*p+4017*t+2048>>12,p=4017*p-799*t+2048>>12,t=c,c=v+u,u=v-u,C=z+t,g=z-t,w=x+p,t=x-p,p=A+m,m=A-m,c=16>c?0:4080<=c?255:c>>4,C=16>C?0:4080<=C?255:C>>4,w=16>w?0:4080<=w?255:w>>4,p=16>p?0:4080<=p?255:p>>4,m=16>m?0:4080<=m?255:m>>4,t=16>t?0:4080<=t?255:t>>4,g=16>g?0:4080<=g?255:g>>4,u=16>u?0:4080<=u?255:u>>4,q[l+n]=c,q[l+n+8]=C,q[l+n+16]=w,q[l+n+24]=
p,q[l+n+32]=m,q[l+n+40]=t,q[l+n+48]=g,q[l+n+56]=u)}return d.a}function N(a,d){var f=2<arguments.length&&void 0!==arguments[2]?arguments[2]:d,e=a.length-1;f=f<d?f:d;if(d>=e)return null;var b=a[d]<<8|a[d+1];if(65472<=b&&65534>=b)return{f:null,F:b,offset:d};for(var B=a[f]<<8|a[f+1];!(65472<=B&&65534>=B);){if(++f>=e)return null;B=a[f]<<8|a[f+1]}return{f:b.toString(16),F:B,offset:f}}var J=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,
57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);g.prototype={parse:function(a){function d(){var d=a[k]<<8|a[k+1];k+=2;return d}function f(){var b=d();b=k+b-2;var c=N(a,b,k);c&&c.f&&((0,_util.warn)("readDataBlock - incorrect length, current marker is: "+c.f),b=c.offset);b=a.subarray(k,b);k+=b.length;return b}function e(a){for(var b=Math.ceil(a.v/8/a.s),c=Math.ceil(a.g/8/a.u),d=0;d<a.b.length;d++){v=a.b[d];var e=Math.ceil(Math.ceil(a.v/8)*v.h/a.s),f=Math.ceil(Math.ceil(a.g/
8)*v.j/a.u);v.a=new Int16Array(64*c*v.j*(b*v.h+1));v.c=e;v.l=f}a.P=b;a.O=c}var b=(1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).N,B=void 0===b?null:b,k=0,l=null,r=0;b=[];var n=[],q=[],h=d();if(65496!==h)throw new D("SOI not found");for(h=d();65497!==h;){switch(h){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var c=f();65518===h&&65===c[0]&&100===
c[1]&&111===c[2]&&98===c[3]&&101===c[4]&&(l={version:c[5]<<8|c[6],Y:c[7]<<8|c[8],Z:c[9]<<8|c[10],W:c[11]});break;case 65499:h=d()+k-2;for(var g;k<h;){var w=a[k++],p=new Uint16Array(64);if(0===w>>4)for(c=0;64>c;c++)g=J[c],p[g]=a[k++];else if(1===w>>4)for(c=0;64>c;c++)g=J[c],p[g]=d();else throw new D("DQT - invalid table spec");b[w&15]=p}break;case 65472:case 65473:case 65474:if(m)throw new D("Only single frame JPEGs supported");d();var m={};m.X=65473===h;m.S=65474===h;m.precision=a[k++];h=d();m.g=
B||h;m.v=d();m.b=[];m.C={};c=a[k++];for(h=p=w=0;h<c;h++){g=a[k];var t=a[k+1]>>4;var H=a[k+1]&15;w<t&&(w=t);p<H&&(p=H);t=m.b.push({h:t,j:H,T:a[k+2],G:null});m.C[g]=t-1;k+=3}m.s=w;m.u=p;e(m);break;case 65476:g=d();for(h=2;h<g;){w=a[k++];p=new Uint8Array(16);for(c=t=0;16>c;c++,k++)t+=p[c]=a[k];H=new Uint8Array(t);for(c=0;c<t;c++,k++)H[c]=a[k];h+=17+t;(0===w>>4?q:n)[w&15]=W(p,H)}break;case 65501:d();var u=d();break;case 65498:c=1===++r&&!B;d();w=a[k++];g=[];for(h=0;h<w;h++){p=m.C[a[k++]];var v=m.b[p];
p=a[k++];v.D=q[p>>4];v.o=n[p&15];g.push(v)}h=a[k++];w=a[k++];p=a[k++];try{var z=X(a,k,m,g,u,h,w,p>>4,p&15,c);k+=z}catch(x){if(x instanceof P)return(0,_util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'),this.parse(a,{N:x.g});throw x;}break;case 65500:k+=4;break;case 65535:255!==a[k]&&k--;break;default:if(255===a[k-3]&&192<=a[k-2]&&254>=a[k-2])k-=3;else if((c=N(a,k-2))&&c.f)(0,_util.warn)("JpegImage.parse - unexpected data, current marker is: "+
c.f),k=c.offset;else throw new D("unknown marker "+h.toString(16));}h=d()}this.width=m.v;this.height=m.g;this.A=l;this.b=[];for(h=0;h<m.b.length;h++){v=m.b[h];if(u=b[v.T])v.G=u;this.b.push({R:Y(m,v),U:v.h/m.s,V:v.j/m.u,c:v.c,l:v.l})}this.i=this.b.length},L:function(a,d){var f=this.width/a,e=this.height/d,b,g,k=this.b.length,l=a*d*k,r=new Uint8ClampedArray(l),n=new Uint32Array(a);for(g=0;g<k;g++){var q=this.b[g];var h=q.U*f;var c=q.V*e;var C=g;var w=q.R;var p=q.c+1<<3;for(b=0;b<a;b++)q=0|b*h,n[b]=
(q&4294967288)<<3|q&7;for(h=0;h<d;h++)for(q=0|h*c,q=p*(q&4294967288)|(q&7)<<3,b=0;b<a;b++)r[C]=w[q+n[b]],C+=k}if(e=this.M)for(g=0;g<l;)for(f=q=0;q<k;q++,g++,f+=2)r[g]=(r[g]*e[f]>>8)+e[f+1];return r},w:function(){return this.A?!!this.A.W:3===this.i?0===this.B?!1:!0:1===this.B?!0:!1},I:function(a){for(var d,f,e,b=0,g=a.length;b<g;b+=3)d=a[b],f=a[b+1],e=a[b+2],a[b]=d-179.456+1.402*e,a[b+1]=d+135.459-.344*f-.714*e,a[b+2]=d-226.816+1.772*f;return a},K:function(a){for(var d,f,e,b,g=0,k=0,l=a.length;k<l;k+=
4)d=a[k],f=a[k+1],e=a[k+2],b=a[k+3],a[g++]=-122.67195406894+f*(-6.60635669420364E-5*f+4.37130475926232E-4*e-5.4080610064599E-5*d+4.8449797120281E-4*b-.154362151871126)+e*(-9.57964378445773E-4*e+8.17076911346625E-4*d-.00477271405408747*b+1.53380253221734)+d*(9.61250184130688E-4*d-.00266257332283933*b+.48357088451265)+b*(-3.36197177618394E-4*b+.484791561490776),a[g++]=107.268039397724+f*(2.19927104525741E-5*f-6.40992018297945E-4*e+6.59397001245577E-4*d+4.26105652938837E-4*b-.176491792462875)+e*(-7.78269941513683E-4*
e+.00130872261408275*d+7.70482631801132E-4*b-.151051492775562)+d*(.00126935368114843*d-.00265090189010898*b+.25802910206845)+b*(-3.18913117588328E-4*b-.213742400323665),a[g++]=-20.810012546947+f*(-5.70115196973677E-4*f-2.63409051004589E-5*e+.0020741088115012*d-.00288260236853442*b+.814272968359295)+e*(-1.53496057440975E-5*e-1.32689043961446E-4*d+5.60833691242812E-4*b-.195152027534049)+d*(.00174418132927582*d-.00255243321439347*b+.116935020465145)+b*(-3.43531996510555E-4*b+.24165260232407);return a.subarray(0,
g)},J:function(a){for(var d,f,e,b=0,g=a.length;b<g;b+=4)d=a[b],f=a[b+1],e=a[b+2],a[b]=434.456-d-1.402*e,a[b+1]=119.541-d+.344*f+.714*e,a[b+2]=481.816-d-1.772*f;return a},H:function(a){for(var d,f,e,b,g=0,k=1/255,l=0,r=a.length;l<r;l+=4)d=a[l]*k,f=a[l+1]*k,e=a[l+2]*k,b=a[l+3]*k,a[g++]=255+d*(-4.387332384609988*d+54.48615194189176*f+18.82290502165302*e+212.25662451639585*b-285.2331026137004)+f*(1.7149763477362134*f-5.6096736904047315*e-17.873870861415444*b-5.497006427196366)+e*(-2.5217340131683033*
e-21.248923337353073*b+17.5119270841813)-b*(21.86122147463605*b+189.48180835922747),a[g++]=255+d*(8.841041422036149*d+60.118027045597366*f+6.871425592049007*e+31.159100130055922*b-79.2970844816548)+f*(-15.310361306967817*f+17.575251261109482*e+131.35250912493976*b-190.9453302588951)+e*(4.444339102852739*e+9.8632861493405*b-24.86741582555878)-b*(20.737325471181034*b+187.80453709719578),a[g++]=255+d*(.8842522430003296*d+8.078677503112928*f+30.89978309703729*e-.23883238689178934*b-14.183576799673286)+
f*(10.49593273432072*f+63.02378494754052*e+50.606957656360734*b-112.23884253719248)+e*(.03296041114873217*e+115.60384449646641*b-193.58209356861505)-b*(22.33816807309886*b+180.12613974708367);return a.subarray(0,g)},getData:function(a,d,f){if(4<this.i)throw new D("Unsupported color mode");a=this.L(a,d);if(1===this.i&&f){f=a.length;d=new Uint8ClampedArray(3*f);for(var e=0,b=0;b<f;b++){var g=a[b];d[e++]=g;d[e++]=g;d[e++]=g}return d}if(3===this.i&&this.w())return this.I(a);if(4===this.i){if(this.w())return f?
this.K(a):this.J(a);if(f)return this.H(a)}return a}}; UTIF.JpegDecoder=g})()})();

//UTIF.JpegDecoder = window.JpegDecoder;

UTIF.encodeImage = function(rgba, w, h, metadata)
{
	var idf = { "t256":[w], "t257":[h], "t258":[8,8,8,8], "t259":[1], "t262":[2], "t273":[1000], // strips offset
				"t277":[4], "t278":[h], /* rows per strip */          "t279":[w*h*4], // strip byte counts
				"t282":[1], "t283":[1], "t284":[1], "t286":[0], "t287":[0], "t296":[1], "t305": ["Photopea (UTIF.js)"], "t338":[1]
		};
	if (metadata) for (var i in metadata) idf[i] = metadata[i];
	
	var prfx = new Uint8Array(UTIF.encode([idf]));
	var img = new Uint8Array(rgba);
	var data = new Uint8Array(1000+w*h*4);
	for(var i=0; i<prfx.length; i++) data[i] = prfx[i];
	for(var i=0; i<img .length; i++) data[1000+i] = img[i];
	return data.buffer;
}

UTIF.encode = function(ifds)
{
	var data = new Uint8Array(20000), offset = 4, bin = UTIF._binBE;
	data[0]=77;  data[1]=77;  data[3]=42;

	var ifdo = 8;
	bin.writeUint(data, offset, ifdo);  offset+=4;
	for(var i=0; i<ifds.length; i++)
	{
		var noffs = UTIF._writeIFD(bin, data, ifdo, ifds[i]);
		ifdo = noffs[1];
		if(i<ifds.length-1) bin.writeUint(data, noffs[0], ifdo);
	}
	return data.slice(0, ifdo).buffer;
}
//UTIF.encode._writeIFD

UTIF.decode = function(buff)
{
	UTIF.decode._decodeG3.allow2D = null;
	var data = new Uint8Array(buff), offset = 0;

	var id = UTIF._binBE.readASCII(data, offset, 2);  offset+=2;
	var bin = id=="II" ? UTIF._binLE : UTIF._binBE;
	var num = bin.readUshort(data, offset);  offset+=2;

	var ifdo = bin.readUint(data, offset);  offset+=4;
	var ifds = [];
	while(true)
	{
		var noff = UTIF._readIFD(bin, data, ifdo, ifds);
		//var ifd = ifds[ifds.length-1];   if(ifd["t34665"]) {  ifd.exifIFD = [];  UTIF._readIFD(bin, data, ifd["t34665"][0], ifd.exifIFD);  }
		ifdo = bin.readUint(data, noff);
		if(ifdo==0) break;
	}
	return ifds;
}

UTIF.decodeImages = function(buff, ifds)
{
	var data = new Uint8Array(buff);
	var id = UTIF._binBE.readASCII(data, 0, 2);

	for(var ii=0; ii<ifds.length; ii++)
	{
		var img = ifds[ii];
		if(img["t256"]==null) continue;	// EXIF files don't have TIFF tags
		img.isLE = id=="II";
		img.width  = img["t256"][0];  //delete img["t256"];
		img.height = img["t257"][0];  //delete img["t257"];

		var cmpr   = img["t259"] ? img["t259"][0] : 1;  //delete img["t259"];
		var fo = img["t266"] ? img["t266"][0] : 1;  //delete img["t266"];
		if(img["t284"] && img["t284"][0]==2) log("PlanarConfiguration 2 should not be used!");

		var bipp = (img["t258"]?Math.min(32,img["t258"][0]):1) * (img["t277"]?img["t277"][0]:1);  // bits per pixel
		var bipl = Math.ceil(img.width*bipp/8)*8;
		var soff = img["t273"];  if(soff==null) soff = img["t324"];
		var bcnt = img["t279"];  if(cmpr==1 && soff.length==1) bcnt = [img.height*(bipl>>>3)];  if(bcnt==null) bcnt = img["t325"];
		var bytes = new Uint8Array(img.height*(bipl>>>3)), bilen = 0;

		if(img["t322"]!=null) // tiled
		{
			var tw = img["t322"][0], th = img["t323"][0];
			var tx = Math.floor((img.width  + tw - 1) / tw);
			var ty = Math.floor((img.height + th - 1) / th);
			var tbuff = new Uint8Array(Math.ceil(tw*th*bipp/8)|0);
			for(var y=0; y<ty; y++)
				for(var x=0; x<tx; x++)
				{
					var i = y*tx+x;  for(var j=0; j<tbuff.length; j++) tbuff[j]=0;
					UTIF.decode._decompress(img, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo);
					// Might be required for 7 too. Need to check
					if (cmpr==6) bytes = tbuff;
					else UTIF._copyTile(tbuff, Math.ceil(tw*bipp/8)|0, th, bytes, Math.ceil(img.width*bipp/8)|0, img.height, Math.ceil(x*tw*bipp/8)|0, y*th);
				}
			bilen = bytes.length*8;
		}
		else	// stripped
		{
			var rps = img["t278"] ? img["t278"][0] : img.height;   rps = Math.min(rps, img.height);
			for(var i=0; i<soff.length; i++)
			{
				UTIF.decode._decompress(img, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen/8)|0, fo);
				bilen += bipl * rps;
			}
			bilen = Math.min(bilen, bytes.length*8);
		}
		img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen/8)|0);
	}
}

UTIF.decode._decompress = function(img, data, off, len, cmpr, tgt, toff, fo)  // fill order
{
	//console.log("compression", cmpr);
	if(false) {}
	else if(cmpr==1) for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];
	else if(cmpr==3) UTIF.decode._decodeG3 (data, off, len, tgt, toff, img.width, fo);
	else if(cmpr==4) UTIF.decode._decodeG4 (data, off, len, tgt, toff, img.width, fo);
	else if(cmpr==5) UTIF.decode._decodeLZW(data, off, tgt, toff);
	else if(cmpr==6) UTIF.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
	else if(cmpr==7) UTIF.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
	else if(cmpr==8) {  var src = new Uint8Array(data.buffer,off,len);  var bin = pako["inflate"](src);  for(var i=0; i<bin.length; i++) tgt[toff+i]=bin[i];  }
	else if(cmpr==32773) UTIF.decode._decodePackBits(data, off, len, tgt, toff);
	else if(cmpr==32809) UTIF.decode._decodeThunder (data, off, len, tgt, toff);
	//else if(cmpr==34713) UTIF.decode._decodeNikon   (data, off, len, tgt, toff);
	else log("Unknown compression", cmpr);

	if(img["t317"] && img["t317"][0]==2)
	{
		var noc = (img["t277"]?img["t277"][0]:1), h = (img["t278"] ? img["t278"][0] : img.height), bpr = img.width*noc;
		//log(noc);
		for(var y=0; y<h; y++)
		{
			var ntoff = toff+y*bpr;
			if(noc==3) for(var j=  3; j<bpr; j+=3)
			{
				tgt[ntoff+j  ] = (tgt[ntoff+j  ] + tgt[ntoff+j-3])&255;
				tgt[ntoff+j+1] = (tgt[ntoff+j+1] + tgt[ntoff+j-2])&255;
				tgt[ntoff+j+2] = (tgt[ntoff+j+2] + tgt[ntoff+j-1])&255;
			}
			else for(var j=noc; j<bpr; j++) tgt[ntoff+j] = (tgt[ntoff+j] + tgt[ntoff+j-noc])&255;
		}
	}
}

UTIF.decode._decodeNikon = function(data, off, len, tgt, toff)
{
	var nikon_tree = [
    [ 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy */
      5,4,3,6,2,7,1,0,8,9,11,10,12 ],
    [ 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy after split */
      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 ],
    [ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */
      5,4,6,3,7,2,8,1,9,0,10,11,12 ],
    [ 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,	/* 14-bit lossy */
      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 ],
    [ 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,	/* 14-bit lossy after split */
      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 ],
    [ 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,	/* 14-bit lossless */
      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 ] ];

	//struct decode *dindex;
	var ver0, ver1, vpred, hpred, csize;
	var i, min, max, step=0, huff=0, split=0, row, col, len, shl, diff;

	log(data.slice(off,off+100));
	ver0 = data[off];  off++;
	ver1 = data[off];  off++;
	log(ver0.toString(16), ver1.toString(16), len);
}

UTIF.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff)
{
	var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
	
	if (tables)
	{
		var SOI = 216, EOI = 217, boff = 0;
		for (var i=0; i<(tlen-1); i++)
		{
			// Skip EOI marker from JPEGTables
			if (tables[i]==255 && tables[i+1]==EOI) break;
			buff[boff++] = tables[i];
		}

		// Skip SOI marker from data
		var byte1 = data[off], byte2 = data[off + 1];
		if (byte1!=255 || byte2!=SOI)
		{
			buff[boff++] = byte1;
			buff[boff++] = byte2;
		}
		for (var i=2; i<len; i++) buff[boff++] = data[off+i];
	}
	else for (var i=0; i<len; i++) buff[i] = data[off+i];

	if(img["t262"]==32803) // lossless JPEG (used in DNG files) is not available in JpegDecoder.
	{
		var bps = img["t258"][0], dcdr = new LosslessJpegDecoder();
		var out = dcdr.decode(buff), olen=out.length;

		if(false) {}
		else if(bps==16) for(var i=0; i<olen; i++) {  tgt[toff++] = (out[i]&255);  tgt[toff++] = (out[i]>>>8);  }
		else if(bps==12) for(var i=0; i<olen; i+=2) {  tgt[toff++] = (out[i]>>>4);  tgt[toff++] = ((out[i]<<4)|(out[i+1]>>>8))&255;  tgt[toff++] = out[i+1]&255;  }
		else throw new Error("unsupported bit depth "+bps);
	}
	else
	{
		var parser = new UTIF.JpegDecoder();  parser.parse(buff);
		var decoded = parser.getData(parser.width, parser.height);
		for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];
	}

	// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
	// RGB format, so updating the tag value
	if(img["t262"][0] == 6)  img["t262"][0] = 2;
}

UTIF.decode._decodeOldJPEGInit = function(img, data, off, len)
{
	var SOI = 216, EOI = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS = 218;
	var joff = 0, soff = 0, tables, sosMarker, isTiled = false, i, j, k;
	var jpgIchgFmt    = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
	var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
	var soffTag       = img["t324"] || img["t273"] || jpgIchgFmt;
	var ycbcrss       = img["t530"], ssx = 0, ssy = 0;
	var spp           = img["t277"]?img["t277"][0]:1;
	var jpgresint     = img["t515"];

	if(soffTag)
	{
		soff = soffTag[0];
		isTiled = (soffTag.length > 1);
	}

	if(!isTiled)
	{
		if(data[off]==255 && data[off+1]==SOI) return { jpegOffset: off };
		if(jpgIchgFmt!=null)
		{
			if(data[off+jifoff]==255 && data[off+jifoff+1]==SOI) joff = off+jifoff;
			else log("JPEGInterchangeFormat does not point to SOI");

			if(jpgIchgFmtLen==null) log("JPEGInterchangeFormatLength field is missing");
			else if(jifoff >= soff || (jifoff+jiflen) <= soff) log("JPEGInterchangeFormatLength field value is invalid");

			if(joff != null) return { jpegOffset: joff };
		}
	}

	if(ycbcrss!=null) {  ssx = ycbcrss[0];  ssy = ycbcrss[1];  }

	if(jpgIchgFmt!=null)
		if(jpgIchgFmtLen!=null)
			if(jiflen >= 2 && (jifoff+jiflen) <= soff)
			{
				if(data[off+jifoff+jiflen-2]==255 && data[off+jifoff+jiflen-1]==SOI) tables = new Uint8Array(jiflen-2);
				else tables = new Uint8Array(jiflen);

				for(i=0; i<tables.length; i++) tables[i] = data[off+jifoff+i];
				log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
			}
			else log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");

	if(tables == null)
	{
		var ooff = 0, out = [];
		out[ooff++] = 255; out[ooff++] = SOI;

		var qtables = img["t519"];
		if(qtables==null) throw new Error("JPEGQTables tag is missing");
		for(i=0; i<qtables.length; i++)
		{
			out[ooff++] = 255; out[ooff++] = DQT; out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
			for(j=0; j<64; j++) out[ooff++] = data[off+qtables[i]+j];
		}

		for(k=0; k<2; k++)
		{
			var htables = img[(k == 0) ? "t520" : "t521"];
			if(htables==null) throw new Error(((k == 0) ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
			for(i=0; i<htables.length; i++)
			{
				out[ooff++] = 255; out[ooff++] = DHT;
				//out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
				var nc = 19;
				for(j=0; j<16; j++) nc += data[off+htables[i]+j];

				out[ooff++] = (nc >>> 8); out[ooff++] = nc & 255;
				out[ooff++] = (i | (k << 4));
				for(j=0; j<16; j++) out[ooff++] = data[off+htables[i]+j];
				for(j=0; j<nc; j++) out[ooff++] = data[off+htables[i]+16+j];
			}
		}

		out[ooff++] = 255; out[ooff++] = SOF0;
		out[ooff++] = 0;  out[ooff++] = 8 + 3*spp;  out[ooff++] = 8;
		out[ooff++] = (img.height >>> 8) & 255;  out[ooff++] = img.height & 255;
		out[ooff++] = (img.width  >>> 8) & 255;  out[ooff++] = img.width  & 255;
		out[ooff++] = spp;
		if(spp==1) {  out[ooff++] = 1;  out[ooff++] = 17;  out[ooff++] = 0;  }
		else for(i=0; i<3; i++)
		{
			out[ooff++] = i + 1;
			out[ooff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
			out[ooff++] = i;
		}

		if(jpgresint!=null && jpgresint[0]!=0)
		{
			out[ooff++] = 255;  out[ooff++] = DRI;  out[ooff++] = 0;  out[ooff++] = 4;
			out[ooff++] = (jpgresint[0] >>> 8) & 255;
			out[ooff++] = jpgresint[0] & 255;
		}

		tables = new Uint8Array(out);
	}

	var sofpos = -1;
	i = 0;
	while(i < (tables.length - 1)) {
		if(tables[i]==255 && tables[i+1]==SOF0) {  sofpos = i; break;  }
		i++;
	}

	if(sofpos == -1)
	{
		var tmptab = new Uint8Array(tables.length + 10 + 3*spp);
		tmptab.set(tables);
		var tmpoff = tables.length;
		sofpos = tables.length;
		tables = tmptab;

		tables[tmpoff++] = 255; tables[tmpoff++] = SOF0;
		tables[tmpoff++] = 0;  tables[tmpoff++] = 8 + 3*spp;  tables[tmpoff++] = 8;
		tables[tmpoff++] = (img.height >>> 8) & 255;  tables[tmpoff++] = img.height & 255;
		tables[tmpoff++] = (img.width  >>> 8) & 255;  tables[tmpoff++] = img.width  & 255;
		tables[tmpoff++] = spp;
		if(spp==1) {  tables[tmpoff++] = 1;  tables[tmpoff++] = 17;  tables[tmpoff++] = 0;  }
		else for(i=0; i<3; i++)
		{
			tables[tmpoff++] = i + 1;
			tables[tmpoff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
			tables[tmpoff++] = i;
		}
	}

	if(data[soff]==255 && data[soff+1]==SOS)
	{
		var soslen = (data[soff+2]<<8) | data[soff+3];
		sosMarker = new Uint8Array(soslen+2);
		sosMarker[0] = data[soff];  sosMarker[1] = data[soff+1]; sosMarker[2] = data[soff+2];  sosMarker[3] = data[soff+3];
		for(i=0; i<(soslen-2); i++) sosMarker[i+4] = data[soff+i+4];
	}
	else
	{
		sosMarker = new Uint8Array(2 + 6 + 2*spp);
		var sosoff = 0;
		sosMarker[sosoff++] = 255;  sosMarker[sosoff++] = SOS;
		sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 6 + 2*spp;  sosMarker[sosoff++] = spp;
		if(spp==1) {  sosMarker[sosoff++] = 1;  sosMarker[sosoff++] = 0;  }
		else for(i=0; i<3; i++)
		{
			sosMarker[sosoff++] = i+1;  sosMarker[sosoff++] = (i << 4) | i;
		}
		sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 63;  sosMarker[sosoff++] = 0;
	}

	return { jpegOffset: off, tables: tables, sosMarker: sosMarker, sofPosition: sofpos };
}

UTIF.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff)
{
	var i, dlen, tlen, buff, buffoff;
	var jpegData = UTIF.decode._decodeOldJPEGInit(img, data, off, len);

	if(jpegData.jpegOffset!=null)
	{
		dlen = off+len-jpegData.jpegOffset;
		buff = new Uint8Array(dlen);
		for(i=0; i<dlen; i++) buff[i] = data[jpegData.jpegOffset+i];
	}
	else
	{
		tlen = jpegData.tables.length;
		buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
		buff.set(jpegData.tables);
		buffoff = tlen;

		buff[jpegData.sofPosition+5] = (img.height >>> 8) & 255;  buff[jpegData.sofPosition+6] = img.height & 255;
		buff[jpegData.sofPosition+7] = (img.width  >>> 8) & 255;  buff[jpegData.sofPosition+8] = img.width  & 255;

		if(data[off]!=255 || data[off+1]!=SOS)
		{
			buff.set(jpegData.sosMarker, bufoff);
			bufoff += sosMarker.length;
		}
		for(i=0; i<len; i++) buff[bufoff++] = data[off+i];
		buff[bufoff++] = 255;  buff[bufoff++] = EOI;
	}

	var parser = new UTIF.JpegDecoder();  parser.parse(buff);
	var decoded = parser.getData(parser.width, parser.height);
	for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];

	// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
	// RGB format, so updating the tag value
	if(img["t262"][0] == 6)  img["t262"][0] = 2;
}

UTIF.decode._decodePackBits = function(data, off, len, tgt, toff)
{
	var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off+len;
	while(off<lim)
	{
		var n = sa[off];  off++;
		if(n>=0  && n<128)    for(var i=0; i< n+1; i++) {  ta[toff]=sa[off];  toff++;  off++;   }
		if(n>=-127 && n<0) {  for(var i=0; i<-n+1; i++) {  ta[toff]=sa[off];  toff++;           }  off++;  }
	}
}

UTIF.decode._decodeThunder = function(data, off, len, tgt, toff)
{
	var d2 = [ 0, 1, 0, -1 ],  d3 = [ 0, 1, 2, 3, 0, -3, -2, -1 ];
	var lim = off+len, qoff = toff*2, px = 0;
	while(off<lim)
	{
		var b = data[off], msk = (b>>>6), n = (b&63);  off++;
		if(msk==3) { px=(n&15);  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
		if(msk==0) for(var i=0; i<n; i++) {  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
		if(msk==2) for(var i=0; i<2; i++) {  var d=(n>>>(3*(1-i)))&7;  if(d!=4) { px+=d3[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
		if(msk==1) for(var i=0; i<3; i++) {  var d=(n>>>(2*(2-i)))&3;  if(d!=2) { px+=d2[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
	}
}

UTIF.decode._dmap = { "1":0,"011":1,"000011":2,"0000011":3, "010":-1,"000010":-2,"0000010":-3  };
UTIF.decode._lens = ( function()
{
	var addKeys = function(lens, arr, i0, inc) {  for(var i=0; i<arr.length; i++) lens[arr[i]] = i0 + i*inc;  }

	var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101," // 15
	+ "101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010," // 31
	+ "00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010," // 47
	+ "00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";

	var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000," // 15
	+ "0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001," // 31
	+ "000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111," // 47
	+ "000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";

	var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,"
	+ "011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";

	var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,"
	+ "0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,"
	+ "0000001011011,0000001100100,0000001100101";

	var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";

	termW = termW.split(",");  termB = termB.split(",");  makeW = makeW.split(",");  makeB = makeB.split(",");  makeA = makeA.split(",");

	var lensW = {}, lensB = {};
	addKeys(lensW, termW, 0, 1);  addKeys(lensW, makeW, 64,64);  addKeys(lensW, makeA, 1792,64);
	addKeys(lensB, termB, 0, 1);  addKeys(lensB, makeB, 64,64);  addKeys(lensB, makeA, 1792,64);
	return [lensW, lensB];
} )();

UTIF.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo)
{
	var U = UTIF.decode, boff=off<<3, len=0, wrd="";	// previous starts with 1
	var line=[], pline=[];  for(var i=0; i<w; i++) pline.push(0);  pline=U._makeDiff(pline);
	var a0=0, a1=0, a2=0, b1=0, b2=0, clr=0;
	var y=0, mode="", toRead=0;
	var bipl = Math.ceil(w/8)*8;

	while((boff>>>3)<off+slen)
	{
		b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
		var bit =0;
		if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
		if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
		boff++;  wrd+=bit;
		if(mode=="H")
		{
			if(U._lens[clr][wrd]!=null)
			{
				var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
				if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
			}
		}
		else
		{
			if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
			if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
			if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
		}
		if(line.length==w && mode=="")
		{
			U._writeBits(line, tgt, toff*8+y*bipl);
			clr=0;  y++;  a0=0;
			pline=U._makeDiff(line);  line=[];
		}
		//if(wrd.length>150) {  log(wrd);  break;  throw "e";  }
	}
}

UTIF.decode._findDiff = function(line, x, clr) {  for(var i=0; i<line.length; i+=2) if(line[i]>=x && line[i+1]==clr)  return line[i];  }

UTIF.decode._makeDiff = function(line)
{
	var out = [];  if(line[0]==1) out.push(0,1);
	for(var i=1; i<line.length; i++) if(line[i-1]!=line[i]) out.push(i, line[i]);
	out.push(line.length,0,line.length,1);  return out;
}

UTIF.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo)
{
	var U = UTIF.decode, boff=off<<3, len=0, wrd="";
	var line=[], pline=[];  for(var i=0; i<w; i++) line.push(0);
	var a0=0, a1=0, a2=0, b1=0, b2=0, clr=0;
	var y=-1, mode="", toRead=0, is1D=false;
	var bipl = Math.ceil(w/8)*8;
	while((boff>>>3)<off+slen)
	{
		b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
		var bit =0;
		if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
		if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
		boff++;  wrd+=bit;

		if(is1D)
		{
			if(U._lens[clr][wrd]!=null)
			{
				var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
				if(dl<64) {  U._addNtimes(line,len,clr);  clr=1-clr;  len=0;  }
			}
		}
		else
		{
			if(mode=="H")
			{
				if(U._lens[clr][wrd]!=null)
				{
					var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
					if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
				}
			}
			else
			{
				if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
				if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
				if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
			}
		}
		if(wrd.endsWith("000000000001")) // needed for some files
		{
			if(y>=0) U._writeBits(line, tgt, toff*8+y*bipl);
			if(fo==1) is1D = ((data[boff>>>3]>>>(7-(boff&7)))&1)==1;
			if(fo==2) is1D = ((data[boff>>>3]>>>(  (boff&7)))&1)==1;
			boff++;
			if(U._decodeG3.allow2D==null) U._decodeG3.allow2D=is1D;
			if(!U._decodeG3.allow2D) {  is1D = true;  boff--;  }
			//log("EOL",y, "next 1D:", is1D);
			wrd="";  clr=0;  y++;  a0=0;
			pline=U._makeDiff(line);  line=[];
		}
	}
	if(line.length==w) U._writeBits(line, tgt, toff*8+y*bipl);
}

UTIF.decode._addNtimes = function(arr, n, val) {  for(var i=0; i<n; i++) arr.push(val);  }

UTIF.decode._writeBits = function(bits, tgt, boff)
{
	for(var i=0; i<bits.length; i++) tgt[(boff+i)>>>3] |= (bits[i]<<(7-((boff+i)&7)));
}

UTIF.decode._decodeLZW = function(data, off, tgt, toff)
{
	if(UTIF.decode._lzwTab==null)
	{
		var tb=new Uint32Array(0xffff), tn=new Uint16Array(0xffff), chr=new Uint8Array(2e6);
		for(var i=0; i<256; i++) { chr[i<<2]=i;  tb[i]=i<<2;  tn[i]=1;  }
		UTIF.decode._lzwTab = [tb,tn,chr];
	}
	var copy = UTIF.decode._copyData;
	var tab = UTIF.decode._lzwTab[0], tln=UTIF.decode._lzwTab[1], chr=UTIF.decode._lzwTab[2], totl = 258, chrl = 258<<2;
	var bits = 9, boff = off<<3;  // offset in bits

	var ClearCode = 256, EoiCode = 257;
	var v = 0, Code = 0, OldCode = 0;
	while(true)
	{
		v = (data[boff>>>3]<<16) | (data[(boff+8)>>>3]<<8) | data[(boff+16)>>>3];
		Code = ( v>>(24-(boff&7)-bits) )    &   ((1<<bits)-1);  boff+=bits;

		if(Code==EoiCode) break;
		if(Code==ClearCode)
		{
			bits=9;  totl = 258;  chrl = 258<<2;

			v = (data[boff>>>3]<<16) | (data[(boff+8)>>>3]<<8) | data[(boff+16)>>>3];
			Code = ( v>>(24-(boff&7)-bits) )    &   ((1<<bits)-1);  boff+=bits;
			if(Code==EoiCode) break;
			tgt[toff]=Code;  toff++;
		}
		else if(Code<totl)
		{
			var cd = tab[Code], cl = tln[Code];
			copy(chr,cd,tgt,toff,cl);  toff += cl;

			if(OldCode>=totl) {  tab[totl] = chrl;  chr[tab[totl]] = cd[0];  tln[totl]=1;  chrl=(chrl+1+3)&~0x03;  totl++;  }
			else
			{
				tab[totl] = chrl;
				var nit = tab[OldCode], nil = tln[OldCode];
				copy(chr,nit,chr,chrl,nil);
				chr[chrl+nil]=chr[cd];  nil++;
				tln[totl]=nil;  totl++;

				chrl=(chrl+nil+3)&~0x03;
			}
			if(totl+1==(1<<bits)) bits++;
		}
		else
		{
			if(OldCode>=totl) {  tab[totl] = chrl;  tln[totl]=0;  totl++;  }
			else
			{
				tab[totl] = chrl;
				var nit = tab[OldCode], nil = tln[OldCode];
				copy(chr,nit,chr,chrl,nil);
				chr[chrl+nil]=chr[chrl];  nil++;
				tln[totl]=nil;  totl++;

				copy(chr,chrl,tgt,toff,nil);  toff += nil;
				chrl=(chrl+nil+3)&~0x03;
			}
			if(totl+1==(1<<bits)) bits++;
		}
		OldCode = Code;
	}
}

UTIF.decode._copyData = function(s,so,t,to,l) {  for(var i=0;i<l;i+=4) {  t[to+i]=s[so+i];  t[to+i+1]=s[so+i+1];  t[to+i+2]=s[so+i+2];  t[to+i+3]=s[so+i+3];  }  }

UTIF.tags = {254:"NewSubfileType",255:"SubfileType",256:"ImageWidth",257:"ImageLength",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",266:"FillOrder",
			269:"DocumentName",270:"ImageDescription",271:"Make",272:"Model",273:"StripOffset",274:"Orientation",277:"SamplesPerPixel",278:"RowsPerStrip",
			279:"StripByteCounts",280:"MinSampleValue",281:"MaxSampleValue",282:"XResolution",283:"YResolution",284:"PlanarConfiguration",285:"PageName",
			286:"XPosition",287:"YPosition",
			292:"T4Options",296:"ResolutionUnit",297:"PageNumber",305:"Software",306:"DateTime",
			315:"Artist",316:"HostComputer",317:"Predictor",318:"WhitePoint",319:"PrimaryChromaticities",320:"ColorMap",
			321:"HalftoneHints",322:"TileWidth",
			323:"TileLength",324:"TileOffset",325:"TileByteCounts",330:"SubIFDs",336:"DotRange",338:"ExtraSample",339:"SampleFormat", 347:"JPEGTables",
			512:"JPEGProc",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",519:"JPEGQTables",520:"JPEGDCTables",521:"JPEGACTables",
			529:"YCbCrCoefficients",530:"YCbCrSubSampling",531:"YCbCrPositioning",532:"ReferenceBlackWhite",700:"XMP",
			33421:"CFARepeatPatternDim",33422:"CFAPattern",33432:"Copyright",33434:"ExposureTime",33437:"FNumber",33723:"IPTC/NAA",34377:"Photoshop",
			34665:"ExifIFD",34675:"ICC Profile",34850:"ExposureProgram",34853:"GPSInfo",34855:"ISOSpeedRatings",34858:"TimeZoneOffset",34859:"SelfTimeMode",
			36867:"DateTimeOriginal",36868:"DateTimeDigitized",
			37377:"ShutterSpeedValue",37378:"ApertureValue",37380:"ExposureBiasValue",37383:"MeteringMode",37385:"Flash",37386:"FocalLength",
			37390:"FocalPlaneXResolution",37391:"FocalPlaneYResolution",37392:"FocalPlaneResolutionUnit",37393:"ImageNumber",37398:"TIFF/EPStandardID",37399:"SensingMethod",
			37500:"MakerNote",37510:"UserComment",37724:"ImageSourceData",
			40092:"XPComment",40094:"XPKeywords",
			40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelXDimension",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",
			41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41990:"SceneCaptureType",
			50706:"DNGVersion",50707:"DNGBackwardVersion",50708:"UniqueCameraModel",50709:"LocalizedCameraModel",50710:"CFAPlaneColor",
			50711:"CFALayout",50712:"LinearizationTable",50713:"BlackLevelRepeatDim",50714:"BlackLevel",50716:"BlackLevelDeltaV",50717:"WhiteLevel",
			50718:"DefaultScale",50719:"DefaultCropOrigin",
			50720:"DefaultCropSize",50733:"BayerGreenSplit",50738:"AntiAliasStrength",
			50721:"ColorMatrix1",50722:"ColorMatrix2",50723:"CameraCalibration1",50724:"CameraCalibration2",50727:"AnalogBalance",50728:"AsShotNeutral",
			50730:"BaselineExposure",50731:"BaselineNoise",50732:"BaselineSharpness",50734:"LinearResponseLimit",50735:"CameraSerialNumber",50736:"LensInfo",50739:"ShadowScale",
			50740:"DNGPrivateData",50741:"MakerNoteSafety",50778:"CalibrationIlluminant1",50779:"CalibrationIlluminant2",50780:"BestQualityScale",
			50781:"RawDataUniqueID",50827:"OriginalRawFileName",50829:"ActiveArea",50830:"MaskedAreas",50931:"CameraCalibrationSignature",50932:"ProfileCalibrationSignature",
			50935:"NoiseReductionApplied",50936:"ProfileName",50937:"ProfileHueSatMapDims",50938:"ProfileHueSatMapData1",50939:"ProfileHueSatMapData2",
			50940:"ProfileToneCurve",50941:"ProfileEmbedPolicy",50942:"ProfileCopyright",
			50964:"ForwardMatrix1",50965:"ForwardMatrix2",50966:"PreviewApplicationName",50967:"PreviewApplicationVersion",50969:"PreviewSettingsDigest",
			50970:"PreviewColorSpace",50971:"PreviewDateTime",50972:"RawImageDigest",
			51008:"OpcodeList1",51009:"OpcodeList2",51022:"OpcodeList3",51041:"NoiseProfile",51089:"OriginalDefaultFinalSize",
			51090:"OriginalBestQualityFinalSize",51091:"OriginalDefaultCropSize",51125:"DefaultUserCrop"};

UTIF.ttypes = {  256:3,257:3,258:3,   259:3, 262:3,  273:4,  274:3, 277:3,278:4,279:4, 282:5, 283:5, 284:3, 286:5,287:5, 296:3, 305:2, 306:2, 338:3, 513:4, 514:4, 34665:4  };

UTIF._readIFD = function(bin, data, offset, ifds)
{
	var cnt = bin.readUshort(data, offset);  offset+=2;
	var ifd = {};  ifds.push(ifd);

	//log(">>>----------------");
	for(var i=0; i<cnt; i++)
	{
		var tag  = bin.readUshort(data, offset);    offset+=2;
		var type = bin.readUshort(data, offset);    offset+=2;
		var num  = bin.readUint  (data, offset);    offset+=4;
		var voff = bin.readUint  (data, offset);    offset+=4;

		var arr = [];
		ifd["t"+tag] = arr;
		//ifd["t"+tag+"-"+UTIF.tags[tag]] = arr;
		if(type== 1 || type==7) {  for(var j=0; j<num; j++) arr.push(data[(num<5 ? offset-4 : voff)+j]); }
		if(type== 2) {  arr.push( bin.readASCII(data, (num<5 ? offset-4 : voff), num-1) );  }
		if(type== 3) {  for(var j=0; j<num; j++) arr.push(bin.readUshort(data, (num<3 ? offset-4 : voff)+2*j));  }
		if(type== 4) {  for(var j=0; j<num; j++) arr.push(bin.readUint  (data, (num<2 ? offset-4 : voff)+4*j));  }
		if(type== 5) {  for(var j=0; j<num; j++) arr.push(bin.readUint  (data, voff+j*8) / bin.readUint(data,voff+j*8+4));  }
		if(type== 8) {  for(var j=0; j<num; j++) arr.push(bin.readShort (data, (num<3 ? offset-4 : voff)+2*j));  }
		if(type== 9) {  for(var j=0; j<num; j++) arr.push(bin.readInt   (data, (num<2 ? offset-4 : voff)+4*j));  }
		if(type==10) {  for(var j=0; j<num; j++) arr.push(bin.readInt   (data, voff+j*8) / bin.readInt (data,voff+j*8+4));  }
		if(type==11) {  for(var j=0; j<num; j++) arr.push(bin.readFloat (data, voff+j*4));  }
		if(type==12) {  for(var j=0; j<num; j++) arr.push(bin.readDouble(data, voff+j*8));  }
		if(num!=0 && arr.length==0) log("unknown TIFF tag type: ", type, "num:",num);
		//log(tag, type, UTIF.tags[tag], arr);
		if(tag==330) for(var j=0; j<num; j++) UTIF._readIFD(bin, data, arr[j], ifds);
		//if(tag==34665) UTIF._readIFD(bin, data, arr[0], ifds);
	}
	//log("<<<---------------");
	return offset;
}

UTIF._writeIFD = function(bin, data, offset, ifd)
{
	var keys = Object.keys(ifd);
	bin.writeUshort(data, offset, keys.length);  offset+=2;

	var eoff = offset + keys.length*12 + 4;

	for(var ki=0; ki<keys.length; ki++)
	{
		var key = keys[ki];
		var tag = parseInt(key.slice(1)), type = UTIF.ttypes[tag];  if(type==null) throw new Error("unknown type of tag: "+tag);
		var val = ifd[key];  if(type==2) val=val[0]+"\u0000";  var num = val.length;
		bin.writeUshort(data, offset, tag );  offset+=2;
		bin.writeUshort(data, offset, type);  offset+=2;
		bin.writeUint  (data, offset, num );  offset+=4;

		var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][type] * num;
		var toff = offset;
		if(dlen>4) {  bin.writeUint(data, offset, eoff);  toff=eoff;  }

		if(type==2) {  bin.writeASCII(data, toff, val);   }
		if(type==3) {  for(var i=0; i<num; i++) bin.writeUshort(data, toff+2*i, val[i]);    }
		if(type==4) {  for(var i=0; i<num; i++) bin.writeUint  (data, toff+4*i, val[i]);    }
		if(type==5) {  for(var i=0; i<num; i++) {  bin.writeUint(data, toff+8*i, Math.round(val[i]*10000));  bin.writeUint(data, toff+8*i+4, 10000);  }   }
		if (type == 12) {  for (var i = 0; i < num; i++) bin.writeDouble(data, toff + 8 * i, val[i]); }

		if(dlen>4) {  dlen += (dlen&1);  eoff += dlen;  }
		offset += 4;
	}
	return [offset, eoff];
}

UTIF.toRGBA8 = function(out)
{
	var w = out.width, h = out.height, area = w*h, qarea = area*4, data = out.data;
	var img = new Uint8Array(area*4);
	// 0: WhiteIsZero, 1: BlackIsZero, 2: RGB, 3: Palette color, 4: Transparency mask, 5: CMYK
	var intp = out["t262"][0], bps = (out["t258"]?Math.min(32,out["t258"][0]):1), isLE = out.isLE ? 1 : 0;
	//log("interpretation: ", intp, "bps", bps, out);
	if(false) {}
	else if(intp==0)
	{
		var bpl = Math.ceil(bps*w/8);
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))& 1;  img[qi]=img[qi+1]=img[qi+2]=( 1-px)*255;  img[qi+3]=255;    }
			if(bps== 4) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>1)])>>(4-4*(i&1)))&15;  img[qi]=img[qi+1]=img[qi+2]=(15-px)* 17;  img[qi+3]=255;    }
			if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i];  img[qi]=img[qi+1]=img[qi+2]=255-px;  img[qi+3]=255;    }
		}
	}
	else if(intp==1)
	{
		var bpl = Math.ceil(bps*w/8);
		for(var y=0; y<h; y++) {
			var off = y*bpl, io = y*w;
			if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))&1;   img[qi]=img[qi+1]=img[qi+2]=(px)*255;  img[qi+3]=255;    }
			if(bps== 2) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>2)])>>(6-2*(i&3)))&3;   img[qi]=img[qi+1]=img[qi+2]=(px)* 85;  img[qi+3]=255;    }
			if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i];  img[qi]=img[qi+1]=img[qi+2]=    px;  img[qi+3]=255;    }
			if(bps==16) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+(2*i+isLE)];  img[qi]=img[qi+1]=img[qi+2]= Math.min(255,px);  img[qi+3]=255;    } // ladoga.tif
		}
	}
	else if(intp==2)
	{
		if(bps== 8) // this needs to be simplified ... how many channels are there???
		{
			if(out["t338"])
			{
				 if(out["t338"][0]>0) for(var i=0; i<qarea; i++) img[i] = data[i];	// sometimes t338 is 1 or 2 in case of Alpha
				 else  for(var i=0; i<qarea; i+=4) {  img[i] = data[i];  img[i+1] = data[i+1];  img[i+2] = data[i+2];  img[i+3] = 255;  }
			}
			else
			{
				var smpls = out["t258"]?out["t258"].length : 3;
				if(smpls==4) for(var i=0; i<qarea; i++) img[i] = data[i];
				if(smpls==3) for(var i=0; i< area; i++) {  var qi=i<<2, ti=i*3;  img[qi]=data[ti];  img[qi+1]=data[ti+1];  img[qi+2]=data[ti+2];  img[qi+3]=255;    }
			}
		}
		else  // 3x 16-bit channel
			for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  img[qi+3]=255;    }
	}
	else if(intp==3)
	{
		var map = out["t320"];
		for(var i=0; i<area; i++) {  var qi=i<<2, mi=data[i];  img[qi]=(map[mi]>>8);  img[qi+1]=(map[256+mi]>>8);  img[qi+2]=(map[512+mi]>>8);  img[qi+3]=255;    }
	}
	else if(intp==5) 
	{
		var smpls = out["t258"]?out["t258"].length : 4;
		var gotAlpha = smpls>4 ? 1 : 0;
		for(var i=0; i<area; i++) {
			var qi=i<<2, si=i*smpls;  var C=255-data[si], M=255-data[si+1], Y=255-data[si+2], K=(255-data[si+3])*(1/255);
			img[qi]=~~(C*K+0.5);  img[qi+1]=~~(M*K+0.5);  img[qi+2]=~~(Y*K+0.5);  img[qi+3]=255*(1-gotAlpha)+data[si+4]*gotAlpha;
		}
	}
	else log("Unknown Photometric interpretation: "+intp);
	return img;
}

UTIF.replaceIMG = function()
{
	var imgs = document.getElementsByTagName("img");
	for (var i=0; i<imgs.length; i++)
	{
		var img=imgs[i], src=img.getAttribute("src");  if(src==null) continue;
		var suff=src.split(".").pop().toLowerCase();
		if(suff!="tif" && suff!="tiff") continue;
		var xhr = new XMLHttpRequest();  UTIF._xhrs.push(xhr);  UTIF._imgs.push(img);
		xhr.open("GET", src);  xhr.responseType = "arraybuffer";
		xhr.onload = UTIF._imgLoaded;   xhr.send();
	}
}

UTIF._xhrs = [];  UTIF._imgs = [];
UTIF._imgLoaded = function(e)
{
	var buff = e.target.response;
	var ifds = UTIF.decode(buff), page = ifds[0];  UTIF.decodeImages(buff, ifds);
	var rgba = UTIF.toRGBA8(page), w=page.width, h=page.height;
	var ind = UTIF._xhrs.indexOf(e.target), img = UTIF._imgs[ind];
	UTIF._xhrs.splice(ind,1);  UTIF._imgs.splice(ind,1);
	var cnv = document.createElement("canvas");  cnv.width=w;  cnv.height=h;
	var ctx = cnv.getContext("2d"), imgd = ctx.createImageData(w,h);
	for(var i=0; i<rgba.length; i++) imgd.data[i]=rgba[i];       ctx.putImageData(imgd,0,0);
	var attr = ["style","class","id"];
	for(var i=0; i<attr.length; i++) cnv.setAttribute(attr[i], img.getAttribute(attr[i]));
	img.parentNode.replaceChild(cnv,img);
}


UTIF._binBE =
{
	nextZero   : function(data, o) {  while(data[o]!=0) o++;  return o;  },
	readUshort : function(buff, p) {  return (buff[p]<< 8) |  buff[p+1];  },
	readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+1];  a[1]=buff[p+0];                                    return UTIF._binBE. i16[0];  },
	readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE. i32[0];  },
	readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE.ui32[0];  },
	readASCII  : function(buff, p, l) {  var s = "";   for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);   return s; },
	readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+3-i];  return UTIF._binBE.fl32[0];  },
	readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+7-i];  return UTIF._binBE.fl64[0];  },

	writeUshort: function(buff, p, n) {  buff[p] = (n>> 8)&255;  buff[p+1] =  n&255;  },
	writeUint  : function(buff, p, n) {  buff[p] = (n>>24)&255;  buff[p+1] = (n>>16)&255;  buff[p+2] = (n>>8)&255;  buff[p+3] = (n>>0)&255;  },
	writeASCII : function(buff, p, s) {  for(var i = 0; i < s.length; i++)  buff[p+i] = s.charCodeAt(i);  },
	writeDouble: function(buff, p, n)
	{
		UTIF._binBE.fl64[0] = n;
		for (var i = 0; i < 8; i++) buff[p + i] = UTIF._binBE.ui8[7 - i];
	}
}
UTIF._binBE.ui8  = new Uint8Array  (8);
UTIF._binBE.i16  = new Int16Array  (UTIF._binBE.ui8.buffer);
UTIF._binBE.i32  = new Int32Array  (UTIF._binBE.ui8.buffer);
UTIF._binBE.ui32 = new Uint32Array (UTIF._binBE.ui8.buffer);
UTIF._binBE.fl32 = new Float32Array(UTIF._binBE.ui8.buffer);
UTIF._binBE.fl64 = new Float64Array(UTIF._binBE.ui8.buffer);

UTIF._binLE =
{
	nextZero   : UTIF._binBE.nextZero,
	readUshort : function(buff, p) {  return (buff[p+1]<< 8) |  buff[p];  },
	readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];                                    return UTIF._binBE. i16[0];  },
	readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE. i32[0];  },
	readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE.ui32[0];  },
	readASCII  : UTIF._binBE.readASCII,
	readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl32[0];  },
	readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl64[0];  }
}
UTIF._copyTile = function(tb, tw, th, b, w, h, xoff, yoff)
{
	//log("copyTile", tw, th,  w, h, xoff, yoff);
	var xlim = Math.min(tw, w-xoff);
	var ylim = Math.min(th, h-yoff);
	for(var y=0; y<ylim; y++)
	{
		var tof = (yoff+y)*w+xoff;
		var sof = y*tw;
		for(var x=0; x<xlim; x++) b[tof+x] = tb[sof+x];
	}
}


})(UTIF, pako);
})();

/***/ }),

/***/ "./server/app.js":
/*!***********************!*\
  !*** ./server/app.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(__dirname) {/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! express */ "express");
/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(express__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var express_session__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! express-session */ "express-session");
/* harmony import */ var express_session__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(express_session__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var body_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! body-parser */ "body-parser");
/* harmony import */ var body_parser__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(body_parser__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models */ "./server/models/index.js");
/* harmony import */ var _routes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./routes */ "./server/routes/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers */ "./server/helpers/index.js");
/* harmony import */ var _config_passport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config/passport */ "./server/config/passport.js");


var PORT = process.env.PORT || 7777;



 // middleware - before you even hit the routes it will run these first
// express.json();
// express.urlencoded({ extended: false });

var app = express__WEBPACK_IMPORTED_MODULE_0___default()();
app.use(body_parser__WEBPACK_IMPORTED_MODULE_2___default.a.json());
app.use(body_parser__WEBPACK_IMPORTED_MODULE_2___default.a.urlencoded({
  extended: true
})); // pass variables through our application through this middleware to all requests

app.use(function (req, res, next) {
  // in helpers can even do something like exports.moment = require('moment'); then you can use it like helpers.moment()
  res.locals.varEveryThingNeeds = 'required function or computation or even string';
  res.locals.helpers = _helpers__WEBPACK_IMPORTED_MODULE_5__["exampleComputation"];
  res.locals.helpersRun = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["exampleComputation"])('brown'); // will not go to the next custom middleware without next

  next();
}); //setting middleware
// serving static files out of the src folder

app.use(express__WEBPACK_IMPORTED_MODULE_0___default.a.static("".concat(__dirname, "/../dist"))); //Serves resources from public folder
// sets up routing

app.use(_routes__WEBPACK_IMPORTED_MODULE_4__["default"]); // passport strat After routing


app.use(express_session__WEBPACK_IMPORTED_MODULE_1___default()({
  secret: 'passport-tutorial',
  cookie: {
    maxAge: 60000
  },
  resave: false,
  saveUninitialized: false
}));
_models__WEBPACK_IMPORTED_MODULE_3__["default"].sequelize.sync({
  force: false
}).then(function () {
  app.listen(PORT, function () {
    console.log("\uD83D\uDD25 on port ".concat(PORT));
  });
});

var thing = __webpack_require__(/*! ./config/passport */ "./server/config/passport.js"); // models.sequelize.sync({ force: false })
//     .then(() => require('./config/passport'))
//     .then(() => {
//         const server = app.listen(PORT, () => {
//             console.log(` on port ${PORT}`);
//         });
//     })
//     .catch(err => console.log('fuckary', err));
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./server/config/config.json":
/*!***********************************!*\
  !*** ./server/config/config.json ***!
  \***********************************/
/*! exports provided: development, test, production, default */
/***/ (function(module) {

module.exports = {"development":{"username":"postgres","password":"brandonr82","database":"codeLove","sequelizeConfig":{"host":"localhost","dialect":"postgres","operatorsAliases":false,"pool":{"max":5,"min":0,"acquire":30000,"idle":10000},"logging":false,"freezeTableName":true,"define":{"timestamps":"time"}}},"test":{"username":"root","password":"sky1","database":"codelove","host":"127.0.0.1","dialect":"mysql"},"production":{"username":"root","password":"sky1","database":"codelove","host":"127.0.0.1","dialect":"mysql"}};

/***/ }),

/***/ "./server/config/passport.js":
/*!***********************************!*\
  !*** ./server/config/passport.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sequelize */ "sequelize");
/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sequelize__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var passport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! passport */ "passport");
/* harmony import */ var passport__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(passport__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var passport_local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! passport-local */ "passport-local");
/* harmony import */ var passport_local__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(passport_local__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _models_user__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/user */ "./server/models/user.js");



var env = "development" || false;

var config = __webpack_require__(/*! ./server/config/../config/config.json */ "./server/config/config.json")[env]; // const { database, username, password, sequelizeConfig } = config;
// const sequelize = new Sequelize(database, username, password, sequelizeConfig);


 // console.log(' User', Users);
// console.log(' sequelize', sequelize);
// console.log('', Sequelize.model);
// const Users = sequelize.model('User');

passport__WEBPACK_IMPORTED_MODULE_1___default.a.use(new passport_local__WEBPACK_IMPORTED_MODULE_2___default.a({
  usernameField: 'user[email]',
  passwordField: 'user[password]'
}, function (email, password, done) {
  _models_user__WEBPACK_IMPORTED_MODULE_3__["default"].findOne({
    email: email
  }).then(function (user) {
    console.log('user -->', user);

    if (!user || !user.validatePassword(password)) {
      return done(null, false, {
        errors: {
          'email or password': 'is invalid'
        }
      });
    }

    return done(null, user);
  }).catch(function (err) {
    return console.log(' passport failed');
  });
}));
console.log(' passport hit'); // module.exports = function(passport, user) {
//   var User = user;
//   console.log('user', user)
//   var LocalStrategy = require('passport-local').Strategy;
// passport.use(new LocalStrategy({
//   usernameField: 'user[email]',
//   passwordField: 'user[password]'
// }, (email, password, done) => {
//   Users.findOne({ email })
//     .then(user => {
//       if (!user || !user.validatePassword(password)) {
//         return done(null, false, { errors: { 'email or password': 'is invalid'} });
//       }
//       return done(null, user);
//     }).catch(err => console.log(' passport failed'));
// }));
// }

/***/ }),

/***/ "./server/controllers/exampleController.js":
/*!*************************************************!*\
  !*** ./server/controllers/exampleController.js ***!
  \*************************************************/
/*! exports provided: homepageExample, logTheName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "homepageExample", function() { return homepageExample; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logTheName", function() { return logTheName; });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// exports is like a global varibable any anything on exports will be importable in another file
var homepageExample = function homepageExample(req, res) {
  return res.send('workingtonz');
};
var logTheName = function logTheName(req, res) {
  var reversedName = _toConsumableArray(req.params.paramName).reverse().join('');

  res.send(reversedName);
};

/***/ }),

/***/ "./server/controllers/middlewareController.js":
/*!****************************************************!*\
  !*** ./server/controllers/middlewareController.js ***!
  \****************************************************/
/*! exports provided: auth, myMiddleware */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "auth", function() { return auth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "myMiddleware", function() { return myMiddleware; });
/* harmony import */ var express_jwt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! express-jwt */ "express-jwt");
/* harmony import */ var express_jwt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(express_jwt__WEBPACK_IMPORTED_MODULE_0__);
// middleware runs after request but before the response


var getTokensFromHeaders = function getTokensFromHeaders(req) {
  console.log('token func ran', req.body);
  var authorization = req.headers.authorization;

  if (authorization && authorization.split(' ')[0] === 'Token') {
    return authorization.split(' ')[1];
  }

  return null;
};

var auth = {
  required: express_jwt__WEBPACK_IMPORTED_MODULE_0___default()({
    secret: 'secret',
    userProperty: 'payload',
    getToken: getTokensFromHeaders
  }),
  optional: express_jwt__WEBPACK_IMPORTED_MODULE_0___default()({
    secret: 'secret',
    userProperty: 'payload',
    getToken: getTokensFromHeaders,
    credentialsRequired: false
  })
};
var myMiddleware = function myMiddleware(req, res, next) {
  req.workToDo = 'b';
  console.log(' bihhhhh');
  next();
};

/***/ }),

/***/ "./server/controllers/nodeAuthController.js":
/*!**************************************************!*\
  !*** ./server/controllers/nodeAuthController.js ***!
  \**************************************************/
/*! exports provided: newModel, activatePassportValidateUser, loggedInOnly */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newModel", function() { return newModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activatePassportValidateUser", function() { return activatePassportValidateUser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loggedInOnly", function() { return loggedInOnly; });
/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sequelize */ "sequelize");
/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sequelize__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var passport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! passport */ "passport");
/* harmony import */ var passport__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(passport__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models */ "./server/models/index.js");
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

 // import Sequelize from 'sequelize';



var User = _models__WEBPACK_IMPORTED_MODULE_2__["default"].User;
var newModel = function newModel(req, res, next) {
  var user = req.body.user; // browser version
  // const { email, password } = req.body; // postman
  // const user = { email: email, password: password };  // postman

  if (!user.email) {
    return res.status(422).json({
      errors: {
        email: 'is required'
      }
    });
  }

  if (!user.password) {
    return res.status(422).json({
      errors: {
        password: 'is required'
      }
    });
  }

  var options = {
    where: _objectSpread({}, user) // defaults: {
    //     email: 'Technical Lead JavaScript',
    //     password: 'password'
    //   }

  };
  return User.findOrCreate(options).spread(function (user, created) {
    console.log('', user.get({
      plain: true
    }));
    created ? console.log('route to here') : console.log('return or throw error');
  }).catch(function (err) {
    return console.log('err', err);
  });
};
var activatePassportValidateUser = function activatePassportValidateUser(req, res, next) {
  var user = req.body.user;

  if (!user.email) {
    return res.status(422).json({
      errors: {
        email: 'is required'
      }
    });
  }

  if (!user.password) {
    return res.status(422).json({
      errors: {
        password: 'is required'
      }
    });
  }

  return passport__WEBPACK_IMPORTED_MODULE_1___default.a.authenticate('local', {
    session: false
  }, function (err, passportUser, info) {
    if (err) {
      return next(err);
    }

    if (passportUser) {
      var _user = passportUser;
      _user.token = passportUser.generateJWT();
      return res.json({
        user: _user.toAuthJSON()
      });
    }

    return status(400).info;
  })(req, res, next);
};
var loggedInOnly = function loggedInOnly(req, res, next) {
  var id = req.payload.id;
  return User.findById(id).then(function (user) {
    if (!user) {
      return res.sendStatus(400);
    }

    return res.json({
      user: user.toAuthJSON()
    });
  });
};

/***/ }),

/***/ "./server/controllers/storeController.js":
/*!***********************************************!*\
  !*** ./server/controllers/storeController.js ***!
  \***********************************************/
/*! exports provided: addStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addStore", function() { return addStore; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
 // exports.addStore = (req, res) => {
//   res.writeHead(200, { 'Content-Type': 'text/html'});
//   fs.readFile('./src/index.html', (err, data) => {
//     err
//       ? res.send('file not found')
//       : res.write(data);
//     res.end();
//   });
// };

var addStore = function addStore(req, res) {
  res.sendFile('index.html', {
    root: './dist'
  });
};

/***/ }),

/***/ "./server/controllers/upload.js":
/*!**************************************!*\
  !*** ./server/controllers/upload.js ***!
  \**************************************/
/*! exports provided: upload, resize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upload", function() { return upload; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resize", function() { return resize; });
/* harmony import */ var multer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multer */ "multer");
/* harmony import */ var multer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(multer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jimp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jimp */ "./node_modules/jimp/es/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ "uuid");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_2__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var multerOptions = {
  storage: multer__WEBPACK_IMPORTED_MODULE_0___default.a.memoryStorage(),
  fileFilter: function fileFilter(req, file, next) {
    // cant trust file extensions, every single file has a mimeType
    var isPhoto = file.mimetype.startsWith('image/');
    return isPhoto ? next(null, true) : next({
      message: "that file type isnt allowed"
    }, false);
  }
};
var upload = multer__WEBPACK_IMPORTED_MODULE_0___default()(multerOptions).single('photo'); // calls next automatically

var resize =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(req, res, next) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.log('resize hit!!!'); // multer will pul file eon req IF it exist

            return _context.abrupt("return", !req.file ? next() : 'xx');

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function resize(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

/***/ }),

/***/ "./server/helpers/index.js":
/*!*********************************!*\
  !*** ./server/helpers/index.js ***!
  \*********************************/
/*! exports provided: exampleComputation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exampleComputation", function() { return exampleComputation; });
// exports.exampleComputation = (lastName) => lastName ? `${lastName}-jenkins` : 'noJoe-jenkins';
// const exampleComputation = (lastName) => lastName ? `${lastName}-jenkins` : 'noJoe-jenkins';
function exampleComputation(lastName) {
  return lastName ? "".concat(lastName, "-jenkins") : 'noJoe-jenkins';
}
; // export default exampleComputation

/***/ }),

/***/ "./server/models/index.js":
/*!********************************!*\
  !*** ./server/models/index.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(__filename, __dirname) {/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sequelize */ "sequelize");
/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sequelize__WEBPACK_IMPORTED_MODULE_0__);


var fs = __webpack_require__(/*! fs */ "fs");

var path = __webpack_require__(/*! path */ "path");


var basename = path.basename(__filename);
var env = "development" || false;

var config = __webpack_require__(/*! ./server/models/../config/config.json */ "./server/config/config.json")[env]; // const db = {};
// console.log('', config.database, config.username, config.password, config)


var database = config.database,
    username = config.username,
    password = config.password,
    sequelizeConfig = config.sequelizeConfig;
var sequelize = new sequelize__WEBPACK_IMPORTED_MODULE_0___default.a(database, username, password, sequelizeConfig);
sequelize.authenticate().then(function () {
  console.log(' Database connection successful');
}).catch(function (err) {
  console.error(' Unable to connect to the database:', err);
});
var db = {};
fs.readdirSync(__dirname).filter(function (file) {
  return file.indexOf('.') !== 0 && file !== 'index.js';
}).forEach(function (file) {
  var model = sequelize.import(path.join(__dirname, file));
  console.log(' db models', model.name);
  db[model.name] = model;
}); // console.log('sequelize -->', sequelize.model);
// console.log('', Sequelize)

Object.keys(db).forEach(function (modelName) {
  if ('associate' in db[modelName]) {
    db[modelName].associate(db);
  }
});
db.sequelize = sequelize;
db.Sequelize = sequelize__WEBPACK_IMPORTED_MODULE_0___default.a;
/* harmony default export */ __webpack_exports__["default"] = (db);
/* WEBPACK VAR INJECTION */}.call(this, "/index.js", "/"))

/***/ }),

/***/ "./server/models/user.js":
/*!*******************************!*\
  !*** ./server/models/user.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonwebtoken */ "jsonwebtoken");
/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_1__);




/* harmony default export */ __webpack_exports__["default"] = (function (sequelize, DataTypes) {
  var User = sequelize.define('User', {
    email: DataTypes.STRING,
    hash: DataTypes.STRING,
    salt: DataTypes.STRING,
    password: DataTypes.STRING,
    name: DataTypes.STRING,
    age: DataTypes.INTEGER,
    friends: DataTypes.ENUM('alice', 'doug'),
    popular: DataTypes.BOOLEAN
  }, {
    tableName: 'user',
    timestamps: true
  }); // ???? doesnt return anything

  User.setPassword = function (password) {
    this.salt = crypto__WEBPACK_IMPORTED_MODULE_0___default.a.randomBytes(16).toString('hex');
    this.hash = crypto__WEBPACK_IMPORTED_MODULE_0___default.a.pbkdf2Sync(password, this.salt, 10000, 512, 'sha512');
    console.log('', this.salt, '', this.hash);
  };

  User.validatePassword = function (password) {
    var hash = crypto__WEBPACK_IMPORTED_MODULE_0___default.a.pbkdf2Sync(password, this.salt, 10000, 512, 'sha512').toString('hex');
    console.log(' hash', hash);
    return this.hash = hash; // <===== triple equals maybe?
  };

  User.generateJWT = function () {
    var today = new Date();
    var expirationDate = new Date(today);
    expirationDate.setDate(today.getDate() * 60);
    console.log(' today, expration', today, expirationDate, xpirationDate.setDate(today.getDate() * 60));
    console.log('', parseInt(expirationDate.getTime() / 1000, 10));
    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_1___default.a.sign({
      email: this.email,
      id: this._id,
      exp: parseInt(expirationDate.getTime() / 1000, 10)
    }, 'secret');
  };

  User.toAuthJSON = function () {
    var jwt = this.generateJWT();
    console.log('this._id, this.email, jwt', this._id, this.email, jwt);
    return {
      _id: this._id,
      email: this.email,
      token: jwt
    };
  }; // add an association later


  User.associate = function (models) {// associations can be defined here
    // User.belongsTo(models.Tasks, {
    //     // as: 'lastUserAction',
    //     // foreignKey: 'last_user_action',
    //     // onDelete: 'cascade',
    //     // hooks: 'true',
    //   }
    // );
  };

  return User;
});
;

/***/ }),

/***/ "./server/routes/index.js":
/*!********************************!*\
  !*** ./server/routes/index.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! express */ "express");
/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(express__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _controllers_exampleController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../controllers/exampleController */ "./server/controllers/exampleController.js");
/* harmony import */ var _controllers_storeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controllers/storeController */ "./server/controllers/storeController.js");
/* harmony import */ var _controllers_nodeAuthController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/nodeAuthController */ "./server/controllers/nodeAuthController.js");
/* harmony import */ var _controllers_upload__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../controllers/upload */ "./server/controllers/upload.js");
/* harmony import */ var _controllers_middlewareController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../controllers/middlewareController */ "./server/controllers/middlewareController.js");

var router = express__WEBPACK_IMPORTED_MODULE_0___default.a.Router();




 // router.use('/api', require('./api')); // auth works now we need to create controllers for logging in auth optinal and auth required for stuff you should be logged in for
// router.post('/home', newModel);

router.post('/upload', _controllers_upload__WEBPACK_IMPORTED_MODULE_4__["upload"], _controllers_upload__WEBPACK_IMPORTED_MODULE_4__["resize"], _controllers_storeController__WEBPACK_IMPORTED_MODULE_2__["addStore"]);
;
router.post('/home', _controllers_middlewareController__WEBPACK_IMPORTED_MODULE_5__["auth"].optional, _controllers_nodeAuthController__WEBPACK_IMPORTED_MODULE_3__["newModel"]);
router.post('/login', _controllers_middlewareController__WEBPACK_IMPORTED_MODULE_5__["auth"].optional, _controllers_nodeAuthController__WEBPACK_IMPORTED_MODULE_3__["activatePassportValidateUser"]);
router.post('/current', _controllers_middlewareController__WEBPACK_IMPORTED_MODULE_5__["auth"].required, _controllers_nodeAuthController__WEBPACK_IMPORTED_MODULE_3__["loggedInOnly"]);
router.get('/logthename/:paramName', _controllers_exampleController__WEBPACK_IMPORTED_MODULE_1__["logTheName"]);
router.get('/add', _controllers_storeController__WEBPACK_IMPORTED_MODULE_2__["addStore"]); // ** route specific middleware

router.get('/', _controllers_middlewareController__WEBPACK_IMPORTED_MODULE_5__["myMiddleware"], _controllers_exampleController__WEBPACK_IMPORTED_MODULE_1__["homepageExample"]);
/* harmony default export */ __webpack_exports__["default"] = (router);

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("body-parser");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("express");

/***/ }),

/***/ "express-jwt":
/*!******************************!*\
  !*** external "express-jwt" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("express-jwt");

/***/ }),

/***/ "express-session":
/*!**********************************!*\
  !*** external "express-session" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("express-session");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("jsonwebtoken");

/***/ }),

/***/ "mime":
/*!***********************!*\
  !*** external "mime" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("mime");

/***/ }),

/***/ "mkdirp":
/*!*************************!*\
  !*** external "mkdirp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("mkdirp");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("multer");

/***/ }),

/***/ "pako":
/*!***********************!*\
  !*** external "pako" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("pako");

/***/ }),

/***/ "passport":
/*!***************************!*\
  !*** external "passport" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("passport");

/***/ }),

/***/ "passport-local":
/*!*********************************!*\
  !*** external "passport-local" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("passport-local");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),

/***/ "sequelize":
/*!****************************!*\
  !*** external "sequelize" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("sequelize");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("uuid");

/***/ }),

/***/ "xml2js":
/*!*************************!*\
  !*** external "xml2js" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("xml2js");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL2JtcC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9lcy9jb21wb3NpdGUvY29tcG9zaXRlLW1vZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL2NvbXBvc2l0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9lcy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZXMvbW9kdWxlcy9waGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9lcy9yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL3V0aWxzL2ltYWdlLWJpdG1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9lcy91dGlscy9taW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL3V0aWxzL3Byb21pc2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvY3VzdG9tL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AamltcC9naWYvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL2pwZWcvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1ibGl0L2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tYmx1ci9lcy9ibHVyLXRhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWJsdXIvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1jb2xvci9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWNvbnRhaW4vZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1jb3Zlci9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWNyb3AvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1kaXNwbGFjZS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWRpdGhlci9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWZsaXAvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1nYXVzc2lhbi9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWludmVydC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLW1hc2svZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1ub3JtYWxpemUvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1wcmludC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLXByaW50L2VzL21lYXN1cmUtdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLXJlc2l6ZS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLXJlc2l6ZS9lcy9tb2R1bGVzL3Jlc2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLXJlc2l6ZS9lcy9tb2R1bGVzL3Jlc2l6ZTIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yb3RhdGUvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1zY2FsZS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2lucy9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvcG5nL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AamltcC90aWZmL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AamltcC90eXBlcy9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGppbXAvdXRpbHMvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FueS1iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnktYmFzZS9zcmMvY29udmVydGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibXAtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JtcC1qcy9saWIvZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm1wLWpzL2xpYi9lbmNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXItZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4aWYtcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leGlmLXBhcnNlci9saWIvYnVmZmVyc3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leGlmLXBhcnNlci9saWIvZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhpZi1wYXJzZXIvbGliL2RvbS1idWZmZXJzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4aWYtcGFyc2VyL2xpYi9leGlmLXRhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4aWYtcGFyc2VyL2xpYi9leGlmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leGlmLXBhcnNlci9saWIvanBlZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhpZi1wYXJzZXIvbGliL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhpZi1wYXJzZXIvbGliL3NpbXBsaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maWxlLXR5cGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppbXAvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pwZWctanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pwZWctanMvbGliL2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pwZWctanMvbGliL2VuY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvYWQtYm1mb250L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2FkLWJtZm9udC9saWIvaXMtYmluYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbWdnaWYvb21nZ2lmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1ibWZvbnQtYXNjaWkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWJtZm9udC1iaW5hcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWJtZm9udC14bWwvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1ibWZvbnQteG1sL2xpYi9wYXJzZS1hdHRyaWJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9waGluL2xpYi9waGluLmNvbXBpbGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9waXhlbG1hdGNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbmdqcy9saWIvYml0bWFwcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbmdqcy9saWIvYml0cGFja2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbmdqcy9saWIvY2h1bmtzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9jcmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9maWx0ZXItcGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG5nanMvbGliL2ZpbHRlci1wYXJzZS1hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG5nanMvbGliL2ZpbHRlci1wYXJzZS1zeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbmdqcy9saWIvZmlsdGVyLXBhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbmdqcy9saWIvZm9ybWF0LW5vcm1hbGlzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9pbnRlcmxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9wYWNrZXItYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9wYWNrZXItc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG5nanMvbGliL3BhY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG5nanMvbGliL3BhZXRoLXByZWRpY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG5nanMvbGliL3BhcnNlci1hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG5nanMvbGliL3BhcnNlci1zeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbmdqcy9saWIvcGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbmdqcy9saWIvcG5nLXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9wbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9zeW5jLWluZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BuZ2pzL2xpYi9zeW5jLXJlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltbS9saWIvdGltbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlueWNvbG9yMi90aW55Y29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWYvVVRJRi5qcyIsIndlYnBhY2s6Ly8vLi9zZXJ2ZXIvYXBwLmpzIiwid2VicGFjazovLy8uL3NlcnZlci9jb25maWcvcGFzc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2VydmVyL2NvbnRyb2xsZXJzL2V4YW1wbGVDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL3NlcnZlci9jb250cm9sbGVycy9taWRkbGV3YXJlQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zZXJ2ZXIvY29udHJvbGxlcnMvbm9kZUF1dGhDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL3NlcnZlci9jb250cm9sbGVycy9zdG9yZUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc2VydmVyL2NvbnRyb2xsZXJzL3VwbG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zZXJ2ZXIvaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zZXJ2ZXIvbW9kZWxzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NlcnZlci9tb2RlbHMvdXNlci5qcyIsIndlYnBhY2s6Ly8vLi9zZXJ2ZXIvcm91dGVzL2luZGV4LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImFzc2VydFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImJvZHktcGFyc2VyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYnVmZmVyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY3J5cHRvXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXhwcmVzc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImV4cHJlc3Mtand0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXhwcmVzcy1zZXNzaW9uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqc29ud2VidG9rZW5cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJtaW1lXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibWtkaXJwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibXVsdGVyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGFrb1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcInBhc3Nwb3J0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGFzc3BvcnQtbG9jYWxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicXVlcnlzdHJpbmdcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzZXF1ZWxpemVcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidXVpZFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInhtbDJqc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcInpsaWJcIiJdLCJuYW1lcyI6WyJQT1JUIiwicHJvY2VzcyIsImVudiIsImFwcCIsImV4cHJlc3MiLCJ1c2UiLCJib2R5UGFyc2VyIiwianNvbiIsInVybGVuY29kZWQiLCJleHRlbmRlZCIsInJlcSIsInJlcyIsIm5leHQiLCJsb2NhbHMiLCJ2YXJFdmVyeVRoaW5nTmVlZHMiLCJoZWxwZXJzIiwiZXhhbXBsZUNvbXB1dGF0aW9uIiwiaGVscGVyc1J1biIsInN0YXRpYyIsIl9fZGlybmFtZSIsInJvdXRlciIsInNlc3Npb24iLCJzZWNyZXQiLCJjb29raWUiLCJtYXhBZ2UiLCJyZXNhdmUiLCJzYXZlVW5pbml0aWFsaXplZCIsIm1vZGVscyIsInNlcXVlbGl6ZSIsInN5bmMiLCJmb3JjZSIsInRoZW4iLCJsaXN0ZW4iLCJjb25zb2xlIiwibG9nIiwidGhpbmciLCJyZXF1aXJlIiwiY29uZmlnIiwicGFzc3BvcnQiLCJMb2NhbFN0cmF0ZWd5IiwidXNlcm5hbWVGaWVsZCIsInBhc3N3b3JkRmllbGQiLCJlbWFpbCIsInBhc3N3b3JkIiwiZG9uZSIsIlVzZXJzIiwiZmluZE9uZSIsInVzZXIiLCJ2YWxpZGF0ZVBhc3N3b3JkIiwiZXJyb3JzIiwiY2F0Y2giLCJlcnIiLCJob21lcGFnZUV4YW1wbGUiLCJzZW5kIiwibG9nVGhlTmFtZSIsInJldmVyc2VkTmFtZSIsInBhcmFtcyIsInBhcmFtTmFtZSIsInJldmVyc2UiLCJqb2luIiwiZ2V0VG9rZW5zRnJvbUhlYWRlcnMiLCJib2R5IiwiYXV0aG9yaXphdGlvbiIsImhlYWRlcnMiLCJzcGxpdCIsImF1dGgiLCJyZXF1aXJlZCIsImp3dCIsInVzZXJQcm9wZXJ0eSIsImdldFRva2VuIiwib3B0aW9uYWwiLCJjcmVkZW50aWFsc1JlcXVpcmVkIiwibXlNaWRkbGV3YXJlIiwid29ya1RvRG8iLCJVc2VyIiwiTW9kZWxzIiwibmV3TW9kZWwiLCJzdGF0dXMiLCJvcHRpb25zIiwid2hlcmUiLCJmaW5kT3JDcmVhdGUiLCJzcHJlYWQiLCJjcmVhdGVkIiwiZ2V0IiwicGxhaW4iLCJhY3RpdmF0ZVBhc3Nwb3J0VmFsaWRhdGVVc2VyIiwiYXV0aGVudGljYXRlIiwicGFzc3BvcnRVc2VyIiwiaW5mbyIsInRva2VuIiwiZ2VuZXJhdGVKV1QiLCJ0b0F1dGhKU09OIiwibG9nZ2VkSW5Pbmx5IiwiaWQiLCJwYXlsb2FkIiwiZmluZEJ5SWQiLCJzZW5kU3RhdHVzIiwiYWRkU3RvcmUiLCJzZW5kRmlsZSIsInJvb3QiLCJtdWx0ZXJPcHRpb25zIiwic3RvcmFnZSIsIm11bHRlciIsIm1lbW9yeVN0b3JhZ2UiLCJmaWxlRmlsdGVyIiwiZmlsZSIsImlzUGhvdG8iLCJtaW1ldHlwZSIsInN0YXJ0c1dpdGgiLCJtZXNzYWdlIiwidXBsb2FkIiwic2luZ2xlIiwicmVzaXplIiwibGFzdE5hbWUiLCJmcyIsInBhdGgiLCJiYXNlbmFtZSIsIl9fZmlsZW5hbWUiLCJkYXRhYmFzZSIsInVzZXJuYW1lIiwic2VxdWVsaXplQ29uZmlnIiwiU2VxdWVsaXplIiwiZXJyb3IiLCJkYiIsInJlYWRkaXJTeW5jIiwiZmlsdGVyIiwiaW5kZXhPZiIsImZvckVhY2giLCJtb2RlbCIsImltcG9ydCIsIm5hbWUiLCJPYmplY3QiLCJrZXlzIiwibW9kZWxOYW1lIiwiYXNzb2NpYXRlIiwiRGF0YVR5cGVzIiwiZGVmaW5lIiwiU1RSSU5HIiwiaGFzaCIsInNhbHQiLCJhZ2UiLCJJTlRFR0VSIiwiZnJpZW5kcyIsIkVOVU0iLCJwb3B1bGFyIiwiQk9PTEVBTiIsInRhYmxlTmFtZSIsInRpbWVzdGFtcHMiLCJzZXRQYXNzd29yZCIsImNyeXB0byIsInJhbmRvbUJ5dGVzIiwidG9TdHJpbmciLCJwYmtkZjJTeW5jIiwidG9kYXkiLCJEYXRlIiwiZXhwaXJhdGlvbkRhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInhwaXJhdGlvbkRhdGUiLCJwYXJzZUludCIsImdldFRpbWUiLCJzaWduIiwiX2lkIiwiZXhwIiwiUm91dGVyIiwicG9zdCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDJDQUEyQyxrQkFBa0Isa0NBQWtDLHFFQUFxRSxFQUFFLEVBQUUsT0FBTyxrQkFBa0IsRUFBRSxZQUFZOztBQUV0TDtBQUNVO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHdEQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDOzs7Ozs7Ozs7OztBQ25aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCLHFCQUFxQixVQUFVO0FBQy9CLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0IscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QixRQUFRO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkMseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTO0FBQ25DOztBQUVBLDRCQUE0QixTQUFTO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQ3ZRQTtBQUFBO0FBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGtCQUFrQjtBQUMvQiwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxzREFBVTtBQUN6Qjs7QUFFQTtBQUNBLGVBQWUsc0RBQVU7QUFDekI7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLFVBQVUsaUVBQWE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSCxpQzs7Ozs7Ozs7Ozs7O0FDdExBO0FBQUE7QUFBd0Q7QUFDeEM7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLHNCQUFzQjtBQUNyQyxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFVO0FBQ3pCOztBQUVBO0FBQ0EsZUFBZSxzREFBVTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxpRUFBYTtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsaUVBQWE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSCxpQzs7Ozs7Ozs7Ozs7O0FDaEVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQ0FBa0MsaUZBQWlGOztBQUVuSCwrQkFBK0Isd0VBQXdFOztBQUV2RyxpQ0FBaUMsK0hBQStIOztBQUVoSyxrQ0FBa0MsMEJBQTBCLDhDQUE4QyxnQkFBZ0IsT0FBTyxrQkFBa0IsRUFBRSxhQUFhLEVBQUU7O0FBRW5JO0FBQ1E7QUFDQTtBQUNKO0FBQ0k7QUFDRjtBQUNBO0FBQ0Y7QUFDQTtBQUNVO0FBQ047QUFDSTtBQUNSO0FBQ0E7QUFDRTtBQUNNO0FBQ0Y7QUFDSjtBQUN2QyxlQUFlLDJEQUFNLEVBQUUsMkRBQU0sRUFBRSx5REFBSSxFQUFFLDJEQUFNLEVBQUUsMERBQUssRUFBRSwwREFBSyxFQUFFLHlEQUFJLEVBQUUseURBQUksRUFBRSw4REFBUyxFQUFFLDREQUFNLEVBQUUsOERBQVEsRUFBRSwwREFBSSxFQUFFLDBEQUFJLEVBQUUsMkRBQUssRUFBRSw4REFBUSxFQUFFLDZEQUFPLEVBQUUsMkRBQUs7QUFDL0g7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsU0FBUyw4Q0FBUztBQUNsQixDQUFDLEVBQUU7QUFDSCxpQzs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkNBQTJDLGtCQUFrQixrQ0FBa0MscUVBQXFFLEVBQUUsRUFBRSxPQUFPLGtCQUFrQixFQUFFLFlBQVk7O0FBRW5MO0FBQzRCO0FBQ3hELDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dCO0FBQ2hCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDO0FBQ2hDLGdDQUFnQyxhQUFhLHlDQUFHO0FBQ2hELGdDQUFnQztBQUNoQyxvQkFBb0IseUNBQUc7QUFDdkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWEseUNBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixzQkFBc0I7QUFDdkMsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBOztBQUVBLFlBQVksaUVBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixzQkFBc0I7QUFDdkMsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBOztBQUVBLFlBQVksaUVBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixzQkFBc0I7QUFDdkMsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBOztBQUVBLFlBQVksaUVBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixzQkFBc0I7QUFDdkMsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBO0FBQ0EsaUJBQWlCLHNEQUFVO0FBQzNCOztBQUVBOztBQUVBLFlBQVksaUVBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNILGlDOzs7Ozs7Ozs7Ozs7QUNsSkE7QUFBQTtBQUFBO0FBQUEsMkNBQTJDLGtCQUFrQixrQ0FBa0MscUVBQXFFLEVBQUUsRUFBRSxPQUFPLGtCQUFrQixFQUFFLFlBQVk7O0FBRXZMO0FBQ3hCO0FBQ2dCO0FBQ2hCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDO0FBQ2hDLGlCQUFpQiwyQ0FBSTtBQUNyQjtBQUNBLE1BQU0sMkNBQUk7QUFDVixpQkFBaUIsMkNBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0M7QUFDaEMsaUJBQWlCLDJDQUFJO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyxFQUFFO0FBQ0gsaUM7Ozs7Ozs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWlDO0FBQ0g7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNaO0FBQ2hCLFNBQVMsc0RBQVMsQ0FBQywwREFBSSxJQUFJLHlEQUFHLElBQUkseURBQUcsSUFBSSwwREFBSSxJQUFJLHlEQUFHO0FBQ3BELENBQUMsRUFBRTtBQUNILGlDOzs7Ozs7Ozs7Ozs7QUNUQTtBQUFBO0FBQUE7QUFBQTtBQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUIsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7OztBQ3RDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBaUI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Qjs7Ozs7Ozs7Ozs7O0FDN0JhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDJEQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywyREFBZTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLEtBQUs7QUFDbEIsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLEtBQUs7QUFDbEIsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBLG1CQUFtQixnQkFBZ0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjLGVBQWUsVUFBVTs7QUFFdEQsK0JBQStCLFFBQVE7QUFDdkM7QUFDQSxtQkFBbUIsZ0JBQWdCOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGdEQUFnRDs7QUFFaEQsd0RBQXdEO0FBQ3hELCtDQUErQztBQUMvQyxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELCtDQUErQztBQUMvQyxrREFBa0Q7QUFDbEQsaURBQWlEO0FBQ2pELDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsZ0RBQWdEO0FBQ2hELHlEQUF5RDs7QUFFekQ7QUFDQTs7QUFFQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQSxPQUFPO0FBQ1AsbUNBQW1DO0FBQ25DLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hGQSxhQUFhLG1CQUFPLENBQUMsc0JBQVEsU0FBUzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2JBLGFBQWEsbUJBQU8sQ0FBQyw4REFBYzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsa0ZBQXdCO0FBQ3pEO0FBQ0EsR0FBRztBQUNILDBCQUEwQixtQkFBTyxDQUFDLDBFQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25GQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRixRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUNuZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QyxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QyxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEMsOEJBQThCLFVBQVU7QUFDeEMsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsVUFBVSxxQkFBcUIsWUFBWSxvQkFBb0IsWUFBWTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxVQUFVLHNDQUFzQyxVQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFVBQVUsc0NBQXNDLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNXpCQTtBQUFBO0FBQUE7QUFBQTtBQUFxQztBQUNMO0FBQ0k7QUFDckIsMkhBQVM7QUFDeEIsVUFBVSxtREFBSztBQUNmLFlBQVkscURBQU87QUFDbkIsQ0FBQyxDQUFDLEVBQUM7QUFDSCxpQzs7Ozs7Ozs7Ozs7QUNQQSxhQUFhLG1CQUFPLENBQUMsNERBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDTkEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDLHVCQUF1QixXQUFXO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQyx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDbitCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFNhOzs7QUFHYixZQUFZLG1CQUFPLENBQUMsOERBQWU7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLDhEQUFlOzs7QUFHbEM7O0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFxQyw0REFBNEQsU0FBWTtBQUNoSjtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDRCQUE0QixnQkFBZ0I7QUFDMUgsOEVBQThFLDJCQUEyQixnQkFBZ0I7QUFDekgscURBQXFELG9EQUFvRCxnQkFBZ0I7QUFDekgscURBQXFELG9EQUFvRCxnQkFBZ0I7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCwwQkFBMEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLGlDIiwiZmlsZSI6InNlcnZlci5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NlcnZlci9hcHAuanNcIik7XG4iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgQk1QIGZyb20gJ2JtcC1qcyc7XG5pbXBvcnQgeyBzY2FuIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xudmFyIE1JTUVfVFlQRSA9ICdpbWFnZS9ibXAnO1xudmFyIE1JTUVfVFlQRV9TRUNPTkQgPSAnaW1hZ2UveC1tcy1ibXAnO1xuXG5mdW5jdGlvbiB0b0FHQlIoaW1hZ2UpIHtcbiAgcmV0dXJuIHNjYW4oaW1hZ2UsIDAsIDAsIGltYWdlLmJpdG1hcC53aWR0aCwgaW1hZ2UuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHgsIHksIGluZGV4KSB7XG4gICAgdmFyIHJlZCA9IHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAwXTtcbiAgICB2YXIgZ3JlZW4gPSB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMV07XG4gICAgdmFyIGJsdWUgPSB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMl07XG4gICAgdmFyIGFscGhhID0gdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDNdO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAwXSA9IGFscGhhO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAxXSA9IGJsdWU7XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDJdID0gZ3JlZW47XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDNdID0gcmVkO1xuICB9KS5iaXRtYXA7XG59XG5cbmZ1bmN0aW9uIGZyb21BR0JSKGJpdG1hcCkge1xuICByZXR1cm4gc2Nhbih7XG4gICAgYml0bWFwOiBiaXRtYXBcbiAgfSwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaW5kZXgpIHtcbiAgICB2YXIgYWxwaGEgPSB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMF07XG4gICAgdmFyIGJsdWUgPSB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMV07XG4gICAgdmFyIGdyZWVuID0gdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDJdO1xuICAgIHZhciByZWQgPSB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgM107XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDBdID0gcmVkO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAxXSA9IGdyZWVuO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAyXSA9IGJsdWU7XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDNdID0gYml0bWFwLmlzX3dpdGhfYWxwaGEgPyBhbHBoYSA6IDB4ZmY7XG4gIH0pLmJpdG1hcDtcbn1cblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gIHJldHVybiBmcm9tQUdCUihCTVAuZGVjb2RlKGRhdGEpKTtcbn07XG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoaW1hZ2UpIHtcbiAgcmV0dXJuIEJNUC5lbmNvZGUodG9BR0JSKGltYWdlKSkuZGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIHZhciBfZGVjb2RlcnMsIF9lbmNvZGVycztcblxuICByZXR1cm4ge1xuICAgIG1pbWU6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgTUlNRV9UWVBFLCBbJ2JtcCddKSxcbiAgICBjb25zdGFudHM6IHtcbiAgICAgIE1JTUVfQk1QOiBNSU1FX1RZUEUsXG4gICAgICBNSU1FX1hfTVNfQk1QOiBNSU1FX1RZUEVfU0VDT05EXG4gICAgfSxcbiAgICBkZWNvZGVyczogKF9kZWNvZGVycyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2RlY29kZXJzLCBNSU1FX1RZUEUsIGRlY29kZSksIF9kZWZpbmVQcm9wZXJ0eShfZGVjb2RlcnMsIE1JTUVfVFlQRV9TRUNPTkQsIGRlY29kZSksIF9kZWNvZGVycyksXG4gICAgZW5jb2RlcnM6IChfZW5jb2RlcnMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9lbmNvZGVycywgTUlNRV9UWVBFLCBlbmNvZGUpLCBfZGVmaW5lUHJvcGVydHkoX2VuY29kZXJzLCBNSU1FX1RZUEVfU0VDT05ELCBlbmNvZGUpLCBfZW5jb2RlcnMpXG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBzcmNPdmVyKHNyYywgZHN0KSB7XG4gIHZhciBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgdmFyIGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgdmFyIHIgPSAoc3JjLnIgKiBzcmMuYSArIGRzdC5yICogZHN0LmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICB2YXIgZyA9IChzcmMuZyAqIHNyYy5hICsgZHN0LmcgKiBkc3QuYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIHZhciBiID0gKHNyYy5iICogc3JjLmEgKyBkc3QuYiAqIGRzdC5hICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZHN0T3ZlcihzcmMsIGRzdCkge1xuICB2YXIgb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICBzcmMuYSAqPSBvcHM7XG4gIHZhciBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIHZhciByID0gKGRzdC5yICogZHN0LmEgKyBzcmMuciAqIHNyYy5hICogKDEgLSBkc3QuYSkpIC8gYTtcbiAgdmFyIGcgPSAoZHN0LmcgKiBkc3QuYSArIHNyYy5nICogc3JjLmEgKiAoMSAtIGRzdC5hKSkgLyBhO1xuICB2YXIgYiA9IChkc3QuYiAqIGRzdC5hICsgc3JjLmIgKiBzcmMuYSAqICgxIC0gZHN0LmEpKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KHNyYywgZHN0KSB7XG4gIHZhciBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgdmFyIGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgdmFyIHNyYSA9IHNyYy5yICogc3JjLmE7XG4gIHZhciBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICB2YXIgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgdmFyIGRyYSA9IGRzdC5yICogZHN0LmE7XG4gIHZhciBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICB2YXIgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgdmFyIHIgPSAoc3JhICogZHJhICsgc3JhICogKDEgLSBkc3QuYSkgKyBkcmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICB2YXIgZyA9IChzZ2EgKiBkZ2EgKyBzZ2EgKiAoMSAtIGRzdC5hKSArIGRnYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIHZhciBiID0gKHNiYSAqIGRiYSArIHNiYSAqICgxIC0gZHN0LmEpICsgZGJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc2NyZWVuKHNyYywgZHN0KSB7XG4gIHZhciBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgdmFyIGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgdmFyIHNyYSA9IHNyYy5yICogc3JjLmE7XG4gIHZhciBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICB2YXIgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgdmFyIGRyYSA9IGRzdC5yICogZHN0LmE7XG4gIHZhciBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICB2YXIgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgdmFyIHIgPSAoc3JhICogZHN0LmEgKyBkcmEgKiBzcmMuYSAtIHNyYSAqIGRyYSArIHNyYSAqICgxIC0gZHN0LmEpICsgZHJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgdmFyIGcgPSAoc2dhICogZHN0LmEgKyBkZ2EgKiBzcmMuYSAtIHNnYSAqIGRnYSArIHNnYSAqICgxIC0gZHN0LmEpICsgZGdhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgdmFyIGIgPSAoc2JhICogZHN0LmEgKyBkYmEgKiBzcmMuYSAtIHNiYSAqIGRiYSArIHNiYSAqICgxIC0gZHN0LmEpICsgZGJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gb3ZlcmxheShzcmMsIGRzdCkge1xuICB2YXIgb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICBzcmMuYSAqPSBvcHM7XG4gIHZhciBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIHZhciBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICB2YXIgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgdmFyIHNiYSA9IHNyYy5iICogc3JjLmE7XG4gIHZhciBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICB2YXIgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgdmFyIGRiYSA9IGRzdC5iICogZHN0LmE7XG4gIHZhciByID0gKDIgKiBkcmEgPD0gZHN0LmEgPyAyICogc3JhICogZHJhICsgc3JhICogKDEgLSBkc3QuYSkgKyBkcmEgKiAoMSAtIHNyYy5hKSA6IHNyYSAqICgxICsgZHN0LmEpICsgZHJhICogKDEgKyBzcmMuYSkgLSAyICogZHJhICogc3JhIC0gZHN0LmEgKiBzcmMuYSkgLyBhO1xuICB2YXIgZyA9ICgyICogZGdhIDw9IGRzdC5hID8gMiAqIHNnYSAqIGRnYSArIHNnYSAqICgxIC0gZHN0LmEpICsgZGdhICogKDEgLSBzcmMuYSkgOiBzZ2EgKiAoMSArIGRzdC5hKSArIGRnYSAqICgxICsgc3JjLmEpIC0gMiAqIGRnYSAqIHNnYSAtIGRzdC5hICogc3JjLmEpIC8gYTtcbiAgdmFyIGIgPSAoMiAqIGRiYSA8PSBkc3QuYSA/IDIgKiBzYmEgKiBkYmEgKyBzYmEgKiAoMSAtIGRzdC5hKSArIGRiYSAqICgxIC0gc3JjLmEpIDogc2JhICogKDEgKyBkc3QuYSkgKyBkYmEgKiAoMSArIHNyYy5hKSAtIDIgKiBkYmEgKiBzYmEgLSBkc3QuYSAqIHNyYy5hKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRhcmtlbihzcmMsIGRzdCkge1xuICB2YXIgb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICBzcmMuYSAqPSBvcHM7XG4gIHZhciBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIHZhciBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICB2YXIgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgdmFyIHNiYSA9IHNyYy5iICogc3JjLmE7XG4gIHZhciBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICB2YXIgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgdmFyIGRiYSA9IGRzdC5iICogZHN0LmE7XG4gIHZhciByID0gKE1hdGgubWluKHNyYSAqIGRzdC5hLCBkcmEgKiBzcmMuYSkgKyBzcmEgKiAoMSAtIGRzdC5hKSArIGRyYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIHZhciBnID0gKE1hdGgubWluKHNnYSAqIGRzdC5hLCBkZ2EgKiBzcmMuYSkgKyBzZ2EgKiAoMSAtIGRzdC5hKSArIGRnYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIHZhciBiID0gKE1hdGgubWluKHNiYSAqIGRzdC5hLCBkYmEgKiBzcmMuYSkgKyBzYmEgKiAoMSAtIGRzdC5hKSArIGRiYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxpZ2h0ZW4oc3JjLCBkc3QpIHtcbiAgdmFyIG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgc3JjLmEgKj0gb3BzO1xuICB2YXIgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICB2YXIgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgdmFyIHNnYSA9IHNyYy5nICogc3JjLmE7XG4gIHZhciBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICB2YXIgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgdmFyIGRnYSA9IGRzdC5nICogZHN0LmE7XG4gIHZhciBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICB2YXIgciA9IChNYXRoLm1heChzcmEgKiBkc3QuYSwgZHJhICogc3JjLmEpICsgc3JhICogKDEgLSBkc3QuYSkgKyBkcmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICB2YXIgZyA9IChNYXRoLm1heChzZ2EgKiBkc3QuYSwgZGdhICogc3JjLmEpICsgc2dhICogKDEgLSBkc3QuYSkgKyBkZ2EgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICB2YXIgYiA9IChNYXRoLm1heChzYmEgKiBkc3QuYSwgZGJhICogc3JjLmEpICsgc2JhICogKDEgLSBkc3QuYSkgKyBkYmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXJkTGlnaHQoc3JjLCBkc3QpIHtcbiAgdmFyIG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgc3JjLmEgKj0gb3BzO1xuICB2YXIgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICB2YXIgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgdmFyIHNnYSA9IHNyYy5nICogc3JjLmE7XG4gIHZhciBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICB2YXIgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgdmFyIGRnYSA9IGRzdC5nICogZHN0LmE7XG4gIHZhciBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICB2YXIgciA9ICgyICogc3JhIDw9IHNyYy5hID8gMiAqIHNyYSAqIGRyYSArIHNyYSAqICgxIC0gZHN0LmEpICsgZHJhICogKDEgLSBzcmMuYSkgOiBzcmEgKiAoMSArIGRzdC5hKSArIGRyYSAqICgxICsgc3JjLmEpIC0gMiAqIGRyYSAqIHNyYSAtIGRzdC5hICogc3JjLmEpIC8gYTtcbiAgdmFyIGcgPSAoMiAqIHNnYSA8PSBzcmMuYSA/IDIgKiBzZ2EgKiBkZ2EgKyBzZ2EgKiAoMSAtIGRzdC5hKSArIGRnYSAqICgxIC0gc3JjLmEpIDogc2dhICogKDEgKyBkc3QuYSkgKyBkZ2EgKiAoMSArIHNyYy5hKSAtIDIgKiBkZ2EgKiBzZ2EgLSBkc3QuYSAqIHNyYy5hKSAvIGE7XG4gIHZhciBiID0gKDIgKiBzYmEgPD0gc3JjLmEgPyAyICogc2JhICogZGJhICsgc2JhICogKDEgLSBkc3QuYSkgKyBkYmEgKiAoMSAtIHNyYy5hKSA6IHNiYSAqICgxICsgZHN0LmEpICsgZGJhICogKDEgKyBzcmMuYSkgLSAyICogZGJhICogc2JhIC0gZHN0LmEgKiBzcmMuYSkgLyBhO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaWZmZXJlbmNlKHNyYywgZHN0KSB7XG4gIHZhciBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgdmFyIGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgdmFyIHNyYSA9IHNyYy5yICogc3JjLmE7XG4gIHZhciBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICB2YXIgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgdmFyIGRyYSA9IGRzdC5yICogZHN0LmE7XG4gIHZhciBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICB2YXIgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgdmFyIHIgPSAoc3JhICsgZHJhIC0gMiAqIE1hdGgubWluKHNyYSAqIGRzdC5hLCBkcmEgKiBzcmMuYSkpIC8gYTtcbiAgdmFyIGcgPSAoc2dhICsgZGdhIC0gMiAqIE1hdGgubWluKHNnYSAqIGRzdC5hLCBkZ2EgKiBzcmMuYSkpIC8gYTtcbiAgdmFyIGIgPSAoc2JhICsgZGJhIC0gMiAqIE1hdGgubWluKHNiYSAqIGRzdC5hLCBkYmEgKiBzcmMuYSkpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZXhjbHVzaW9uKHNyYywgZHN0KSB7XG4gIHZhciBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgdmFyIGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgdmFyIHNyYSA9IHNyYy5yICogc3JjLmE7XG4gIHZhciBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICB2YXIgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgdmFyIGRyYSA9IGRzdC5yICogZHN0LmE7XG4gIHZhciBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICB2YXIgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgdmFyIHIgPSAoc3JhICogZHN0LmEgKyBkcmEgKiBzcmMuYSAtIDIgKiBzcmEgKiBkcmEgKyBzcmEgKiAoMSAtIGRzdC5hKSArIGRyYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIHZhciBnID0gKHNnYSAqIGRzdC5hICsgZGdhICogc3JjLmEgLSAyICogc2dhICogZGdhICsgc2dhICogKDEgLSBkc3QuYSkgKyBkZ2EgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICB2YXIgYiA9IChzYmEgKiBkc3QuYSArIGRiYSAqIHNyYy5hIC0gMiAqIHNiYSAqIGRiYSArIHNiYSAqICgxIC0gZHN0LmEpICsgZGJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb3NpdGUtbW9kZXMuanMubWFwIiwiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiwgdGhyb3dFcnJvciB9IGZyb20gJ0BqaW1wL3V0aWxzJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgY29tcG9zaXRlTW9kZXMgZnJvbSAnLi9jb21wb3NpdGUtbW9kZXMnO1xuLyoqXG4gKiBDb21wb3NpdGVzIGEgc291cmNlIGltYWdlIG92ZXIgdG8gdGhpcyBpbWFnZSByZXNwZWN0aW5nIGFscGhhIGNoYW5uZWxzXG4gKiBAcGFyYW0ge0ppbXB9IHNyYyB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IHBvc2l0aW9uIHRvIGJsaXQgdGhlIGltYWdlXG4gKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBwb3NpdGlvbiB0byBibGl0IHRoZSBpbWFnZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgZGV0ZXJtaW5lIHdoYXQgbW9kZSB0byB1c2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zaXRlKHNyYywgeCwgeSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoIShzcmMgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSkge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ1RoZSBzb3VyY2UgbXVzdCBiZSBhIEppbXAgaW1hZ2UnLCBjYik7XG4gIH1cblxuICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInIHx8IHR5cGVvZiB5ICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3ggYW5kIHkgbXVzdCBiZSBudW1iZXJzJywgY2IpO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucy5tb2RlLFxuICAgICAgb3BhY2l0eVNvdXJjZSA9IF9vcHRpb25zLm9wYWNpdHlTb3VyY2UsXG4gICAgICBvcGFjaXR5RGVzdCA9IF9vcHRpb25zLm9wYWNpdHlEZXN0O1xuXG4gIGlmICghbW9kZSkge1xuICAgIG1vZGUgPSBjb25zdGFudHMuQkxFTkRfU09VUkNFX09WRVI7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wYWNpdHlTb3VyY2UgIT09ICdudW1iZXInIHx8IG9wYWNpdHlTb3VyY2UgPCAwIHx8IG9wYWNpdHlTb3VyY2UgPiAxKSB7XG4gICAgb3BhY2l0eVNvdXJjZSA9IDEuMDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3BhY2l0eURlc3QgIT09ICdudW1iZXInIHx8IG9wYWNpdHlEZXN0IDwgMCB8fCBvcGFjaXR5RGVzdCA+IDEpIHtcbiAgICBvcGFjaXR5RGVzdCA9IDEuMDtcbiAgfVxuXG4gIHZhciBibGVuZG1vZGUgPSBjb21wb3NpdGVNb2Rlc1ttb2RlXTsgLy8gcm91bmQgaW5wdXRcblxuICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgeSA9IE1hdGgucm91bmQoeSk7XG4gIHZhciBiYXNlSW1hZ2UgPSB0aGlzO1xuXG4gIGlmIChvcGFjaXR5RGVzdCAhPT0gMS4wKSB7XG4gICAgYmFzZUltYWdlLm9wYWNpdHkob3BhY2l0eURlc3QpO1xuICB9XG5cbiAgc3JjLnNjYW5RdWlldCgwLCAwLCBzcmMuYml0bWFwLndpZHRoLCBzcmMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHN4LCBzeSwgaWR4KSB7XG4gICAgdmFyIGRzdElkeCA9IGJhc2VJbWFnZS5nZXRQaXhlbEluZGV4KHggKyBzeCwgeSArIHN5LCBjb25zdGFudHMuRURHRV9DUk9QKTtcbiAgICB2YXIgYmxlbmRlZCA9IGJsZW5kbW9kZSh7XG4gICAgICByOiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDBdIC8gMjU1LFxuICAgICAgZzogdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSAvIDI1NSxcbiAgICAgIGI6IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gLyAyNTUsXG4gICAgICBhOiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdIC8gMjU1XG4gICAgfSwge1xuICAgICAgcjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDBdIC8gMjU1LFxuICAgICAgZzogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDFdIC8gMjU1LFxuICAgICAgYjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDJdIC8gMjU1LFxuICAgICAgYTogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdIC8gMjU1XG4gICAgfSwgb3BhY2l0eVNvdXJjZSk7XG4gICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDBdID0gdGhpcy5jb25zdHJ1Y3Rvci5saW1pdDI1NShibGVuZGVkLnIgKiAyNTUpO1xuICAgIGJhc2VJbWFnZS5iaXRtYXAuZGF0YVtkc3RJZHggKyAxXSA9IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUoYmxlbmRlZC5nICogMjU1KTtcbiAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMl0gPSB0aGlzLmNvbnN0cnVjdG9yLmxpbWl0MjU1KGJsZW5kZWQuYiAqIDI1NSk7XG4gICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdID0gdGhpcy5jb25zdHJ1Y3Rvci5saW1pdDI1NShibGVuZGVkLmEgKiAyNTUpO1xuICB9KTtcblxuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyB1c2VkIHRvIGF1dG8gcmVzaXppbmcgZXRjLlxuZXhwb3J0IHZhciBBVVRPID0gLTE7IC8vIEFsaWduIG1vZGVzIGZvciBjb3ZlciwgY29udGFpbiwgYml0IG1hc2tzXG5cbmV4cG9ydCB2YXIgSE9SSVpPTlRBTF9BTElHTl9MRUZUID0gMTtcbmV4cG9ydCB2YXIgSE9SSVpPTlRBTF9BTElHTl9DRU5URVIgPSAyO1xuZXhwb3J0IHZhciBIT1JJWk9OVEFMX0FMSUdOX1JJR0hUID0gNDtcbmV4cG9ydCB2YXIgVkVSVElDQUxfQUxJR05fVE9QID0gODtcbmV4cG9ydCB2YXIgVkVSVElDQUxfQUxJR05fTUlERExFID0gMTY7XG5leHBvcnQgdmFyIFZFUlRJQ0FMX0FMSUdOX0JPVFRPTSA9IDMyOyAvLyBibGVuZCBtb2Rlc1xuXG5leHBvcnQgdmFyIEJMRU5EX1NPVVJDRV9PVkVSID0gJ3NyY092ZXInO1xuZXhwb3J0IHZhciBCTEVORF9ERVNUSU5BVElPTl9PVkVSID0gJ2RzdE92ZXInO1xuZXhwb3J0IHZhciBCTEVORF9NVUxUSVBMWSA9ICdtdWx0aXBseSc7XG5leHBvcnQgdmFyIEJMRU5EX1NDUkVFTiA9ICdzY3JlZW4nO1xuZXhwb3J0IHZhciBCTEVORF9PVkVSTEFZID0gJ292ZXJsYXknO1xuZXhwb3J0IHZhciBCTEVORF9EQVJLRU4gPSAnZGFya2VuJztcbmV4cG9ydCB2YXIgQkxFTkRfTElHSFRFTiA9ICdsaWdodGVuJztcbmV4cG9ydCB2YXIgQkxFTkRfSEFSRExJR0hUID0gJ2hhcmRMaWdodCc7XG5leHBvcnQgdmFyIEJMRU5EX0RJRkZFUkVOQ0UgPSAnZGlmZmVyZW5jZSc7XG5leHBvcnQgdmFyIEJMRU5EX0VYQ0xVU0lPTiA9ICdleGNsdXNpb24nOyAvLyBFZGdlIEhhbmRsaW5nXG5cbmV4cG9ydCB2YXIgRURHRV9FWFRFTkQgPSAxO1xuZXhwb3J0IHZhciBFREdFX1dSQVAgPSAyO1xuZXhwb3J0IHZhciBFREdFX0NST1AgPSAzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsImZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IFBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yLCBzY2FuIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xuaW1wb3J0IGFueUJhc2UgZnJvbSAnYW55LWJhc2UnO1xuaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xuaW1wb3J0IHBpeGVsTWF0Y2ggZnJvbSAncGl4ZWxtYXRjaCc7XG5pbXBvcnQgdGlueUNvbG9yIGZyb20gJ3Rpbnljb2xvcjInO1xuaW1wb3J0IEltYWdlUEhhc2ggZnJvbSAnLi9tb2R1bGVzL3BoYXNoJztcbmltcG9ydCByZXF1ZXN0IGZyb20gJy4vcmVxdWVzdCc7XG5pbXBvcnQgY29tcG9zaXRlIGZyb20gJy4vY29tcG9zaXRlJztcbmltcG9ydCBwcm9taXNpZnkgZnJvbSAnLi91dGlscy9wcm9taXNpZnknO1xuaW1wb3J0ICogYXMgTUlNRSBmcm9tICcuL3V0aWxzL21pbWUnO1xuaW1wb3J0IHsgcGFyc2VCaXRtYXAgYXMgX3BhcnNlQml0bWFwLCBnZXRCdWZmZXIsIGdldEJ1ZmZlckFzeW5jIH0gZnJvbSAnLi91dGlscy9pbWFnZS1iaXRtYXAnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJzsgLy8gYW4gYXJyYXkgc3RvcmluZyB0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoIG9mIGhhc2hlcyBhdCB2YXJpb3VzIGJhc2VzXG4vLyAwIGFuZCAxIGRvIG5vdCBleGlzdCBhcyBwb3NzaWJsZSBoYXNoIGxlbmd0aHNcblxudmFyIG1heEhhc2hMZW5ndGggPSBbTmFOLCBOYU5dO1xuXG5mb3IgKHZhciBpID0gMjsgaSA8IDY1OyBpKyspIHtcbiAgdmFyIG1heEhhc2ggPSBhbnlCYXNlKGFueUJhc2UuQklOLCBhbHBoYWJldC5zbGljZSgwLCBpKSkobmV3IEFycmF5KDY0ICsgMSkuam9pbignMScpKTtcbiAgbWF4SGFzaExlbmd0aC5wdXNoKG1heEhhc2gubGVuZ3RoKTtcbn0gLy8gbm8gb3BlcmF0aW9uXG5cblxuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVycm9yIGNoZWNraW5nIG1ldGhvZHNcblxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHRlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0ZXN0KS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2FycmF5YnVmZmVyJykgPiAtMTtcbn0gLy8gUHJlcGFyZSBhIEJ1ZmZlciBvYmplY3QgZnJvbSB0aGUgYXJyYXlCdWZmZXIuIE5lY2Vzc2FyeSBpbiB0aGUgYnJvd3NlciA+IG5vZGUgY29udmVyc2lvbixcbi8vIEJ1dCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCB1c2VmdWwgd2hlbiBydW5uaW5nIGluIG5vZGUgZGlyZWN0bHlcblxuXG5mdW5jdGlvbiBidWZmZXJGcm9tQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJ1ZmZlci5sZW5ndGg7ICsrX2kpIHtcbiAgICBidWZmZXJbX2ldID0gdmlld1tfaV07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBsb2FkRnJvbVVSTChvcHRpb25zLCBjYikge1xuICByZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YoZGF0YSkgPT09ICdvYmplY3QnICYmIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIGNiKG51bGwsIGRhdGEpO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSAnQ291bGQgbm90IGxvYWQgQnVmZmVyIGZyb20gPCcgKyBvcHRpb25zLnVybCArICc+ICcgKyAnKEhUVFA6ICcgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgJyknO1xuICAgIHJldHVybiBuZXcgRXJyb3IobXNnKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRCdWZmZXJGcm9tUGF0aChzcmMsIGNiKSB7XG4gIGlmIChmcyAmJiB0eXBlb2YgZnMucmVhZEZpbGUgPT09ICdmdW5jdGlvbicgJiYgIXNyYy5tYXRjaCgvXihodHRwfGZ0cClzPzpcXC9cXC8uLykpIHtcbiAgICBmcy5yZWFkRmlsZShzcmMsIGNiKTtcbiAgfSBlbHNlIHtcbiAgICBsb2FkRnJvbVVSTCh7XG4gICAgICB1cmw6IHNyY1xuICAgIH0sIGNiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1Jhd1JHQkFEYXRhKG9iaikge1xuICByZXR1cm4gb2JqICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai53aWR0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iai5oZWlnaHQgPT09ICdudW1iZXInICYmIChCdWZmZXIuaXNCdWZmZXIob2JqLmRhdGEpIHx8IG9iai5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICdmdW5jdGlvbicgJiYgb2JqLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgJiYgKG9iai5kYXRhLmxlbmd0aCA9PT0gb2JqLndpZHRoICogb2JqLmhlaWdodCAqIDQgfHwgb2JqLmRhdGEubGVuZ3RoID09PSBvYmoud2lkdGggKiBvYmouaGVpZ2h0ICogMyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VSR0JBQnVmZmVyRnJvbVJHQihidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggJSAzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgbGVuZ3RoIGlzIGluY29ycmVjdCcpO1xuICB9XG5cbiAgdmFyIHJnYmFCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmZmVyLmxlbmd0aCAvIDMgKiA0KTtcbiAgdmFyIGogPSAwO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGJ1ZmZlci5sZW5ndGg7IF9pMisrKSB7XG4gICAgcmdiYUJ1ZmZlcltqXSA9IGJ1ZmZlcltfaTJdO1xuXG4gICAgaWYgKChfaTIgKyAxKSAlIDMgPT09IDApIHtcbiAgICAgIHJnYmFCdWZmZXJbKytqXSA9IDI1NTtcbiAgICB9XG5cbiAgICBqKys7XG4gIH1cblxuICByZXR1cm4gcmdiYUJ1ZmZlcjtcbn1cblxudmFyIGVtcHR5Qml0bWFwID0ge1xuICBkYXRhOiBudWxsLFxuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsXG59O1xuLyoqXG4gKiBKaW1wIGNvbnN0cnVjdG9yIChmcm9tIGEgZmlsZSlcbiAqIEBwYXJhbSBwYXRoIGEgcGF0aCB0byB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBpbWFnZSBpcyBwYXJzZWQgdG8gYSBiaXRtYXBcbiAqL1xuXG4vKipcbiAqIEppbXAgY29uc3RydWN0b3IgKGZyb20gYSB1cmwgd2l0aCBvcHRpb25zKVxuICogQHBhcmFtIG9wdGlvbnMgeyB1cmwsIG90aGVyT3B0aW9uc31cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBpbWFnZSBpcyBwYXJzZWQgdG8gYSBiaXRtYXBcbiAqL1xuXG4vKipcbiAqIEppbXAgY29uc3RydWN0b3IgKGZyb20gYW5vdGhlciBKaW1wIGltYWdlIG9yIHJhdyBpbWFnZSBkYXRhKVxuICogQHBhcmFtIGltYWdlIGEgSmltcCBpbWFnZSB0byBjbG9uZVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBpbWFnZSBpcyBwYXJzZWQgdG8gYSBiaXRtYXBcbiAqL1xuXG4vKipcbiAqIEppbXAgY29uc3RydWN0b3IgKGZyb20gYSBCdWZmZXIpXG4gKiBAcGFyYW0gZGF0YSBhIEJ1ZmZlciBjb250YWluaW5nIHRoZSBpbWFnZSBkYXRhXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGltYWdlIGlzIHBhcnNlZCB0byBhIGJpdG1hcFxuICovXG5cbi8qKlxuICogSmltcCBjb25zdHJ1Y3RvciAodG8gZ2VuZXJhdGUgYSBuZXcgaW1hZ2UpXG4gKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGltYWdlIGlzIHBhcnNlZCB0byBhIGJpdG1hcFxuICovXG5cbi8qKlxuICogSmltcCBjb25zdHJ1Y3RvciAodG8gZ2VuZXJhdGUgYSBuZXcgaW1hZ2UpXG4gKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCB0aGUgaW1hZ2Ugd2l0aFxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGltYWdlIGlzIHBhcnNlZCB0byBhIGJpdG1hcFxuICovXG5cbnZhciBKaW1wID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhKaW1wLCBfRXZlbnRFbWl0dGVyKTtcblxuICAvLyBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgYml0bWFwIGluIG1lbW9yeSwgY29tcHJpc2luZzpcbiAgLy8gIC0gZGF0YTogYSBidWZmZXIgb2YgdGhlIGJpdG1hcCBkYXRhXG4gIC8vICAtIHdpZHRoOiB0aGUgd2lkdGggb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuICAvLyAgLSBoZWlnaHQ6IHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuICAvLyBEZWZhdWx0IGNvbG91ciB0byB1c2UgZm9yIG5ldyBwaXhlbHNcbiAgLy8gRGVmYXVsdCBNSU1FIGlzIFBOR1xuICAvLyBFeGlmIGRhdGEgZm9yIHRoZSBpbWFnZVxuICAvLyBXaGV0aGVyIFRyYW5zcGFyZW5jeSBzdXBwb3J0aW5nIGZvcm1hdHMgd2lsbCBiZSBleHBvcnRlZCBhcyBSR0Igb3IgUkdCQVxuICBmdW5jdGlvbiBKaW1wKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSmltcCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihKaW1wKS5jYWxsKHRoaXMpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJiaXRtYXBcIiwgZW1wdHlCaXRtYXApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcIl9iYWNrZ3JvdW5kXCIsIDB4MDAwMDAwMDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcIl9vcmlnaW5hbE1pbWVcIiwgSmltcC5NSU1FX1BORyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwiX2V4aWZcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwiX3JnYmFcIiwgdHJ1ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwid3JpdGVBc3luY1wiLCBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHByb21pc2lmeShfdGhpcy53cml0ZSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIHBhdGgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcImdldEJhc2U2NEFzeW5jXCIsIGZ1bmN0aW9uIChtaW1lKSB7XG4gICAgICByZXR1cm4gcHJvbWlzaWZ5KF90aGlzLmdldEJhc2U2NCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIG1pbWUpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcImdldEJ1ZmZlclwiLCBnZXRCdWZmZXIpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcImdldEJ1ZmZlckFzeW5jXCIsIGdldEJ1ZmZlckFzeW5jKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJnZXRQaXhlbENvbG91clwiLCBfdGhpcy5nZXRQaXhlbENvbG9yKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJzZXRQaXhlbENvbG91clwiLCBfdGhpcy5zZXRQaXhlbENvbG9yKTtcblxuICAgIHZhciBqaW1wSW5zdGFuY2UgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHZhciBjYiA9IG5vb3A7XG5cbiAgICBpZiAoaXNBcnJheUJ1ZmZlcihhcmdzWzBdKSkge1xuICAgICAgYXJnc1swXSA9IGJ1ZmZlckZyb21BcnJheUJ1ZmZlcihhcmdzWzBdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyID0gYXJnc1swXTtcbiAgICAgIHZhciBldkRhdGEgPSBlcnIgfHwge307XG4gICAgICBldkRhdGEubWV0aG9kTmFtZSA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9jYjtcblxuICAgICAgICAvLyBydW4gb24gbmV4dCB0aWNrLlxuICAgICAgICBpZiAoZXJyICYmIGNiID09PSBub29wKSB7XG4gICAgICAgICAgamltcEluc3RhbmNlLmVtaXRFcnJvcignY29uc3RydWN0b3InLCBlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnIpIHtcbiAgICAgICAgICBqaW1wSW5zdGFuY2UuZW1pdE11bHRpKCdjb25zdHJ1Y3RvcicsICdpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgKF9jYiA9IGNiKS5jYWxsLmFwcGx5KF9jYiwgW2ppbXBJbnN0YW5jZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH0sIDEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdudW1iZXInIHx8IHBhcnNlSW50KGFyZ3NbMF0sIDEwKSAmJiBwYXJzZUludChhcmdzWzFdLCAxMCkpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBpbWFnZVxuICAgICAgdmFyIHcgPSBwYXJzZUludChhcmdzWzBdLCAxMCk7XG4gICAgICB2YXIgaCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIGNiID0gYXJnc1syXTsgLy8gd2l0aCBhIGhleCBjb2xvclxuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIF90aGlzLl9iYWNrZ3JvdW5kID0gYXJnc1syXTtcbiAgICAgICAgY2IgPSBhcmdzWzNdO1xuICAgICAgfSAvLyB3aXRoIGEgY3NzIGNvbG9yXG5cblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnc3RyaW5nJykge1xuICAgICAgICBfdGhpcy5fYmFja2dyb3VuZCA9IEppbXAuY3NzQ29sb3JUb0hleChhcmdzWzJdKTtcbiAgICAgICAgY2IgPSBhcmdzWzNdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYiA9IG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCB0aHJvd0Vycm9yLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksICdjYiBtdXN0IGJlIGEgZnVuY3Rpb24nLCBmaW5pc2gpKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYml0bWFwID0ge1xuICAgICAgICBkYXRhOiBCdWZmZXIuYWxsb2ModyAqIGggKiA0KSxcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaFxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgX3RoaXMuYml0bWFwLmRhdGEubGVuZ3RoOyBfaTMgKz0gNCkge1xuICAgICAgICBfdGhpcy5iaXRtYXAuZGF0YS53cml0ZVVJbnQzMkJFKF90aGlzLl9iYWNrZ3JvdW5kLCBfaTMpO1xuICAgICAgfVxuXG4gICAgICBmaW5pc2gobnVsbCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhcmdzWzBdKSA9PT0gJ29iamVjdCcgJiYgYXJnc1swXS51cmwpIHtcbiAgICAgIGNiID0gYXJnc1sxXSB8fCBub29wO1xuXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgdGhyb3dFcnJvci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJywgZmluaXNoKSk7XG4gICAgICB9XG5cbiAgICAgIGxvYWRGcm9tVVJMKGFyZ3NbMF0sIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIGVyciwgZmluaXNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnBhcnNlQml0bWFwKGRhdGEsIGFyZ3NbMF0udXJsLCBmaW5pc2gpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgSmltcCkge1xuICAgICAgLy8gY2xvbmUgYW4gZXhpc3RpbmcgSmltcFxuICAgICAgdmFyIG9yaWdpbmFsID0gYXJnc1swXTtcbiAgICAgIGNiID0gYXJnc1sxXTtcblxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2IgPSBub29wO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgdGhyb3dFcnJvci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJywgZmluaXNoKSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmJpdG1hcCA9IHtcbiAgICAgICAgZGF0YTogQnVmZmVyLmZyb20ob3JpZ2luYWwuYml0bWFwLmRhdGEpLFxuICAgICAgICB3aWR0aDogb3JpZ2luYWwuYml0bWFwLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG9yaWdpbmFsLmJpdG1hcC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBfdGhpcy5fcXVhbGl0eSA9IG9yaWdpbmFsLl9xdWFsaXR5O1xuICAgICAgX3RoaXMuX2RlZmxhdGVMZXZlbCA9IG9yaWdpbmFsLl9kZWZsYXRlTGV2ZWw7XG4gICAgICBfdGhpcy5fZGVmbGF0ZVN0cmF0ZWd5ID0gb3JpZ2luYWwuX2RlZmxhdGVTdHJhdGVneTtcbiAgICAgIF90aGlzLl9maWx0ZXJUeXBlID0gb3JpZ2luYWwuX2ZpbHRlclR5cGU7XG4gICAgICBfdGhpcy5fcmdiYSA9IG9yaWdpbmFsLl9yZ2JhO1xuICAgICAgX3RoaXMuX2JhY2tncm91bmQgPSBvcmlnaW5hbC5fYmFja2dyb3VuZDtcbiAgICAgIF90aGlzLl9vcmlnaW5hbE1pbWUgPSBvcmlnaW5hbC5fb3JpZ2luYWxNaW1lO1xuICAgICAgZmluaXNoKG51bGwsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICB9IGVsc2UgaWYgKGlzUmF3UkdCQURhdGEoYXJnc1swXSkpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBhcmdzWzBdO1xuICAgICAgY2IgPSBhcmdzWzFdIHx8IG5vb3A7XG4gICAgICB2YXIgaXNSR0JBID0gaW1hZ2VEYXRhLndpZHRoICogaW1hZ2VEYXRhLmhlaWdodCAqIDQgPT09IGltYWdlRGF0YS5kYXRhLmxlbmd0aDtcbiAgICAgIHZhciBidWZmZXIgPSBpc1JHQkEgPyBCdWZmZXIuZnJvbShpbWFnZURhdGEuZGF0YSkgOiBtYWtlUkdCQUJ1ZmZlckZyb21SR0IoaW1hZ2VEYXRhLmRhdGEpO1xuICAgICAgX3RoaXMuYml0bWFwID0ge1xuICAgICAgICBkYXRhOiBidWZmZXIsXG4gICAgICAgIHdpZHRoOiBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGZpbmlzaChudWxsLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJlYWQgZnJvbSBhIHBhdGhcbiAgICAgIHZhciBwYXRoID0gYXJnc1swXTtcbiAgICAgIGNiID0gYXJnc1sxXTtcblxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2IgPSBub29wO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgdGhyb3dFcnJvci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJywgZmluaXNoKSk7XG4gICAgICB9XG5cbiAgICAgIGxvYWRCdWZmZXJGcm9tUGF0aChwYXRoLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBlcnIsIGZpbmlzaCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5wYXJzZUJpdG1hcChkYXRhLCBwYXRoLCBmaW5pc2gpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGFyZ3NbMF0pID09PSAnb2JqZWN0JyAmJiBCdWZmZXIuaXNCdWZmZXIoYXJnc1swXSkpIHtcbiAgICAgIC8vIHJlYWQgZnJvbSBhIGJ1ZmZlclxuICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgY2IgPSBhcmdzWzFdO1xuXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgdGhyb3dFcnJvci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJywgZmluaXNoKSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnBhcnNlQml0bWFwKGRhdGEsIG51bGwsIGZpbmlzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFsbG93IGNsaWVudCBsaWJzIHRvIGFkZCBuZXcgd2F5cyB0byBidWlsZCBhIEppbXAgb2JqZWN0LlxuICAgICAgLy8gRXh0cmEgY29uc3RydWN0b3JzIG11c3QgYmUgYWRkZWQgYnkgYEppbXAuYXBwZW5kQ29uc3RydWN0b3JPcHRpb24oKWBcbiAgICAgIGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IHRyeSB0byBzb2x2ZSB0aGUgYXJncyBhZnRlciBjYiBwcm9ibGVtLlxuICAgICAgICBjYiA9IGFyZ3NbYXJncy5sZW5ndGggLSAyXTtcblxuICAgICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2IgPSBub29wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRyYUNvbnN0cnVjdG9yID0gSmltcC5fX2V4dHJhQ29uc3RydWN0b3JzLmZpbmQoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMudGVzdC5hcHBseShjLCBhcmdzKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXh0cmFDb25zdHJ1Y3Rvcikge1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIF9leHRyYUNvbnN0cnVjdG9yJHJ1bjtcblxuICAgICAgICAgIHJldHVybiAoX2V4dHJhQ29uc3RydWN0b3IkcnVuID0gZXh0cmFDb25zdHJ1Y3Rvci5ydW4pLmNhbGwuYXBwbHkoX2V4dHJhQ29uc3RydWN0b3IkcnVuLCBbX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIHJlc29sdmUsIHJlamVjdF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaChudWxsLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgICAgIH0pLmNhdGNoKGZpbmlzaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIHRocm93RXJyb3IuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgJ05vIG1hdGNoaW5nIGNvbnN0cnVjdG9yIG92ZXJsb2FkaW5nIHdhcyBmb3VuZC4gJyArICdQbGVhc2Ugc2VlIHRoZSBkb2NzIGZvciBob3cgdG8gY2FsbCB0aGUgSmltcCBjb25zdHJ1Y3Rvci4nLCBmaW5pc2gpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgYml0bWFwIHdpdGggdGhlIGxvYWRlZCBpbWFnZSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgcmF3IGltYWdlIGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggb3B0aW9uYWwgcGF0aCB0byBmaWxlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQG1lbWJlcm9mIEppbXBcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSmltcCwgW3tcbiAgICBrZXk6IFwicGFyc2VCaXRtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VCaXRtYXAoZGF0YSwgcGF0aCwgZmluaXNoKSB7XG4gICAgICBfcGFyc2VCaXRtYXAuY2FsbCh0aGlzLCBkYXRhLCBudWxsLCBmaW5pc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0eXBlIG9mIHRoZSBpbWFnZSAoUkdCIG9yIFJHQkEpIHdoZW4gc2F2aW5nIGluIGEgZm9ybWF0IHRoYXQgc3VwcG9ydHMgdHJhbnNwYXJlbmN5IChkZWZhdWx0IGlzIFJHQkEpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBib29sIEEgQm9vbGVhbiwgdHJ1ZSB0byB1c2UgUkdCQSBvciBmYWxzZSB0byB1c2UgUkdCXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZ2JhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJnYmEoYm9vbCwgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ2Jvb2wgbXVzdCBiZSBhIGJvb2xlYW4sIHRydWUgZm9yIFJHQkEgb3IgZmFsc2UgZm9yIFJHQicsIGNiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmdiYSA9IGJvb2w7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBmb3IgbXVsdGlwbGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGVtaXQgYW4gZXJyb3IgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBuYW1lIG9mIHRoZSBldmVudE5hbWUgdG8gZW1pdCBhbiBlcnJvciBmb3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSB0byBlbWl0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0TXVsdGlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdE11bHRpKG1ldGhvZE5hbWUsIGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgZGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoJ2FueScsIGRhdGEpO1xuXG4gICAgICBpZiAobWV0aG9kTmFtZSkge1xuICAgICAgICB0aGlzLmVtaXQobWV0aG9kTmFtZSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWl0RXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdEVycm9yKG1ldGhvZE5hbWUsIGVycikge1xuICAgICAgdGhpcy5lbWl0TXVsdGkobWV0aG9kTmFtZSwgJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGltYWdlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgaW1hZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYml0bWFwLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOaWNlbHkgZm9ybWF0IEppbXAgb2JqZWN0IHdoZW4gc2VudCB0byB0aGUgY29uc29sZSBlLmcuIGNvbnNvbGUubG9nKGltYWdlKVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHByZXR0eSBwcmludGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbnNwZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICByZXR1cm4gJzxKaW1wICcgKyAodGhpcy5iaXRtYXAgPT09IGVtcHR5Qml0bWFwID8gJ3BlbmRpbmcuLi4nIDogdGhpcy5iaXRtYXAud2lkdGggKyAneCcgKyB0aGlzLmJpdG1hcC5oZWlnaHQpICsgJz4nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOaWNlbHkgZm9ybWF0IEppbXAgb2JqZWN0IHdoZW4gY29udmVydGVkIHRvIGEgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcHJldHR5IHByaW50ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdbb2JqZWN0IEppbXBdJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgTUlNRSBvZiB0aGUgaW1hZ2UgKGRlZmF1bHQ6IFwiaW1hZ2UvcG5nXCIpXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIE1JTUVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE1JTUVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TUlNRSgpIHtcbiAgICAgIHZhciBtaW1lID0gdGhpcy5fb3JpZ2luYWxNaW1lIHx8IEppbXAuTUlNRV9QTkc7XG4gICAgICByZXR1cm4gbWltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgZmlsZSBleHRlbnNpb24gZm9yIHRoZSBvcmlnaW5hbCBNSU1FIG9mIHRoZSBpbWFnZSAoZGVmYXVsdDogXCJwbmdcIilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZmlsZSBleHRlbnNpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEV4dGVuc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFeHRlbnNpb24oKSB7XG4gICAgICB2YXIgbWltZSA9IHRoaXMuZ2V0TUlNRSgpO1xuICAgICAgcmV0dXJuIE1JTUUuZ2V0RXh0ZW5zaW9uKG1pbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIGltYWdlIHRvIGEgZmlsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGEgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZmlsZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBpbWFnZSBpcyBzYXZlZCB0byBkaXNrXG4gICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKHBhdGgsIGNiKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCFmcyB8fCAhZnMuY3JlYXRlV3JpdGVTdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW50IGFjY2VzcyB0aGUgZmlsZXN5c3RlbS4gWW91IGNhbiB1c2UgdGhlIGdldEJhc2U2NCBtZXRob2QuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAncGF0aCBtdXN0IGJlIGEgc3RyaW5nJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYiA9IG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJywgY2IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWltZSA9IE1JTUUuZ2V0VHlwZShwYXRoKSB8fCB0aGlzLmdldE1JTUUoKTtcbiAgICAgIHZhciBwYXRoT2JqID0gUGF0aC5wYXJzZShwYXRoKTtcblxuICAgICAgaWYgKHBhdGhPYmouZGlyKSB7XG4gICAgICAgIG1rZGlycC5zeW5jKHBhdGhPYmouZGlyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5nZXRCdWZmZXIobWltZSwgZnVuY3Rpb24gKGVyciwgYnVmZmVyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKF90aGlzMiwgZXJyLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ocGF0aCk7XG4gICAgICAgIHN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgIH0pLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKF90aGlzMiwgZXJyLCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYi5jYWxsKF90aGlzMiwgbnVsbCwgX3RoaXMyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXNlNjRcIixcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBpbWFnZSB0byBhIGJhc2UgNjQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbWUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UgZGF0YSB0byBiZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIGEgTm9kZS1zdHlsZSBmdW5jdGlvbiB0byBjYWxsIHdpdGggdGhlIGJ1ZmZlciBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZTY0KG1pbWUsIGNiKSB7XG4gICAgICBpZiAobWltZSA9PT0gSmltcC5BVVRPKSB7XG4gICAgICAgIC8vIGFsbG93IGF1dG8gTUlNRSBkZXRlY3Rpb25cbiAgICAgICAgbWltZSA9IHRoaXMuZ2V0TUlNRSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG1pbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ21pbWUgbXVzdCBiZSBhIHN0cmluZycsIGNiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdjYiBtdXN0IGJlIGEgZnVuY3Rpb24nLCBjYik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ2V0QnVmZmVyKG1pbWUsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgZXJyLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3JjID0gJ2RhdGE6JyArIG1pbWUgKyAnO2Jhc2U2NCwnICsgZGF0YS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgc3JjKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc2hcIixcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHBlcmNlcHR1YWwgaGFzaCBvZiB0aGUgaW1hZ2UgPGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcmNlcHR1YWxfaGFzaGluZz4uIEFuZCBwYWRzIHRoZSBzdHJpbmcuIENhbiBjb25maWd1cmUgYmFzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZSAob3B0aW9uYWwpIGEgbnVtYmVyIGJldHdlZW4gMiBhbmQgNjQgcmVwcmVzZW50aW5nIHRoZSBiYXNlIGZvciB0aGUgaGFzaCAoZS5nLiAyIGlzIGJpbmFyeSwgMTAgaXMgZGVjaW1hbCwgMTYgaXMgaGV4LCA2NCBpcyBiYXNlIDY0KS4gRGVmYXVsdHMgdG8gNjQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaGFzaFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNoKGJhc2UsIGNiKSB7XG4gICAgICBiYXNlID0gYmFzZSB8fCA2NDtcblxuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDY0O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGJhc2UgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ2Jhc2UgbXVzdCBiZSBhIG51bWJlcicsIGNiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhc2UgPCAyIHx8IGJhc2UgPiA2NCkge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdiYXNlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAyIGFuZCA2NCcsIGNiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSB0aGlzLnBIYXNoKCk7XG4gICAgICBoYXNoID0gYW55QmFzZShhbnlCYXNlLkJJTiwgYWxwaGFiZXQuc2xpY2UoMCwgYmFzZSkpKGhhc2gpO1xuXG4gICAgICB3aGlsZSAoaGFzaC5sZW5ndGggPCBtYXhIYXNoTGVuZ3RoW2Jhc2VdKSB7XG4gICAgICAgIGhhc2ggPSAnMCcgKyBoYXNoOyAvLyBwYWQgb3V0IHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCBoYXNoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBlcmNlcHR1YWwgaGFzaFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwZXJjZXB0dWFsIGhhc2hcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBIYXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBIYXNoKCkge1xuICAgICAgdmFyIHBIYXNoID0gbmV3IEltYWdlUEhhc2goKTtcbiAgICAgIHJldHVybiBwSGFzaC5nZXRIYXNoKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBoYW1taW5nIGRpc3RhbmNlIG9mIHRoZSBjdXJyZW50IGltYWdlIGFuZCBhIGhhc2ggYmFzZWQgb24gdGhlaXIgcGVyY2VwdHVhbCBoYXNoXG4gICAgICogQHBhcmFtIHtoYXNofSBjb21wYXJlSGFzaCBoYXNoIHRvIGNvbXBhcmUgdG9cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBhIG51bWJlciByYW5naW5nIGZyb20gMCB0byAxLCAwIG1lYW5zIHRoZXkgYXJlIGJlbGlldmVkIHRvIGJlIGlkZW50aWNhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VGcm9tSGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZUZyb21IYXNoKGNvbXBhcmVIYXNoKSB7XG4gICAgICB2YXIgcEhhc2ggPSBuZXcgSW1hZ2VQSGFzaCgpO1xuICAgICAgdmFyIGN1cnJlbnRIYXNoID0gcEhhc2guZ2V0SGFzaCh0aGlzKTtcbiAgICAgIHJldHVybiBwSGFzaC5kaXN0YW5jZShjdXJyZW50SGFzaCwgY29tcGFyZUhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgaW1hZ2UgdG8gYSBidWZmZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWltZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBidWZmZXIgdG8gYmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiBhIE5vZGUtc3R5bGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBidWZmZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXhlbEluZGV4XCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgYSBwaXhlbCBpbiB0aGUgYml0bWFwIGJ1ZmZlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVkZ2VIYW5kbGluZyAob3B0aW9uYWwpIGRlZmluZSBob3cgdG8gc3VtIHBpeGVscyBmcm9tIG91dHNpZGUgdGhlIGJvcmRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHBpeGVsIG9yIC0xIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaXhlbEluZGV4KHgsIHksIGVkZ2VIYW5kbGluZywgY2IpIHtcbiAgICAgIHZhciB4aTtcbiAgICAgIHZhciB5aTtcblxuICAgICAgaWYgKHR5cGVvZiBlZGdlSGFuZGxpbmcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYiA9IGVkZ2VIYW5kbGluZztcbiAgICAgICAgZWRnZUhhbmRsaW5nID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlZGdlSGFuZGxpbmcpIHtcbiAgICAgICAgZWRnZUhhbmRsaW5nID0gSmltcC5FREdFX0VYVEVORDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgeSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAneCBhbmQgeSBtdXN0IGJlIG51bWJlcnMnLCBjYik7XG4gICAgICB9IC8vIHJvdW5kIGlucHV0XG5cblxuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgIHhpID0geDtcbiAgICAgIHlpID0geTtcblxuICAgICAgaWYgKGVkZ2VIYW5kbGluZyA9PT0gSmltcC5FREdFX0VYVEVORCkge1xuICAgICAgICBpZiAoeCA8IDApIHhpID0gMDtcbiAgICAgICAgaWYgKHggPj0gdGhpcy5iaXRtYXAud2lkdGgpIHhpID0gdGhpcy5iaXRtYXAud2lkdGggLSAxO1xuICAgICAgICBpZiAoeSA8IDApIHlpID0gMDtcbiAgICAgICAgaWYgKHkgPj0gdGhpcy5iaXRtYXAuaGVpZ2h0KSB5aSA9IHRoaXMuYml0bWFwLmhlaWdodCAtIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlSGFuZGxpbmcgPT09IEppbXAuRURHRV9XUkFQKSB7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgIHhpID0gdGhpcy5iaXRtYXAud2lkdGggKyB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPj0gdGhpcy5iaXRtYXAud2lkdGgpIHtcbiAgICAgICAgICB4aSA9IHggJSB0aGlzLmJpdG1hcC53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5IDwgMCkge1xuICAgICAgICAgIHhpID0gdGhpcy5iaXRtYXAuaGVpZ2h0ICsgeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5ID49IHRoaXMuYml0bWFwLmhlaWdodCkge1xuICAgICAgICAgIHlpID0geSAlIHRoaXMuYml0bWFwLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IHRoaXMuYml0bWFwLndpZHRoICogeWkgKyB4aSA8PCAyOyAvLyBpZiBvdXQgb2YgYm91bmRzIGluZGV4IGlzIC0xXG5cbiAgICAgIGlmICh4aSA8IDAgfHwgeGkgPj0gdGhpcy5iaXRtYXAud2lkdGgpIHtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoeWkgPCAwIHx8IHlpID49IHRoaXMuYml0bWFwLmhlaWdodCkge1xuICAgICAgICBpID0gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGV4IGNvbG91ciB2YWx1ZSBvZiBhIHBpeGVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIGNvbG9yIG9mIHRoZSBwaXhlbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGl4ZWxDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaXhlbENvbG9yKHgsIHksIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInIHx8IHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAneCBhbmQgeSBtdXN0IGJlIG51bWJlcnMnLCBjYik7IC8vIHJvdW5kIGlucHV0XG5cbiAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5nZXRQaXhlbEluZGV4KHgsIHkpO1xuICAgICAgdmFyIGhleCA9IHRoaXMuYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKGlkeCk7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIGhleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBpeGVsQ29sb3JcIixcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhleCBjb2xvdXIgdmFsdWUgb2YgYSBwaXhlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZXggY29sb3IgdG8gc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBwaXhlbCBvciAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGl4ZWxDb2xvcihoZXgsIHgsIHksIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIGhleCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHggIT09ICdudW1iZXInIHx8IHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnaGV4LCB4IGFuZCB5IG11c3QgYmUgbnVtYmVycycsIGNiKTsgLy8gcm91bmQgaW5wdXRcblxuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgIHZhciBpZHggPSB0aGlzLmdldFBpeGVsSW5kZXgoeCwgeSk7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhLndyaXRlVUludDMyQkUoaGV4LCBpZHgpO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0FscGhhXCIsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGltYWdlIGNvbnRhaW5zIG9wYXF1ZSBwaXhlbHMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gaGFzQWxwaGEgd2hldGhlciB0aGUgaW1hZ2UgY29udGFpbnMgb3BhcXVlIHBpeGVsc1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNBbHBoYSgpIHtcbiAgICAgIGZvciAodmFyIHlJbmRleCA9IDA7IHlJbmRleCA8IHRoaXMuYml0bWFwLmhlaWdodDsgeUluZGV4KyspIHtcbiAgICAgICAgZm9yICh2YXIgeEluZGV4ID0gMDsgeEluZGV4IDwgdGhpcy5iaXRtYXAud2lkdGg7IHhJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGlkeCA9IHRoaXMuYml0bWFwLndpZHRoICogeUluZGV4ICsgeEluZGV4IDw8IDI7XG4gICAgICAgICAgdmFyIGFscGhhID0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAzXTtcblxuICAgICAgICAgIGlmIChhbHBoYSAhPT0gMHhmZikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSmltcDtcbn0oRXZlbnRFbWl0dGVyKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbnN0YW50cyhjb25zdGFudHMpIHtcbiAgdmFyIGppbXBJbnN0YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogSmltcDtcbiAgT2JqZWN0LmVudHJpZXMoY29uc3RhbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIG5hbWUgPSBfcmVmMlswXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMlsxXTtcblxuICAgIGppbXBJbnN0YW5jZVtuYW1lXSA9IHZhbHVlO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRKaW1wTWV0aG9kcyhtZXRob2RzKSB7XG4gIHZhciBqaW1wSW5zdGFuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEppbXA7XG4gIE9iamVjdC5lbnRyaWVzKG1ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICBuYW1lID0gX3JlZjRbMF0sXG4gICAgICAgIHZhbHVlID0gX3JlZjRbMV07XG5cbiAgICBqaW1wSW5zdGFuY2UucHJvdG90eXBlW25hbWVdID0gdmFsdWU7XG4gIH0pO1xufVxuYWRkQ29uc3RhbnRzKGNvbnN0YW50cyk7XG5hZGRKaW1wTWV0aG9kcyh7XG4gIGNvbXBvc2l0ZTogY29tcG9zaXRlXG59KTtcbkppbXAuX19leHRyYUNvbnN0cnVjdG9ycyA9IFtdO1xuLyoqXG4gKiBBbGxvdyBjbGllbnQgbGlicyB0byBhZGQgbmV3IHdheXMgdG8gYnVpbGQgYSBKaW1wIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGlkZW50aWZ5IHRoZSBleHRyYSBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRlc3QgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSB3aGVuIGl0IGFjY2VwdHMgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1haW4gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBydW4gd2hlcmUgdGhlIG1hZ2ljIGhhcHBlbnMuXG4gKi9cblxuSmltcC5hcHBlbmRDb25zdHJ1Y3Rvck9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0LCBydW4pIHtcbiAgSmltcC5fX2V4dHJhQ29uc3RydWN0b3JzLnB1c2goe1xuICAgIG5hbWU6IG5hbWUsXG4gICAgdGVzdDogdGVzdCxcbiAgICBydW46IHJ1blxuICB9KTtcbn07XG4vKipcbiAqIFJlYWQgYW4gaW1hZ2UgZnJvbSBhIGZpbGUgb3IgYSBCdWZmZXIuIFRha2VzIHRoZSBzYW1lIGFyZ3MgYXMgdGhlIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlXG4gKi9cblxuXG5KaW1wLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX2NvbnN0cnVjdChKaW1wLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKGVyciwgaW1hZ2UpIHtcbiAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO2Vsc2UgcmVzb2x2ZShpbWFnZSk7XG4gICAgfV0pKTtcbiAgfSk7XG59O1xuXG5KaW1wLmNyZWF0ZSA9IEppbXAucmVhZDtcbi8qKlxuICogQSBzdGF0aWMgaGVscGVyIG1ldGhvZCB0aGF0IGNvbnZlcnRzIFJHQkEgdmFsdWVzIHRvIGEgc2luZ2xlIGludGVnZXIgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIHRoZSByZWQgdmFsdWUgKDAtMjU1KVxuICogQHBhcmFtIHtudW1iZXJ9IGcgdGhlIGdyZWVuIHZhbHVlICgwLTI1NSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIHRoZSBibHVlIHZhbHVlICgwLTI1NSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRoZSBhbHBoYSB2YWx1ZSAoMC0yNTUpXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBBIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbiBzaW5nbGUgaW50ZWdlciBjb2xvdXIgdmFsdWVcbiAqL1xuXG5KaW1wLnJnYmFUb0ludCA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBjYikge1xuICBpZiAodHlwZW9mIHIgIT09ICdudW1iZXInIHx8IHR5cGVvZiBnICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgYiAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGEgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnciwgZywgYiBhbmQgYSBtdXN0IGJlIG51bWJlcnMnLCBjYik7XG4gIH1cblxuICBpZiAociA8IDAgfHwgciA+IDI1NSkge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NScsIGNiKTtcbiAgfVxuXG4gIGlmIChnIDwgMCB8fCBnID4gMjU1KSB7XG4gICAgdGhyb3dFcnJvci5jYWxsKHRoaXMsICdnIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUnLCBjYik7XG4gIH1cblxuICBpZiAoYiA8IDAgfHwgYiA+IDI1NSkge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ2IgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NScsIGNiKTtcbiAgfVxuXG4gIGlmIChhIDwgMCB8fCBhID4gMjU1KSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnYSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1JywgY2IpO1xuICB9XG5cbiAgciA9IE1hdGgucm91bmQocik7XG4gIGIgPSBNYXRoLnJvdW5kKGIpO1xuICBnID0gTWF0aC5yb3VuZChnKTtcbiAgYSA9IE1hdGgucm91bmQoYSk7XG4gIHZhciBpID0gciAqIE1hdGgucG93KDI1NiwgMykgKyBnICogTWF0aC5wb3coMjU2LCAyKSArIGIgKiBNYXRoLnBvdygyNTYsIDEpICsgYSAqIE1hdGgucG93KDI1NiwgMCk7XG5cbiAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgY2IuY2FsbCh0aGlzLCBudWxsLCBpKTtcbiAgfVxuXG4gIHJldHVybiBpO1xufTtcbi8qKlxuICogQSBzdGF0aWMgaGVscGVyIG1ldGhvZCB0aGF0IGNvbnZlcnRzIFJHQkEgdmFsdWVzIHRvIGEgc2luZ2xlIGludGVnZXIgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIGEgc2luZ2xlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50aW5nIGFuIFJHQkEgY29sb3VyIChlLmcuIDB4RkYwMDAwRkYgZm9yIHJlZClcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIEEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIHIsIGcsIGIgYW5kIGEgcmVwcmVzZW50aW5nIFJHQkEgdmFsdWVzXG4gKi9cblxuXG5KaW1wLmludFRvUkdCQSA9IGZ1bmN0aW9uIChpLCBjYikge1xuICBpZiAodHlwZW9mIGkgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnaSBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICB9XG5cbiAgdmFyIHJnYmEgPSB7fTtcbiAgcmdiYS5yID0gTWF0aC5mbG9vcihpIC8gTWF0aC5wb3coMjU2LCAzKSk7XG4gIHJnYmEuZyA9IE1hdGguZmxvb3IoKGkgLSByZ2JhLnIgKiBNYXRoLnBvdygyNTYsIDMpKSAvIE1hdGgucG93KDI1NiwgMikpO1xuICByZ2JhLmIgPSBNYXRoLmZsb29yKChpIC0gcmdiYS5yICogTWF0aC5wb3coMjU2LCAzKSAtIHJnYmEuZyAqIE1hdGgucG93KDI1NiwgMikpIC8gTWF0aC5wb3coMjU2LCAxKSk7XG4gIHJnYmEuYSA9IE1hdGguZmxvb3IoKGkgLSByZ2JhLnIgKiBNYXRoLnBvdygyNTYsIDMpIC0gcmdiYS5nICogTWF0aC5wb3coMjU2LCAyKSAtIHJnYmEuYiAqIE1hdGgucG93KDI1NiwgMSkpIC8gTWF0aC5wb3coMjU2LCAwKSk7XG5cbiAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgY2IuY2FsbCh0aGlzLCBudWxsLCByZ2JhKTtcbiAgfVxuXG4gIHJldHVybiByZ2JhO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBjc3MgY29sb3IgKEhleCwgOC1kaWdpdCAoUkdCQSkgSGV4LCBSR0IsIFJHQkEsIEhTTCwgSFNMQSwgSFNWLCBIU1ZBLCBOYW1lZCkgdG8gYSBoZXggbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzQ29sb3IgYSBudW1iZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGEgaGV4IG51bWJlciByZXByZXNlbnRpbmcgYSBjb2xvclxuICovXG5cblxuSmltcC5jc3NDb2xvclRvSGV4ID0gZnVuY3Rpb24gKGNzc0NvbG9yKSB7XG4gIGNzc0NvbG9yID0gY3NzQ29sb3IgfHwgMDsgLy8gMCwgbnVsbCwgdW5kZWZpbmVkLCBOYU5cblxuICBpZiAodHlwZW9mIGNzc0NvbG9yID09PSAnbnVtYmVyJykgcmV0dXJuIE51bWJlcihjc3NDb2xvcik7XG4gIHJldHVybiBwYXJzZUludCh0aW55Q29sb3IoY3NzQ29sb3IpLnRvSGV4OCgpLCAxNik7XG59O1xuLyoqXG4gKiBMaW1pdHMgYSBudW1iZXIgdG8gYmV0d2VlbiAwIG9yIDI1NVxuICogQHBhcmFtIHtudW1iZXJ9IG4gYSBudW1iZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBudW1iZXIgbGltaXRlZCB0byBiZXR3ZWVuIDAgb3IgMjU1XG4gKi9cblxuXG5KaW1wLmxpbWl0MjU1ID0gZnVuY3Rpb24gKG4pIHtcbiAgbiA9IE1hdGgubWF4KG4sIDApO1xuICBuID0gTWF0aC5taW4obiwgMjU1KTtcbiAgcmV0dXJuIG47XG59O1xuLyoqXG4gKiBEaWZmcyB0d28gaW1hZ2VzIGFuZCByZXR1cm5zXG4gKiBAcGFyYW0ge0ppbXB9IGltZzEgYSBKaW1wIGltYWdlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7SmltcH0gaW1nMiBhIEppbXAgaW1hZ2UgdG8gY29tcGFyZVxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCAob3B0aW9uYWwpIGEgbnVtYmVyLCAwIHRvIDEsIHRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbW9yZSBzZW5zaXRpdmUgdGhlIGNvbXBhcmlzb24gKGRlZmF1bHQ6IDAuMSlcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFuIG9iamVjdCB7IHBlcmNlbnQ6IHBlcmNlbnQgc2ltaWxhciwgZGlmZjogYSBKaW1wIGltYWdlIGhpZ2hsaWdodGluZyBkaWZmZXJlbmNlcyB9XG4gKi9cblxuXG5KaW1wLmRpZmYgPSBmdW5jdGlvbiAoaW1nMSwgaW1nMikge1xuICB2YXIgdGhyZXNob2xkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwLjE7XG4gIGlmICghKGltZzEgaW5zdGFuY2VvZiBKaW1wKSB8fCAhKGltZzIgaW5zdGFuY2VvZiBKaW1wKSkgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnaW1nMSBhbmQgaW1nMiBtdXN0IGJlIGFuIEppbXAgaW1hZ2VzJyk7XG4gIHZhciBibXAxID0gaW1nMS5iaXRtYXA7XG4gIHZhciBibXAyID0gaW1nMi5iaXRtYXA7XG5cbiAgaWYgKGJtcDEud2lkdGggIT09IGJtcDIud2lkdGggfHwgYm1wMS5oZWlnaHQgIT09IGJtcDIuaGVpZ2h0KSB7XG4gICAgaWYgKGJtcDEud2lkdGggKiBibXAxLmhlaWdodCA+IGJtcDIud2lkdGggKiBibXAyLmhlaWdodCkge1xuICAgICAgLy8gaW1nMSBpcyBiaWdnZXJcbiAgICAgIGltZzEgPSBpbWcxLmNsb25lUXVpZXQoKS5yZXNpemUoYm1wMi53aWR0aCwgYm1wMi5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbWcyIGlzIGJpZ2dlciAob3IgdGhleSBhcmUgdGhlIHNhbWUgaW4gYXJlYSlcbiAgICAgIGltZzIgPSBpbWcyLmNsb25lUXVpZXQoKS5yZXNpemUoYm1wMS53aWR0aCwgYm1wMS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAnbnVtYmVyJyB8fCB0aHJlc2hvbGQgPCAwIHx8IHRocmVzaG9sZCA+IDEpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd0aHJlc2hvbGQgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEnKTtcbiAgfVxuXG4gIHZhciBkaWZmID0gbmV3IEppbXAoYm1wMS53aWR0aCwgYm1wMS5oZWlnaHQsIDB4ZmZmZmZmZmYpO1xuICB2YXIgbnVtRGlmZlBpeGVscyA9IHBpeGVsTWF0Y2goYm1wMS5kYXRhLCBibXAyLmRhdGEsIGRpZmYuYml0bWFwLmRhdGEsIGRpZmYuYml0bWFwLndpZHRoLCBkaWZmLmJpdG1hcC5oZWlnaHQsIHtcbiAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwZXJjZW50OiBudW1EaWZmUGl4ZWxzIC8gKGRpZmYuYml0bWFwLndpZHRoICogZGlmZi5iaXRtYXAuaGVpZ2h0KSxcbiAgICBpbWFnZTogZGlmZlxuICB9O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaGFtbWluZyBkaXN0YW5jZSBvZiB0d28gaW1hZ2VzIGJhc2VkIG9uIHRoZWlyIHBlcmNlcHR1YWwgaGFzaFxuICogQHBhcmFtIHtKaW1wfSBpbWcxIGEgSmltcCBpbWFnZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0ppbXB9IGltZzIgYSBKaW1wIGltYWdlIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGEgbnVtYmVyIHJhbmdpbmcgZnJvbSAwIHRvIDEsIDAgbWVhbnMgdGhleSBhcmUgYmVsaWV2ZWQgdG8gYmUgaWRlbnRpY2FsXG4gKi9cblxuXG5KaW1wLmRpc3RhbmNlID0gZnVuY3Rpb24gKGltZzEsIGltZzIpIHtcbiAgdmFyIHBoYXNoID0gbmV3IEltYWdlUEhhc2goKTtcbiAgdmFyIGhhc2gxID0gcGhhc2guZ2V0SGFzaChpbWcxKTtcbiAgdmFyIGhhc2gyID0gcGhhc2guZ2V0SGFzaChpbWcyKTtcbiAgcmV0dXJuIHBoYXNoLmRpc3RhbmNlKGhhc2gxLCBoYXNoMik7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBoYW1taW5nIGRpc3RhbmNlIG9mIHR3byBpbWFnZXMgYmFzZWQgb24gdGhlaXIgcGVyY2VwdHVhbCBoYXNoXG4gKiBAcGFyYW0ge2hhc2h9IGhhc2gxIGEgcEhhc2hcbiAqIEBwYXJhbSB7aGFzaH0gaGFzaDIgYSBwSGFzaFxuICogQHJldHVybnMge251bWJlcn0gYSBudW1iZXIgcmFuZ2luZyBmcm9tIDAgdG8gMSwgMCBtZWFucyB0aGV5IGFyZSBiZWxpZXZlZCB0byBiZSBpZGVudGljYWxcbiAqL1xuXG5cbkppbXAuY29tcGFyZUhhc2hlcyA9IGZ1bmN0aW9uIChoYXNoMSwgaGFzaDIpIHtcbiAgdmFyIHBoYXNoID0gbmV3IEltYWdlUEhhc2goKTtcbiAgcmV0dXJuIHBoYXNoLmRpc3RhbmNlKGhhc2gxLCBoYXNoMik7XG59O1xuLyoqXG4gKiBDb21wdXRlIGNvbG9yIGRpZmZlcmVuY2VcbiAqIDAgbWVhbnMgbm8gZGlmZmVyZW5jZSwgMSBtZWFucyBtYXhpbXVtIGRpZmZlcmVuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gcmdiYTE6ICAgIGZpcnN0IGNvbG9yIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmdiYTI6ICAgIHNlY29uZCBjb2xvciB0byBjb21wYXJlLlxuICogQm90aCBwYXJhbWV0ZXJzIG11c3QgYmUgYW4gY29sb3Igb2JqZWN0IHtyOnZhbCwgZzp2YWwsIGI6dmFsLCBhOnZhbH1cbiAqIFdoZXJlIGBhYCBpcyBvcHRpb25hbCBhbmQgYHZhbGAgaXMgYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDI1NS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqL1xuXG5cbkppbXAuY29sb3JEaWZmID0gZnVuY3Rpb24gKHJnYmExLCByZ2JhMikge1xuICB2YXIgcG93ID0gZnVuY3Rpb24gcG93KG4pIHtcbiAgICByZXR1cm4gTWF0aC5wb3cobiwgMik7XG4gIH07XG5cbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuICB2YXIgbWF4VmFsID0gMjU1ICogMjU1ICogMztcblxuICBpZiAocmdiYTEuYSAhPT0gMCAmJiAhcmdiYTEuYSkge1xuICAgIHJnYmExLmEgPSAyNTU7XG4gIH1cblxuICBpZiAocmdiYTIuYSAhPT0gMCAmJiAhcmdiYTIuYSkge1xuICAgIHJnYmEyLmEgPSAyNTU7XG4gIH1cblxuICByZXR1cm4gKG1heChwb3cocmdiYTEuciAtIHJnYmEyLnIpLCBwb3cocmdiYTEuciAtIHJnYmEyLnIgLSByZ2JhMS5hICsgcmdiYTIuYSkpICsgbWF4KHBvdyhyZ2JhMS5nIC0gcmdiYTIuZyksIHBvdyhyZ2JhMS5nIC0gcmdiYTIuZyAtIHJnYmExLmEgKyByZ2JhMi5hKSkgKyBtYXgocG93KHJnYmExLmIgLSByZ2JhMi5iKSwgcG93KHJnYmExLmIgLSByZ2JhMi5iIC0gcmdiYTEuYSArIHJnYmEyLmEpKSkgLyBtYXhWYWw7XG59O1xuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIEppbXAgbWV0aG9kcyB0aGF0IGVtaXQgZXZlbnRzIGJlZm9yZSBhbmQgYWZ0ZXIgaXRzIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lICAgVGhlIG5hbWUgdG8gYmUgYXBwZW5kZWQgdG8gSmltcCBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZOYW1lICAgICAgIFRoZSBldmVudCBuYW1lIHRvIGJlIGNhbGxlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgSXQgd2lsbCBiZSBwcmVmaXhlZCBieSBgYmVmb3JlLWAgYW5kIGVtaXR0ZWQgd2hlbiBvbiBtZXRob2QgY2FsbC5cbiAqICAgICAgICAgICAgICAgICAgICAgSXQgd2lsbCBiZSBhcHBlbmRlZCBieSBgZWRgIGFuZCBlbWl0dGVkIGFmdGVyIHRoZSBtZXRob2QgcnVuLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kICAgICAgIEEgZnVuY3Rpb24gaW1wbGVtZW50aW5nIHRoZSBtZXRob2QgaXRzZWxmLlxuICogSXQgd2lsbCBhbHNvIGNyZWF0ZSBhIHF1aWV0IHZlcnNpb24gdGhhdCB3aWxsIG5vdCBlbWl0IGV2ZW50cywgdG8gbm90XG4gKiBtZXNzIHRoZSB1c2VyIGNvZGUgd2l0aCBtYW55IGBjaGFuZ2VkYCBldmVudCBjYWxscy4gWW91IGNhbiBjYWxsIHdpdGhcbiAqIGBtZXRob2ROYW1lICsgXCJRdWlldFwiYC5cbiAqXG4gKiBUaGUgZW1pdHRlZCBldmVudCBjb21lcyB3aXRoIGEgb2JqZWN0IHBhcmFtZXRlciB0byB0aGUgbGlzdGVuZXIgd2l0aCB0aGVcbiAqIGBtZXRob2ROYW1lYCBhcyBvbmUgYXR0cmlidXRlLlxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGppbXBFdk1ldGhvZChtZXRob2ROYW1lLCBldk5hbWUsIG1ldGhvZCkge1xuICB2YXIgZXZOYW1lQmVmb3JlID0gJ2JlZm9yZS0nICsgZXZOYW1lO1xuICB2YXIgZXZOYW1lQWZ0ZXIgPSBldk5hbWUucmVwbGFjZSgvZSQvLCAnJykgKyAnZWQnO1xuXG4gIEppbXAucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB3cmFwcGVkQ2I7XG5cbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICB9XG5cbiAgICB2YXIgY2IgPSBhcmdzW21ldGhvZC5sZW5ndGggLSAxXTtcbiAgICB2YXIgamltcEluc3RhbmNlID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdyYXBwZWRDYiA9IGZ1bmN0aW9uIHdyYXBwZWRDYigpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVyciA9IGFyZ3NbMF0sXG4gICAgICAgICAgICBkYXRhID0gYXJnc1sxXTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgamltcEluc3RhbmNlLmVtaXRFcnJvcihtZXRob2ROYW1lLCBlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGppbXBJbnN0YW5jZS5lbWl0TXVsdGkobWV0aG9kTmFtZSwgZXZOYW1lQWZ0ZXIsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgbWV0aG9kTmFtZSwgZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuXG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSB3cmFwcGVkQ2I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyYXBwZWRDYiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdE11bHRpKG1ldGhvZE5hbWUsIGV2TmFtZUJlZm9yZSk7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgIGlmICghd3JhcHBlZENiKSB7XG4gICAgICAgIHRoaXMuZW1pdE11bHRpKG1ldGhvZE5hbWUsIGV2TmFtZUFmdGVyLCBfZGVmaW5lUHJvcGVydHkoe30sIG1ldGhvZE5hbWUsIHJlc3VsdCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXRob2ROYW1lID0gbWV0aG9kTmFtZTtcbiAgICAgIHRoaXMuZW1pdEVycm9yKG1ldGhvZE5hbWUsIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIEppbXAucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUXVpZXQnXSA9IG1ldGhvZDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbWFnZSB0aGF0IGlzIGEgY2xvbmUgb2YgdGhpcyBvbmUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBBIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB0aGUgbmV3IGltYWdlXG4gKi9cblxuamltcEV2TWV0aG9kKCdjbG9uZScsICdjbG9uZScsIGZ1bmN0aW9uIChjYikge1xuICB2YXIgY2xvbmUgPSBuZXcgSmltcCh0aGlzKTtcblxuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKGNsb25lLCBudWxsLCBjbG9uZSk7XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59KTtcbi8qKlxuICogU2ltcGxpZnkgamltcEV2TWV0aG9kIGNhbGwgZm9yIHRoZSBjb21tb24gYGNoYW5nZWAgZXZOYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgdG8gd2F0Y2ggY2hhbmdlcyBmb3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gamltcEV2Q2hhbmdlKG1ldGhvZE5hbWUsIG1ldGhvZCkge1xuICBqaW1wRXZNZXRob2QobWV0aG9kTmFtZSwgJ2NoYW5nZScsIG1ldGhvZCk7XG59XG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgdGhlIGltYWdlIChSR0Igb3IgUkdCQSkgd2hlbiBzYXZpbmcgYXMgUE5HIGZvcm1hdCAoZGVmYXVsdCBpcyBSR0JBKVxuICogQHBhcmFtIGIgQSBCb29sZWFuLCB0cnVlIHRvIHVzZSBSR0JBIG9yIGZhbHNlIHRvIHVzZSBSR0JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cblxuamltcEV2Q2hhbmdlKCdiYWNrZ3JvdW5kJywgZnVuY3Rpb24gKGhleCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBoZXggIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnaGV4IG11c3QgYmUgYSBoZXhhZGVjaW1hbCByZ2JhIHZhbHVlJywgY2IpO1xuICB9XG5cbiAgdGhpcy5fYmFja2dyb3VuZCA9IGhleDtcblxuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59KTtcbi8qKlxuICogU2NhbnMgdGhyb3VnaCBhIHJlZ2lvbiBvZiB0aGUgYml0bWFwLCBjYWxsaW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggcGl4ZWwuXG4gKiBAcGFyYW0ge251bWJlcn0geCB0aGUgeCBjb29yZGluYXRlIHRvIGJlZ2luIHRoZSBzY2FuIGF0XG4gKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIHRvIGJlZ2luIHRoZSBzY2FuIGF0XG4gKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIHNjYW4gcmVnaW9uXG4gKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBzY2FuIHJlZ2lvblxuICogQHBhcmFtIGYgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGV2ZW4gcGl4ZWw7IHRoZSAoeCwgeSkgcG9zaXRpb24gb2YgdGhlIHBpeGVsXG4gKiBhbmQgdGhlIGluZGV4IG9mIHRoZSBwaXhlbCBpbiB0aGUgYml0bWFwIGJ1ZmZlciBhcmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAqL1xuXG5qaW1wRXZDaGFuZ2UoJ3NjYW4nLCBmdW5jdGlvbiAoeCwgeSwgdywgaCwgZiwgY2IpIHtcbiAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgeSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd4IGFuZCB5IG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdyAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGggIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAndyBhbmQgaCBtdXN0IGJlIG51bWJlcnMnLCBjYik7XG4gIH1cblxuICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdmIG11c3QgYmUgYSBmdW5jdGlvbicsIGNiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBzY2FuKHRoaXMsIHgsIHksIHcsIGgsIGYpO1xuXG4gIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgIGNiLmNhbGwodGhpcywgbnVsbCwgcmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52LkVOVklST05NRU5UID09PSAnQlJPV1NFUicpIHtcbiAgLy8gRm9yIHVzZSBpbiBhIHdlYiBicm93c2VyIG9yIHdlYiB3b3JrZXJcblxuICAvKiBnbG9iYWwgc2VsZiAqL1xuICB2YXIgZ2w7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnKSB7XG4gICAgZ2wgPSB3aW5kb3c7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHNlbGYpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBnbCA9IHNlbGY7XG4gIH1cblxuICBnbC5KaW1wID0gSmltcDtcbiAgZ2wuQnVmZmVyID0gQnVmZmVyO1xufVxuXG5leHBvcnQgeyBhZGRUeXBlIH0gZnJvbSAnLi91dGlscy9taW1lJztcbmV4cG9ydCBkZWZhdWx0IEppbXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKlxuQ29weXJpZ2h0IChjKSAyMDExIEVsbGlvdCBTaGVwaGVyZFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvaXJvbmNoZWYtdGVhbTIxL3NvdXJjZS9icm93c2UvaXJvbmNoZWZfdGVhbTIxL3NyYy9JbWFnZVBIYXNoLmphdmFcblxuLypcbiAqIHBIYXNoLWxpa2UgaW1hZ2UgaGFzaC5cbiAqIEF1dGhvcjogRWxsaW90IFNoZXBoZXJkIChlbGxpb3RAamFyb2Z3b3Jtcy5jb21cbiAqIEJhc2VkIE9uOiBodHRwOi8vd3d3LmhhY2tlcmZhY3Rvci5jb20vYmxvZy9pbmRleC5waHA/L2FyY2hpdmVzLzQzMi1Mb29rcy1MaWtlLUl0Lmh0bWxcbiAqL1xuZnVuY3Rpb24gSW1hZ2VQSGFzaChzaXplLCBzbWFsbGVyU2l6ZSkge1xuICB0aGlzLnNpemUgPSB0aGlzLnNpemUgfHwgc2l6ZTtcbiAgdGhpcy5zbWFsbGVyU2l6ZSA9IHRoaXMuc21hbGxlclNpemUgfHwgc21hbGxlclNpemU7XG4gIGluaXRDb2VmZmljaWVudHModGhpcy5zaXplKTtcbn1cblxuSW1hZ2VQSGFzaC5wcm90b3R5cGUuc2l6ZSA9IDMyO1xuSW1hZ2VQSGFzaC5wcm90b3R5cGUuc21hbGxlclNpemUgPSA4O1xuXG5JbWFnZVBIYXNoLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIChzMSwgczIpIHtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgczEubGVuZ3RoOyBrKyspIHtcbiAgICBpZiAoczFba10gIT09IHMyW2tdKSB7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50ZXIgLyBzMS5sZW5ndGg7XG59OyAvLyBSZXR1cm5zIGEgJ2JpbmFyeSBzdHJpbmcnIChsaWtlLiAwMDEwMTAxMTEwMTExMDAwMTApIHdoaWNoIGlzIGVhc3kgdG8gZG8gYSBoYW1taW5nIGRpc3RhbmNlIG9uLlxuXG5cbkltYWdlUEhhc2gucHJvdG90eXBlLmdldEhhc2ggPSBmdW5jdGlvbiAoaW1nKSB7XG4gIC8qIDEuIFJlZHVjZSBzaXplLlxuICAgICAqIExpa2UgQXZlcmFnZSBIYXNoLCBwSGFzaCBzdGFydHMgd2l0aCBhIHNtYWxsIGltYWdlLlxuICAgICAqIEhvd2V2ZXIsIHRoZSBpbWFnZSBpcyBsYXJnZXIgdGhhbiA4eDg7IDMyeDMyIGlzIGEgZ29vZCBzaXplLlxuICAgICAqIFRoaXMgaXMgcmVhbGx5IGRvbmUgdG8gc2ltcGxpZnkgdGhlIERDVCBjb21wdXRhdGlvbiBhbmQgbm90XG4gICAgICogYmVjYXVzZSBpdCBpcyBuZWVkZWQgdG8gcmVkdWNlIHRoZSBoaWdoIGZyZXF1ZW5jaWVzLlxuICAgICAqL1xuICBpbWcgPSBpbWcuY2xvbmUoKS5yZXNpemUodGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAvKiAyLiBSZWR1Y2UgY29sb3IuXG4gICAgICogVGhlIGltYWdlIGlzIHJlZHVjZWQgdG8gYSBncmF5c2NhbGUganVzdCB0byBmdXJ0aGVyIHNpbXBsaWZ5XG4gICAgICogdGhlIG51bWJlciBvZiBjb21wdXRhdGlvbnMuXG4gICAgICovXG5cbiAgaW1nLmdyYXlzY2FsZSgpO1xuICB2YXIgdmFscyA9IFtdO1xuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgaW1nLmJpdG1hcC53aWR0aDsgeCsrKSB7XG4gICAgdmFsc1t4XSA9IFtdO1xuXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbWcuYml0bWFwLmhlaWdodDsgeSsrKSB7XG4gICAgICB2YWxzW3hdW3ldID0gaW50VG9SR0JBKGltZy5nZXRQaXhlbENvbG9yKHgsIHkpKS5iO1xuICAgIH1cbiAgfVxuICAvKiAzLiBDb21wdXRlIHRoZSBEQ1QuXG4gICAgICogVGhlIERDVCBzZXBhcmF0ZXMgdGhlIGltYWdlIGludG8gYSBjb2xsZWN0aW9uIG9mIGZyZXF1ZW5jaWVzXG4gICAgICogYW5kIHNjYWxhcnMuIFdoaWxlIEpQRUcgdXNlcyBhbiA4eDggRENULCB0aGlzIGFsZ29yaXRobSB1c2VzXG4gICAgICogYSAzMngzMiBEQ1QuXG4gICAgICovXG5cblxuICB2YXIgZGN0VmFscyA9IGFwcGx5RENUKHZhbHMsIHRoaXMuc2l6ZSk7XG4gIC8qIDQuIFJlZHVjZSB0aGUgRENULlxuICAgICAqIFRoaXMgaXMgdGhlIG1hZ2ljIHN0ZXAuIFdoaWxlIHRoZSBEQ1QgaXMgMzJ4MzIsIGp1c3Qga2VlcCB0aGVcbiAgICAgKiB0b3AtbGVmdCA4eDguIFRob3NlIHJlcHJlc2VudCB0aGUgbG93ZXN0IGZyZXF1ZW5jaWVzIGluIHRoZVxuICAgICAqIHBpY3R1cmUuXG4gICAgICovXG5cbiAgLyogNS4gQ29tcHV0ZSB0aGUgYXZlcmFnZSB2YWx1ZS5cbiAgICAgKiBMaWtlIHRoZSBBdmVyYWdlIEhhc2gsIGNvbXB1dGUgdGhlIG1lYW4gRENUIHZhbHVlICh1c2luZyBvbmx5XG4gICAgICogdGhlIDh4OCBEQ1QgbG93LWZyZXF1ZW5jeSB2YWx1ZXMgYW5kIGV4Y2x1ZGluZyB0aGUgZmlyc3QgdGVybVxuICAgICAqIHNpbmNlIHRoZSBEQyBjb2VmZmljaWVudCBjYW4gYmUgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgZnJvbVxuICAgICAqIHRoZSBvdGhlciB2YWx1ZXMgYW5kIHdpbGwgdGhyb3cgb2ZmIHRoZSBhdmVyYWdlKS5cbiAgICAgKi9cblxuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZvciAodmFyIF94ID0gMDsgX3ggPCB0aGlzLnNtYWxsZXJTaXplOyBfeCsrKSB7XG4gICAgZm9yICh2YXIgX3kgPSAwOyBfeSA8IHRoaXMuc21hbGxlclNpemU7IF95KyspIHtcbiAgICAgIHRvdGFsICs9IGRjdFZhbHNbX3hdW195XTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXZnID0gdG90YWwgLyAodGhpcy5zbWFsbGVyU2l6ZSAqIHRoaXMuc21hbGxlclNpemUpO1xuICAvKiA2LiBGdXJ0aGVyIHJlZHVjZSB0aGUgRENULlxuICAgICAqIFRoaXMgaXMgdGhlIG1hZ2ljIHN0ZXAuIFNldCB0aGUgNjQgaGFzaCBiaXRzIHRvIDAgb3IgMVxuICAgICAqIGRlcGVuZGluZyBvbiB3aGV0aGVyIGVhY2ggb2YgdGhlIDY0IERDVCB2YWx1ZXMgaXMgYWJvdmUgb3JcbiAgICAgKiBiZWxvdyB0aGUgYXZlcmFnZSB2YWx1ZS4gVGhlIHJlc3VsdCBkb2Vzbid0IHRlbGwgdXMgdGhlXG4gICAgICogYWN0dWFsIGxvdyBmcmVxdWVuY2llczsgaXQganVzdCB0ZWxscyB1cyB0aGUgdmVyeS1yb3VnaFxuICAgICAqIHJlbGF0aXZlIHNjYWxlIG9mIHRoZSBmcmVxdWVuY2llcyB0byB0aGUgbWVhbi4gVGhlIHJlc3VsdFxuICAgICAqIHdpbGwgbm90IHZhcnkgYXMgbG9uZyBhcyB0aGUgb3ZlcmFsbCBzdHJ1Y3R1cmUgb2YgdGhlIGltYWdlXG4gICAgICogcmVtYWlucyB0aGUgc2FtZTsgdGhpcyBjYW4gc3Vydml2ZSBnYW1tYSBhbmQgY29sb3IgaGlzdG9ncmFtXG4gICAgICogYWRqdXN0bWVudHMgd2l0aG91dCBhIHByb2JsZW0uXG4gICAgICovXG5cbiAgdmFyIGhhc2ggPSAnJztcblxuICBmb3IgKHZhciBfeDIgPSAwOyBfeDIgPCB0aGlzLnNtYWxsZXJTaXplOyBfeDIrKykge1xuICAgIGZvciAodmFyIF95MiA9IDA7IF95MiA8IHRoaXMuc21hbGxlclNpemU7IF95MisrKSB7XG4gICAgICBoYXNoICs9IGRjdFZhbHNbX3gyXVtfeTJdID4gYXZnID8gJzEnIDogJzAnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTsgLy8gRENUIGZ1bmN0aW9uIHN0b2xlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDI0MDQ5MC9wcm9ibGVtcy13aXRoLWRjdC1hbmQtaWRjdC1hbGdvcml0aG0taW4tamF2YVxuXG5cbmZ1bmN0aW9uIGludFRvUkdCQShpKSB7XG4gIHZhciByZ2JhID0ge307XG4gIHJnYmEuciA9IE1hdGguZmxvb3IoaSAvIE1hdGgucG93KDI1NiwgMykpO1xuICByZ2JhLmcgPSBNYXRoLmZsb29yKChpIC0gcmdiYS5yICogTWF0aC5wb3coMjU2LCAzKSkgLyBNYXRoLnBvdygyNTYsIDIpKTtcbiAgcmdiYS5iID0gTWF0aC5mbG9vcigoaSAtIHJnYmEuciAqIE1hdGgucG93KDI1NiwgMykgLSByZ2JhLmcgKiBNYXRoLnBvdygyNTYsIDIpKSAvIE1hdGgucG93KDI1NiwgMSkpO1xuICByZ2JhLmEgPSBNYXRoLmZsb29yKChpIC0gcmdiYS5yICogTWF0aC5wb3coMjU2LCAzKSAtIHJnYmEuZyAqIE1hdGgucG93KDI1NiwgMikgLSByZ2JhLmIgKiBNYXRoLnBvdygyNTYsIDEpKSAvIE1hdGgucG93KDI1NiwgMCkpO1xuICByZXR1cm4gcmdiYTtcbn1cblxudmFyIGMgPSBbXTtcblxuZnVuY3Rpb24gaW5pdENvZWZmaWNpZW50cyhzaXplKSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgY1tpXSA9IDE7XG4gIH1cblxuICBjWzBdID0gMSAvIE1hdGguc3FydCgyLjApO1xufVxuXG5mdW5jdGlvbiBhcHBseURDVChmLCBzaXplKSB7XG4gIHZhciBOID0gc2l6ZTtcbiAgdmFyIEYgPSBbXTtcblxuICBmb3IgKHZhciB1ID0gMDsgdSA8IE47IHUrKykge1xuICAgIEZbdV0gPSBbXTtcblxuICAgIGZvciAodmFyIHYgPSAwOyB2IDwgTjsgdisrKSB7XG4gICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBOOyBqKyspIHtcbiAgICAgICAgICBzdW0gKz0gTWF0aC5jb3MoKDIgKiBpICsgMSkgLyAoMi4wICogTikgKiB1ICogTWF0aC5QSSkgKiBNYXRoLmNvcygoMiAqIGogKyAxKSAvICgyLjAgKiBOKSAqIHYgKiBNYXRoLlBJKSAqIGZbaV1bal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3VtICo9IGNbdV0gKiBjW3ZdIC8gNDtcbiAgICAgIEZbdV1bdl0gPSBzdW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VQSGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBoYXNoLmpzLm1hcCIsImZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuLyogZ2xvYmFsIFhNTEh0dHBSZXF1ZXN0ICovXG5pZiAocHJvY2Vzcy5icm93c2VyIHx8IHByb2Nlc3MuZW52LkVOVklST05NRU5UID09PSAnQlJPV1NFUicgfHwgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gSWYgd2UgcnVuIGludG8gYSBicm93c2VyIG9yIHRoZSBlbGVjdHJvbiByZW5kZXJlciBwcm9jZXNzLFxuICAvLyB1c2UgWEhSIG1ldGhvZCBpbnN0ZWFkIG9mIFJlcXVlc3Qgbm9kZSBtb2R1bGUuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNiKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCBvcHRpb25zLnVybCwgdHJ1ZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoeGhyLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBkYXRhID0gQnVmZmVyLmZyb20odGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgY2IobnVsbCwgeGhyLCBkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgYSBidWZmZXIgZm9yIHVybCAnICsgb3B0aW9ucy51cmwgKyAnLiBFcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobmV3IEVycm9yKCdIVFRQIFN0YXR1cyAnICsgeGhyLnN0YXR1cyArICcgZm9yIHVybCAnICsgb3B0aW9ucy51cmwpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9yZWYsIGNiKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgX3JlZik7XG5cbiAgICB2YXIgcCA9IHJlcXVpcmUoJ3BoaW4nKTtcblxuICAgIHAoX29iamVjdFNwcmVhZCh7XG4gICAgICBjb21wcmVzc2lvbjogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgY2IobnVsbCwgcmVzLCByZXMuYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC5qcy5tYXAiLCJpbXBvcnQgZmlsZVR5cGUgZnJvbSAnZmlsZS10eXBlJztcbmltcG9ydCBFWElGUGFyc2VyIGZyb20gJ2V4aWYtcGFyc2VyJztcbmltcG9ydCB7IHRocm93RXJyb3IgfSBmcm9tICdAamltcC91dGlscyc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIE1JTUUgZnJvbSAnLi9taW1lJztcbmltcG9ydCBwcm9taXNpZnkgZnJvbSAnLi9wcm9taXNpZnknO1xuXG5mdW5jdGlvbiBnZXRNSU1FRnJvbUJ1ZmZlcihidWZmZXIsIHBhdGgpIHtcbiAgdmFyIGZpbGVUeXBlRnJvbUJ1ZmZlciA9IGZpbGVUeXBlKGJ1ZmZlcik7XG5cbiAgaWYgKGZpbGVUeXBlRnJvbUJ1ZmZlcikge1xuICAgIC8vIElmIGZpbGVUeXBlIHJldHVybnMgc29tZXRoaW5nIGZvciBidWZmZXIsIHRoZW4gcmV0dXJuIHRoZSBtaW1lIGdpdmVuXG4gICAgcmV0dXJuIGZpbGVUeXBlRnJvbUJ1ZmZlci5taW1lO1xuICB9XG5cbiAgaWYgKHBhdGgpIHtcbiAgICAvLyBJZiBhIHBhdGggaXMgc3VwcGxpZWQsIGFuZCBmaWxlVHlwZSB5aWVsZHMgbm8gcmVzdWx0cywgdGhlbiByZXRyeSB3aXRoIE1JTUVcbiAgICAvLyBQYXRoIGNhbiBiZSBlaXRoZXIgYSBmaWxlIHBhdGggb3IgYSB1cmxcbiAgICByZXR1cm4gTUlNRS5nZXRUeXBlKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKlxuICogQXV0b21hZ2ljYWxseSByb3RhdGVzIGFuIGltYWdlIGJhc2VkIG9uIGl0cyBFWElGIGRhdGEgKGlmIHByZXNlbnQpXG4gKiBAcGFyYW0gaW1nIGEgY29uc3RhbnRzIG9iamVjdFxuKi9cblxuXG5mdW5jdGlvbiBleGlmUm90YXRlKGltZykge1xuICB2YXIgZXhpZiA9IGltZy5fZXhpZjtcblxuICBpZiAoZXhpZiAmJiBleGlmLnRhZ3MgJiYgZXhpZi50YWdzLk9yaWVudGF0aW9uKSB7XG4gICAgc3dpdGNoIChpbWcuX2V4aWYudGFncy5PcmllbnRhdGlvbikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvLyBIb3Jpem9udGFsIChub3JtYWwpXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gTWlycm9yIGhvcml6b250YWxcbiAgICAgICAgaW1nLm1pcnJvcih0cnVlLCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIFJvdGF0ZSAxODBcbiAgICAgICAgaW1nLnJvdGF0ZSgxODAsIGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgLy8gTWlycm9yIHZlcnRpY2FsXG4gICAgICAgIGltZy5taXJyb3IoZmFsc2UsIHRydWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA1OlxuICAgICAgICAvLyBNaXJyb3IgaG9yaXpvbnRhbCBhbmQgcm90YXRlIDI3MCBDV1xuICAgICAgICBpbWcucm90YXRlKC05MCwgZmFsc2UpLm1pcnJvcih0cnVlLCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8vIFJvdGF0ZSA5MCBDV1xuICAgICAgICBpbWcucm90YXRlKC05MCwgZmFsc2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyBNaXJyb3IgaG9yaXpvbnRhbCBhbmQgcm90YXRlIDkwIENXXG4gICAgICAgIGltZy5yb3RhdGUoOTAsIGZhbHNlKS5taXJyb3IodHJ1ZSwgZmFsc2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA4OlxuICAgICAgICAvLyBSb3RhdGUgMjcwIENXXG4gICAgICAgIGltZy5yb3RhdGUoLTI3MCwgZmFsc2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGltZztcbn0gLy8gcGFyc2VzIGEgYml0bWFwIGZyb20gdGhlIGNvbnN0cnVjdG9yIHRvIHRoZSBKSU1QIGJpdG1hcCBwcm9wZXJ0eVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJpdG1hcChkYXRhLCBwYXRoLCBjYikge1xuICB2YXIgbWltZSA9IGdldE1JTUVGcm9tQnVmZmVyKGRhdGEsIHBhdGgpO1xuXG4gIGlmICh0eXBlb2YgbWltZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBNSU1FIGZvciBCdWZmZXIgPCcgKyBwYXRoICsgJz4nKSk7XG4gIH1cblxuICB0aGlzLl9vcmlnaW5hbE1pbWUgPSBtaW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX21pbWUgPSB0aGlzLmdldE1JTUUoKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmRlY29kZXJzW19taW1lXSkge1xuICAgICAgdGhpcy5iaXRtYXAgPSB0aGlzLmNvbnN0cnVjdG9yLmRlY29kZXJzW19taW1lXShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnVW5zdXBwb3J0ZWQgTUlNRSB0eXBlOiAnICsgX21pbWUsIGNiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGNiLmNhbGwodGhpcywgZXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLl9leGlmID0gRVhJRlBhcnNlci5jcmVhdGUoZGF0YSkucGFyc2UoKTtcbiAgICBleGlmUm90YXRlKHRoaXMpOyAvLyBFWElGIGRhdGFcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBtZWggKi9cbiAgfVxuXG4gIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBjb21wb3NpdGVCaXRtYXBPdmVyQmFja2dyb3VuZChKaW1wLCBpbWFnZSkge1xuICByZXR1cm4gbmV3IEppbXAoaW1hZ2UuYml0bWFwLndpZHRoLCBpbWFnZS5iaXRtYXAuaGVpZ2h0LCBpbWFnZS5fYmFja2dyb3VuZCkuY29tcG9zaXRlKGltYWdlLCAwLCAwKS5iaXRtYXA7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBpbWFnZSB0byBhIGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IG1pbWUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UgYnVmZmVyIHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiBhIE5vZGUtc3R5bGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBidWZmZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWZmZXIobWltZSwgY2IpIHtcbiAgaWYgKG1pbWUgPT09IGNvbnN0YW50cy5BVVRPKSB7XG4gICAgLy8gYWxsb3cgYXV0byBNSU1FIGRldGVjdGlvblxuICAgIG1pbWUgPSB0aGlzLmdldE1JTUUoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWltZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdtaW1lIG11c3QgYmUgYSBzdHJpbmcnLCBjYik7XG4gIH1cblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJywgY2IpO1xuICB9XG5cbiAgbWltZSA9IG1pbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodGhpcy5fcmdiYSAmJiB0aGlzLmNvbnN0cnVjdG9yLmhhc0FscGhhW21pbWVdKSB7XG4gICAgdGhpcy5iaXRtYXAuZGF0YSA9IEJ1ZmZlci5mcm9tKHRoaXMuYml0bWFwLmRhdGEpO1xuICB9IGVsc2Uge1xuICAgIC8vIHdoZW4gZm9ybWF0IGRvZXNuJ3Qgc3VwcG9ydCBhbHBoYVxuICAgIC8vIGNvbXBvc2l0ZSBvbnRvIGEgbmV3IGltYWdlIHNvIHRoYXQgdGhlIGJhY2tncm91bmQgc2hvd3MgdGhyb3VnaCBhbHBoYSBjaGFubmVsc1xuICAgIHRoaXMuYml0bWFwLmRhdGEgPSBjb21wb3NpdGVCaXRtYXBPdmVyQmFja2dyb3VuZCh0aGlzLmNvbnN0cnVjdG9yLCB0aGlzKS5kYXRhO1xuICB9XG5cbiAgaWYgKHRoaXMuY29uc3RydWN0b3IuZW5jb2RlcnNbbWltZV0pIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5jb25zdHJ1Y3Rvci5lbmNvZGVyc1ttaW1lXSh0aGlzKTtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIGJ1ZmZlcik7XG4gIH0gZWxzZSB7XG4gICAgY2IuY2FsbCh0aGlzLCAnVW5zdXBwb3J0ZWQgTUlNRSB0eXBlOiAnICsgbWltZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWZmZXJBc3luYyhtaW1lKSB7XG4gIHJldHVybiBwcm9taXNpZnkoZ2V0QnVmZmVyLCB0aGlzLCBtaW1lKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWJpdG1hcC5qcy5tYXAiLCJ2YXIgbWltZVR5cGVzID0ge307XG5cbnZhciBmaW5kVHlwZSA9IGZ1bmN0aW9uIGZpbmRUeXBlKGV4dGVuc2lvbikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobWltZVR5cGVzKS5maW5kKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVbMV0uaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgfSkgfHwgW107XG59O1xuXG5leHBvcnQgdmFyIGFkZFR5cGUgPSBmdW5jdGlvbiBhZGRUeXBlKG1pbWUsIGV4dGVuc2lvbnMpIHtcbiAgbWltZVR5cGVzW21pbWVdID0gZXh0ZW5zaW9ucztcbn07XG4vKipcbiAqIExvb2t1cCBhIG1pbWUgdHlwZSBiYXNlZCBvbiBleHRlbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gZmluZCBleHRlbnNpb24gZm9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBtaW1lIGZvdW5kIG1pbWUgdHlwZVxuICovXG5cbmV4cG9ydCB2YXIgZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUocGF0aCkge1xuICB2YXIgcGF0aFBhcnRzID0gcGF0aC5zcGxpdCgnLycpLnNsaWNlKC0xKTtcbiAgdmFyIGV4dGVuc2lvbiA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV0uc3BsaXQoJy4nKVsxXTtcbiAgdmFyIHR5cGUgPSBmaW5kVHlwZShleHRlbnNpb24pO1xuICByZXR1cm4gdHlwZVswXTtcbn07XG4vKipcbiAqIFJldHVybiBmaWxlIGV4dGVuc2lvbiBhc3NvY2lhdGVkIHdpdGggYSBtaW1lIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIG1pbWUgdHlwZSB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBleHRlbnNpb24gZmlsZSBleHRlbnNpb25cbiAqL1xuXG5leHBvcnQgdmFyIGdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlKSB7XG4gIHJldHVybiAobWltZVR5cGVzW3R5cGUudG9Mb3dlckNhc2UoKV0gfHwgW10pWzBdO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbWUuanMubWFwIiwidmFyIHByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShmdW4sIGN0eCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIGZ1bi5iaW5kKGN0eCkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwcm9taXNpZnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNpZnkuanMubWFwIiwiZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuaW1wb3J0IEppbXAsIHsgYWRkVHlwZSwgYWRkSmltcE1ldGhvZHMsIGFkZENvbnN0YW50cywgamltcEV2Q2hhbmdlIH0gZnJvbSAnQGppbXAvY29yZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25maWd1cmUoY29uZmlndXJhdGlvbikge1xuICB2YXIgamltcEluc3RhbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBKaW1wO1xuICB2YXIgamltcENvbmZpZyA9IHtcbiAgICBoYXNBbHBoYToge30sXG4gICAgZW5jb2RlcnM6IHt9LFxuICAgIGRlY29kZXJzOiB7fSxcbiAgICBjbGFzczoge30sXG4gICAgY29uc3RhbnRzOiB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZFRvQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIE9iamVjdC5lbnRyaWVzKG5ld0NvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAga2V5ID0gX3JlZjJbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMlsxXTtcblxuICAgICAgamltcENvbmZpZ1trZXldID0gX29iamVjdFNwcmVhZCh7fSwgamltcENvbmZpZ1trZXldLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRJbWFnZVR5cGUodHlwZU1vZHVsZSkge1xuICAgIHZhciB0eXBlID0gdHlwZU1vZHVsZSgpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZS5taW1lKSkge1xuICAgICAgYWRkVHlwZS5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheSh0eXBlLm1pbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmVudHJpZXModHlwZS5taW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChtaW1lVHlwZSkge1xuICAgICAgICByZXR1cm4gYWRkVHlwZS5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShtaW1lVHlwZSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHR5cGUubWltZTtcbiAgICBhZGRUb0NvbmZpZyh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFBsdWdpbihwbHVnaW5Nb2R1bGUpIHtcbiAgICB2YXIgcGx1Z2luID0gcGx1Z2luTW9kdWxlKGppbXBFdkNoYW5nZSkgfHwge307XG5cbiAgICBpZiAoIXBsdWdpbi5jbGFzcyAmJiAhcGx1Z2luLmNvbnN0YW50cykge1xuICAgICAgLy8gRGVmYXVsdCB0byBjbGFzcyBmdW5jdGlvblxuICAgICAgYWRkVG9Db25maWcoe1xuICAgICAgICBjbGFzczogcGx1Z2luXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkVG9Db25maWcocGx1Z2luKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29uZmlndXJhdGlvbi50eXBlcykge1xuICAgIGNvbmZpZ3VyYXRpb24udHlwZXMuZm9yRWFjaChhZGRJbWFnZVR5cGUpO1xuICAgIGppbXBJbnN0YW5jZS5kZWNvZGVycyA9IF9vYmplY3RTcHJlYWQoe30sIGppbXBJbnN0YW5jZS5kZWNvZGVycywgamltcENvbmZpZy5kZWNvZGVycyk7XG4gICAgamltcEluc3RhbmNlLmVuY29kZXJzID0gX29iamVjdFNwcmVhZCh7fSwgamltcEluc3RhbmNlLmVuY29kZXJzLCBqaW1wQ29uZmlnLmVuY29kZXJzKTtcbiAgICBqaW1wSW5zdGFuY2UuaGFzQWxwaGEgPSBfb2JqZWN0U3ByZWFkKHt9LCBqaW1wSW5zdGFuY2UuaGFzQWxwaGEsIGppbXBDb25maWcuaGFzQWxwaGEpO1xuICB9XG5cbiAgaWYgKGNvbmZpZ3VyYXRpb24ucGx1Z2lucykge1xuICAgIGNvbmZpZ3VyYXRpb24ucGx1Z2lucy5mb3JFYWNoKGFkZFBsdWdpbik7XG4gIH1cblxuICBhZGRKaW1wTWV0aG9kcyhqaW1wQ29uZmlnLmNsYXNzLCBqaW1wSW5zdGFuY2UpO1xuICBhZGRDb25zdGFudHMoamltcENvbmZpZy5jb25zdGFudHMsIGppbXBJbnN0YW5jZSk7XG4gIHJldHVybiBKaW1wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IEdJRiBmcm9tICdvbWdnaWYnO1xudmFyIE1JTUVfVFlQRSA9ICdpbWFnZS9naWYnO1xuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW1lOiBfZGVmaW5lUHJvcGVydHkoe30sIE1JTUVfVFlQRSwgWydnaWYnXSksXG4gICAgY29uc3RhbnRzOiB7XG4gICAgICBNSU1FX0dJRjogTUlNRV9UWVBFXG4gICAgfSxcbiAgICBkZWNvZGVyczogX2RlZmluZVByb3BlcnR5KHt9LCBNSU1FX1RZUEUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgZ2lmT2JqID0gbmV3IEdJRi5HaWZSZWFkZXIoZGF0YSk7XG4gICAgICB2YXIgZ2lmRGF0YSA9IEJ1ZmZlci5hbGxvYyhnaWZPYmoud2lkdGggKiBnaWZPYmouaGVpZ2h0ICogNCk7XG4gICAgICBnaWZPYmouZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSgwLCBnaWZEYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGdpZkRhdGEsXG4gICAgICAgIHdpZHRoOiBnaWZPYmoud2lkdGgsXG4gICAgICAgIGhlaWdodDogZ2lmT2JqLmhlaWdodFxuICAgICAgfTtcbiAgICB9KVxuICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgSlBFRyBmcm9tICdqcGVnLWpzJztcbmltcG9ydCB7IHRocm93RXJyb3IsIGlzTm9kZVBhdHRlcm4gfSBmcm9tICdAamltcC91dGlscyc7XG52YXIgTUlNRV9UWVBFID0gJ2ltYWdlL2pwZWcnO1xuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW1lOiBfZGVmaW5lUHJvcGVydHkoe30sIE1JTUVfVFlQRSwgWydqcGVnJywgJ2pwZycsICdqcGUnXSksXG4gICAgY29uc3RhbnRzOiB7XG4gICAgICBNSU1FX0pQRUc6IE1JTUVfVFlQRVxuICAgIH0sXG4gICAgZGVjb2RlcnM6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgTUlNRV9UWVBFLCBKUEVHLmRlY29kZSksXG4gICAgZW5jb2RlcnM6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgTUlNRV9UWVBFLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHJldHVybiBKUEVHLmVuY29kZShpbWFnZS5iaXRtYXAsIGltYWdlLl9xdWFsaXR5KS5kYXRhO1xuICAgIH0pLFxuICAgIGNsYXNzOiB7XG4gICAgICAvLyBUaGUgcXVhbGl0eSB0byBiZSB1c2VkIHdoZW4gc2F2aW5nIEpQRUcgaW1hZ2VzXG4gICAgICBfcXVhbGl0eTogMTAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIHF1YWxpdHkgb2YgdGhlIGltYWdlIHdoZW4gc2F2aW5nIGFzIEpQRUcgZm9ybWF0IChkZWZhdWx0IGlzIDEwMClcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBxdWFsaXR5IHRvIHVzZSAwLTEwMFxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgICAqL1xuICAgICAgcXVhbGl0eTogZnVuY3Rpb24gcXVhbGl0eShuLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnbiBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPCAwIHx8IG4gPiAxMDApIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICduIG11c3QgYmUgYSBudW1iZXIgMCAtIDEwMCcsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3F1YWxpdHkgPSBNYXRoLnJvdW5kKG4pO1xuXG4gICAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmltcG9ydCB7IHRocm93RXJyb3IsIGlzTm9kZVBhdHRlcm4gfSBmcm9tICdAamltcC91dGlscyc7XG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEJsaXRzIGEgc291cmNlIGltYWdlIG9uIHRvIHRoaXMgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0ppbXB9IHNyYyB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB0aGUgeCBwb3NpdGlvbiB0byBibGl0IHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IHBvc2l0aW9uIHRvIGJsaXQgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY3ggKG9wdGlvbmFsKSB0aGUgeCBwb3NpdGlvbiBmcm9tIHdoaWNoIHRvIGNyb3AgdGhlIHNvdXJjZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmN5IChvcHRpb25hbCkgdGhlIHkgcG9zaXRpb24gZnJvbSB3aGljaCB0byBjcm9wIHRoZSBzb3VyY2UgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjdyAob3B0aW9uYWwpIHRoZSB3aWR0aCB0byB3aGljaCB0byBjcm9wIHRoZSBzb3VyY2UgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjaCAob3B0aW9uYWwpIHRoZSBoZWlnaHQgdG8gd2hpY2ggdG8gY3JvcCB0aGUgc291cmNlIGltYWdlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgYmxpdDogZnVuY3Rpb24gYmxpdChzcmMsIHgsIHksIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIGNiKSB7XG4gICAgICBpZiAoIShzcmMgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdUaGUgc291cmNlIG11c3QgYmUgYSBKaW1wIGltYWdlJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInIHx8IHR5cGVvZiB5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd4IGFuZCB5IG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzcmN4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gc3JjeDtcbiAgICAgICAgc3JjeCA9IDA7XG4gICAgICAgIHNyY3kgPSAwO1xuICAgICAgICBzcmN3ID0gc3JjLmJpdG1hcC53aWR0aDtcbiAgICAgICAgc3JjaCA9IHNyYy5iaXRtYXAuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHNyY3gpID09PSBfdHlwZW9mKHNyY3kpICYmIF90eXBlb2Yoc3JjeSkgPT09IF90eXBlb2Yoc3JjdykgJiYgX3R5cGVvZihzcmN3KSA9PT0gX3R5cGVvZihzcmNoKSkge1xuICAgICAgICBzcmN4ID0gc3JjeCB8fCAwO1xuICAgICAgICBzcmN5ID0gc3JjeSB8fCAwO1xuICAgICAgICBzcmN3ID0gc3JjdyB8fCBzcmMuYml0bWFwLndpZHRoO1xuICAgICAgICBzcmNoID0gc3JjaCB8fCBzcmMuYml0bWFwLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3NyY3gsIHNyY3ksIHNyY3csIHNyY2ggbXVzdCBiZSBudW1iZXJzJywgY2IpO1xuICAgICAgfSAvLyByb3VuZCBpbnB1dFxuXG5cbiAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgeSA9IE1hdGgucm91bmQoeSk7IC8vIHJvdW5kIGlucHV0XG5cbiAgICAgIHNyY3ggPSBNYXRoLnJvdW5kKHNyY3gpO1xuICAgICAgc3JjeSA9IE1hdGgucm91bmQoc3JjeSk7XG4gICAgICBzcmN3ID0gTWF0aC5yb3VuZChzcmN3KTtcbiAgICAgIHNyY2ggPSBNYXRoLnJvdW5kKHNyY2gpO1xuICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5iaXRtYXAud2lkdGg7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuICAgICAgdmFyIGJhc2VJbWFnZSA9IHRoaXM7XG4gICAgICBzcmMuc2NhblF1aWV0KHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIGZ1bmN0aW9uIChzeCwgc3ksIGlkeCkge1xuICAgICAgICB2YXIgeE9mZnNldCA9IHggKyBzeCAtIHNyY3g7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0geSArIHN5IC0gc3JjeTtcblxuICAgICAgICBpZiAoeE9mZnNldCA+PSAwICYmIHlPZmZzZXQgPj0gMCAmJiBtYXhXaWR0aCAtIHhPZmZzZXQgPiAwICYmIG1heEhlaWdodCAtIHlPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgdmFyIGRzdElkeCA9IGJhc2VJbWFnZS5nZXRQaXhlbEluZGV4KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgIHZhciBfc3JjID0ge1xuICAgICAgICAgICAgcjogdGhpcy5iaXRtYXAuZGF0YVtpZHhdLFxuICAgICAgICAgICAgZzogdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSxcbiAgICAgICAgICAgIGI6IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0sXG4gICAgICAgICAgICBhOiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZHN0ID0ge1xuICAgICAgICAgICAgcjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeF0sXG4gICAgICAgICAgICBnOiBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMV0sXG4gICAgICAgICAgICBiOiBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMl0sXG4gICAgICAgICAgICBhOiBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgM11cbiAgICAgICAgICB9O1xuICAgICAgICAgIGJhc2VJbWFnZS5iaXRtYXAuZGF0YVtkc3RJZHhdID0gKF9zcmMuYSAqIChfc3JjLnIgLSBkc3QucikgLSBkc3QuciArIDI1NSA+PiA4KSArIGRzdC5yO1xuICAgICAgICAgIGJhc2VJbWFnZS5iaXRtYXAuZGF0YVtkc3RJZHggKyAxXSA9IChfc3JjLmEgKiAoX3NyYy5nIC0gZHN0LmcpIC0gZHN0LmcgKyAyNTUgPj4gOCkgKyBkc3QuZztcbiAgICAgICAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMl0gPSAoX3NyYy5hICogKF9zcmMuYiAtIGRzdC5iKSAtIGRzdC5iICsgMjU1ID4+IDgpICsgZHN0LmI7XG4gICAgICAgICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdID0gdGhpcy5jb25zdHJ1Y3Rvci5saW1pdDI1NShkc3QuYSArIF9zcmMuYSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgdmFyIG11bFRhYmxlID0gWzEsIDU3LCA0MSwgMjEsIDIwMywgMzQsIDk3LCA3MywgMjI3LCA5MSwgMTQ5LCA2MiwgMTA1LCA0NSwgMzksIDEzNywgMjQxLCAxMDcsIDMsIDE3MywgMzksIDcxLCA2NSwgMjM4LCAyMTksIDEwMSwgMTg3LCA4NywgODEsIDE1MSwgMTQxLCAxMzMsIDI0OSwgMTE3LCAyMjEsIDIwOSwgMTk3LCAxODcsIDE3NywgMTY5LCA1LCAxNTMsIDczLCAxMzksIDEzMywgMTI3LCAyNDMsIDIzMywgMjIzLCAxMDcsIDEwMywgOTksIDE5MSwgMjMsIDE3NywgMTcxLCAxNjUsIDE1OSwgNzcsIDE0OSwgOSwgMTM5LCAxMzUsIDEzMSwgMjUzLCAyNDUsIDExOSwgMjMxLCAyMjQsIDEwOSwgMjExLCAxMDMsIDI1LCAxOTUsIDE4OSwgMjMsIDQ1LCAxNzUsIDE3MSwgODMsIDgxLCA3OSwgMTU1LCAxNTEsIDE0NywgOSwgMTQxLCAxMzcsIDY3LCAxMzEsIDEyOSwgMjUxLCAxMjMsIDMwLCAyMzUsIDExNSwgMTEzLCAyMjEsIDIxNywgNTMsIDEzLCA1MSwgNTAsIDQ5LCAxOTMsIDE4OSwgMTg1LCA5MSwgMTc5LCAxNzUsIDQzLCAxNjksIDgzLCAxNjMsIDUsIDc5LCAxNTUsIDE5LCA3NSwgMTQ3LCAxNDUsIDE0MywgMzUsIDY5LCAxNywgNjcsIDMzLCA2NSwgMjU1LCAyNTEsIDI0NywgMjQzLCAyMzksIDU5LCAyOSwgMjI5LCAxMTMsIDExMSwgMjE5LCAyNywgMjEzLCAxMDUsIDIwNywgNTEsIDIwMSwgMTk5LCA0OSwgMTkzLCAxOTEsIDQ3LCA5MywgMTgzLCAxODEsIDE3OSwgMTEsIDg3LCA0MywgODUsIDE2NywgMTY1LCAxNjMsIDE2MSwgMTU5LCAxNTcsIDE1NSwgNzcsIDE5LCA3NSwgMzcsIDczLCAxNDUsIDE0MywgMTQxLCAzNSwgMTM4LCAxMzcsIDEzNSwgNjcsIDMzLCAxMzEsIDEyOSwgMjU1LCA2MywgMjUwLCAyNDcsIDYxLCAxMjEsIDIzOSwgMjM3LCAxMTcsIDI5LCAyMjksIDIyNywgMjI1LCAxMTEsIDU1LCAxMDksIDIxNiwgMjEzLCAyMTEsIDIwOSwgMjA3LCAyMDUsIDIwMywgMjAxLCAxOTksIDE5NywgMTk1LCAxOTMsIDQ4LCAxOTAsIDQ3LCA5MywgMTg1LCAxODMsIDE4MSwgMTc5LCAxNzgsIDE3NiwgMTc1LCAxNzMsIDE3MSwgODUsIDIxLCAxNjcsIDE2NSwgNDEsIDE2MywgMTYxLCA1LCA3OSwgMTU3LCA3OCwgMTU0LCAxNTMsIDE5LCA3NSwgMTQ5LCA3NCwgMTQ3LCA3MywgMTQ0LCAxNDMsIDcxLCAxNDEsIDE0MCwgMTM5LCAxMzcsIDE3LCAxMzUsIDEzNCwgMTMzLCA2NiwgMTMxLCA2NSwgMTI5LCAxXTtcbmV4cG9ydCB2YXIgc2hnVGFibGUgPSBbMCwgOSwgMTAsIDEwLCAxNCwgMTIsIDE0LCAxNCwgMTYsIDE1LCAxNiwgMTUsIDE2LCAxNSwgMTUsIDE3LCAxOCwgMTcsIDEyLCAxOCwgMTYsIDE3LCAxNywgMTksIDE5LCAxOCwgMTksIDE4LCAxOCwgMTksIDE5LCAxOSwgMjAsIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAxNSwgMjAsIDE5LCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMCwgMjAsIDIwLCAyMSwgMTgsIDIxLCAyMSwgMjEsIDIxLCAyMCwgMjEsIDE3LCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIxLCAyMiwgMjIsIDIxLCAyMiwgMjEsIDE5LCAyMiwgMjIsIDE5LCAyMCwgMjIsIDIyLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAxOCwgMjIsIDIyLCAyMSwgMjIsIDIyLCAyMywgMjIsIDIwLCAyMywgMjIsIDIyLCAyMywgMjMsIDIxLCAxOSwgMjEsIDIxLCAyMSwgMjMsIDIzLCAyMywgMjIsIDIzLCAyMywgMjEsIDIzLCAyMiwgMjMsIDE4LCAyMiwgMjMsIDIwLCAyMiwgMjMsIDIzLCAyMywgMjEsIDIyLCAyMCwgMjIsIDIxLCAyMiwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyMiwgMjEsIDI0LCAyMywgMjMsIDI0LCAyMSwgMjQsIDIzLCAyNCwgMjIsIDI0LCAyNCwgMjIsIDI0LCAyNCwgMjIsIDIzLCAyNCwgMjQsIDI0LCAyMCwgMjMsIDIyLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDIzLCAyMSwgMjMsIDIyLCAyMywgMjQsIDI0LCAyNCwgMjIsIDI0LCAyNCwgMjQsIDIzLCAyMiwgMjQsIDI0LCAyNSwgMjMsIDI1LCAyNSwgMjMsIDI0LCAyNSwgMjUsIDI0LCAyMiwgMjUsIDI1LCAyNSwgMjQsIDIzLCAyNCwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjMsIDI1LCAyMywgMjQsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI0LCAyMiwgMjUsIDI1LCAyMywgMjUsIDI1LCAyMCwgMjQsIDI1LCAyNCwgMjUsIDI1LCAyMiwgMjQsIDI1LCAyNCwgMjUsIDI0LCAyNSwgMjUsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjIsIDI1LCAyNSwgMjUsIDI0LCAyNSwgMjQsIDI1LCAxOF07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibHVyLXRhYmxlcy5qcy5tYXAiLCJpbXBvcnQgeyB0aHJvd0Vycm9yLCBpc05vZGVQYXR0ZXJuIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xuaW1wb3J0IHsgbXVsVGFibGUsIHNoZ1RhYmxlIH0gZnJvbSAnLi9ibHVyLXRhYmxlcyc7XG4vKlxuICAgIFN1cGVyZmFzdCBCbHVyICgwLjUpXG4gICAgaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9Cb3hCbHVyRm9yQ2FudmFzL0Zhc3RCbHVyLmpzXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTEgTWFyaW8gS2xpbmdlbWFublxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEEgZmFzdCBibHVyIGFsZ29yaXRobSB0aGF0IHByb2R1Y2VzIHNpbWlsYXIgZWZmZWN0IHRvIGEgR2F1c3NpYW4gYmx1ciAtIGJ1dCBNVUNIIHF1aWNrZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciB0aGUgcGl4ZWwgcmFkaXVzIG9mIHRoZSBibHVyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgYmx1cjogZnVuY3Rpb24gYmx1cihyLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiByICE9PSAnbnVtYmVyJykgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnciBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgaWYgKHIgPCAxKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdyIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnLCBjYik7XG4gICAgICB2YXIgcnN1bTtcbiAgICAgIHZhciBnc3VtO1xuICAgICAgdmFyIGJzdW07XG4gICAgICB2YXIgYXN1bTtcbiAgICAgIHZhciB4O1xuICAgICAgdmFyIHk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBwO1xuICAgICAgdmFyIHAxO1xuICAgICAgdmFyIHAyO1xuICAgICAgdmFyIHlwO1xuICAgICAgdmFyIHlpO1xuICAgICAgdmFyIHl3O1xuICAgICAgdmFyIHBhO1xuICAgICAgdmFyIHdtID0gdGhpcy5iaXRtYXAud2lkdGggLSAxO1xuICAgICAgdmFyIGhtID0gdGhpcy5iaXRtYXAuaGVpZ2h0IC0gMTsgLy8gY29uc3Qgd2ggPSB0aGlzLmJpdG1hcC53aWR0aCAqIHRoaXMuYml0bWFwLmhlaWdodDtcblxuICAgICAgdmFyIHJhZDEgPSByICsgMTtcbiAgICAgIHZhciBtdWxTdW0gPSBtdWxUYWJsZVtyXTtcbiAgICAgIHZhciBzaGdTdW0gPSBzaGdUYWJsZVtyXTtcbiAgICAgIHZhciByZWQgPSBbXTtcbiAgICAgIHZhciBncmVlbiA9IFtdO1xuICAgICAgdmFyIGJsdWUgPSBbXTtcbiAgICAgIHZhciBhbHBoYSA9IFtdO1xuICAgICAgdmFyIHZtaW4gPSBbXTtcbiAgICAgIHZhciB2bWF4ID0gW107XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDI7XG5cbiAgICAgIHdoaWxlIChpdGVyYXRpb25zLS0gPiAwKSB7XG4gICAgICAgIHlpID0gMDtcbiAgICAgICAgeXcgPSAwO1xuXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCB0aGlzLmJpdG1hcC5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIHJzdW0gPSB0aGlzLmJpdG1hcC5kYXRhW3l3XSAqIHJhZDE7XG4gICAgICAgICAgZ3N1bSA9IHRoaXMuYml0bWFwLmRhdGFbeXcgKyAxXSAqIHJhZDE7XG4gICAgICAgICAgYnN1bSA9IHRoaXMuYml0bWFwLmRhdGFbeXcgKyAyXSAqIHJhZDE7XG4gICAgICAgICAgYXN1bSA9IHRoaXMuYml0bWFwLmRhdGFbeXcgKyAzXSAqIHJhZDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHI7IGkrKykge1xuICAgICAgICAgICAgcCA9IHl3ICsgKChpID4gd20gPyB3bSA6IGkpIDw8IDIpO1xuICAgICAgICAgICAgcnN1bSArPSB0aGlzLmJpdG1hcC5kYXRhW3ArK107XG4gICAgICAgICAgICBnc3VtICs9IHRoaXMuYml0bWFwLmRhdGFbcCsrXTtcbiAgICAgICAgICAgIGJzdW0gKz0gdGhpcy5iaXRtYXAuZGF0YVtwKytdO1xuICAgICAgICAgICAgYXN1bSArPSB0aGlzLmJpdG1hcC5kYXRhW3BdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB0aGlzLmJpdG1hcC53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICByZWRbeWldID0gcnN1bTtcbiAgICAgICAgICAgIGdyZWVuW3lpXSA9IGdzdW07XG4gICAgICAgICAgICBibHVlW3lpXSA9IGJzdW07XG4gICAgICAgICAgICBhbHBoYVt5aV0gPSBhc3VtO1xuXG4gICAgICAgICAgICBpZiAoeSA9PT0gMCkge1xuICAgICAgICAgICAgICB2bWluW3hdID0gKChwID0geCArIHJhZDEpIDwgd20gPyBwIDogd20pIDw8IDI7XG4gICAgICAgICAgICAgIHZtYXhbeF0gPSAocCA9IHggLSByKSA+IDAgPyBwIDw8IDIgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwMSA9IHl3ICsgdm1pblt4XTtcbiAgICAgICAgICAgIHAyID0geXcgKyB2bWF4W3hdO1xuICAgICAgICAgICAgcnN1bSArPSB0aGlzLmJpdG1hcC5kYXRhW3AxKytdIC0gdGhpcy5iaXRtYXAuZGF0YVtwMisrXTtcbiAgICAgICAgICAgIGdzdW0gKz0gdGhpcy5iaXRtYXAuZGF0YVtwMSsrXSAtIHRoaXMuYml0bWFwLmRhdGFbcDIrK107XG4gICAgICAgICAgICBic3VtICs9IHRoaXMuYml0bWFwLmRhdGFbcDErK10gLSB0aGlzLmJpdG1hcC5kYXRhW3AyKytdO1xuICAgICAgICAgICAgYXN1bSArPSB0aGlzLmJpdG1hcC5kYXRhW3AxXSAtIHRoaXMuYml0bWFwLmRhdGFbcDJdO1xuICAgICAgICAgICAgeWkrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5dyArPSB0aGlzLmJpdG1hcC53aWR0aCA8PCAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHRoaXMuYml0bWFwLndpZHRoOyB4KyspIHtcbiAgICAgICAgICB5cCA9IHg7XG4gICAgICAgICAgcnN1bSA9IHJlZFt5cF0gKiByYWQxO1xuICAgICAgICAgIGdzdW0gPSBncmVlblt5cF0gKiByYWQxO1xuICAgICAgICAgIGJzdW0gPSBibHVlW3lwXSAqIHJhZDE7XG4gICAgICAgICAgYXN1bSA9IGFscGhhW3lwXSAqIHJhZDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHI7IGkrKykge1xuICAgICAgICAgICAgeXAgKz0gaSA+IGhtID8gMCA6IHRoaXMuYml0bWFwLndpZHRoO1xuICAgICAgICAgICAgcnN1bSArPSByZWRbeXBdO1xuICAgICAgICAgICAgZ3N1bSArPSBncmVlblt5cF07XG4gICAgICAgICAgICBic3VtICs9IGJsdWVbeXBdO1xuICAgICAgICAgICAgYXN1bSArPSBhbHBoYVt5cF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeWkgPSB4IDw8IDI7XG5cbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgdGhpcy5iaXRtYXAuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHBhID0gYXN1bSAqIG11bFN1bSA+Pj4gc2hnU3VtO1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aSArIDNdID0gcGE7IC8vIG5vcm1hbGl6ZSBhbHBoYVxuXG4gICAgICAgICAgICBpZiAocGEgPiAyNTUpIHtcbiAgICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aSArIDNdID0gMjU1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGEgPiAwKSB7XG4gICAgICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbeWldID0gKHJzdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aSArIDFdID0gKGdzdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aSArIDJdID0gKGJzdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bSkgKiBwYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbeWkgKyAyXSA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbeWkgKyAxXSA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbeWldID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgICAgICAgdm1pblt5XSA9ICgocCA9IHkgKyByYWQxKSA8IGhtID8gcCA6IGhtKSAqIHRoaXMuYml0bWFwLndpZHRoO1xuICAgICAgICAgICAgICB2bWF4W3ldID0gKHAgPSB5IC0gcikgPiAwID8gcCAqIHRoaXMuYml0bWFwLndpZHRoIDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcDEgPSB4ICsgdm1pblt5XTtcbiAgICAgICAgICAgIHAyID0geCArIHZtYXhbeV07XG4gICAgICAgICAgICByc3VtICs9IHJlZFtwMV0gLSByZWRbcDJdO1xuICAgICAgICAgICAgZ3N1bSArPSBncmVlbltwMV0gLSBncmVlbltwMl07XG4gICAgICAgICAgICBic3VtICs9IGJsdWVbcDFdIC0gYmx1ZVtwMl07XG4gICAgICAgICAgICBhc3VtICs9IGFscGhhW3AxXSAtIGFscGhhW3AyXTtcbiAgICAgICAgICAgIHlpICs9IHRoaXMuYml0bWFwLndpZHRoIDw8IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSB9XG5cbmltcG9ydCB0aW55Q29sb3IgZnJvbSAndGlueWNvbG9yMic7XG5pbXBvcnQgeyB0aHJvd0Vycm9yLCBpc05vZGVQYXR0ZXJuIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xuXG5mdW5jdGlvbiBhcHBseUtlcm5lbChpbSwga2VybmVsLCB4LCB5KSB7XG4gIHZhciB2YWx1ZSA9IFswLCAwLCAwXTtcbiAgdmFyIHNpemUgPSAoa2VybmVsLmxlbmd0aCAtIDEpIC8gMjtcblxuICBmb3IgKHZhciBreCA9IDA7IGt4IDwga2VybmVsLmxlbmd0aDsga3ggKz0gMSkge1xuICAgIGZvciAodmFyIGt5ID0gMDsga3kgPCBrZXJuZWxba3hdLmxlbmd0aDsga3kgKz0gMSkge1xuICAgICAgdmFyIGlkeCA9IGltLmdldFBpeGVsSW5kZXgoeCArIGt4IC0gc2l6ZSwgeSArIGt5IC0gc2l6ZSk7XG4gICAgICB2YWx1ZVswXSArPSBpbS5iaXRtYXAuZGF0YVtpZHhdICoga2VybmVsW2t4XVtreV07XG4gICAgICB2YWx1ZVsxXSArPSBpbS5iaXRtYXAuZGF0YVtpZHggKyAxXSAqIGtlcm5lbFtreF1ba3ldO1xuICAgICAgdmFsdWVbMl0gKz0gaW0uYml0bWFwLmRhdGFbaWR4ICsgMl0gKiBrZXJuZWxba3hdW2t5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBpc0RlZiA9IGZ1bmN0aW9uIGlzRGVmKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ICE9PSAndW5kZWZpbmVkJyAmJiB2ICE9PSBudWxsO1xufTtcblxuZnVuY3Rpb24gZ3JleXNjYWxlKGNiKSB7XG4gIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICB2YXIgZ3JleSA9IHBhcnNlSW50KDAuMjEyNiAqIHRoaXMuYml0bWFwLmRhdGFbaWR4XSArIDAuNzE1MiAqIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gKyAwLjA3MjIgKiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdLCAxMCk7XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gZ3JleTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gZ3JleTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gZ3JleTtcbiAgfSk7XG5cbiAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBtaXgoY2xyLCBjbHIyKSB7XG4gIHZhciBwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA1MDtcbiAgcmV0dXJuIHtcbiAgICByOiAoY2xyMi5yIC0gY2xyLnIpICogKHAgLyAxMDApICsgY2xyLnIsXG4gICAgZzogKGNscjIuZyAtIGNsci5nKSAqIChwIC8gMTAwKSArIGNsci5nLFxuICAgIGI6IChjbHIyLmIgLSBjbHIuYikgKiAocCAvIDEwMCkgKyBjbHIuYlxuICB9O1xufVxuXG5mdW5jdGlvbiBjb2xvckZuKGFjdGlvbnMsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCFhY3Rpb25zIHx8ICFBcnJheS5pc0FycmF5KGFjdGlvbnMpKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnYWN0aW9ucyBtdXN0IGJlIGFuIGFycmF5JywgY2IpO1xuICB9XG5cbiAgYWN0aW9ucyA9IGFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICBpZiAoYWN0aW9uLmFwcGx5ID09PSAneG9yJyB8fCBhY3Rpb24uYXBwbHkgPT09ICdtaXgnKSB7XG4gICAgICBhY3Rpb24ucGFyYW1zWzBdID0gdGlueUNvbG9yKGFjdGlvbi5wYXJhbXNbMF0pLnRvUmdiKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfSk7XG4gIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICB2YXIgY2xyID0ge1xuICAgICAgcjogX3RoaXMuYml0bWFwLmRhdGFbaWR4XSxcbiAgICAgIGc6IF90aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdLFxuICAgICAgYjogX3RoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl1cbiAgICB9O1xuXG4gICAgdmFyIGNvbG9yTW9kaWZpZXIgPSBmdW5jdGlvbiBjb2xvck1vZGlmaWVyKGksIGFtb3VudCkge1xuICAgICAgcmV0dXJuIF90aGlzLmNvbnN0cnVjdG9yLmxpbWl0MjU1KGNscltpXSArIGFtb3VudCk7XG4gICAgfTtcblxuICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLmFwcGx5ID09PSAnbWl4Jykge1xuICAgICAgICBjbHIgPSBtaXgoY2xyLCBhY3Rpb24ucGFyYW1zWzBdLCBhY3Rpb24ucGFyYW1zWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLmFwcGx5ID09PSAndGludCcpIHtcbiAgICAgICAgY2xyID0gbWl4KGNsciwge1xuICAgICAgICAgIHI6IDI1NSxcbiAgICAgICAgICBnOiAyNTUsXG4gICAgICAgICAgYjogMjU1XG4gICAgICAgIH0sIGFjdGlvbi5wYXJhbXNbMF0pO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24uYXBwbHkgPT09ICdzaGFkZScpIHtcbiAgICAgICAgY2xyID0gbWl4KGNsciwge1xuICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgZzogMCxcbiAgICAgICAgICBiOiAwXG4gICAgICAgIH0sIGFjdGlvbi5wYXJhbXNbMF0pO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24uYXBwbHkgPT09ICd4b3InKSB7XG4gICAgICAgIGNsciA9IHtcbiAgICAgICAgICByOiBjbHIuciBeIGFjdGlvbi5wYXJhbXNbMF0ucixcbiAgICAgICAgICBnOiBjbHIuZyBeIGFjdGlvbi5wYXJhbXNbMF0uZyxcbiAgICAgICAgICBiOiBjbHIuYiBeIGFjdGlvbi5wYXJhbXNbMF0uYlxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24uYXBwbHkgPT09ICdyZWQnKSB7XG4gICAgICAgIGNsci5yID0gY29sb3JNb2RpZmllcigncicsIGFjdGlvbi5wYXJhbXNbMF0pO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24uYXBwbHkgPT09ICdncmVlbicpIHtcbiAgICAgICAgY2xyLmcgPSBjb2xvck1vZGlmaWVyKCdnJywgYWN0aW9uLnBhcmFtc1swXSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi5hcHBseSA9PT0gJ2JsdWUnKSB7XG4gICAgICAgIGNsci5iID0gY29sb3JNb2RpZmllcignYicsIGFjdGlvbi5wYXJhbXNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jbHI7XG5cbiAgICAgICAgaWYgKGFjdGlvbi5hcHBseSA9PT0gJ2h1ZScpIHtcbiAgICAgICAgICBhY3Rpb24uYXBwbHkgPSAnc3Bpbic7XG4gICAgICAgIH1cblxuICAgICAgICBjbHIgPSB0aW55Q29sb3IoY2xyKTtcblxuICAgICAgICBpZiAoIWNsclthY3Rpb24uYXBwbHldKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbChfdGhpcywgJ2FjdGlvbiAnICsgYWN0aW9uLmFwcGx5ICsgJyBub3Qgc3VwcG9ydGVkJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xyID0gKF9jbHIgPSBjbHIpW2FjdGlvbi5hcHBseV0uYXBwbHkoX2NsciwgX3RvQ29uc3VtYWJsZUFycmF5KGFjdGlvbi5wYXJhbXMpKS50b1JnYigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSBjbHIucjtcbiAgICBfdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IGNsci5nO1xuICAgIF90aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gY2xyLmI7XG4gIH0pO1xuXG4gIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgdGhlIGFtb3VudCB0byBhZGp1c3QgdGhlIGJyaWdodG5lc3MsIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kICsxXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgYnJpZ2h0bmVzczogZnVuY3Rpb24gYnJpZ2h0bmVzcyh2YWwsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAndmFsIG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbCA8IC0xIHx8IHZhbCA+ICsxKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3ZhbCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kICsxJywgY2IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgIGlmICh2YWwgPCAwLjApIHtcbiAgICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gKiAoMSArIHZhbCk7XG4gICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gKiAoMSArIHZhbCk7XG4gICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gKiAoMSArIHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gdGhpcy5iaXRtYXAuZGF0YVtpZHhdICsgKDI1NSAtIHRoaXMuYml0bWFwLmRhdGFbaWR4XSkgKiB2YWw7XG4gICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gKyAoMjU1IC0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSkgKiB2YWw7XG4gICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gKyAoMjU1IC0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSkgKiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgdGhlIGFtb3VudCB0byBhZGp1c3QgdGhlIGNvbnRyYXN0LCBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCArMVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIGNvbnRyYXN0OiBmdW5jdGlvbiBjb250cmFzdCh2YWwsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAndmFsIG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbCA8IC0xIHx8IHZhbCA+ICsxKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3ZhbCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kICsxJywgY2IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gKHZhbCArIDEpIC8gKDEgLSB2YWwpO1xuXG4gICAgICBmdW5jdGlvbiBhZGp1c3QodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKGZhY3RvciAqICh2YWx1ZSAtIDEyNykgKyAxMjcpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gMCA6IHZhbHVlID4gMjU1ID8gMjU1IDogdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gYWRqdXN0KHRoaXMuYml0bWFwLmRhdGFbaWR4XSk7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSBhZGp1c3QodGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSk7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSBhZGp1c3QodGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHBvc3Rlcml6ZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgYW1vdW50IHRvIGFkanVzdCB0aGUgY29udHJhc3QsIG1pbmltdW0gdGhyZXNob2xkIGlzIHR3b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIHBvc3Rlcml6ZTogZnVuY3Rpb24gcG9zdGVyaXplKG4sIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ24gbXVzdCBiZSBudW1iZXJzJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA8IDIpIHtcbiAgICAgICAgbiA9IDI7XG4gICAgICB9IC8vIG1pbmltdW0gb2YgMiBsZXZlbHNcblxuXG4gICAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4XSA9IE1hdGguZmxvb3IodGhpcy5iaXRtYXAuZGF0YVtpZHhdIC8gMjU1ICogKG4gLSAxKSkgLyAobiAtIDEpICogMjU1O1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gTWF0aC5mbG9vcih0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdIC8gMjU1ICogKG4gLSAxKSkgLyAobiAtIDEpICogMjU1O1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gTWF0aC5mbG9vcih0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdIC8gMjU1ICogKG4gLSAxKSkgLyAobiAtIDEpICogMjU1O1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBjb2xvdXIgZnJvbSB0aGUgaW1hZ2UgdXNpbmcgSVRVIFJlYyA3MDkgbHVtaW5hbmNlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIGdyZXlzY2FsZTogZ3JleXNjYWxlLFxuICAgIC8vIEFsaWFzIG9mIGdyZXlzY2FsZSBmb3Igb3VyIEFtZXJpY2FuIGZyaWVuZHNcbiAgICBncmF5c2NhbGU6IGdyZXlzY2FsZSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIG9wYWNpdHkgb2YgZWFjaCBwaXhlbCBieSBhIGZhY3RvciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiBBIG51bWJlciwgdGhlIGZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseSB0aGUgb3BhY2l0eSBvZiBlYWNoIHBpeGVsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgb3BhY2l0eTogZnVuY3Rpb24gb3BhY2l0eShmLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBmICE9PSAnbnVtYmVyJykgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnZiBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgaWYgKGYgPCAwIHx8IGYgPiAxKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdmIG11c3QgYmUgYSBudW1iZXIgZnJvbSAwIHRvIDEnLCBjYik7XG4gICAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAzXSAqIGY7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgM10gPSB2O1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHNlcGlhIHRvbmUgdG8gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgc2VwaWE6IGZ1bmN0aW9uIHNlcGlhKGNiKSB7XG4gICAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgIHZhciByZWQgPSB0aGlzLmJpdG1hcC5kYXRhW2lkeF07XG4gICAgICAgIHZhciBncmVlbiA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV07XG4gICAgICAgIHZhciBibHVlID0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICAgICAgcmVkID0gcmVkICogMC4zOTMgKyBncmVlbiAqIDAuNzY5ICsgYmx1ZSAqIDAuMTg5O1xuICAgICAgICBncmVlbiA9IHJlZCAqIDAuMzQ5ICsgZ3JlZW4gKiAwLjY4NiArIGJsdWUgKiAwLjE2ODtcbiAgICAgICAgYmx1ZSA9IHJlZCAqIDAuMjcyICsgZ3JlZW4gKiAwLjUzNCArIGJsdWUgKiAwLjEzMTtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gcmVkIDwgMjU1ID8gcmVkIDogMjU1O1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gZ3JlZW4gPCAyNTUgPyBncmVlbiA6IDI1NTtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IGJsdWUgPCAyNTUgPyBibHVlIDogMjU1O1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmFkZXMgZWFjaCBwaXhlbCBieSBhIGZhY3RvciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiBBIG51bWJlciBmcm9tIDAgdG8gMS4gMCB3aWxsIGhhdmVuIG5vIGVmZmVjdC4gMSB3aWxsIHR1cm4gdGhlIGltYWdlIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgZmFkZTogZnVuY3Rpb24gZmFkZShmLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBmICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdmIG11c3QgYmUgYSBudW1iZXInLCBjYik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmIDwgMCB8fCBmID4gMSkge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdmIG11c3QgYmUgYSBudW1iZXIgZnJvbSAwIHRvIDEnLCBjYik7XG4gICAgICB9IC8vIHRoaXMgbWV0aG9kIGlzIGFuIGFsdGVybmF0aXZlIHRvIG9wYWNpdHkgKHdoaWNoIG1heSBiZSBkZXByZWNhdGVkKVxuXG5cbiAgICAgIHRoaXMub3BhY2l0eSgxIC0gZik7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGltYWdlIHRvIGl0cyBsb2NhbCBuZWlnaGJvcnMsIHdlaWdodGVkIGJ5IHRoZSBrZXJuZWxcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBrZXJuZWwgYSBtYXRyaXggdG8gd2VpZ2h0IHRoZSBuZWlnaGJvcnMgc3VtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVkZ2VIYW5kbGluZyAob3B0aW9uYWwpIGRlZmluZSBob3cgdG8gc3VtIHBpeGVscyBmcm9tIG91dHNpZGUgdGhlIGJvcmRlclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIGNvbnZvbHV0aW9uOiBmdW5jdGlvbiBjb252b2x1dGlvbihrZXJuZWwsIGVkZ2VIYW5kbGluZywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgZWRnZUhhbmRsaW5nID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2IgPSBlZGdlSGFuZGxpbmc7XG4gICAgICAgIGVkZ2VIYW5kbGluZyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWRnZUhhbmRsaW5nKSB7XG4gICAgICAgIGVkZ2VIYW5kbGluZyA9IHRoaXMuY29uc3RydWN0b3IuRURHRV9FWFRFTkQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdEYXRhID0gQnVmZmVyLmZyb20odGhpcy5iaXRtYXAuZGF0YSk7XG4gICAgICB2YXIga1Jvd3MgPSBrZXJuZWwubGVuZ3RoO1xuICAgICAgdmFyIGtDb2xzID0ga2VybmVsWzBdLmxlbmd0aDtcbiAgICAgIHZhciByb3dFbmQgPSBNYXRoLmZsb29yKGtSb3dzIC8gMik7XG4gICAgICB2YXIgY29sRW5kID0gTWF0aC5mbG9vcihrQ29scyAvIDIpO1xuICAgICAgdmFyIHJvd0luaSA9IC1yb3dFbmQ7XG4gICAgICB2YXIgY29sSW5pID0gLWNvbEVuZDtcbiAgICAgIHZhciB3ZWlnaHQ7XG4gICAgICB2YXIgclN1bTtcbiAgICAgIHZhciBnU3VtO1xuICAgICAgdmFyIGJTdW07XG4gICAgICB2YXIgcmk7XG4gICAgICB2YXIgZ2k7XG4gICAgICB2YXIgYmk7XG4gICAgICB2YXIgeGk7XG4gICAgICB2YXIgeWk7XG4gICAgICB2YXIgaWR4aTtcbiAgICAgIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgICAgYlN1bSA9IDA7XG4gICAgICAgIGdTdW0gPSAwO1xuICAgICAgICByU3VtID0gMDtcblxuICAgICAgICBmb3IgKHZhciByb3cgPSByb3dJbmk7IHJvdyA8PSByb3dFbmQ7IHJvdysrKSB7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gY29sSW5pOyBjb2wgPD0gY29sRW5kOyBjb2wrKykge1xuICAgICAgICAgICAgeGkgPSB4ICsgY29sO1xuICAgICAgICAgICAgeWkgPSB5ICsgcm93O1xuICAgICAgICAgICAgd2VpZ2h0ID0ga2VybmVsW3JvdyArIHJvd0VuZF1bY29sICsgY29sRW5kXTtcbiAgICAgICAgICAgIGlkeGkgPSB0aGlzLmdldFBpeGVsSW5kZXgoeGksIHlpLCBlZGdlSGFuZGxpbmcpO1xuXG4gICAgICAgICAgICBpZiAoaWR4aSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgYmkgPSAwO1xuICAgICAgICAgICAgICBnaSA9IDA7XG4gICAgICAgICAgICAgIHJpID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJpID0gdGhpcy5iaXRtYXAuZGF0YVtpZHhpICsgMF07XG4gICAgICAgICAgICAgIGdpID0gdGhpcy5iaXRtYXAuZGF0YVtpZHhpICsgMV07XG4gICAgICAgICAgICAgIGJpID0gdGhpcy5iaXRtYXAuZGF0YVtpZHhpICsgMl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJTdW0gKz0gd2VpZ2h0ICogcmk7XG4gICAgICAgICAgICBnU3VtICs9IHdlaWdodCAqIGdpO1xuICAgICAgICAgICAgYlN1bSArPSB3ZWlnaHQgKiBiaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoclN1bSA8IDApIHtcbiAgICAgICAgICByU3VtID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnU3VtIDwgMCkge1xuICAgICAgICAgIGdTdW0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJTdW0gPCAwKSB7XG4gICAgICAgICAgYlN1bSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoclN1bSA+IDI1NSkge1xuICAgICAgICAgIHJTdW0gPSAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ1N1bSA+IDI1NSkge1xuICAgICAgICAgIGdTdW0gPSAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYlN1bSA+IDI1NSkge1xuICAgICAgICAgIGJTdW0gPSAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRhW2lkeCArIDBdID0gclN1bTtcbiAgICAgICAgbmV3RGF0YVtpZHggKyAxXSA9IGdTdW07XG4gICAgICAgIG5ld0RhdGFbaWR4ICsgMl0gPSBiU3VtO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhID0gbmV3RGF0YTtcblxuICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGFscGhhIGNoYW5uZWwgb24gZXZlcnkgcGl4ZWwgdG8gZnVsbHkgb3BhcXVlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgb3BhcXVlOiBmdW5jdGlvbiBvcGFxdWUoY2IpIHtcbiAgICAgIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAzXSA9IDI1NTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpeGVsYXRlcyB0aGUgaW1hZ2Ugb3IgYSByZWdpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgc2l6ZSBvZiB0aGUgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggKG9wdGlvbmFsKSB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVnaW9uIHRvIHBpeGVsYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgKG9wdGlvbmFsKSB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVnaW9uIHRvIHBpeGVsYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgKG9wdGlvbmFsKSB0aGUgd2lkdGggb2YgdGhlIHJlZ2lvbiB0byBwaXhlbGF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoIChvcHRpb25hbCkgdGhlIGhlaWdodCBvZiB0aGUgcmVnaW9uIHRvIHBpeGVsYXRlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgcGl4ZWxhdGU6IGZ1bmN0aW9uIHBpeGVsYXRlKHNpemUsIHgsIHksIHcsIGgsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSB4O1xuICAgICAgICBoID0gbnVsbDtcbiAgICAgICAgdyA9IG51bGw7XG4gICAgICAgIHkgPSBudWxsO1xuICAgICAgICB4ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdzaXplIG11c3QgYmUgYSBudW1iZXInLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYoeCkgJiYgdHlwZW9mIHggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAneCBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHkpICYmIHR5cGVvZiB5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3kgbXVzdCBiZSBhIG51bWJlcicsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZih3KSAmJiB0eXBlb2YgdyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd3IG11c3QgYmUgYSBudW1iZXInLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYoaCkgJiYgdHlwZW9mIGggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnaCBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXJuZWwgPSBbWzEgLyAxNiwgMiAvIDE2LCAxIC8gMTZdLCBbMiAvIDE2LCA0IC8gMTYsIDIgLyAxNl0sIFsxIC8gMTYsIDIgLyAxNiwgMSAvIDE2XV07XG4gICAgICB4ID0geCB8fCAwO1xuICAgICAgeSA9IHkgfHwgMDtcbiAgICAgIHcgPSBpc0RlZih3KSA/IHcgOiB0aGlzLmJpdG1hcC53aWR0aCAtIHg7XG4gICAgICBoID0gaXNEZWYoaCkgPyBoIDogdGhpcy5iaXRtYXAuaGVpZ2h0IC0geTtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmNsb25lUXVpZXQoKTtcbiAgICAgIHRoaXMuc2NhblF1aWV0KHgsIHksIHcsIGgsIGZ1bmN0aW9uICh4eCwgeXgsIGlkeCkge1xuICAgICAgICB4eCA9IHNpemUgKiBNYXRoLmZsb29yKHh4IC8gc2l6ZSk7XG4gICAgICAgIHl4ID0gc2l6ZSAqIE1hdGguZmxvb3IoeXggLyBzaXplKTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXBwbHlLZXJuZWwoc291cmNlLCBrZXJuZWwsIHh4LCB5eCk7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4XSA9IHZhbHVlWzBdO1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gdmFsdWVbMV07XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSB2YWx1ZVsyXTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBjb252b2x1dGlvbiBrZXJuZWwgdG8gdGhlIGltYWdlIG9yIGEgcmVnaW9uXG4gICAgICogQHBhcmFtIHthcnJheX0ga2VybmVsIHRoZSBjb252b2x1dGlvbiBrZXJuZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAob3B0aW9uYWwpIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSByZWdpb24gdG8gYXBwbHkgY29udm9sdXRpb24gdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAob3B0aW9uYWwpIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSByZWdpb24gdG8gYXBwbHkgY29udm9sdXRpb24gdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyAob3B0aW9uYWwpIHRoZSB3aWR0aCBvZiB0aGUgcmVnaW9uIHRvIGFwcGx5IGNvbnZvbHV0aW9uIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggKG9wdGlvbmFsKSB0aGUgaGVpZ2h0IG9mIHRoZSByZWdpb24gdG8gYXBwbHkgY29udm9sdXRpb24gdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge0ppbXAgfXRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgKi9cbiAgICBjb252b2x1dGU6IGZ1bmN0aW9uIGNvbnZvbHV0ZShrZXJuZWwsIHgsIHksIHcsIGgsIGNiKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2VybmVsKSkgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAndGhlIGtlcm5lbCBtdXN0IGJlIGFuIGFycmF5JywgY2IpO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSB4O1xuICAgICAgICB4ID0gbnVsbDtcbiAgICAgICAgeSA9IG51bGw7XG4gICAgICAgIHcgPSBudWxsO1xuICAgICAgICBoID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0RlZih4KSAmJiB0eXBlb2YgeCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd4IG11c3QgYmUgYSBudW1iZXInLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYoeSkgJiYgdHlwZW9mIHkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAneSBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHcpICYmIHR5cGVvZiB3ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3cgbXVzdCBiZSBhIG51bWJlcicsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihoKSAmJiB0eXBlb2YgaCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdoIG11c3QgYmUgYSBudW1iZXInLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGtzaXplID0gKGtlcm5lbC5sZW5ndGggLSAxKSAvIDI7XG4gICAgICB4ID0gaXNEZWYoeCkgPyB4IDoga3NpemU7XG4gICAgICB5ID0gaXNEZWYoeSkgPyB5IDoga3NpemU7XG4gICAgICB3ID0gaXNEZWYodykgPyB3IDogdGhpcy5iaXRtYXAud2lkdGggLSB4O1xuICAgICAgaCA9IGlzRGVmKGgpID8gaCA6IHRoaXMuYml0bWFwLmhlaWdodCAtIHk7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5jbG9uZVF1aWV0KCk7XG4gICAgICB0aGlzLnNjYW5RdWlldCh4LCB5LCB3LCBoLCBmdW5jdGlvbiAoeHgsIHl4LCBpZHgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXBwbHlLZXJuZWwoc291cmNlLCBrZXJuZWwsIHh4LCB5eCk7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4XSA9IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUodmFsdWVbMF0pO1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gdGhpcy5jb25zdHJ1Y3Rvci5saW1pdDI1NSh2YWx1ZVsxXSk7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSB0aGlzLmNvbnN0cnVjdG9yLmxpbWl0MjU1KHZhbHVlWzJdKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IG11bHRpcGxlIGNvbG9yIG1vZGlmaWNhdGlvbiBydWxlc1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFjdGlvbnMgbGlzdCBvZiBjb2xvciBtb2RpZmljYXRpb24gcnVsZXMsIGluIGZvbGxvd2luZyBmb3JtYXQ6IHsgYXBwbHk6ICc8cnVsZS1uYW1lPicsIHBhcmFtczogWyA8cnVsZS1wYXJhbWV0ZXJzPiBdICB9XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgY29sb3I6IGNvbG9yRm4sXG4gICAgY29sb3VyOiBjb2xvckZuXG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tICdAamltcC91dGlscyc7XG4vKipcbiAqIFNjYWxlIHRoZSBpbWFnZSB0byB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodCBrZWVwaW5nIHRoZSBhc3BlY3QgcmF0aW8uIFNvbWUgcGFydHMgb2YgdGhlIGltYWdlIG1heSBiZSBsZXR0ZXIgYm94ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdyB0aGUgd2lkdGggdG8gcmVzaXplIHRoZSBpbWFnZSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IGggdGhlIGhlaWdodCB0byByZXNpemUgdGhlIGltYWdlIHRvXG4gKiBAcGFyYW0ge251bWJlcn0gYWxpZ25CaXRzIChvcHRpb25hbCkgQSBiaXRtYXNrIGZvciBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbGlnbm1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIChvcHRpb25hbCkgYSBzY2FsaW5nIG1ldGhvZCAoZS5nLiBKaW1wLlJFU0laRV9CRVpJRVIpXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgY29udGFpbjogZnVuY3Rpb24gY29udGFpbih3LCBoLCBhbGlnbkJpdHMsIG1vZGUsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIHcgIT09ICdudW1iZXInIHx8IHR5cGVvZiBoICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd3IGFuZCBoIG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICAgIH0gLy8gcGVybWl0IGFueSBzb3J0IG9mIG9wdGlvbmFsIHBhcmFtZXRlcnMgY29tYmluYXRpb25cblxuXG4gICAgICBpZiAodHlwZW9mIGFsaWduQml0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIGNiID0gbW9kZTtcbiAgICAgICAgbW9kZSA9IGFsaWduQml0cztcbiAgICAgICAgYWxpZ25CaXRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhbGlnbkJpdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIGNiID0gYWxpZ25CaXRzO1xuICAgICAgICBtb2RlID0gbnVsbDtcbiAgICAgICAgYWxpZ25CaXRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2IgPSBtb2RlO1xuICAgICAgICBtb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgYWxpZ25CaXRzID0gYWxpZ25CaXRzIHx8IHRoaXMuY29uc3RydWN0b3IuSE9SSVpPTlRBTF9BTElHTl9DRU5URVIgfCB0aGlzLmNvbnN0cnVjdG9yLlZFUlRJQ0FMX0FMSUdOX01JRERMRTtcbiAgICAgIHZhciBoYml0cyA9IGFsaWduQml0cyAmICgxIDw8IDMpIC0gMTtcbiAgICAgIHZhciB2Yml0cyA9IGFsaWduQml0cyA+PiAzOyAvLyBjaGVjayBpZiBtb3JlIGZsYWdzIHRoYW4gb25lIGlzIGluIHRoZSBiaXQgc2V0c1xuXG4gICAgICBpZiAoIShoYml0cyAhPT0gMCAmJiAhKGhiaXRzICYgaGJpdHMgLSAxKSB8fCB2Yml0cyAhPT0gMCAmJiAhKHZiaXRzICYgdmJpdHMgLSAxKSkpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnb25seSB1c2Ugb25lIGZsYWcgcGVyIGFsaWdubWVudCBkaXJlY3Rpb24nLCBjYik7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGlnbkggPSBoYml0cyA+PiAxOyAvLyAwLCAxLCAyXG5cbiAgICAgIHZhciBhbGlnblYgPSB2Yml0cyA+PiAxOyAvLyAwLCAxLCAyXG5cbiAgICAgIHZhciBmID0gdyAvIGggPiB0aGlzLmJpdG1hcC53aWR0aCAvIHRoaXMuYml0bWFwLmhlaWdodCA/IGggLyB0aGlzLmJpdG1hcC5oZWlnaHQgOiB3IC8gdGhpcy5iaXRtYXAud2lkdGg7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmVRdWlldCgpLnNjYWxlKGYsIG1vZGUpO1xuICAgICAgdGhpcy5yZXNpemUodywgaCwgbW9kZSk7XG4gICAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGEud3JpdGVVSW50MzJCRSh0aGlzLl9iYWNrZ3JvdW5kLCBpZHgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJsaXQoYywgKHRoaXMuYml0bWFwLndpZHRoIC0gYy5iaXRtYXAud2lkdGgpIC8gMiAqIGFsaWduSCwgKHRoaXMuYml0bWFwLmhlaWdodCAtIGMuYml0bWFwLmhlaWdodCkgLyAyICogYWxpZ25WKTtcblxuICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiwgdGhyb3dFcnJvciB9IGZyb20gJ0BqaW1wL3V0aWxzJztcbi8qKlxuICogU2NhbGUgdGhlIGltYWdlIHNvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0IGtlZXBpbmcgdGhlIGFzcGVjdCByYXRpby4gU29tZSBwYXJ0cyBvZiB0aGUgaW1hZ2UgbWF5IGJlIGNsaXBwZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdyB0aGUgd2lkdGggdG8gcmVzaXplIHRoZSBpbWFnZSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IGggdGhlIGhlaWdodCB0byByZXNpemUgdGhlIGltYWdlIHRvXG4gKiBAcGFyYW0ge251bWJlcn0gYWxpZ25CaXRzIChvcHRpb25hbCkgQSBiaXRtYXNrIGZvciBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbGlnbm1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIChvcHRpb25hbCkgYSBzY2FsaW5nIG1ldGhvZCAoZS5nLiBKaW1wLlJFU0laRV9CRVpJRVIpXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgY292ZXI6IGZ1bmN0aW9uIGNvdmVyKHcsIGgsIGFsaWduQml0cywgbW9kZSwgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgdyAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3cgYW5kIGggbXVzdCBiZSBudW1iZXJzJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ25CaXRzICYmIHR5cGVvZiBhbGlnbkJpdHMgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYiA9IGFsaWduQml0cztcbiAgICAgICAgYWxpZ25CaXRzID0gbnVsbDtcbiAgICAgICAgbW9kZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2IgPSBtb2RlO1xuICAgICAgICBtb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgYWxpZ25CaXRzID0gYWxpZ25CaXRzIHx8IHRoaXMuY29uc3RydWN0b3IuSE9SSVpPTlRBTF9BTElHTl9DRU5URVIgfCB0aGlzLmNvbnN0cnVjdG9yLlZFUlRJQ0FMX0FMSUdOX01JRERMRTtcbiAgICAgIHZhciBoYml0cyA9IGFsaWduQml0cyAmICgxIDw8IDMpIC0gMTtcbiAgICAgIHZhciB2Yml0cyA9IGFsaWduQml0cyA+PiAzOyAvLyBjaGVjayBpZiBtb3JlIGZsYWdzIHRoYW4gb25lIGlzIGluIHRoZSBiaXQgc2V0c1xuXG4gICAgICBpZiAoIShoYml0cyAhPT0gMCAmJiAhKGhiaXRzICYgaGJpdHMgLSAxKSB8fCB2Yml0cyAhPT0gMCAmJiAhKHZiaXRzICYgdmJpdHMgLSAxKSkpIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ29ubHkgdXNlIG9uZSBmbGFnIHBlciBhbGlnbm1lbnQgZGlyZWN0aW9uJywgY2IpO1xuICAgICAgdmFyIGFsaWduSCA9IGhiaXRzID4+IDE7IC8vIDAsIDEsIDJcblxuICAgICAgdmFyIGFsaWduViA9IHZiaXRzID4+IDE7IC8vIDAsIDEsIDJcblxuICAgICAgdmFyIGYgPSB3IC8gaCA+IHRoaXMuYml0bWFwLndpZHRoIC8gdGhpcy5iaXRtYXAuaGVpZ2h0ID8gdyAvIHRoaXMuYml0bWFwLndpZHRoIDogaCAvIHRoaXMuYml0bWFwLmhlaWdodDtcbiAgICAgIHRoaXMuc2NhbGUoZiwgbW9kZSk7XG4gICAgICB0aGlzLmNyb3AoKHRoaXMuYml0bWFwLndpZHRoIC0gdykgLyAyICogYWxpZ25ILCAodGhpcy5iaXRtYXAuaGVpZ2h0IC0gaCkgLyAyICogYWxpZ25WLCB3LCBoKTtcblxuICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tbGFiZWxzICovXG5pbXBvcnQgeyB0aHJvd0Vycm9yLCBpc05vZGVQYXR0ZXJuIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGx1Z2luQ3JvcChldmVudCkge1xuICAvKipcbiAgICogQ3JvcHMgdGhlIGltYWdlIGF0IGEgZ2l2ZW4gcG9pbnQgdG8gYSBnaXZlIHNpemVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZSB0byBjcm9wIGZvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgdGhlIHkgY29vcmRpbmF0ZSB0byBjcm9wIGZvcm1cbiAgICogQHBhcmFtIHcgdGhlIHdpZHRoIG9mIHRoZSBjcm9wIHJlZ2lvblxuICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBjcm9wIHJlZ2lvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAqL1xuICBldmVudCgnY3JvcCcsIGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBjYikge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHkgIT09ICdudW1iZXInKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd4IGFuZCB5IG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICBpZiAodHlwZW9mIHcgIT09ICdudW1iZXInIHx8IHR5cGVvZiBoICE9PSAnbnVtYmVyJykgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAndyBhbmQgaCBtdXN0IGJlIG51bWJlcnMnLCBjYik7IC8vIHJvdW5kIGlucHV0XG5cbiAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB3ID0gTWF0aC5yb3VuZCh3KTtcbiAgICBoID0gTWF0aC5yb3VuZChoKTtcblxuICAgIGlmICh4ID09PSAwICYmIHcgPT09IHRoaXMuYml0bWFwLndpZHRoKSB7XG4gICAgICAvLyBzaG9ydGN1dFxuICAgICAgdmFyIHN0YXJ0ID0gdyAqIHkgKyB4IDw8IDI7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyBoICogdyA8PCAyICsgMTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGEgPSB0aGlzLmJpdG1hcC5kYXRhLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYml0bWFwID0gQnVmZmVyLmFsbG9jVW5zYWZlKHcgKiBoICogNCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuc2NhblF1aWV0KHgsIHksIHcsIGgsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmJpdG1hcC5kYXRhLnJlYWRVSW50MzJCRShpZHgsIHRydWUpO1xuICAgICAgICBiaXRtYXAud3JpdGVVSW50MzJCRShkYXRhLCBvZmZzZXQsIHRydWUpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YSA9IGJpdG1hcDtcbiAgICB9XG5cbiAgICB0aGlzLmJpdG1hcC53aWR0aCA9IHc7XG4gICAgdGhpcy5iaXRtYXAuaGVpZ2h0ID0gaDtcblxuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xhc3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogQXV0b2Nyb3Agc2FtZSBjb2xvciBib3JkZXJzIGZyb20gdGhpcyBpbWFnZVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSAob3B0aW9uYWwpOiBhIHBlcmNlbnQgdmFsdWUgb2YgdG9sZXJhbmNlIGZvciBwaXhlbHMgY29sb3IgZGlmZmVyZW5jZSAoZGVmYXVsdDogMC4wMDAyJSlcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JvcE9ubHlGcmFtZXMgKG9wdGlvbmFsKTogZmxhZyB0byBjcm9wIG9ubHkgcmVhbCBmcmFtZXM6IGFsbCA0IHNpZGVzIG9mIHRoZSBpbWFnZSBtdXN0IGhhdmUgc29tZSBib3JkZXIgKGRlZmF1bHQ6IHRydWUpXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKTogYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZSAoZGVmYXVsdDogbm8gY2FsbGJhY2spXG4gICAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAgICovXG4gICAgICBhdXRvY3JvcDogZnVuY3Rpb24gYXV0b2Nyb3AoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy5iaXRtYXAud2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuICAgICAgICB2YXIgbWluUGl4ZWxzUGVyU2lkZSA9IDE7IC8vIHRvIGF2b2lkIGNyb3BwaW5nIGNvbXBsZXRlbHkgdGhlIGltYWdlLCByZXN1bHRpbmcgaW4gYW4gaW52YWxpZCAwIHNpemVkIGltYWdlXG5cbiAgICAgICAgdmFyIGNiOyAvLyBjYWxsYmFja1xuXG4gICAgICAgIHZhciBsZWF2ZUJvcmRlciA9IDA7IC8vIEFtb3VudCBvZiBwaXhlbHMgaW4gYm9yZGVyIHRvIGxlYXZlXG5cbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDAuMDAwMjsgLy8gcGVyY2VudCBvZiBjb2xvciBkaWZmZXJlbmNlIHRvbGVyYW5jZSAoZGVmYXVsdCB2YWx1ZSlcblxuICAgICAgICB2YXIgY3JvcE9ubHlGcmFtZXMgPSB0cnVlOyAvLyBmbGFnIHRvIGZvcmNlIGNyb3BwaW5nIG9ubHkgaWYgdGhlIGltYWdlIGhhcyBhIHJlYWwgXCJmcmFtZVwiXG4gICAgICAgIC8vIGkuZS4gYWxsIDQgc2lkZXMgaGF2ZSBzb21lIGJvcmRlciAoZGVmYXVsdCB2YWx1ZSlcblxuICAgICAgICB2YXIgY3JvcFN5bW1ldHJpYyA9IGZhbHNlOyAvLyBmbGFnIHRvIGZvcmNlIGNyb3BwaW5nIHRvcCBiZSBzeW1tZXRyaWMuXG4gICAgICAgIC8vIGkuZS4gbm9ydGggYW5kIHNvdXRoIC8gZWFzdCBhbmQgd2VzdCBhcmUgY3JvcHBlZCBieSB0aGUgc2FtZSB2YWx1ZVxuICAgICAgICAvLyBwYXJzZSBhcmd1bWVudHNcblxuICAgICAgICBmb3IgKHZhciBhID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgYSA8IGxlbjsgYSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiAoYSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBhID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2FdKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIHRvbGVyYW5jZSB2YWx1ZSBwYXNzZWRcbiAgICAgICAgICAgIHRvbGVyYW5jZSA9IGEgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gYSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1thXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIChhIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbYV0pID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIC8vIGNyb3BPbmx5RnJhbWVzIHZhbHVlIHBhc3NlZFxuICAgICAgICAgICAgY3JvcE9ubHlGcmFtZXMgPSBhIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiAoYSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBhID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2FdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gY2FsbGJhY2sgdmFsdWUgcGFzc2VkXG4gICAgICAgICAgICBjYiA9IGEgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gYSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1thXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3R5cGVvZihhIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbYV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gY29uZmlnIG9iamVjdCBwYXNzZWRcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBhIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbYV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRvbGVyYW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdG9sZXJhbmNlID0gY29uZmlnLnRvbGVyYW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuY3JvcE9ubHlGcmFtZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGNyb3BPbmx5RnJhbWVzID0gY29uZmlnLmNyb3BPbmx5RnJhbWVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5jcm9wU3ltbWV0cmljICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjcm9wU3ltbWV0cmljID0gY29uZmlnLmNyb3BTeW1tZXRyaWM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmxlYXZlQm9yZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBsZWF2ZUJvcmRlciA9IGNvbmZpZy5sZWF2ZUJvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBib3JkZXJzIG11c3QgYmUgb2YgdGhlIHNhbWUgY29sb3IgYXMgdGhlIHRvcCBsZWZ0IHBpeGVsLCB0byBiZSBjcm9wcGVkLlxuICAgICAgICAgKiBJdCBzaG91bGQgYmUgcG9zc2libGUgdG8gY3JvcCBib3JkZXJzIGVhY2ggd2l0aCBhIGRpZmZlcmVudCBjb2xvcixcbiAgICAgICAgICogYnV0IHNpbmNlIHRoZXJlIGFyZSBtYW55IHdheXMgZm9yIGNvcm5lcnMgdG8gaW50ZXJzZWN0LCBpdCB3b3VsZFxuICAgICAgICAgKiBpbnRyb2R1Y2UgdW5uZWNlc3NhcnkgY29tcGxleGl0eSB0byB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gc2NhbiBlYWNoIHNpZGUgZm9yIHNhbWUgY29sb3IgYm9yZGVyc1xuXG5cbiAgICAgICAgdmFyIGNvbG9yVGFyZ2V0ID0gdGhpcy5nZXRQaXhlbENvbG9yKDAsIDApOyAvLyB0b3AgbGVmdCBwaXhlbCBjb2xvciBpcyB0aGUgdGFyZ2V0IGNvbG9yXG5cbiAgICAgICAgdmFyIHJnYmExID0gdGhpcy5jb25zdHJ1Y3Rvci5pbnRUb1JHQkEoY29sb3JUYXJnZXQpOyAvLyBmb3Igbm9ydGggYW5kIGVhc3Qgc2lkZXNcblxuICAgICAgICB2YXIgbm9ydGhQaXhlbHNUb0Nyb3AgPSAwO1xuICAgICAgICB2YXIgZWFzdFBpeGVsc1RvQ3JvcCA9IDA7XG4gICAgICAgIHZhciBzb3V0aFBpeGVsc1RvQ3JvcCA9IDA7XG4gICAgICAgIHZhciB3ZXN0UGl4ZWxzVG9Dcm9wID0gMDsgLy8gbm9ydGggc2lkZSAoc2NhbiByb3dzIGZyb20gbm9ydGggdG8gc291dGgpXG5cbiAgICAgICAgY29sb3JUYXJnZXQgPSB0aGlzLmdldFBpeGVsQ29sb3IoMCwgMCk7XG5cbiAgICAgICAgbm9ydGg6IGZvciAodmFyIHkgPSAwOyB5IDwgaCAtIG1pblBpeGVsc1BlclNpZGU7IHkrKykge1xuICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JYWSA9IHRoaXMuZ2V0UGl4ZWxDb2xvcih4LCB5KTtcbiAgICAgICAgICAgIHZhciByZ2JhMiA9IHRoaXMuY29uc3RydWN0b3IuaW50VG9SR0JBKGNvbG9yWFkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5jb2xvckRpZmYocmdiYTEsIHJnYmEyKSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIHBpeGVsIGlzIHRvbyBkaXN0YW50IGZyb20gdGhlIGZpcnN0IG9uZTogYWJvcnQgdGhpcyBzaWRlIHNjYW5cbiAgICAgICAgICAgICAgbm9ydGhQaXhlbHNUb0Nyb3AgLT0gbGVhdmVCb3JkZXI7XG4gICAgICAgICAgICAgIGJyZWFrIG5vcnRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gdGhpcyByb3cgY29udGFpbnMgYWxsIHBpeGVscyB3aXRoIHRoZSBzYW1lIGNvbG9yOiBpbmNyZW1lbnQgdGhpcyBzaWRlIHBpeGVscyB0byBjcm9wXG5cblxuICAgICAgICAgIG5vcnRoUGl4ZWxzVG9Dcm9wKys7XG4gICAgICAgIH0gLy8gZWFzdCBzaWRlIChzY2FuIGNvbHVtbnMgZnJvbSBlYXN0IHRvIHdlc3QpXG5cblxuICAgICAgICBjb2xvclRhcmdldCA9IHRoaXMuZ2V0UGl4ZWxDb2xvcih3LCAwKTtcblxuICAgICAgICBlYXN0OiBmb3IgKHZhciBfeCA9IDA7IF94IDwgdyAtIG1pblBpeGVsc1BlclNpZGU7IF94KyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfeSA9IDAgKyBub3J0aFBpeGVsc1RvQ3JvcDsgX3kgPCBoOyBfeSsrKSB7XG4gICAgICAgICAgICB2YXIgX2NvbG9yWFkgPSB0aGlzLmdldFBpeGVsQ29sb3IoX3gsIF95KTtcblxuICAgICAgICAgICAgdmFyIF9yZ2JhID0gdGhpcy5jb25zdHJ1Y3Rvci5pbnRUb1JHQkEoX2NvbG9yWFkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5jb2xvckRpZmYocmdiYTEsIF9yZ2JhKSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIHBpeGVsIGlzIHRvbyBkaXN0YW50IGZyb20gdGhlIGZpcnN0IG9uZTogYWJvcnQgdGhpcyBzaWRlIHNjYW5cbiAgICAgICAgICAgICAgZWFzdFBpeGVsc1RvQ3JvcCAtPSBsZWF2ZUJvcmRlcjtcbiAgICAgICAgICAgICAgYnJlYWsgZWFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHRoaXMgY29sdW1uIGNvbnRhaW5zIGFsbCBwaXhlbHMgd2l0aCB0aGUgc2FtZSBjb2xvcjogaW5jcmVtZW50IHRoaXMgc2lkZSBwaXhlbHMgdG8gY3JvcFxuXG5cbiAgICAgICAgICBlYXN0UGl4ZWxzVG9Dcm9wKys7XG4gICAgICAgIH0gLy8gc291dGggc2lkZSAoc2NhbiByb3dzIGZyb20gc291dGggdG8gbm9ydGgpXG5cblxuICAgICAgICBjb2xvclRhcmdldCA9IHRoaXMuZ2V0UGl4ZWxDb2xvcigwLCBoKTtcblxuICAgICAgICBzb3V0aDogZm9yICh2YXIgX3kyID0gaCAtIDE7IF95MiA+PSBub3J0aFBpeGVsc1RvQ3JvcCArIG1pblBpeGVsc1BlclNpZGU7IF95Mi0tKSB7XG4gICAgICAgICAgZm9yICh2YXIgX3gyID0gdyAtIGVhc3RQaXhlbHNUb0Nyb3AgLSAxOyBfeDIgPj0gMDsgX3gyLS0pIHtcbiAgICAgICAgICAgIHZhciBfY29sb3JYWTIgPSB0aGlzLmdldFBpeGVsQ29sb3IoX3gyLCBfeTIpO1xuXG4gICAgICAgICAgICB2YXIgX3JnYmEyID0gdGhpcy5jb25zdHJ1Y3Rvci5pbnRUb1JHQkEoX2NvbG9yWFkyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuY29sb3JEaWZmKHJnYmExLCBfcmdiYTIpID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgcGl4ZWwgaXMgdG9vIGRpc3RhbnQgZnJvbSB0aGUgZmlyc3Qgb25lOiBhYm9ydCB0aGlzIHNpZGUgc2NhblxuICAgICAgICAgICAgICBzb3V0aFBpeGVsc1RvQ3JvcCAtPSBsZWF2ZUJvcmRlcjtcbiAgICAgICAgICAgICAgYnJlYWsgc291dGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyB0aGlzIHJvdyBjb250YWlucyBhbGwgcGl4ZWxzIHdpdGggdGhlIHNhbWUgY29sb3I6IGluY3JlbWVudCB0aGlzIHNpZGUgcGl4ZWxzIHRvIGNyb3BcblxuXG4gICAgICAgICAgc291dGhQaXhlbHNUb0Nyb3ArKztcbiAgICAgICAgfSAvLyB3ZXN0IHNpZGUgKHNjYW4gY29sdW1ucyBmcm9tIHdlc3QgdG8gZWFzdClcblxuXG4gICAgICAgIGNvbG9yVGFyZ2V0ID0gdGhpcy5nZXRQaXhlbENvbG9yKHcsIGgpO1xuXG4gICAgICAgIHdlc3Q6IGZvciAodmFyIF94MyA9IHcgLSAxOyBfeDMgPj0gMCArIGVhc3RQaXhlbHNUb0Nyb3AgKyBtaW5QaXhlbHNQZXJTaWRlOyBfeDMtLSkge1xuICAgICAgICAgIGZvciAodmFyIF95MyA9IGggLSAxOyBfeTMgPj0gMCArIG5vcnRoUGl4ZWxzVG9Dcm9wOyBfeTMtLSkge1xuICAgICAgICAgICAgdmFyIF9jb2xvclhZMyA9IHRoaXMuZ2V0UGl4ZWxDb2xvcihfeDMsIF95Myk7XG5cbiAgICAgICAgICAgIHZhciBfcmdiYTMgPSB0aGlzLmNvbnN0cnVjdG9yLmludFRvUkdCQShfY29sb3JYWTMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5jb2xvckRpZmYocmdiYTEsIF9yZ2JhMykgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBwaXhlbCBpcyB0b28gZGlzdGFudCBmcm9tIHRoZSBmaXJzdCBvbmU6IGFib3J0IHRoaXMgc2lkZSBzY2FuXG4gICAgICAgICAgICAgIHdlc3RQaXhlbHNUb0Nyb3AgLT0gbGVhdmVCb3JkZXI7XG4gICAgICAgICAgICAgIGJyZWFrIHdlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyB0aGlzIGNvbHVtbiBjb250YWlucyBhbGwgcGl4ZWxzIHdpdGggdGhlIHNhbWUgY29sb3I6IGluY3JlbWVudCB0aGlzIHNpZGUgcGl4ZWxzIHRvIGNyb3BcblxuXG4gICAgICAgICAgd2VzdFBpeGVsc1RvQ3JvcCsrO1xuICAgICAgICB9IC8vIGRlY2lkZSBpZiBhIGNyb3AgaXMgbmVlZGVkXG5cblxuICAgICAgICB2YXIgZG9Dcm9wID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNyb3BTeW1tZXRyaWMpIHtcbiAgICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IE1hdGgubWluKGVhc3RQaXhlbHNUb0Nyb3AsIHdlc3RQaXhlbHNUb0Nyb3ApO1xuICAgICAgICAgIHZhciB2ZXJ0aWNhbCA9IE1hdGgubWluKG5vcnRoUGl4ZWxzVG9Dcm9wLCBzb3V0aFBpeGVsc1RvQ3JvcCk7XG4gICAgICAgICAgd2VzdFBpeGVsc1RvQ3JvcCA9IGhvcml6b250YWw7XG4gICAgICAgICAgZWFzdFBpeGVsc1RvQ3JvcCA9IGhvcml6b250YWw7XG4gICAgICAgICAgbm9ydGhQaXhlbHNUb0Nyb3AgPSB2ZXJ0aWNhbDtcbiAgICAgICAgICBzb3V0aFBpeGVsc1RvQ3JvcCA9IHZlcnRpY2FsO1xuICAgICAgICB9IC8vIHNhZmV0eSBjaGVja3NcblxuXG4gICAgICAgIHZhciB3aWR0aE9mUmVtYWluaW5nUGl4ZWxzID0gdyAtICh3ZXN0UGl4ZWxzVG9Dcm9wICsgZWFzdFBpeGVsc1RvQ3JvcCk7XG4gICAgICAgIHZhciBoZWlnaHRPZlJlbWFpbmluZ1BpeGVscyA9IGggLSAoc291dGhQaXhlbHNUb0Nyb3AgKyBub3J0aFBpeGVsc1RvQ3JvcCk7XG5cbiAgICAgICAgaWYgKGNyb3BPbmx5RnJhbWVzKSB7XG4gICAgICAgICAgLy8gY3JvcCBpbWFnZSBpZiBhbGwgc2lkZXMgc2hvdWxkIGJlIGNyb3BwZWRcbiAgICAgICAgICBkb0Nyb3AgPSBlYXN0UGl4ZWxzVG9Dcm9wICE9PSAwICYmIG5vcnRoUGl4ZWxzVG9Dcm9wICE9PSAwICYmIHdlc3RQaXhlbHNUb0Nyb3AgIT09IDAgJiYgc291dGhQaXhlbHNUb0Nyb3AgIT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JvcCBpbWFnZSBpZiBhdCBsZWFzdCBvbmUgc2lkZSBzaG91bGQgYmUgY3JvcHBlZFxuICAgICAgICAgIGRvQ3JvcCA9IGVhc3RQaXhlbHNUb0Nyb3AgIT09IDAgfHwgbm9ydGhQaXhlbHNUb0Nyb3AgIT09IDAgfHwgd2VzdFBpeGVsc1RvQ3JvcCAhPT0gMCB8fCBzb3V0aFBpeGVsc1RvQ3JvcCAhPT0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb0Nyb3ApIHtcbiAgICAgICAgICAvLyBkbyB0aGUgcmVhbCBjcm9wXG4gICAgICAgICAgdGhpcy5jcm9wKGVhc3RQaXhlbHNUb0Nyb3AsIG5vcnRoUGl4ZWxzVG9Dcm9wLCB3aWR0aE9mUmVtYWluaW5nUGl4ZWxzLCBoZWlnaHRPZlJlbWFpbmluZ1BpeGVscyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuaW1wb3J0IHsgaXNOb2RlUGF0dGVybiwgdGhyb3dFcnJvciB9IGZyb20gJ0BqaW1wL3V0aWxzJztcbi8qKlxuICogRGlzcGxhY2VzIHRoZSBpbWFnZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGlzcGxhY2VtZW50IG1hcFxuICogQHBhcmFtIHtvYmplY3R9IG1hcCB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIG1heGltdW0gZGlzcGxhY2VtZW50IHZhbHVlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2U6IGZ1bmN0aW9uIGRpc3BsYWNlKG1hcCwgb2Zmc2V0LCBjYikge1xuICAgICAgaWYgKF90eXBlb2YobWFwKSAhPT0gJ29iamVjdCcgfHwgbWFwLmNvbnN0cnVjdG9yICE9PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ1RoZSBzb3VyY2UgbXVzdCBiZSBhIEppbXAgaW1hZ2UnLCBjYik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdmYWN0b3IgbXVzdCBiZSBhIG51bWJlcicsIGNiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuY2xvbmVRdWlldCgpO1xuICAgICAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHgsIHksIGlkeCkge1xuICAgICAgICB2YXIgZGlzcGxhY2VtZW50ID0gbWFwLmJpdG1hcC5kYXRhW2lkeF0gLyAyNTYgKiBvZmZzZXQ7XG4gICAgICAgIGRpc3BsYWNlbWVudCA9IE1hdGgucm91bmQoZGlzcGxhY2VtZW50KTtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuZ2V0UGl4ZWxJbmRleCh4ICsgZGlzcGxhY2VtZW50LCB5KTtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHNdID0gc291cmNlLmJpdG1hcC5kYXRhW2lkeF07XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWRzICsgMV0gPSBzb3VyY2UuYml0bWFwLmRhdGFbaWR4ICsgMV07XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWRzICsgMl0gPSBzb3VyY2UuYml0bWFwLmRhdGFbaWR4ICsgMl07XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiB9IGZyb20gJ0BqaW1wL3V0aWxzJztcbi8qKlxuICogQXBwbHkgYSBvcmRlcmVkIGRpdGhlcmluZyBlZmZlY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cblxuZnVuY3Rpb24gZGl0aGVyKGNiKSB7XG4gIHZhciByZ2I1NjVNYXRyaXggPSBbMSwgOSwgMywgMTEsIDEzLCA1LCAxNSwgNywgNCwgMTIsIDIsIDEwLCAxNiwgOCwgMTQsIDZdO1xuICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgdmFyIHRocmVzaG9sZElkID0gKCh5ICYgMykgPDwgMikgKyB4ICUgNDtcbiAgICB2YXIgZGl0aGVyID0gcmdiNTY1TWF0cml4W3RocmVzaG9sZElkXTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSBNYXRoLm1pbih0aGlzLmJpdG1hcC5kYXRhW2lkeF0gKyBkaXRoZXIsIDB4ZmYpO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSBNYXRoLm1pbih0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdICsgZGl0aGVyLCAweGZmKTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gTWF0aC5taW4odGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSArIGRpdGhlciwgMHhmZik7XG4gIH0pO1xuXG4gIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkaXRoZXI1NjU6IGRpdGhlcixcbiAgICBkaXRoZXIxNjogZGl0aGVyXG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tICdAamltcC91dGlscyc7XG4vKipcbiAqIEZsaXAgdGhlIGltYWdlIGhvcml6b250YWxseVxuICogQHBhcmFtIHtib29sZWFufSBob3Jpem9udGFsIGEgQm9vbGVhbiwgaWYgdHJ1ZSB0aGUgaW1hZ2Ugd2lsbCBiZSBmbGlwcGVkIGhvcml6b250YWxseVxuICogQHBhcmFtIHtib29sZWFufSB2ZXJ0aWNhbCBhIEJvb2xlYW4sIGlmIHRydWUgdGhlIGltYWdlIHdpbGwgYmUgZmxpcHBlZCB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5cbmZ1bmN0aW9uIGZsaXBGbihob3Jpem9udGFsLCB2ZXJ0aWNhbCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBob3Jpem9udGFsICE9PSAnYm9vbGVhbicgfHwgdHlwZW9mIHZlcnRpY2FsICE9PSAnYm9vbGVhbicpIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ2hvcml6b250YWwgYW5kIHZlcnRpY2FsIG11c3QgYmUgQm9vbGVhbnMnLCBjYik7XG5cbiAgaWYgKGhvcml6b250YWwgJiYgdmVydGljYWwpIHtcbiAgICAvLyBzaG9ydGN1dFxuICAgIHJldHVybiB0aGlzLnJvdGF0ZSgxODAsIHRydWUsIGNiKTtcbiAgfVxuXG4gIHZhciBiaXRtYXAgPSBCdWZmZXIuYWxsb2ModGhpcy5iaXRtYXAuZGF0YS5sZW5ndGgpO1xuICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgdmFyIF94ID0gaG9yaXpvbnRhbCA/IHRoaXMuYml0bWFwLndpZHRoIC0gMSAtIHggOiB4O1xuXG4gICAgdmFyIF95ID0gdmVydGljYWwgPyB0aGlzLmJpdG1hcC5oZWlnaHQgLSAxIC0geSA6IHk7XG5cbiAgICB2YXIgX2lkeCA9IHRoaXMuYml0bWFwLndpZHRoICogX3kgKyBfeCA8PCAyO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmJpdG1hcC5kYXRhLnJlYWRVSW50MzJCRShpZHgpO1xuICAgIGJpdG1hcC53cml0ZVVJbnQzMkJFKGRhdGEsIF9pZHgpO1xuICB9KTtcbiAgdGhpcy5iaXRtYXAuZGF0YSA9IEJ1ZmZlci5mcm9tKGJpdG1hcCk7XG5cbiAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGZsaXA6IGZsaXBGbixcbiAgICBtaXJyb3I6IGZsaXBGblxuICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xuLyoqXG4gKiBBcHBsaWVzIGEgdHJ1ZSBHYXVzc2lhbiBibHVyIHRvIHRoZSBpbWFnZSAod2FybmluZzogdGhpcyBpcyBWRVJZIHNsb3cpXG4gKiBAcGFyYW0ge251bWJlcn0gciB0aGUgcGl4ZWwgcmFkaXVzIG9mIHRoZSBibHVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgZ2F1c3NpYW46IGZ1bmN0aW9uIGdhdXNzaWFuKHIsIGNiKSB7XG4gICAgICAvLyBodHRwOi8vYmxvZy5pdmFuay5uZXQvZmFzdGVzdC1nYXVzc2lhbi1ibHVyLmh0bWxcbiAgICAgIGlmICh0eXBlb2YgciAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnciBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAociA8IDEpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnciBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJywgY2IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcnMgPSBNYXRoLmNlaWwociAqIDIuNTcpOyAvLyBzaWduaWZpY2FudCByYWRpdXNcblxuICAgICAgdmFyIHJhbmdlID0gcnMgKiAyICsgMTtcbiAgICAgIHZhciBycjIgPSByICogciAqIDI7XG4gICAgICB2YXIgcnIycGkgPSBycjIgKiBNYXRoLlBJO1xuICAgICAgdmFyIHdlaWdodHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCByYW5nZTsgeSsrKSB7XG4gICAgICAgIHdlaWdodHNbeV0gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHJhbmdlOyB4KyspIHtcbiAgICAgICAgICB2YXIgZHNxID0gTWF0aC5wb3coeCAtIHJzLCAyKSArIE1hdGgucG93KHkgLSBycywgMik7XG4gICAgICAgICAgd2VpZ2h0c1t5XVt4XSA9IE1hdGguZXhwKC1kc3EgLyBycjIpIC8gcnIycGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3kgPSAwOyBfeSA8IHRoaXMuYml0bWFwLmhlaWdodDsgX3krKykge1xuICAgICAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgdGhpcy5iaXRtYXAud2lkdGg7IF94KyspIHtcbiAgICAgICAgICB2YXIgcmVkID0gMDtcbiAgICAgICAgICB2YXIgZ3JlZW4gPSAwO1xuICAgICAgICAgIHZhciBibHVlID0gMDtcbiAgICAgICAgICB2YXIgYWxwaGEgPSAwO1xuICAgICAgICAgIHZhciB3c3VtID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGl5ID0gMDsgaXkgPCByYW5nZTsgaXkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaXggPSAwOyBpeCA8IHJhbmdlOyBpeCsrKSB7XG4gICAgICAgICAgICAgIHZhciB4MSA9IE1hdGgubWluKHRoaXMuYml0bWFwLndpZHRoIC0gMSwgTWF0aC5tYXgoMCwgaXggKyBfeCAtIHJzKSk7XG4gICAgICAgICAgICAgIHZhciB5MSA9IE1hdGgubWluKHRoaXMuYml0bWFwLmhlaWdodCAtIDEsIE1hdGgubWF4KDAsIGl5ICsgX3kgLSBycykpO1xuICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0c1tpeV1baXhdO1xuXG4gICAgICAgICAgICAgIHZhciBfaWR4ID0geTEgKiB0aGlzLmJpdG1hcC53aWR0aCArIHgxIDw8IDI7XG5cbiAgICAgICAgICAgICAgcmVkICs9IHRoaXMuYml0bWFwLmRhdGFbX2lkeF0gKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgIGdyZWVuICs9IHRoaXMuYml0bWFwLmRhdGFbX2lkeCArIDFdICogd2VpZ2h0O1xuICAgICAgICAgICAgICBibHVlICs9IHRoaXMuYml0bWFwLmRhdGFbX2lkeCArIDJdICogd2VpZ2h0O1xuICAgICAgICAgICAgICBhbHBoYSArPSB0aGlzLmJpdG1hcC5kYXRhW19pZHggKyAzXSAqIHdlaWdodDtcbiAgICAgICAgICAgICAgd3N1bSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSBfeSAqIHRoaXMuYml0bWFwLndpZHRoICsgX3ggPDwgMjtcbiAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4XSA9IE1hdGgucm91bmQocmVkIC8gd3N1bSk7XG4gICAgICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gTWF0aC5yb3VuZChncmVlbiAvIHdzdW0pO1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IE1hdGgucm91bmQoYmx1ZSAvIHdzdW0pO1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAzXSA9IE1hdGgucm91bmQoYWxwaGEgLyB3c3VtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiB9IGZyb20gJ0BqaW1wL3V0aWxzJztcbi8qKlxuICogSW52ZXJ0cyB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnZlcnQ6IGZ1bmN0aW9uIGludmVydChjYikge1xuICAgICAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHgsIHksIGlkeCkge1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSAyNTUgLSB0aGlzLmJpdG1hcC5kYXRhW2lkeF07XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSAyNTUgLSB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdO1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gMjU1IC0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xuLyoqXG4gKiBNYXNrcyBhIHNvdXJjZSBpbWFnZSBvbiB0byB0aGlzIGltYWdlIHVzaW5nIGF2ZXJhZ2UgcGl4ZWwgY29sb3VyLiBBIGNvbXBsZXRlbHkgYmxhY2sgcGl4ZWwgb24gdGhlIG1hc2sgd2lsbCB0dXJuIGEgcGl4ZWwgaW4gdGhlIGltYWdlIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnQuXG4gKiBAcGFyYW0ge0ppbXB9IHNyYyB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIHRvIGJsaXQgdGhlIGltYWdlXG4gKiBAcGFyYW0ge251bWJlcn0geSB0aGUgdmVydGljYWwgcG9zaXRpb24gdG8gYmxpdCB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBtYXNrOiBmdW5jdGlvbiBtYXNrKHNyYykge1xuICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIShzcmMgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdUaGUgc291cmNlIG11c3QgYmUgYSBKaW1wIGltYWdlJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInIHx8IHR5cGVvZiB5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd4IGFuZCB5IG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICAgIH0gLy8gcm91bmQgaW5wdXRcblxuXG4gICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgdmFyIHcgPSB0aGlzLmJpdG1hcC53aWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuICAgICAgdmFyIGJhc2VJbWFnZSA9IHRoaXM7XG4gICAgICBzcmMuc2NhblF1aWV0KDAsIDAsIHNyYy5iaXRtYXAud2lkdGgsIHNyYy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoc3gsIHN5LCBpZHgpIHtcbiAgICAgICAgdmFyIGRlc3RYID0geCArIHN4O1xuICAgICAgICB2YXIgZGVzdFkgPSB5ICsgc3k7XG5cbiAgICAgICAgaWYgKGRlc3RYID49IDAgJiYgZGVzdFkgPj0gMCAmJiBkZXN0WCA8IHcgJiYgZGVzdFkgPCBoKSB7XG4gICAgICAgICAgdmFyIGRzdElkeCA9IGJhc2VJbWFnZS5nZXRQaXhlbEluZGV4KGRlc3RYLCBkZXN0WSk7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmJpdG1hcC5kYXRhO1xuICAgICAgICAgIHZhciBhdmcgPSAoZGF0YVtpZHggKyAwXSArIGRhdGFbaWR4ICsgMV0gKyBkYXRhW2lkeCArIDJdKSAvIDM7XG4gICAgICAgICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdICo9IGF2ZyAvIDI1NTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWxhYmVscyAqL1xuaW1wb3J0IHsgaXNOb2RlUGF0dGVybiB9IGZyb20gJ0BqaW1wL3V0aWxzJztcbi8qKlxuICogR2V0IGFuIGltYWdlJ3MgaGlzdG9ncmFtXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIGNvbG9yIG9jY3VycmVuY2UgY291bnRzIGZvciBlYWNoIGNoYW5uZWwgKHIsZyxiKVxuICovXG5cbmZ1bmN0aW9uIGhpc3RvZ3JhbSgpIHtcbiAgdmFyIGhpc3RvZ3JhbSA9IHtcbiAgICByOiBuZXcgQXJyYXkoMjU2KS5maWxsKDApLFxuICAgIGc6IG5ldyBBcnJheSgyNTYpLmZpbGwoMCksXG4gICAgYjogbmV3IEFycmF5KDI1NikuZmlsbCgwKVxuICB9O1xuICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaW5kZXgpIHtcbiAgICBoaXN0b2dyYW0uclt0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMF1dKys7XG4gICAgaGlzdG9ncmFtLmdbdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDFdXSsrO1xuICAgIGhpc3RvZ3JhbS5iW3RoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAyXV0rKztcbiAgfSk7XG4gIHJldHVybiBoaXN0b2dyYW07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSB2YWx1ZXNcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHZhbHVlIFBpeGVsIGNoYW5uZWwgdmFsdWUuXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBtaW4gICBNaW5pbXVtIHZhbHVlIGZvciBjaGFubmVsXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBtYXggICBNYXhpbXVtIHZhbHVlIGZvciBjaGFubmVsXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSBub3JtYWxpemVkIHZhbHVlc1xuICovXG5cblxudmFyIF9ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiAodmFsdWUgLSBtaW4pICogMjU1IC8gKG1heCAtIG1pbik7XG59O1xuXG52YXIgZ2V0Qm91bmRzID0gZnVuY3Rpb24gZ2V0Qm91bmRzKGhpc3RvZ3JhbUNoYW5uZWwpIHtcbiAgcmV0dXJuIFtoaXN0b2dyYW1DaGFubmVsLmZpbmRJbmRleChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPiAwO1xuICB9KSwgMjU1IC0gaGlzdG9ncmFtQ2hhbm5lbC5zbGljZSgpLnJldmVyc2UoKS5maW5kSW5kZXgoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID4gMDtcbiAgfSldO1xufTtcbi8qKlxuICogTm9ybWFsaXplcyB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKGNiKSB7XG4gICAgICB2YXIgaCA9IGhpc3RvZ3JhbS5jYWxsKHRoaXMpOyAvLyBzdG9yZSBib3VuZHMgKG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzKVxuXG4gICAgICB2YXIgYm91bmRzID0ge1xuICAgICAgICByOiBnZXRCb3VuZHMoaC5yKSxcbiAgICAgICAgZzogZ2V0Qm91bmRzKGguZyksXG4gICAgICAgIGI6IGdldEJvdW5kcyhoLmIpXG4gICAgICB9OyAvLyBhcHBseSB2YWx1ZSB0cmFuc2Zvcm1hdGlvbnNcblxuICAgICAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHgsIHksIGlkeCkge1xuICAgICAgICB2YXIgciA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMF07XG4gICAgICAgIHZhciBnID0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdO1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDBdID0gX25vcm1hbGl6ZShyLCBib3VuZHMuclswXSwgYm91bmRzLnJbMV0pO1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gX25vcm1hbGl6ZShnLCBib3VuZHMuZ1swXSwgYm91bmRzLmdbMV0pO1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gX25vcm1hbGl6ZShiLCBib3VuZHMuYlswXSwgYm91bmRzLmJbMV0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSB9XG5cbmltcG9ydCBQYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGJNRm9udCBmcm9tICdsb2FkLWJtZm9udCc7XG5pbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xuaW1wb3J0IHsgbWVhc3VyZVRleHQsIG1lYXN1cmVUZXh0SGVpZ2h0IH0gZnJvbSAnLi9tZWFzdXJlLXRleHQnO1xuXG5mdW5jdGlvbiB4T2Zmc2V0QmFzZWRPbkFsaWdubWVudChjb25zdGFudHMsIGZvbnQsIGxpbmUsIG1heFdpZHRoLCBhbGlnbm1lbnQpIHtcbiAgaWYgKGFsaWdubWVudCA9PT0gY29uc3RhbnRzLkhPUklaT05UQUxfQUxJR05fTEVGVCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFsaWdubWVudCA9PT0gY29uc3RhbnRzLkhPUklaT05UQUxfQUxJR05fQ0VOVEVSKSB7XG4gICAgcmV0dXJuIChtYXhXaWR0aCAtIG1lYXN1cmVUZXh0KGZvbnQsIGxpbmUpKSAvIDI7XG4gIH1cblxuICByZXR1cm4gbWF4V2lkdGggLSBtZWFzdXJlVGV4dChmb250LCBsaW5lKTtcbn1cblxuZnVuY3Rpb24gZHJhd0NoYXJhY3RlcihpbWFnZSwgZm9udCwgeCwgeSwgY2hhcikge1xuICBpZiAoY2hhci53aWR0aCA+IDAgJiYgY2hhci5oZWlnaHQgPiAwKSB7XG4gICAgdmFyIGNoYXJhY3RlclBhZ2UgPSBmb250LnBhZ2VzW2NoYXIucGFnZV07XG4gICAgaW1hZ2UuYmxpdChjaGFyYWN0ZXJQYWdlLCB4ICsgY2hhci54b2Zmc2V0LCB5ICsgY2hhci55b2Zmc2V0LCBjaGFyLngsIGNoYXIueSwgY2hhci53aWR0aCwgY2hhci5oZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIGltYWdlO1xufVxuXG5mdW5jdGlvbiBwcmludFRleHQoZm9udCwgeCwgeSwgdGV4dCwgZGVmYXVsdENoYXJXaWR0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhciA9IHZvaWQgMDtcblxuICAgIGlmIChmb250LmNoYXJzW3RleHRbaV1dKSB7XG4gICAgICBjaGFyID0gdGV4dFtpXTtcbiAgICB9IGVsc2UgaWYgKC9cXHMvLnRlc3QodGV4dFtpXSkpIHtcbiAgICAgIGNoYXIgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhciA9ICc/JztcbiAgICB9XG5cbiAgICB2YXIgZm9udENoYXIgPSBmb250LmNoYXJzW2NoYXJdIHx8IHt9O1xuICAgIHZhciBmb250S2VybmluZyA9IGZvbnQua2VybmluZ3NbY2hhcl07XG4gICAgZHJhd0NoYXJhY3Rlcih0aGlzLCBmb250LCB4LCB5LCBmb250Q2hhciB8fCB7fSk7XG4gICAgdmFyIGtlcm5pbmcgPSBmb250S2VybmluZyAmJiBmb250S2VybmluZ1t0ZXh0W2kgKyAxXV0gPyBmb250S2VybmluZ1t0ZXh0W2kgKyAxXV0gOiAwO1xuICAgIHggKz0ga2VybmluZyArIChmb250Q2hhci54YWR2YW5jZSB8fCBkZWZhdWx0Q2hhcldpZHRoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdExpbmVzKGZvbnQsIHRleHQsIG1heFdpZHRoKSB7XG4gIHZhciB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKTtcbiAgdmFyIGxpbmVzID0gW107XG4gIHZhciBjdXJyZW50TGluZSA9IFtdO1xuICB2YXIgbG9uZ2VzdExpbmUgPSAwO1xuICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgdmFyIGxpbmUgPSBfdG9Db25zdW1hYmxlQXJyYXkoY3VycmVudExpbmUpLmNvbmNhdChbd29yZF0pLmpvaW4oJyAnKTtcblxuICAgIHZhciBsZW5ndGggPSBtZWFzdXJlVGV4dChmb250LCBsaW5lKTtcblxuICAgIGlmIChsZW5ndGggPD0gbWF4V2lkdGgpIHtcbiAgICAgIGlmIChsZW5ndGggPiBsb25nZXN0TGluZSkge1xuICAgICAgICBsb25nZXN0TGluZSA9IGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgY3VycmVudExpbmUucHVzaCh3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICBjdXJyZW50TGluZSA9IFt3b3JkXTtcbiAgICB9XG4gIH0pO1xuICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZXMsXG4gICAgbG9uZ2VzdExpbmU6IGxvbmdlc3RMaW5lXG4gIH07XG59XG5cbmZ1bmN0aW9uIGxvYWRQYWdlcyhKaW1wLCBkaXIsIHBhZ2VzKSB7XG4gIHZhciBuZXdQYWdlcyA9IHBhZ2VzLm1hcChmdW5jdGlvbiAocGFnZSkge1xuICAgIHJldHVybiBKaW1wLnJlYWQoZGlyICsgJy8nICsgcGFnZSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwobmV3UGFnZXMpO1xufVxuXG52YXIgZGlyID0gcHJvY2Vzcy5lbnYuRElSTkFNRSB8fCBcIlwiLmNvbmNhdChfX2Rpcm5hbWUsIFwiLy4uL1wiKTtcbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgY29uc3RhbnRzOiB7XG4gICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVRleHQsXG4gICAgICBtZWFzdXJlVGV4dEhlaWdodDogbWVhc3VyZVRleHRIZWlnaHQsXG4gICAgICBGT05UX1NBTlNfOF9CTEFDSzogUGF0aC5qb2luKGRpciwgJ2ZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtOC1ibGFjay9vcGVuLXNhbnMtOC1ibGFjay5mbnQnKSxcbiAgICAgIEZPTlRfU0FOU18xMF9CTEFDSzogUGF0aC5qb2luKGRpciwgJ2ZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtMTAtYmxhY2svb3Blbi1zYW5zLTEwLWJsYWNrLmZudCcpLFxuICAgICAgRk9OVF9TQU5TXzEyX0JMQUNLOiBQYXRoLmpvaW4oZGlyLCAnZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy0xMi1ibGFjay9vcGVuLXNhbnMtMTItYmxhY2suZm50JyksXG4gICAgICBGT05UX1NBTlNfMTRfQkxBQ0s6IFBhdGguam9pbihkaXIsICdmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTE0LWJsYWNrL29wZW4tc2Fucy0xNC1ibGFjay5mbnQnKSxcbiAgICAgIEZPTlRfU0FOU18xNl9CTEFDSzogUGF0aC5qb2luKGRpciwgJ2ZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtMTYtYmxhY2svb3Blbi1zYW5zLTE2LWJsYWNrLmZudCcpLFxuICAgICAgRk9OVF9TQU5TXzMyX0JMQUNLOiBQYXRoLmpvaW4oZGlyLCAnZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy0zMi1ibGFjay9vcGVuLXNhbnMtMzItYmxhY2suZm50JyksXG4gICAgICBGT05UX1NBTlNfNjRfQkxBQ0s6IFBhdGguam9pbihkaXIsICdmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTY0LWJsYWNrL29wZW4tc2Fucy02NC1ibGFjay5mbnQnKSxcbiAgICAgIEZPTlRfU0FOU18xMjhfQkxBQ0s6IFBhdGguam9pbihkaXIsICdmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTEyOC1ibGFjay9vcGVuLXNhbnMtMTI4LWJsYWNrLmZudCcpLFxuICAgICAgRk9OVF9TQU5TXzhfV0hJVEU6IFBhdGguam9pbihkaXIsICdmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTgtd2hpdGUvb3Blbi1zYW5zLTgtd2hpdGUuZm50JyksXG4gICAgICBGT05UX1NBTlNfMTZfV0hJVEU6IFBhdGguam9pbihkaXIsICdmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTE2LXdoaXRlL29wZW4tc2Fucy0xNi13aGl0ZS5mbnQnKSxcbiAgICAgIEZPTlRfU0FOU18zMl9XSElURTogUGF0aC5qb2luKGRpciwgJ2ZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtMzItd2hpdGUvb3Blbi1zYW5zLTMyLXdoaXRlLmZudCcpLFxuICAgICAgRk9OVF9TQU5TXzY0X1dISVRFOiBQYXRoLmpvaW4oZGlyLCAnZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy02NC13aGl0ZS9vcGVuLXNhbnMtNjQtd2hpdGUuZm50JyksXG4gICAgICBGT05UX1NBTlNfMTI4X1dISVRFOiBQYXRoLmpvaW4oZGlyLCAnZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy0xMjgtd2hpdGUvb3Blbi1zYW5zLTEyOC13aGl0ZS5mbnQnKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBMb2FkcyBhIGJpdG1hcCBmb250IGZyb20gYSBmaWxlXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZSB0aGUgZmlsZSBwYXRoIG9mIGEgLmZudCBmaWxlXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZm9udCBpcyBsb2FkZWRcbiAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2VcbiAgICAgICAqL1xuICAgICAgbG9hZEZvbnQ6IGZ1bmN0aW9uIGxvYWRGb250KGZpbGUsIGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlICE9PSAnc3RyaW5nJykgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnZmlsZSBtdXN0IGJlIGEgc3RyaW5nJywgY2IpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGNiID0gY2IgfHwgZnVuY3Rpb24gKGVyciwgZm9udCkge1xuICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7ZWxzZSByZXNvbHZlKGZvbnQpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBiTUZvbnQoZmlsZSwgZnVuY3Rpb24gKGVyciwgZm9udCkge1xuICAgICAgICAgICAgdmFyIGNoYXJzID0ge307XG4gICAgICAgICAgICB2YXIga2VybmluZ3MgPSB7fTtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKF90aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNoYXJzW1N0cmluZy5mcm9tQ2hhckNvZGUoZm9udC5jaGFyc1tpXS5pZCldID0gZm9udC5jaGFyc1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZvbnQua2VybmluZ3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBmaXJzdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZm9udC5rZXJuaW5nc1tfaV0uZmlyc3QpO1xuICAgICAgICAgICAgICBrZXJuaW5nc1tmaXJzdFN0cmluZ10gPSBrZXJuaW5nc1tmaXJzdFN0cmluZ10gfHwge307XG4gICAgICAgICAgICAgIGtlcm5pbmdzW2ZpcnN0U3RyaW5nXVtTdHJpbmcuZnJvbUNoYXJDb2RlKGZvbnQua2VybmluZ3NbX2ldLnNlY29uZCldID0gZm9udC5rZXJuaW5nc1tfaV0uYW1vdW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2FkUGFnZXMoX3RoaXMsIFBhdGguZGlybmFtZShmaWxlKSwgZm9udC5wYWdlcykudGhlbihmdW5jdGlvbiAocGFnZXMpIHtcbiAgICAgICAgICAgICAgY2IobnVsbCwge1xuICAgICAgICAgICAgICAgIGNoYXJzOiBjaGFycyxcbiAgICAgICAgICAgICAgICBrZXJuaW5nczoga2VybmluZ3MsXG4gICAgICAgICAgICAgICAgcGFnZXM6IHBhZ2VzLFxuICAgICAgICAgICAgICAgIGNvbW1vbjogZm9udC5jb21tb24sXG4gICAgICAgICAgICAgICAgaW5mbzogZm9udC5pbmZvXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xhc3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogRHJhd3MgYSB0ZXh0IG9uIGEgaW1hZ2Ugb24gYSBnaXZlbiBib3VuZGFyeVxuICAgICAgICogQHBhcmFtIHtKaW1wfSBmb250IGEgYml0bWFwIGZvbnQgbG9hZGVkIGZyb20gYEppbXAubG9hZEZvbnRgIGNvbW1hbmRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IHBvc2l0aW9uIHRvIHN0YXJ0IGRyYXdpbmcgdGhlIHRleHRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IHBvc2l0aW9uIHRvIHN0YXJ0IGRyYXdpbmcgdGhlIHRleHRcbiAgICAgICAqIEBwYXJhbSB7YW55fSB0ZXh0IHRoZSB0ZXh0IHRvIGRyYXcgKHN0cmluZyBvciBvYmplY3Qgd2l0aCBgdGV4dGAsIGBhbGlnbm1lbnRYYCwgYW5kL29yIGBhbGlnbm1lbnRZYClcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAob3B0aW9uYWwpIHRoZSBib3VuZGFyeSB3aWR0aCB0byBkcmF3IGluXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IChvcHRpb25hbCkgdGhlIGJvdW5kYXJ5IGhlaWdodCB0byBkcmF3IGluXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdGV4dCBpcyB3cml0dGVuXG4gICAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAgICovXG4gICAgICBwcmludDogZnVuY3Rpb24gcHJpbnQoZm9udCwgeCwgeSwgdGV4dCwgbWF4V2lkdGgsIG1heEhlaWdodCwgY2IpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXhXaWR0aCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY2IgPSBtYXhXaWR0aDtcbiAgICAgICAgICBtYXhXaWR0aCA9IEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXhXaWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXhIZWlnaHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNiID0gbWF4SGVpZ2h0O1xuICAgICAgICAgIG1heEhlaWdodCA9IEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXhIZWlnaHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3R5cGVvZihmb250KSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdmb250IG11c3QgYmUgYSBKaW1wIGxvYWRGb250JywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgeSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIG1heFdpZHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3gsIHkgYW5kIG1heFdpZHRoIG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4V2lkdGggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnbWF4V2lkdGggbXVzdCBiZSBhIG51bWJlcicsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4SGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ21heEhlaWdodCBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFsaWdubWVudFg7XG4gICAgICAgIHZhciBhbGlnbm1lbnRZO1xuXG4gICAgICAgIGlmIChfdHlwZW9mKHRleHQpID09PSAnb2JqZWN0JyAmJiB0ZXh0LnRleHQgIT09IG51bGwgJiYgdGV4dC50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhbGlnbm1lbnRYID0gdGV4dC5hbGlnbm1lbnRYIHx8IHRoaXMuY29uc3RydWN0b3IuSE9SSVpPTlRBTF9BTElHTl9MRUZUO1xuICAgICAgICAgIGFsaWdubWVudFkgPSB0ZXh0LmFsaWdubWVudFkgfHwgdGhpcy5jb25zdHJ1Y3Rvci5WRVJUSUNBTF9BTElHTl9UT1A7XG4gICAgICAgICAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgICAgICAgICB0ZXh0ID0gX3RleHQudGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbm1lbnRYID0gdGhpcy5jb25zdHJ1Y3Rvci5IT1JJWk9OVEFMX0FMSUdOX0xFRlQ7XG4gICAgICAgICAgYWxpZ25tZW50WSA9IHRoaXMuY29uc3RydWN0b3IuVkVSVElDQUxfQUxJR05fVE9QO1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4SGVpZ2h0ICE9PSBJbmZpbml0eSAmJiBhbGlnbm1lbnRZID09PSB0aGlzLmNvbnN0cnVjdG9yLlZFUlRJQ0FMX0FMSUdOX0JPVFRPTSkge1xuICAgICAgICAgIHkgKz0gbWF4SGVpZ2h0IC0gbWVhc3VyZVRleHRIZWlnaHQoZm9udCwgdGV4dCwgbWF4V2lkdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1heEhlaWdodCAhPT0gSW5maW5pdHkgJiYgYWxpZ25tZW50WSA9PT0gdGhpcy5jb25zdHJ1Y3Rvci5WRVJUSUNBTF9BTElHTl9NSURETEUpIHtcbiAgICAgICAgICB5ICs9IG1heEhlaWdodCAvIDIgLSBtZWFzdXJlVGV4dEhlaWdodChmb250LCB0ZXh0LCBtYXhXaWR0aCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRDaGFyV2lkdGggPSBPYmplY3QuZW50cmllcyhmb250LmNoYXJzKVswXVsxXS54YWR2YW5jZTtcblxuICAgICAgICB2YXIgX3NwbGl0TGluZXMgPSBzcGxpdExpbmVzKGZvbnQsIHRleHQsIG1heFdpZHRoKSxcbiAgICAgICAgICAgIGxpbmVzID0gX3NwbGl0TGluZXMubGluZXMsXG4gICAgICAgICAgICBsb25nZXN0TGluZSA9IF9zcGxpdExpbmVzLmxvbmdlc3RMaW5lO1xuXG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICB2YXIgbGluZVN0cmluZyA9IGxpbmUuam9pbignICcpO1xuICAgICAgICAgIHZhciBhbGlnbm1lbnRXaWR0aCA9IHhPZmZzZXRCYXNlZE9uQWxpZ25tZW50KF90aGlzMi5jb25zdHJ1Y3RvciwgZm9udCwgbGluZVN0cmluZywgbWF4V2lkdGgsIGFsaWdubWVudFgpO1xuICAgICAgICAgIHByaW50VGV4dC5jYWxsKF90aGlzMiwgZm9udCwgeCArIGFsaWdubWVudFdpZHRoLCB5LCBsaW5lU3RyaW5nLCBkZWZhdWx0Q2hhcldpZHRoKTtcbiAgICAgICAgICB5ICs9IGZvbnQuY29tbW9uLmxpbmVIZWlnaHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcywge1xuICAgICAgICAgICAgeDogeCArIGxvbmdlc3RMaW5lLFxuICAgICAgICAgICAgeTogeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gbWVhc3VyZVRleHQoZm9udCwgdGV4dCkge1xuICB2YXIgeCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZvbnQuY2hhcnNbdGV4dFtpXV0pIHtcbiAgICAgIHZhciBrZXJuaW5nID0gZm9udC5rZXJuaW5nc1t0ZXh0W2ldXSAmJiBmb250Lmtlcm5pbmdzW3RleHRbaV1dW3RleHRbaSArIDFdXSA/IGZvbnQua2VybmluZ3NbdGV4dFtpXV1bdGV4dFtpICsgMV1dIDogMDtcbiAgICAgIHggKz0gKGZvbnQuY2hhcnNbdGV4dFtpXV0ueGFkdmFuY2UgfHwgMCkgKyBrZXJuaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0SGVpZ2h0KGZvbnQsIHRleHQsIG1heFdpZHRoKSB7XG4gIHZhciB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKTtcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIHRleHRUb3RhbEhlaWdodCA9IGZvbnQuY29tbW9uLmxpbmVIZWlnaHQ7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB3b3Jkcy5sZW5ndGg7IG4rKykge1xuICAgIHZhciB0ZXN0TGluZSA9IGxpbmUgKyB3b3Jkc1tuXSArICcgJztcbiAgICB2YXIgdGVzdFdpZHRoID0gbWVhc3VyZVRleHQoZm9udCwgdGVzdExpbmUpO1xuXG4gICAgaWYgKHRlc3RXaWR0aCA+IG1heFdpZHRoICYmIG4gPiAwKSB7XG4gICAgICB0ZXh0VG90YWxIZWlnaHQgKz0gZm9udC5jb21tb24ubGluZUhlaWdodDtcbiAgICAgIGxpbmUgPSB3b3Jkc1tuXSArICcgJztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHRlc3RMaW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXh0VG90YWxIZWlnaHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWFzdXJlLXRleHQuanMubWFwIiwiaW1wb3J0IHsgdGhyb3dFcnJvciwgaXNOb2RlUGF0dGVybiB9IGZyb20gJ0BqaW1wL3V0aWxzJztcbmltcG9ydCBSZXNpemUgZnJvbSAnLi9tb2R1bGVzL3Jlc2l6ZSc7XG5pbXBvcnQgUmVzaXplMiBmcm9tICcuL21vZHVsZXMvcmVzaXplMic7XG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnN0YW50czoge1xuICAgICAgUkVTSVpFX05FQVJFU1RfTkVJR0hCT1I6ICduZWFyZXN0TmVpZ2hib3InLFxuICAgICAgUkVTSVpFX0JJTElORUFSOiAnYmlsaW5lYXJJbnRlcnBvbGF0aW9uJyxcbiAgICAgIFJFU0laRV9CSUNVQklDOiAnYmljdWJpY0ludGVycG9sYXRpb24nLFxuICAgICAgUkVTSVpFX0hFUk1JVEU6ICdoZXJtaXRlSW50ZXJwb2xhdGlvbicsXG4gICAgICBSRVNJWkVfQkVaSUVSOiAnYmV6aWVySW50ZXJwb2xhdGlvbidcbiAgICB9LFxuICAgIGNsYXNzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlc2l6ZXMgdGhlIGltYWdlIHRvIGEgc2V0IHdpZHRoIGFuZCBoZWlnaHQgdXNpbmcgYSAyLXBhc3MgYmlsaW5lYXIgYWxnb3JpdGhtXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gdyB0aGUgd2lkdGggdG8gcmVzaXplIHRoZSBpbWFnZSB0byAob3IgSmltcC5BVVRPKVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGggdGhlIGhlaWdodCB0byByZXNpemUgdGhlIGltYWdlIHRvIChvciBKaW1wLkFVVE8pXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAob3B0aW9uYWwpIGEgc2NhbGluZyBtZXRob2QgKGUuZy4gSmltcC5SRVNJWkVfQkVaSUVSKVxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgICAqL1xuICAgICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUodywgaCwgbW9kZSwgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgaCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd3IGFuZCBoIG11c3QgYmUgbnVtYmVycycsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY2IgPSBtb2RlO1xuICAgICAgICAgIG1vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcgPT09IHRoaXMuY29uc3RydWN0b3IuQVVUTyAmJiBoID09PSB0aGlzLmNvbnN0cnVjdG9yLkFVVE8pIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd3IGFuZCBoIGNhbm5vdCBib3RoIGJlIHNldCB0byBhdXRvJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcgPT09IHRoaXMuY29uc3RydWN0b3IuQVVUTykge1xuICAgICAgICAgIHcgPSB0aGlzLmJpdG1hcC53aWR0aCAqIChoIC8gdGhpcy5iaXRtYXAuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoID09PSB0aGlzLmNvbnN0cnVjdG9yLkFVVE8pIHtcbiAgICAgICAgICBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0ICogKHcgLyB0aGlzLmJpdG1hcC53aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodyA8IDAgfHwgaCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICd3IGFuZCBoIG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycycsIGNiKTtcbiAgICAgICAgfSAvLyByb3VuZCBpbnB1dHNcblxuXG4gICAgICAgIHcgPSBNYXRoLnJvdW5kKHcpO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChoKTtcblxuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZTJbbW9kZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgZHN0ID0ge1xuICAgICAgICAgICAgZGF0YTogQnVmZmVyLmFsbG9jKHcgKiBoICogNCksXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICAgIH07XG4gICAgICAgICAgUmVzaXplMlttb2RlXSh0aGlzLmJpdG1hcCwgZHN0KTtcbiAgICAgICAgICB0aGlzLmJpdG1hcCA9IGRzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXNpemUgPSBuZXcgUmVzaXplKHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIHcsIGgsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC53aWR0aCA9IHc7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuaGVpZ2h0ID0gaDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNpemUucmVzaXplKHRoaXMuYml0bWFwLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gSmF2YVNjcmlwdCBJbWFnZSBSZXNpemVyIChjKSAyMDEyIC0gR3JhbnQgR2FsaXR6XG4vLyBSZWxlYXNlZCB0byBwdWJsaWMgZG9tYWluIDI5IEp1bHkgMjAxMzogaHR0cHM6Ly9naXRodWIuY29tL2dyYW50Z2FsaXR6L0pTLUltYWdlLVJlc2l6ZXIvaXNzdWVzLzRcbmZ1bmN0aW9uIFJlc2l6ZSh3aWR0aE9yaWdpbmFsLCBoZWlnaHRPcmlnaW5hbCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgYmxlbmRBbHBoYSwgaW50ZXJwb2xhdGlvblBhc3MsIHJlc2l6ZUNhbGxiYWNrKSB7XG4gIHRoaXMud2lkdGhPcmlnaW5hbCA9IE1hdGguYWJzKE1hdGguZmxvb3Iod2lkdGhPcmlnaW5hbCkgfHwgMCk7XG4gIHRoaXMuaGVpZ2h0T3JpZ2luYWwgPSBNYXRoLmFicyhNYXRoLmZsb29yKGhlaWdodE9yaWdpbmFsKSB8fCAwKTtcbiAgdGhpcy50YXJnZXRXaWR0aCA9IE1hdGguYWJzKE1hdGguZmxvb3IodGFyZ2V0V2lkdGgpIHx8IDApO1xuICB0aGlzLnRhcmdldEhlaWdodCA9IE1hdGguYWJzKE1hdGguZmxvb3IodGFyZ2V0SGVpZ2h0KSB8fCAwKTtcbiAgdGhpcy5jb2xvckNoYW5uZWxzID0gYmxlbmRBbHBoYSA/IDQgOiAzO1xuICB0aGlzLmludGVycG9sYXRpb25QYXNzID0gQm9vbGVhbihpbnRlcnBvbGF0aW9uUGFzcyk7XG4gIHRoaXMucmVzaXplQ2FsbGJhY2sgPSB0eXBlb2YgcmVzaXplQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyByZXNpemVDYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMgPSB0aGlzLnRhcmdldFdpZHRoICogdGhpcy5jb2xvckNoYW5uZWxzO1xuICB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyA9IHRoaXMud2lkdGhPcmlnaW5hbCAqIHRoaXMuY29sb3JDaGFubmVscztcbiAgdGhpcy5vcmlnaW5hbEhlaWdodE11bHRpcGxpZWRCeUNoYW5uZWxzID0gdGhpcy5oZWlnaHRPcmlnaW5hbCAqIHRoaXMuY29sb3JDaGFubmVscztcbiAgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplID0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzICogdGhpcy5oZWlnaHRPcmlnaW5hbDtcbiAgdGhpcy5maW5hbFJlc3VsdFNpemUgPSB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMgKiB0aGlzLnRhcmdldEhlaWdodDtcbiAgdGhpcy5pbml0aWFsaXplKCk7XG59XG5cblJlc2l6ZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUGVyZm9ybSBzb21lIGNoZWNrczpcbiAgaWYgKHRoaXMud2lkdGhPcmlnaW5hbCA+IDAgJiYgdGhpcy5oZWlnaHRPcmlnaW5hbCA+IDAgJiYgdGhpcy50YXJnZXRXaWR0aCA+IDAgJiYgdGhpcy50YXJnZXRIZWlnaHQgPiAwKSB7XG4gICAgdGhpcy5jb25maWd1cmVQYXNzZXMoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2V0dGluZ3Mgc3BlY2lmaWVkIGZvciB0aGUgcmVzaXplci4nKTtcbiAgfVxufTtcblxuUmVzaXplLnByb3RvdHlwZS5jb25maWd1cmVQYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLndpZHRoT3JpZ2luYWwgPT09IHRoaXMudGFyZ2V0V2lkdGgpIHtcbiAgICAvLyBCeXBhc3MgdGhlIHdpZHRoIHJlc2l6ZXIgcGFzczpcbiAgICB0aGlzLnJlc2l6ZVdpZHRoID0gdGhpcy5ieXBhc3NSZXNpemVyO1xuICB9IGVsc2Uge1xuICAgIC8vIFNldHVwIHRoZSB3aWR0aCByZXNpemVyIHBhc3M6XG4gICAgdGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcyA9IHRoaXMud2lkdGhPcmlnaW5hbCAvIHRoaXMudGFyZ2V0V2lkdGg7XG5cbiAgICBpZiAodGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcyA8IDEgJiYgdGhpcy5pbnRlcnBvbGF0aW9uUGFzcykge1xuICAgICAgdGhpcy5pbml0aWFsaXplRmlyc3RQYXNzQnVmZmVycyh0cnVlKTtcbiAgICAgIHRoaXMucmVzaXplV2lkdGggPSB0aGlzLmNvbG9yQ2hhbm5lbHMgPT09IDQgPyB0aGlzLnJlc2l6ZVdpZHRoSW50ZXJwb2xhdGVkUkdCQSA6IHRoaXMucmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUZpcnN0UGFzc0J1ZmZlcnMoZmFsc2UpO1xuICAgICAgdGhpcy5yZXNpemVXaWR0aCA9IHRoaXMuY29sb3JDaGFubmVscyA9PT0gNCA/IHRoaXMucmVzaXplV2lkdGhSR0JBIDogdGhpcy5yZXNpemVXaWR0aFJHQjtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5oZWlnaHRPcmlnaW5hbCA9PT0gdGhpcy50YXJnZXRIZWlnaHQpIHtcbiAgICAvLyBCeXBhc3MgdGhlIGhlaWdodCByZXNpemVyIHBhc3M6XG4gICAgdGhpcy5yZXNpemVIZWlnaHQgPSB0aGlzLmJ5cGFzc1Jlc2l6ZXI7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2V0dXAgdGhlIGhlaWdodCByZXNpemVyIHBhc3M6XG4gICAgdGhpcy5yYXRpb1dlaWdodEhlaWdodFBhc3MgPSB0aGlzLmhlaWdodE9yaWdpbmFsIC8gdGhpcy50YXJnZXRIZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5yYXRpb1dlaWdodEhlaWdodFBhc3MgPCAxICYmIHRoaXMuaW50ZXJwb2xhdGlvblBhc3MpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVNlY29uZFBhc3NCdWZmZXJzKHRydWUpO1xuICAgICAgdGhpcy5yZXNpemVIZWlnaHQgPSB0aGlzLnJlc2l6ZUhlaWdodEludGVycG9sYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0aWFsaXplU2Vjb25kUGFzc0J1ZmZlcnMoZmFsc2UpO1xuICAgICAgdGhpcy5yZXNpemVIZWlnaHQgPSB0aGlzLmNvbG9yQ2hhbm5lbHMgPT09IDQgPyB0aGlzLnJlc2l6ZUhlaWdodFJHQkEgOiB0aGlzLnJlc2l6ZUhlaWdodFJHQjtcbiAgICB9XG4gIH1cbn07XG5cblJlc2l6ZS5wcm90b3R5cGUuX3Jlc2l6ZVdpZHRoSW50ZXJwb2xhdGVkUkdCQ2hhbm5lbHMgPSBmdW5jdGlvbiAoYnVmZmVyLCBmb3VydGhDaGFubmVsKSB7XG4gIHZhciBjaGFubmVsc051bSA9IGZvdXJ0aENoYW5uZWwgPyA0IDogMztcbiAgdmFyIHJhdGlvV2VpZ2h0ID0gdGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcztcbiAgdmFyIG91dHB1dEJ1ZmZlciA9IHRoaXMud2lkdGhCdWZmZXI7XG4gIHZhciB3ZWlnaHQgPSAwO1xuICB2YXIgZmluYWxPZmZzZXQgPSAwO1xuICB2YXIgcGl4ZWxPZmZzZXQgPSAwO1xuICB2YXIgZmlyc3RXZWlnaHQgPSAwO1xuICB2YXIgc2Vjb25kV2VpZ2h0ID0gMDtcbiAgdmFyIHRhcmdldFBvc2l0aW9uOyAvLyBIYW5kbGUgZm9yIG9ubHkgb25lIGludGVycG9sYXRpb24gaW5wdXQgYmVpbmcgdmFsaWQgZm9yIHN0YXJ0IGNhbGN1bGF0aW9uOlxuXG4gIGZvciAodGFyZ2V0UG9zaXRpb24gPSAwOyB3ZWlnaHQgPCAxIC8gMzsgdGFyZ2V0UG9zaXRpb24gKz0gY2hhbm5lbHNOdW0sIHdlaWdodCArPSByYXRpb1dlaWdodCkge1xuICAgIGZvciAoZmluYWxPZmZzZXQgPSB0YXJnZXRQb3NpdGlvbiwgcGl4ZWxPZmZzZXQgPSAwOyBmaW5hbE9mZnNldCA8IHRoaXMud2lkdGhQYXNzUmVzdWx0U2l6ZTsgcGl4ZWxPZmZzZXQgKz0gdGhpcy5vcmlnaW5hbFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMsIGZpbmFsT2Zmc2V0ICs9IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscykge1xuICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0XSA9IGJ1ZmZlcltwaXhlbE9mZnNldF07XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAxXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDFdO1xuICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgMl0gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAyXTtcbiAgICAgIGlmIChmb3VydGhDaGFubmVsKSBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAzXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDNdO1xuICAgIH1cbiAgfSAvLyBBZGp1c3QgZm9yIG92ZXJzaG9vdCBvZiB0aGUgbGFzdCBwYXNzJ3MgY291bnRlcjpcblxuXG4gIHdlaWdodCAtPSAxIC8gMztcbiAgdmFyIGludGVycG9sYXRpb25XaWR0aFNvdXJjZVJlYWRTdG9wO1xuXG4gIGZvciAoaW50ZXJwb2xhdGlvbldpZHRoU291cmNlUmVhZFN0b3AgPSB0aGlzLndpZHRoT3JpZ2luYWwgLSAxOyB3ZWlnaHQgPCBpbnRlcnBvbGF0aW9uV2lkdGhTb3VyY2VSZWFkU3RvcDsgdGFyZ2V0UG9zaXRpb24gKz0gY2hhbm5lbHNOdW0sIHdlaWdodCArPSByYXRpb1dlaWdodCkge1xuICAgIC8vIENhbGN1bGF0ZSB3ZWlnaHRpbmdzOlxuICAgIHNlY29uZFdlaWdodCA9IHdlaWdodCAlIDE7XG4gICAgZmlyc3RXZWlnaHQgPSAxIC0gc2Vjb25kV2VpZ2h0OyAvLyBJbnRlcnBvbGF0ZTpcblxuICAgIGZvciAoZmluYWxPZmZzZXQgPSB0YXJnZXRQb3NpdGlvbiwgcGl4ZWxPZmZzZXQgPSBNYXRoLmZsb29yKHdlaWdodCkgKiBjaGFubmVsc051bTsgZmluYWxPZmZzZXQgPCB0aGlzLndpZHRoUGFzc1Jlc3VsdFNpemU7IHBpeGVsT2Zmc2V0ICs9IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzLCBmaW5hbE9mZnNldCArPSB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMpIHtcbiAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDBdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMF0gKiBmaXJzdFdlaWdodCArIGJ1ZmZlcltwaXhlbE9mZnNldCArIGNoYW5uZWxzTnVtICsgMF0gKiBzZWNvbmRXZWlnaHQ7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAxXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDFdICogZmlyc3RXZWlnaHQgKyBidWZmZXJbcGl4ZWxPZmZzZXQgKyBjaGFubmVsc051bSArIDFdICogc2Vjb25kV2VpZ2h0O1xuICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgMl0gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAyXSAqIGZpcnN0V2VpZ2h0ICsgYnVmZmVyW3BpeGVsT2Zmc2V0ICsgY2hhbm5lbHNOdW0gKyAyXSAqIHNlY29uZFdlaWdodDtcbiAgICAgIGlmIChmb3VydGhDaGFubmVsKSBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAzXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDNdICogZmlyc3RXZWlnaHQgKyBidWZmZXJbcGl4ZWxPZmZzZXQgKyBjaGFubmVsc051bSArIDNdICogc2Vjb25kV2VpZ2h0O1xuICAgIH1cbiAgfSAvLyBIYW5kbGUgZm9yIG9ubHkgb25lIGludGVycG9sYXRpb24gaW5wdXQgYmVpbmcgdmFsaWQgZm9yIGVuZCBjYWxjdWxhdGlvbjpcblxuXG4gIGZvciAoaW50ZXJwb2xhdGlvbldpZHRoU291cmNlUmVhZFN0b3AgPSB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyAtIGNoYW5uZWxzTnVtOyB0YXJnZXRQb3NpdGlvbiA8IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVsczsgdGFyZ2V0UG9zaXRpb24gKz0gY2hhbm5lbHNOdW0pIHtcbiAgICBmb3IgKGZpbmFsT2Zmc2V0ID0gdGFyZ2V0UG9zaXRpb24sIHBpeGVsT2Zmc2V0ID0gaW50ZXJwb2xhdGlvbldpZHRoU291cmNlUmVhZFN0b3A7IGZpbmFsT2Zmc2V0IDwgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplOyBwaXhlbE9mZnNldCArPSB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscywgZmluYWxPZmZzZXQgKz0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKSB7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXRdID0gYnVmZmVyW3BpeGVsT2Zmc2V0XTtcbiAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDFdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMV07XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAyXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDJdO1xuICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDNdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgM107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbn07XG5cblJlc2l6ZS5wcm90b3R5cGUuX3Jlc2l6ZVdpZHRoUkdCQ2hhbm5lbHMgPSBmdW5jdGlvbiAoYnVmZmVyLCBmb3VydGhDaGFubmVsKSB7XG4gIHZhciBjaGFubmVsc051bSA9IGZvdXJ0aENoYW5uZWwgPyA0IDogMztcbiAgdmFyIHJhdGlvV2VpZ2h0ID0gdGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcztcbiAgdmFyIHJhdGlvV2VpZ2h0RGl2aXNvciA9IDEgLyByYXRpb1dlaWdodDtcbiAgdmFyIG5leHRMaW5lT2Zmc2V0T3JpZ2luYWxXaWR0aCA9IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzIC0gY2hhbm5lbHNOdW0gKyAxO1xuICB2YXIgbmV4dExpbmVPZmZzZXRUYXJnZXRXaWR0aCA9IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyAtIGNoYW5uZWxzTnVtICsgMTtcbiAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0V2lkdGhXb3JrQmVuY2g7XG4gIHZhciBvdXRwdXRCdWZmZXIgPSB0aGlzLndpZHRoQnVmZmVyO1xuICB2YXIgdHJ1c3R3b3J0aHlDb2xvcnNDb3VudCA9IHRoaXMub3V0cHV0V2lkdGhXb3JrQmVuY2hPcGFxdWVQaXhlbHNDb3VudDtcbiAgdmFyIHdlaWdodCA9IDA7XG4gIHZhciBhbW91bnRUb05leHQgPSAwO1xuICB2YXIgYWN0dWFsUG9zaXRpb24gPSAwO1xuICB2YXIgY3VycmVudFBvc2l0aW9uID0gMDtcbiAgdmFyIGxpbmUgPSAwO1xuICB2YXIgcGl4ZWxPZmZzZXQgPSAwO1xuICB2YXIgb3V0cHV0T2Zmc2V0ID0gMDtcbiAgdmFyIG11bHRpcGxpZXIgPSAxO1xuICB2YXIgciA9IDA7XG4gIHZhciBnID0gMDtcbiAgdmFyIGIgPSAwO1xuICB2YXIgYSA9IDA7XG5cbiAgZG8ge1xuICAgIGZvciAobGluZSA9IDA7IGxpbmUgPCB0aGlzLm9yaWdpbmFsSGVpZ2h0TXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG4gICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG4gICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG5cbiAgICAgIGlmIChmb3VydGhDaGFubmVsKSB7XG4gICAgICAgIG91dHB1dFtsaW5lKytdID0gMDtcbiAgICAgICAgdHJ1c3R3b3J0aHlDb2xvcnNDb3VudFtsaW5lIC8gY2hhbm5lbHNOdW0gLSAxXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2VpZ2h0ID0gcmF0aW9XZWlnaHQ7XG5cbiAgICBkbyB7XG4gICAgICBhbW91bnRUb05leHQgPSAxICsgYWN0dWFsUG9zaXRpb24gLSBjdXJyZW50UG9zaXRpb247XG4gICAgICBtdWx0aXBsaWVyID0gTWF0aC5taW4od2VpZ2h0LCBhbW91bnRUb05leHQpO1xuXG4gICAgICBmb3IgKGxpbmUgPSAwLCBwaXhlbE9mZnNldCA9IGFjdHVhbFBvc2l0aW9uOyBsaW5lIDwgdGhpcy5vcmlnaW5hbEhlaWdodE11bHRpcGxpZWRCeUNoYW5uZWxzOyBwaXhlbE9mZnNldCArPSBuZXh0TGluZU9mZnNldE9yaWdpbmFsV2lkdGgpIHtcbiAgICAgICAgciA9IGJ1ZmZlcltwaXhlbE9mZnNldF07XG4gICAgICAgIGcgPSBidWZmZXJbKytwaXhlbE9mZnNldF07XG4gICAgICAgIGIgPSBidWZmZXJbKytwaXhlbE9mZnNldF07XG4gICAgICAgIGEgPSBmb3VydGhDaGFubmVsID8gYnVmZmVyWysrcGl4ZWxPZmZzZXRdIDogMjU1OyAvLyBJZ25vcmUgUkdCIHZhbHVlcyBpZiBwaXhlbCBpcyBjb21wbGV0ZWx5IHRyYW5zcGFyZW50XG5cbiAgICAgICAgb3V0cHV0W2xpbmUrK10gKz0gKGEgPyByIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBvdXRwdXRbbGluZSsrXSArPSAoYSA/IGcgOiAwKSAqIG11bHRpcGxpZXI7XG4gICAgICAgIG91dHB1dFtsaW5lKytdICs9IChhID8gYiA6IDApICogbXVsdGlwbGllcjtcblxuICAgICAgICBpZiAoZm91cnRoQ2hhbm5lbCkge1xuICAgICAgICAgIG91dHB1dFtsaW5lKytdICs9IGEgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgIHRydXN0d29ydGh5Q29sb3JzQ291bnRbbGluZSAvIGNoYW5uZWxzTnVtIC0gMV0gKz0gYSA/IG11bHRpcGxpZXIgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3ZWlnaHQgPj0gYW1vdW50VG9OZXh0KSB7XG4gICAgICAgIGFjdHVhbFBvc2l0aW9uICs9IGNoYW5uZWxzTnVtO1xuICAgICAgICBjdXJyZW50UG9zaXRpb24gPSBhY3R1YWxQb3NpdGlvbjtcbiAgICAgICAgd2VpZ2h0IC09IGFtb3VudFRvTmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB3ZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHdlaWdodCA+IDAgJiYgYWN0dWFsUG9zaXRpb24gPCB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyk7XG5cbiAgICBmb3IgKGxpbmUgPSAwLCBwaXhlbE9mZnNldCA9IG91dHB1dE9mZnNldDsgbGluZSA8IHRoaXMub3JpZ2luYWxIZWlnaHRNdWx0aXBsaWVkQnlDaGFubmVsczsgcGl4ZWxPZmZzZXQgKz0gbmV4dExpbmVPZmZzZXRUYXJnZXRXaWR0aCkge1xuICAgICAgd2VpZ2h0ID0gZm91cnRoQ2hhbm5lbCA/IHRydXN0d29ydGh5Q29sb3JzQ291bnRbbGluZSAvIGNoYW5uZWxzTnVtXSA6IDE7XG4gICAgICBtdWx0aXBsaWVyID0gZm91cnRoQ2hhbm5lbCA/IHdlaWdodCA/IDEgLyB3ZWlnaHQgOiAwIDogcmF0aW9XZWlnaHREaXZpc29yO1xuICAgICAgb3V0cHV0QnVmZmVyW3BpeGVsT2Zmc2V0XSA9IG91dHB1dFtsaW5lKytdICogbXVsdGlwbGllcjtcbiAgICAgIG91dHB1dEJ1ZmZlclsrK3BpeGVsT2Zmc2V0XSA9IG91dHB1dFtsaW5lKytdICogbXVsdGlwbGllcjtcbiAgICAgIG91dHB1dEJ1ZmZlclsrK3BpeGVsT2Zmc2V0XSA9IG91dHB1dFtsaW5lKytdICogbXVsdGlwbGllcjtcbiAgICAgIGlmIChmb3VydGhDaGFubmVsKSBvdXRwdXRCdWZmZXJbKytwaXhlbE9mZnNldF0gPSBvdXRwdXRbbGluZSsrXSAqIHJhdGlvV2VpZ2h0RGl2aXNvcjtcbiAgICB9XG5cbiAgICBvdXRwdXRPZmZzZXQgKz0gY2hhbm5lbHNOdW07XG4gIH0gd2hpbGUgKG91dHB1dE9mZnNldCA8IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyk7XG5cbiAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbn07XG5cblJlc2l6ZS5wcm90b3R5cGUuX3Jlc2l6ZUhlaWdodFJHQkNoYW5uZWxzID0gZnVuY3Rpb24gKGJ1ZmZlciwgZm91cnRoQ2hhbm5lbCkge1xuICB2YXIgcmF0aW9XZWlnaHQgPSB0aGlzLnJhdGlvV2VpZ2h0SGVpZ2h0UGFzcztcbiAgdmFyIHJhdGlvV2VpZ2h0RGl2aXNvciA9IDEgLyByYXRpb1dlaWdodDtcbiAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0SGVpZ2h0V29ya0JlbmNoO1xuICB2YXIgb3V0cHV0QnVmZmVyID0gdGhpcy5oZWlnaHRCdWZmZXI7XG4gIHZhciB0cnVzdHdvcnRoeUNvbG9yc0NvdW50ID0gdGhpcy5vdXRwdXRIZWlnaHRXb3JrQmVuY2hPcGFxdWVQaXhlbHNDb3VudDtcbiAgdmFyIHdlaWdodCA9IDA7XG4gIHZhciBhbW91bnRUb05leHQgPSAwO1xuICB2YXIgYWN0dWFsUG9zaXRpb24gPSAwO1xuICB2YXIgY3VycmVudFBvc2l0aW9uID0gMDtcbiAgdmFyIHBpeGVsT2Zmc2V0ID0gMDtcbiAgdmFyIG91dHB1dE9mZnNldCA9IDA7XG4gIHZhciBjYXJldCA9IDA7XG4gIHZhciBtdWx0aXBsaWVyID0gMTtcbiAgdmFyIHIgPSAwO1xuICB2YXIgZyA9IDA7XG4gIHZhciBiID0gMDtcbiAgdmFyIGEgPSAwO1xuXG4gIGRvIHtcbiAgICBmb3IgKHBpeGVsT2Zmc2V0ID0gMDsgcGl4ZWxPZmZzZXQgPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gPSAwO1xuICAgICAgb3V0cHV0W3BpeGVsT2Zmc2V0KytdID0gMDtcbiAgICAgIG91dHB1dFtwaXhlbE9mZnNldCsrXSA9IDA7XG5cbiAgICAgIGlmIChmb3VydGhDaGFubmVsKSB7XG4gICAgICAgIG91dHB1dFtwaXhlbE9mZnNldCsrXSA9IDA7XG4gICAgICAgIHRydXN0d29ydGh5Q29sb3JzQ291bnRbcGl4ZWxPZmZzZXQgLyA0IC0gMV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdlaWdodCA9IHJhdGlvV2VpZ2h0O1xuXG4gICAgZG8ge1xuICAgICAgYW1vdW50VG9OZXh0ID0gMSArIGFjdHVhbFBvc2l0aW9uIC0gY3VycmVudFBvc2l0aW9uO1xuICAgICAgbXVsdGlwbGllciA9IE1hdGgubWluKHdlaWdodCwgYW1vdW50VG9OZXh0KTtcbiAgICAgIGNhcmV0ID0gYWN0dWFsUG9zaXRpb247XG5cbiAgICAgIGZvciAocGl4ZWxPZmZzZXQgPSAwOyBwaXhlbE9mZnNldCA8IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVsczspIHtcbiAgICAgICAgciA9IGJ1ZmZlcltjYXJldCsrXTtcbiAgICAgICAgZyA9IGJ1ZmZlcltjYXJldCsrXTtcbiAgICAgICAgYiA9IGJ1ZmZlcltjYXJldCsrXTtcbiAgICAgICAgYSA9IGZvdXJ0aENoYW5uZWwgPyBidWZmZXJbY2FyZXQrK10gOiAyNTU7IC8vIElnbm9yZSBSR0IgdmFsdWVzIGlmIHBpeGVsIGlzIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnRcblxuICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKz0gKGEgPyByIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKz0gKGEgPyBnIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKz0gKGEgPyBiIDogMCkgKiBtdWx0aXBsaWVyO1xuXG4gICAgICAgIGlmIChmb3VydGhDaGFubmVsKSB7XG4gICAgICAgICAgb3V0cHV0W3BpeGVsT2Zmc2V0KytdICs9IGEgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgIHRydXN0d29ydGh5Q29sb3JzQ291bnRbcGl4ZWxPZmZzZXQgLyA0IC0gMV0gKz0gYSA/IG11bHRpcGxpZXIgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3ZWlnaHQgPj0gYW1vdW50VG9OZXh0KSB7XG4gICAgICAgIGFjdHVhbFBvc2l0aW9uID0gY2FyZXQ7XG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IGFjdHVhbFBvc2l0aW9uO1xuICAgICAgICB3ZWlnaHQgLT0gYW1vdW50VG9OZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFBvc2l0aW9uICs9IHdlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAod2VpZ2h0ID4gMCAmJiBhY3R1YWxQb3NpdGlvbiA8IHRoaXMud2lkdGhQYXNzUmVzdWx0U2l6ZSk7XG5cbiAgICBmb3IgKHBpeGVsT2Zmc2V0ID0gMDsgcGl4ZWxPZmZzZXQgPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICB3ZWlnaHQgPSBmb3VydGhDaGFubmVsID8gdHJ1c3R3b3J0aHlDb2xvcnNDb3VudFtwaXhlbE9mZnNldCAvIDRdIDogMTtcbiAgICAgIG11bHRpcGxpZXIgPSBmb3VydGhDaGFubmVsID8gd2VpZ2h0ID8gMSAvIHdlaWdodCA6IDAgOiByYXRpb1dlaWdodERpdmlzb3I7XG4gICAgICBvdXRwdXRCdWZmZXJbb3V0cHV0T2Zmc2V0KytdID0gTWF0aC5yb3VuZChvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKiBtdWx0aXBsaWVyKTtcbiAgICAgIG91dHB1dEJ1ZmZlcltvdXRwdXRPZmZzZXQrK10gPSBNYXRoLnJvdW5kKG91dHB1dFtwaXhlbE9mZnNldCsrXSAqIG11bHRpcGxpZXIpO1xuICAgICAgb3V0cHV0QnVmZmVyW291dHB1dE9mZnNldCsrXSA9IE1hdGgucm91bmQob3V0cHV0W3BpeGVsT2Zmc2V0KytdICogbXVsdGlwbGllcik7XG5cbiAgICAgIGlmIChmb3VydGhDaGFubmVsKSB7XG4gICAgICAgIG91dHB1dEJ1ZmZlcltvdXRwdXRPZmZzZXQrK10gPSBNYXRoLnJvdW5kKG91dHB1dFtwaXhlbE9mZnNldCsrXSAqIHJhdGlvV2VpZ2h0RGl2aXNvcik7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlIChvdXRwdXRPZmZzZXQgPCB0aGlzLmZpbmFsUmVzdWx0U2l6ZSk7XG5cbiAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbn07XG5cblJlc2l6ZS5wcm90b3R5cGUucmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0IgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQkNoYW5uZWxzKGJ1ZmZlciwgZmFsc2UpO1xufTtcblxuUmVzaXplLnByb3RvdHlwZS5yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQkEgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQkNoYW5uZWxzKGJ1ZmZlciwgdHJ1ZSk7XG59O1xuXG5SZXNpemUucHJvdG90eXBlLnJlc2l6ZVdpZHRoUkdCID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5fcmVzaXplV2lkdGhSR0JDaGFubmVscyhidWZmZXIsIGZhbHNlKTtcbn07XG5cblJlc2l6ZS5wcm90b3R5cGUucmVzaXplV2lkdGhSR0JBID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5fcmVzaXplV2lkdGhSR0JDaGFubmVscyhidWZmZXIsIHRydWUpO1xufTtcblxuUmVzaXplLnByb3RvdHlwZS5yZXNpemVIZWlnaHRJbnRlcnBvbGF0ZWQgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHZhciByYXRpb1dlaWdodCA9IHRoaXMucmF0aW9XZWlnaHRIZWlnaHRQYXNzO1xuICB2YXIgb3V0cHV0QnVmZmVyID0gdGhpcy5oZWlnaHRCdWZmZXI7XG4gIHZhciB3ZWlnaHQgPSAwO1xuICB2YXIgZmluYWxPZmZzZXQgPSAwO1xuICB2YXIgcGl4ZWxPZmZzZXQgPSAwO1xuICB2YXIgcGl4ZWxPZmZzZXRBY2N1bXVsYXRlZCA9IDA7XG4gIHZhciBwaXhlbE9mZnNldEFjY3VtdWxhdGVkMiA9IDA7XG4gIHZhciBmaXJzdFdlaWdodCA9IDA7XG4gIHZhciBzZWNvbmRXZWlnaHQgPSAwO1xuICB2YXIgaW50ZXJwb2xhdGlvbkhlaWdodFNvdXJjZVJlYWRTdG9wOyAvLyBIYW5kbGUgZm9yIG9ubHkgb25lIGludGVycG9sYXRpb24gaW5wdXQgYmVpbmcgdmFsaWQgZm9yIHN0YXJ0IGNhbGN1bGF0aW9uOlxuXG4gIGZvciAoOyB3ZWlnaHQgPCAxIC8gMzsgd2VpZ2h0ICs9IHJhdGlvV2VpZ2h0KSB7XG4gICAgZm9yIChwaXhlbE9mZnNldCA9IDA7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOykge1xuICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0KytdID0gTWF0aC5yb3VuZChidWZmZXJbcGl4ZWxPZmZzZXQrK10pO1xuICAgIH1cbiAgfSAvLyBBZGp1c3QgZm9yIG92ZXJzaG9vdCBvZiB0aGUgbGFzdCBwYXNzJ3MgY291bnRlcjpcblxuXG4gIHdlaWdodCAtPSAxIC8gMztcblxuICBmb3IgKGludGVycG9sYXRpb25IZWlnaHRTb3VyY2VSZWFkU3RvcCA9IHRoaXMuaGVpZ2h0T3JpZ2luYWwgLSAxOyB3ZWlnaHQgPCBpbnRlcnBvbGF0aW9uSGVpZ2h0U291cmNlUmVhZFN0b3A7IHdlaWdodCArPSByYXRpb1dlaWdodCkge1xuICAgIC8vIENhbGN1bGF0ZSB3ZWlnaHRpbmdzOlxuICAgIHNlY29uZFdlaWdodCA9IHdlaWdodCAlIDE7XG4gICAgZmlyc3RXZWlnaHQgPSAxIC0gc2Vjb25kV2VpZ2h0OyAvLyBJbnRlcnBvbGF0ZTpcblxuICAgIHBpeGVsT2Zmc2V0QWNjdW11bGF0ZWQgPSBNYXRoLmZsb29yKHdlaWdodCkgKiB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7XG4gICAgcGl4ZWxPZmZzZXRBY2N1bXVsYXRlZDIgPSBwaXhlbE9mZnNldEFjY3VtdWxhdGVkICsgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzO1xuXG4gICAgZm9yIChwaXhlbE9mZnNldCA9IDA7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOyArK3BpeGVsT2Zmc2V0KSB7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQrK10gPSBNYXRoLnJvdW5kKGJ1ZmZlcltwaXhlbE9mZnNldEFjY3VtdWxhdGVkKytdICogZmlyc3RXZWlnaHQgKyBidWZmZXJbcGl4ZWxPZmZzZXRBY2N1bXVsYXRlZDIrK10gKiBzZWNvbmRXZWlnaHQpO1xuICAgIH1cbiAgfSAvLyBIYW5kbGUgZm9yIG9ubHkgb25lIGludGVycG9sYXRpb24gaW5wdXQgYmVpbmcgdmFsaWQgZm9yIGVuZCBjYWxjdWxhdGlvbjpcblxuXG4gIHdoaWxlIChmaW5hbE9mZnNldCA8IHRoaXMuZmluYWxSZXN1bHRTaXplKSB7XG4gICAgZm9yIChwaXhlbE9mZnNldCA9IDAsIHBpeGVsT2Zmc2V0QWNjdW11bGF0ZWQgPSBpbnRlcnBvbGF0aW9uSGVpZ2h0U291cmNlUmVhZFN0b3AgKiB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOyArK3BpeGVsT2Zmc2V0KSB7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQrK10gPSBNYXRoLnJvdW5kKGJ1ZmZlcltwaXhlbE9mZnNldEFjY3VtdWxhdGVkKytdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0QnVmZmVyO1xufTtcblxuUmVzaXplLnByb3RvdHlwZS5yZXNpemVIZWlnaHRSR0IgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZXNpemVIZWlnaHRSR0JDaGFubmVscyhidWZmZXIsIGZhbHNlKTtcbn07XG5cblJlc2l6ZS5wcm90b3R5cGUucmVzaXplSGVpZ2h0UkdCQSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc2l6ZUhlaWdodFJHQkNoYW5uZWxzKGJ1ZmZlciwgdHJ1ZSk7XG59O1xuXG5SZXNpemUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5yZXNpemVDYWxsYmFjayh0aGlzLnJlc2l6ZUhlaWdodCh0aGlzLnJlc2l6ZVdpZHRoKGJ1ZmZlcikpKTtcbn07XG5cblJlc2l6ZS5wcm90b3R5cGUuYnlwYXNzUmVzaXplciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgLy8gSnVzdCByZXR1cm4gdGhlIGJ1ZmZlciBwYXNzZWQ6XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5SZXNpemUucHJvdG90eXBlLmluaXRpYWxpemVGaXJzdFBhc3NCdWZmZXJzID0gZnVuY3Rpb24gKEJJTElORUFSQWxnbykge1xuICAvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCB3aWR0aCBwYXNzIGJ1ZmZlcnM6XG4gIHRoaXMud2lkdGhCdWZmZXIgPSB0aGlzLmdlbmVyYXRlRmxvYXRCdWZmZXIodGhpcy53aWR0aFBhc3NSZXN1bHRTaXplKTtcblxuICBpZiAoIUJJTElORUFSQWxnbykge1xuICAgIHRoaXMub3V0cHV0V2lkdGhXb3JrQmVuY2ggPSB0aGlzLmdlbmVyYXRlRmxvYXRCdWZmZXIodGhpcy5vcmlnaW5hbEhlaWdodE11bHRpcGxpZWRCeUNoYW5uZWxzKTtcblxuICAgIGlmICh0aGlzLmNvbG9yQ2hhbm5lbHMgPiAzKSB7XG4gICAgICB0aGlzLm91dHB1dFdpZHRoV29ya0JlbmNoT3BhcXVlUGl4ZWxzQ291bnQgPSB0aGlzLmdlbmVyYXRlRmxvYXQ2NEJ1ZmZlcih0aGlzLmhlaWdodE9yaWdpbmFsKTtcbiAgICB9XG4gIH1cbn07XG5cblJlc2l6ZS5wcm90b3R5cGUuaW5pdGlhbGl6ZVNlY29uZFBhc3NCdWZmZXJzID0gZnVuY3Rpb24gKEJJTElORUFSQWxnbykge1xuICAvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCBoZWlnaHQgcGFzcyBidWZmZXJzOlxuICB0aGlzLmhlaWdodEJ1ZmZlciA9IHRoaXMuZ2VuZXJhdGVVaW50OEJ1ZmZlcih0aGlzLmZpbmFsUmVzdWx0U2l6ZSk7XG5cbiAgaWYgKCFCSUxJTkVBUkFsZ28pIHtcbiAgICB0aGlzLm91dHB1dEhlaWdodFdvcmtCZW5jaCA9IHRoaXMuZ2VuZXJhdGVGbG9hdEJ1ZmZlcih0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMpO1xuXG4gICAgaWYgKHRoaXMuY29sb3JDaGFubmVscyA+IDMpIHtcbiAgICAgIHRoaXMub3V0cHV0SGVpZ2h0V29ya0JlbmNoT3BhcXVlUGl4ZWxzQ291bnQgPSB0aGlzLmdlbmVyYXRlRmxvYXQ2NEJ1ZmZlcih0aGlzLnRhcmdldFdpZHRoKTtcbiAgICB9XG4gIH1cbn07XG5cblJlc2l6ZS5wcm90b3R5cGUuZ2VuZXJhdGVGbG9hdEJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXJMZW5ndGgpIHtcbiAgLy8gR2VuZXJhdGUgYSBmbG9hdDMyIHR5cGVkIGFycmF5IGJ1ZmZlcjpcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXJMZW5ndGgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuUmVzaXplLnByb3RvdHlwZS5nZW5lcmF0ZUZsb2F0NjRCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyTGVuZ3RoKSB7XG4gIC8vIEdlbmVyYXRlIGEgZmxvYXQ2NCB0eXBlZCBhcnJheSBidWZmZXI6XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cblJlc2l6ZS5wcm90b3R5cGUuZ2VuZXJhdGVVaW50OEJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXJMZW5ndGgpIHtcbiAgLy8gR2VuZXJhdGUgYSB1aW50OCB0eXBlZCBhcnJheSBidWZmZXI6XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2l6ZS5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNSBHdXlvbiBSb2NoZVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczo8L3A+XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5lYXJlc3ROZWlnaGJvcjogZnVuY3Rpb24gbmVhcmVzdE5laWdoYm9yKHNyYywgZHN0KSB7XG4gICAgdmFyIHdTcmMgPSBzcmMud2lkdGg7XG4gICAgdmFyIGhTcmMgPSBzcmMuaGVpZ2h0O1xuICAgIHZhciB3RHN0ID0gZHN0LndpZHRoO1xuICAgIHZhciBoRHN0ID0gZHN0LmhlaWdodDtcbiAgICB2YXIgYnVmU3JjID0gc3JjLmRhdGE7XG4gICAgdmFyIGJ1ZkRzdCA9IGRzdC5kYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoRHN0OyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd0RzdDsgaisrKSB7XG4gICAgICAgIHZhciBwb3NEc3QgPSAoaSAqIHdEc3QgKyBqKSAqIDQ7XG4gICAgICAgIHZhciBpU3JjID0gTWF0aC5mbG9vcihpICogaFNyYyAvIGhEc3QpO1xuICAgICAgICB2YXIgalNyYyA9IE1hdGguZmxvb3IoaiAqIHdTcmMgLyB3RHN0KTtcbiAgICAgICAgdmFyIHBvc1NyYyA9IChpU3JjICogd1NyYyArIGpTcmMpICogNDtcbiAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICAgIGJ1ZkRzdFtwb3NEc3QrK10gPSBidWZTcmNbcG9zU3JjKytdO1xuICAgICAgICBidWZEc3RbcG9zRHN0KytdID0gYnVmU3JjW3Bvc1NyYysrXTtcbiAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiaWxpbmVhckludGVycG9sYXRpb246IGZ1bmN0aW9uIGJpbGluZWFySW50ZXJwb2xhdGlvbihzcmMsIGRzdCkge1xuICAgIHZhciB3U3JjID0gc3JjLndpZHRoO1xuICAgIHZhciBoU3JjID0gc3JjLmhlaWdodDtcbiAgICB2YXIgd0RzdCA9IGRzdC53aWR0aDtcbiAgICB2YXIgaERzdCA9IGRzdC5oZWlnaHQ7XG4gICAgdmFyIGJ1ZlNyYyA9IHNyYy5kYXRhO1xuICAgIHZhciBidWZEc3QgPSBkc3QuZGF0YTtcblxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlKGssIGtNaW4sIHZNaW4sIGtNYXgsIHZNYXgpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSAtIGsgaXMgaW50ZWdlclxuICAgICAgaWYgKGtNaW4gPT09IGtNYXgpIHtcbiAgICAgICAgcmV0dXJuIHZNaW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChrIC0ga01pbikgKiB2TWF4ICsgKGtNYXggLSBrKSAqIHZNaW4pO1xuICAgIH07XG5cbiAgICB2YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHBvcywgb2Zmc2V0LCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KSB7XG4gICAgICB2YXIgcG9zTWluID0gKHlNaW4gKiB3U3JjICsgeE1pbikgKiA0ICsgb2Zmc2V0O1xuICAgICAgdmFyIHBvc01heCA9ICh5TWluICogd1NyYyArIHhNYXgpICogNCArIG9mZnNldDtcbiAgICAgIHZhciB2TWluID0gaW50ZXJwb2xhdGUoeCwgeE1pbiwgYnVmU3JjW3Bvc01pbl0sIHhNYXgsIGJ1ZlNyY1twb3NNYXhdKTsgLy8gc3BlY2lhbCBjYXNlLCB5IGlzIGludGVnZXJcblxuICAgICAgaWYgKHlNYXggPT09IHlNaW4pIHtcbiAgICAgICAgYnVmRHN0W3BvcyArIG9mZnNldF0gPSB2TWluO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zTWluID0gKHlNYXggKiB3U3JjICsgeE1pbikgKiA0ICsgb2Zmc2V0O1xuICAgICAgICBwb3NNYXggPSAoeU1heCAqIHdTcmMgKyB4TWF4KSAqIDQgKyBvZmZzZXQ7XG4gICAgICAgIHZhciB2TWF4ID0gaW50ZXJwb2xhdGUoeCwgeE1pbiwgYnVmU3JjW3Bvc01pbl0sIHhNYXgsIGJ1ZlNyY1twb3NNYXhdKTtcbiAgICAgICAgYnVmRHN0W3BvcyArIG9mZnNldF0gPSBpbnRlcnBvbGF0ZSh5LCB5TWluLCB2TWluLCB5TWF4LCB2TWF4KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoRHN0OyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd0RzdDsgaisrKSB7XG4gICAgICAgIHZhciBwb3NEc3QgPSAoaSAqIHdEc3QgKyBqKSAqIDQ7IC8vIHggJiB5IGluIHNyYyBjb29yZGluYXRlc1xuXG4gICAgICAgIHZhciB4ID0gaiAqIHdTcmMgLyB3RHN0O1xuICAgICAgICB2YXIgeE1pbiA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIHZhciB4TWF4ID0gTWF0aC5taW4oTWF0aC5jZWlsKHgpLCB3U3JjIC0gMSk7XG4gICAgICAgIHZhciB5ID0gaSAqIGhTcmMgLyBoRHN0O1xuICAgICAgICB2YXIgeU1pbiA9IE1hdGguZmxvb3IoeSk7XG4gICAgICAgIHZhciB5TWF4ID0gTWF0aC5taW4oTWF0aC5jZWlsKHkpLCBoU3JjIC0gMSk7XG4gICAgICAgIGFzc2lnbihwb3NEc3QsIDAsIHgsIHhNaW4sIHhNYXgsIHksIHlNaW4sIHlNYXgpO1xuICAgICAgICBhc3NpZ24ocG9zRHN0LCAxLCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KTtcbiAgICAgICAgYXNzaWduKHBvc0RzdCwgMiwgeCwgeE1pbiwgeE1heCwgeSwgeU1pbiwgeU1heCk7XG4gICAgICAgIGFzc2lnbihwb3NEc3QsIDMsIHgsIHhNaW4sIHhNYXgsIHksIHlNaW4sIHlNYXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2ludGVycG9sYXRlMkQ6IGZ1bmN0aW9uIF9pbnRlcnBvbGF0ZTJEKHNyYywgZHN0LCBvcHRpb25zLCBpbnRlcnBvbGF0ZSkge1xuICAgIHZhciBidWZTcmMgPSBzcmMuZGF0YTtcbiAgICB2YXIgYnVmRHN0ID0gZHN0LmRhdGE7XG4gICAgdmFyIHdTcmMgPSBzcmMud2lkdGg7XG4gICAgdmFyIGhTcmMgPSBzcmMuaGVpZ2h0O1xuICAgIHZhciB3RHN0ID0gZHN0LndpZHRoO1xuICAgIHZhciBoRHN0ID0gZHN0LmhlaWdodDsgLy8gd2hlbiBkc3Qgc21hbGxlciB0aGFuIHNyYy8yLCBpbnRlcnBvbGF0ZSBmaXJzdCB0byBhIG11bHRpcGxlIGJldHdlZW4gMC41IGFuZCAxLjAgc3JjLCB0aGVuIHN1bSBzcXVhcmVzXG5cbiAgICB2YXIgd00gPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHdTcmMgLyB3RHN0KSk7XG4gICAgdmFyIHdEc3QyID0gd0RzdCAqIHdNO1xuICAgIHZhciBoTSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaFNyYyAvIGhEc3QpKTtcbiAgICB2YXIgaERzdDIgPSBoRHN0ICogaE07IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUGFzcyAxIC0gaW50ZXJwb2xhdGUgcm93c1xuICAgIC8vIGJ1ZjEgaGFzIHdpZHRoIG9mIGRzdDIgYW5kIGhlaWdodCBvZiBzcmNcblxuICAgIHZhciBidWYxID0gQnVmZmVyLmFsbG9jKHdEc3QyICogaFNyYyAqIDQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoU3JjOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd0RzdDI7IGorKykge1xuICAgICAgICAvLyBpIGluIHNyYyBjb29yZHMsIGogaW4gZHN0IGNvb3Jkc1xuICAgICAgICAvLyBjYWxjdWxhdGUgeCBpbiBzcmMgY29vcmRzXG4gICAgICAgIC8vIHRoaXMgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyA0IHNhbXBsZSBwb2ludHMgYW5kIHRoZSB0d28gaW5uZXIgb25lcyBtdXN0IGJlIHJlYWxcbiAgICAgICAgLy8gdGhlIG91dGVyIHBvaW50cyBjYW4gYmUgZnVkZ2VkIGZvciB0aGUgZWRnZXMuXG4gICAgICAgIC8vIHRoZXJlZm9yZSAod1NyYy0xKS93RHN0MlxuICAgICAgICB2YXIgeCA9IGogKiAod1NyYyAtIDEpIC8gd0RzdDI7XG4gICAgICAgIHZhciB4UG9zID0gTWF0aC5mbG9vcih4KTtcbiAgICAgICAgdmFyIHQgPSB4IC0geFBvcztcbiAgICAgICAgdmFyIHNyY1BvcyA9IChpICogd1NyYyArIHhQb3MpICogNDtcbiAgICAgICAgdmFyIGJ1ZjFQb3MgPSAoaSAqIHdEc3QyICsgaikgKiA0O1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgNDsgaysrKSB7XG4gICAgICAgICAgdmFyIGtQb3MgPSBzcmNQb3MgKyBrO1xuICAgICAgICAgIHZhciB4MCA9IHhQb3MgPiAwID8gYnVmU3JjW2tQb3MgLSA0XSA6IDIgKiBidWZTcmNba1Bvc10gLSBidWZTcmNba1BvcyArIDRdO1xuICAgICAgICAgIHZhciB4MSA9IGJ1ZlNyY1trUG9zXTtcbiAgICAgICAgICB2YXIgeDIgPSBidWZTcmNba1BvcyArIDRdO1xuICAgICAgICAgIHZhciB4MyA9IHhQb3MgPCB3U3JjIC0gMiA/IGJ1ZlNyY1trUG9zICsgOF0gOiAyICogYnVmU3JjW2tQb3MgKyA0XSAtIGJ1ZlNyY1trUG9zXTtcbiAgICAgICAgICBidWYxW2J1ZjFQb3MgKyBrXSA9IGludGVycG9sYXRlKHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gdGhpcy5fd3JpdGVGaWxlKHdEc3QyLCBoU3JjLCBidWYxLCBcIm91dC9idWYxLmpwZ1wiKTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBhc3MgMiAtIGludGVycG9sYXRlIGNvbHVtbnNcbiAgICAvLyBidWYyIGhhcyB3aWR0aCBhbmQgaGVpZ2h0IG9mIGRzdDJcblxuXG4gICAgdmFyIGJ1ZjIgPSBCdWZmZXIuYWxsb2Mod0RzdDIgKiBoRHN0MiAqIDQpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGhEc3QyOyBfaSsrKSB7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgd0RzdDI7IF9qKyspIHtcbiAgICAgICAgLy8gaSZqIGluIGRzdDIgY29vcmRzXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB5IGluIGJ1ZjEgY29vcmRzXG4gICAgICAgIC8vIHRoaXMgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyA0IHNhbXBsZSBwb2ludHMgYW5kIHRoZSB0d28gaW5uZXIgb25lcyBtdXN0IGJlIHJlYWxcbiAgICAgICAgLy8gdGhlIG91dGVyIHBvaW50cyBjYW4gYmUgZnVkZ2VkIGZvciB0aGUgZWRnZXMuXG4gICAgICAgIC8vIHRoZXJlZm9yZSAoaFNyYy0xKS9oRHN0MlxuICAgICAgICB2YXIgeSA9IF9pICogKGhTcmMgLSAxKSAvIGhEc3QyO1xuICAgICAgICB2YXIgeVBvcyA9IE1hdGguZmxvb3IoeSk7XG5cbiAgICAgICAgdmFyIF90ID0geSAtIHlQb3M7XG5cbiAgICAgICAgdmFyIF9idWYxUG9zID0gKHlQb3MgKiB3RHN0MiArIF9qKSAqIDQ7XG5cbiAgICAgICAgdmFyIGJ1ZjJQb3MgPSAoX2kgKiB3RHN0MiArIF9qKSAqIDQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IDQ7IF9rKyspIHtcbiAgICAgICAgICB2YXIgX2tQb3MgPSBfYnVmMVBvcyArIF9rO1xuXG4gICAgICAgICAgdmFyIHkwID0geVBvcyA+IDAgPyBidWYxW19rUG9zIC0gd0RzdDIgKiA0XSA6IDIgKiBidWYxW19rUG9zXSAtIGJ1ZjFbX2tQb3MgKyB3RHN0MiAqIDRdO1xuICAgICAgICAgIHZhciB5MSA9IGJ1ZjFbX2tQb3NdO1xuICAgICAgICAgIHZhciB5MiA9IGJ1ZjFbX2tQb3MgKyB3RHN0MiAqIDRdO1xuICAgICAgICAgIHZhciB5MyA9IHlQb3MgPCBoU3JjIC0gMiA/IGJ1ZjFbX2tQb3MgKyB3RHN0MiAqIDhdIDogMiAqIGJ1ZjFbX2tQb3MgKyB3RHN0MiAqIDRdIC0gYnVmMVtfa1Bvc107XG4gICAgICAgICAgYnVmMltidWYyUG9zICsgX2tdID0gaW50ZXJwb2xhdGUoeTAsIHkxLCB5MiwgeTMsIF90KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gdGhpcy5fd3JpdGVGaWxlKHdEc3QyLCBoRHN0MiwgYnVmMiwgXCJvdXQvYnVmMi5qcGdcIik7XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQYXNzIDMgLSBzY2FsZSB0byBkc3RcblxuXG4gICAgdmFyIG0gPSB3TSAqIGhNO1xuXG4gICAgaWYgKG0gPiAxKSB7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBoRHN0OyBfaTIrKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCB3RHN0OyBfajIrKykge1xuICAgICAgICAgIC8vIGkmaiBpbiBkc3QgYm91bmRlZCBjb29yZHNcbiAgICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgICAgdmFyIGcgPSAwO1xuICAgICAgICAgIHZhciBiID0gMDtcbiAgICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgICAgdmFyIHJlYWxDb2xvcnMgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX3kgPSAwOyBfeSA8IGhNOyBfeSsrKSB7XG4gICAgICAgICAgICB2YXIgX3lQb3MgPSBfaTIgKiBoTSArIF95O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgd007IF94KyspIHtcbiAgICAgICAgICAgICAgdmFyIF94UG9zID0gX2oyICogd00gKyBfeDtcblxuICAgICAgICAgICAgICB2YXIgeHlQb3MgPSAoX3lQb3MgKiB3RHN0MiArIF94UG9zKSAqIDQ7XG4gICAgICAgICAgICAgIHZhciBwaXhlbEFscGhhID0gYnVmMlt4eVBvcyArIDNdO1xuXG4gICAgICAgICAgICAgIGlmIChwaXhlbEFscGhhKSB7XG4gICAgICAgICAgICAgICAgciArPSBidWYyW3h5UG9zXTtcbiAgICAgICAgICAgICAgICBnICs9IGJ1ZjJbeHlQb3MgKyAxXTtcbiAgICAgICAgICAgICAgICBiICs9IGJ1ZjJbeHlQb3MgKyAyXTtcbiAgICAgICAgICAgICAgICByZWFsQ29sb3JzKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhICs9IHBpeGVsQWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvcyA9IChfaTIgKiB3RHN0ICsgX2oyKSAqIDQ7XG4gICAgICAgICAgYnVmRHN0W3Bvc10gPSByZWFsQ29sb3JzID8gTWF0aC5yb3VuZChyIC8gcmVhbENvbG9ycykgOiAwO1xuICAgICAgICAgIGJ1ZkRzdFtwb3MgKyAxXSA9IHJlYWxDb2xvcnMgPyBNYXRoLnJvdW5kKGcgLyByZWFsQ29sb3JzKSA6IDA7XG4gICAgICAgICAgYnVmRHN0W3BvcyArIDJdID0gcmVhbENvbG9ycyA/IE1hdGgucm91bmQoYiAvIHJlYWxDb2xvcnMpIDogMDtcbiAgICAgICAgICBidWZEc3RbcG9zICsgM10gPSBNYXRoLnJvdW5kKGEgLyBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXBsYWNlIGRzdCBidWZmZXIgd2l0aCBidWYyXG4gICAgICBkc3QuZGF0YSA9IGJ1ZjI7XG4gICAgfVxuICB9LFxuICBiaWN1YmljSW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gYmljdWJpY0ludGVycG9sYXRpb24oc3JjLCBkc3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW50ZXJwb2xhdGVDdWJpYyA9IGZ1bmN0aW9uIGludGVycG9sYXRlQ3ViaWMoeDAsIHgxLCB4MiwgeDMsIHQpIHtcbiAgICAgIHZhciBhMCA9IHgzIC0geDIgLSB4MCArIHgxO1xuICAgICAgdmFyIGExID0geDAgLSB4MSAtIGEwO1xuICAgICAgdmFyIGEyID0geDIgLSB4MDtcbiAgICAgIHZhciBhMyA9IHgxO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgYTAgKiAodCAqIHQgKiB0KSArIGExICogKHQgKiB0KSArIGEyICogdCArIGEzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0ZTJEKHNyYywgZHN0LCBvcHRpb25zLCBpbnRlcnBvbGF0ZUN1YmljKTtcbiAgfSxcbiAgaGVybWl0ZUludGVycG9sYXRpb246IGZ1bmN0aW9uIGhlcm1pdGVJbnRlcnBvbGF0aW9uKHNyYywgZHN0LCBvcHRpb25zKSB7XG4gICAgdmFyIGludGVycG9sYXRlSGVybWl0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlSGVybWl0ZSh4MCwgeDEsIHgyLCB4MywgdCkge1xuICAgICAgdmFyIGMwID0geDE7XG4gICAgICB2YXIgYzEgPSAwLjUgKiAoeDIgLSB4MCk7XG4gICAgICB2YXIgYzIgPSB4MCAtIDIuNSAqIHgxICsgMiAqIHgyIC0gMC41ICogeDM7XG4gICAgICB2YXIgYzMgPSAwLjUgKiAoeDMgLSB4MCkgKyAxLjUgKiAoeDEgLSB4Mik7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKCgoYzMgKiB0ICsgYzIpICogdCArIGMxKSAqIHQgKyBjMCkpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRlMkQoc3JjLCBkc3QsIG9wdGlvbnMsIGludGVycG9sYXRlSGVybWl0ZSk7XG4gIH0sXG4gIGJlemllckludGVycG9sYXRpb246IGZ1bmN0aW9uIGJlemllckludGVycG9sYXRpb24oc3JjLCBkc3QsIG9wdGlvbnMpIHtcbiAgICAvLyBiZXR3ZWVuIDIgcG9pbnRzIHkobiksIHkobisxKSwgdXNlIG5leHQgcG9pbnRzIG91dCwgeShuLTEpLCB5KG4rMilcbiAgICAvLyB0byBwcmVkaWN0IGNvbnRyb2wgcG9pbnRzIChhICYgYikgdG8gYmUgcGxhY2VkIGF0IG4rMC41XG4gICAgLy8gIHlhKG4pID0geShuKSArICh5KG4rMSkteShuLTEpKS80XG4gICAgLy8gIHliKG4pID0geShuKzEpIC0gKHkobisyKS15KG4pKS80XG4gICAgLy8gdGhlbiB1c2Ugc3RkIGJlemllciB0byBpbnRlcnBvbGF0ZSBbbixuKzEpXG4gICAgLy8gIHkobit0KSA9IHkobikqKDEtdCleMyArIDMgKiB5YShuKSooMS10KV4yKnQgKyAzICogeWIobikqKDEtdCkqdF4yICsgeShuKzEpKnReM1xuICAgIC8vICBub3RlIHRoZSAzKiBmYWN0b3IgZm9yIHRoZSB0d28gY29udHJvbCBwb2ludHNcbiAgICAvLyBmb3IgZWRnZSBjYXNlcywgY2FuIGNob29zZTpcbiAgICAvLyAgeSgtMSkgPSB5KDApIC0gMiooeSgxKS15KDApKVxuICAgIC8vICB5KHcpID0geSh3LTEpICsgMiooeSh3LTEpLXkody0yKSlcbiAgICAvLyBidXQgY2FuIGdvIHdpdGggeSgtMSkgPSB5KDApIGFuZCB5KHcpID0geSh3LTEpXG4gICAgdmFyIGludGVycG9sYXRlQmV6aWVyID0gZnVuY3Rpb24gaW50ZXJwb2xhdGVCZXppZXIoeDAsIHgxLCB4MiwgeDMsIHQpIHtcbiAgICAgIC8vIHgxLCB4MiBhcmUgdGhlIGtub3RzLCB1c2UgeDAgYW5kIHgzIHRvIGNhbGN1bGF0ZSBjb250cm9sIHBvaW50c1xuICAgICAgdmFyIGNwMSA9IHgxICsgKHgyIC0geDApIC8gNDtcbiAgICAgIHZhciBjcDIgPSB4MiAtICh4MyAtIHgxKSAvIDQ7XG4gICAgICB2YXIgbnQgPSAxIC0gdDtcbiAgICAgIHZhciBjMCA9IHgxICogbnQgKiBudCAqIG50O1xuICAgICAgdmFyIGMxID0gMyAqIGNwMSAqIG50ICogbnQgKiB0O1xuICAgICAgdmFyIGMyID0gMyAqIGNwMiAqIG50ICogdCAqIHQ7XG4gICAgICB2YXIgYzMgPSB4MiAqIHQgKiB0ICogdDtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoYzAgKyBjMSArIGMyICsgYzMpKSk7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0ZTJEKHNyYywgZHN0LCBvcHRpb25zLCBpbnRlcnBvbGF0ZUJlemllcik7XG4gIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemUyLmpzLm1hcCIsImltcG9ydCB7IHRocm93RXJyb3IsIGlzTm9kZVBhdHRlcm4gfSBmcm9tICdAamltcC91dGlscyc7XG5cbmZ1bmN0aW9uIHJvdGF0ZTkwZGVncmVlcyhiaXRtYXAsIGRzdEJ1ZmZlciwgY2xvY2t3aXNlKSB7XG4gIHZhciBkc3RPZmZzZXRTdGVwID0gY2xvY2t3aXNlID8gLTQgOiA0O1xuICB2YXIgZHN0T2Zmc2V0ID0gY2xvY2t3aXNlID8gZHN0QnVmZmVyLmxlbmd0aCAtIDQgOiAwO1xuICB2YXIgdG1wO1xuICB2YXIgeDtcbiAgdmFyIHk7XG4gIHZhciBzcmNPZmZzZXQ7XG5cbiAgZm9yICh4ID0gMDsgeCA8IGJpdG1hcC53aWR0aDsgeCsrKSB7XG4gICAgZm9yICh5ID0gYml0bWFwLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICBzcmNPZmZzZXQgPSBiaXRtYXAud2lkdGggKiB5ICsgeCA8PCAyO1xuICAgICAgdG1wID0gYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKHNyY09mZnNldCwgdHJ1ZSk7XG4gICAgICBkc3RCdWZmZXIud3JpdGVVSW50MzJCRSh0bXAsIGRzdE9mZnNldCwgdHJ1ZSk7XG4gICAgICBkc3RPZmZzZXQgKz0gZHN0T2Zmc2V0U3RlcDtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogUm90YXRlcyBhbiBpbWFnZSBjbG9ja3dpc2UgYnkgYSBudW1iZXIgb2YgZGVncmVlcyByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IDkwIGRlZ3JlZXMuIE5COiAndGhpcycgbXVzdCBiZSBhIEppbXAgb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZyB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpbWFnZSBieVxuICovXG5cblxuZnVuY3Rpb24gc2ltcGxlUm90YXRlKGRlZykge1xuICB2YXIgc3RlcHMgPSBNYXRoLnJvdW5kKGRlZyAvIDkwKSAlIDQ7XG4gIHN0ZXBzICs9IHN0ZXBzIDwgMCA/IDQgOiAwO1xuICBpZiAoc3RlcHMgPT09IDApIHJldHVybjtcbiAgdmFyIHNyY0J1ZmZlciA9IHRoaXMuYml0bWFwLmRhdGE7XG4gIHZhciBsZW4gPSBzcmNCdWZmZXIubGVuZ3RoO1xuICB2YXIgZHN0QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbik7XG4gIHZhciB0bXA7XG5cbiAgaWYgKHN0ZXBzID09PSAyKSB7XG4gICAgLy8gVXBzaWRlLWRvd25cbiAgICBmb3IgKHZhciBzcmNPZmZzZXQgPSAwOyBzcmNPZmZzZXQgPCBsZW47IHNyY09mZnNldCArPSA0KSB7XG4gICAgICB0bXAgPSBzcmNCdWZmZXIucmVhZFVJbnQzMkJFKHNyY09mZnNldCwgdHJ1ZSk7XG4gICAgICBkc3RCdWZmZXIud3JpdGVVSW50MzJCRSh0bXAsIGxlbiAtIHNyY09mZnNldCAtIDQsIHRydWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDbG9ja3dpc2Ugb3IgY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24gYnkgOTAgZGVncmVlXG4gICAgcm90YXRlOTBkZWdyZWVzKHRoaXMuYml0bWFwLCBkc3RCdWZmZXIsIHN0ZXBzID09PSAxKTtcbiAgICB0bXAgPSB0aGlzLmJpdG1hcC53aWR0aDtcbiAgICB0aGlzLmJpdG1hcC53aWR0aCA9IHRoaXMuYml0bWFwLmhlaWdodDtcbiAgICB0aGlzLmJpdG1hcC5oZWlnaHQgPSB0bXA7XG4gIH1cblxuICB0aGlzLmJpdG1hcC5kYXRhID0gZHN0QnVmZmVyO1xufVxuLyoqXG4gKiBSb3RhdGVzIGFuIGltYWdlIGNsb2Nrd2lzZSBieSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGRlZ3JlZXMuIE5COiAndGhpcycgbXVzdCBiZSBhIEppbXAgb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZyB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpbWFnZSBieVxuICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gbW9kZSAob3B0aW9uYWwpIHJlc2l6ZSBtb2RlIG9yIGEgYm9vbGVhbiwgaWYgZmFsc2UgdGhlbiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgaW1hZ2Ugd2lsbCBub3QgYmUgY2hhbmdlZFxuICovXG5cblxuZnVuY3Rpb24gYWR2YW5jZWRSb3RhdGUoZGVnLCBtb2RlKSB7XG4gIGRlZyAlPSAzNjA7XG4gIHZhciByYWQgPSBkZWcgKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgY29zaW5lID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIHNpbmUgPSBNYXRoLnNpbihyYWQpOyAvLyB0aGUgZmluYWwgd2lkdGggYW5kIGhlaWdodCB3aWxsIGNoYW5nZSBpZiByZXNpemUgPT0gdHJ1ZVxuXG4gIHZhciB3ID0gdGhpcy5iaXRtYXAud2lkdGg7XG4gIHZhciBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuXG4gIGlmIChtb2RlID09PSB0cnVlIHx8IHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJykge1xuICAgIC8vIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gaXQgbWF4aW11bSBkaW1lbnNpb24gYW5kIGJsaXQgdGhlIGV4aXN0aW5nIGltYWdlXG4gICAgLy8gb250byB0aGUgY2VudGVyIHNvIHRoYXQgd2hlbiBpdCBpcyByb3RhdGVkIHRoZSBpbWFnZSBpcyBrZXB0IGluIGJvdW5kc1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzIzMTE3Ni9ob3ctdG8tZ2V0LXNpemUtb2YtYS1yb3RhdGVkLXJlY3RhbmdsZVxuICAgIC8vIFBsdXMgMSBib3JkZXIgcGl4ZWwgdG8gZW5zdXJlIHRvIHNob3cgYWxsIHJvdGF0ZWQgcmVzdWx0IGZvciBzb21lIGNhc2VzLlxuICAgIHcgPSBNYXRoLmNlaWwoTWF0aC5hYnModGhpcy5iaXRtYXAud2lkdGggKiBjb3NpbmUpICsgTWF0aC5hYnModGhpcy5iaXRtYXAuaGVpZ2h0ICogc2luZSkpICsgMTtcbiAgICBoID0gTWF0aC5jZWlsKE1hdGguYWJzKHRoaXMuYml0bWFwLndpZHRoICogc2luZSkgKyBNYXRoLmFicyh0aGlzLmJpdG1hcC5oZWlnaHQgKiBjb3NpbmUpKSArIDE7IC8vIEVuc3VyZSBkZXN0aW5hdGlvbiB0byBoYXZlIGV2ZW4gc2l6ZSB0byBhIGJldHRlciByZXN1bHQuXG5cbiAgICBpZiAodyAlIDIgIT09IDApIHtcbiAgICAgIHcrKztcbiAgICB9XG5cbiAgICBpZiAoaCAlIDIgIT09IDApIHtcbiAgICAgIGgrKztcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY2xvbmVRdWlldCgpO1xuICAgIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGEud3JpdGVVSW50MzJCRSh0aGlzLl9iYWNrZ3JvdW5kLCBpZHgpO1xuICAgIH0pO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCh3LCBoLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0KTtcbiAgICB0aGlzLnJlc2l6ZShtYXgsIG1heCwgbW9kZSk7XG4gICAgdGhpcy5ibGl0KGMsIHRoaXMuYml0bWFwLndpZHRoIC8gMiAtIGMuYml0bWFwLndpZHRoIC8gMiwgdGhpcy5iaXRtYXAuaGVpZ2h0IC8gMiAtIGMuYml0bWFwLmhlaWdodCAvIDIpO1xuICB9XG5cbiAgdmFyIGJXID0gdGhpcy5iaXRtYXAud2lkdGg7XG4gIHZhciBiSCA9IHRoaXMuYml0bWFwLmhlaWdodDtcbiAgdmFyIGRzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmJpdG1hcC5kYXRhLmxlbmd0aCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRpb25GdW5jdGlvbihkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIGRlbHRhWCxcbiAgICAgICAgeTogeSArIGRlbHRhWVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHRyYW5zbGF0ZTJDYXJ0ZXNpYW4gPSBjcmVhdGVUcmFuc2xhdGlvbkZ1bmN0aW9uKC0oYlcgLyAyKSwgLShiSCAvIDIpKTtcbiAgdmFyIHRyYW5zbGF0ZTJTY3JlZW4gPSBjcmVhdGVUcmFuc2xhdGlvbkZ1bmN0aW9uKGJXIC8gMiArIDAuNSwgYkggLyAyICsgMC41KTtcblxuICBmb3IgKHZhciB5ID0gMTsgeSA8PSBiSDsgeSsrKSB7XG4gICAgZm9yICh2YXIgeCA9IDE7IHggPD0gYlc7IHgrKykge1xuICAgICAgdmFyIGNhcnRlc2lhbiA9IHRyYW5zbGF0ZTJDYXJ0ZXNpYW4oeCwgeSk7XG4gICAgICB2YXIgc291cmNlID0gdHJhbnNsYXRlMlNjcmVlbihjb3NpbmUgKiBjYXJ0ZXNpYW4ueCAtIHNpbmUgKiBjYXJ0ZXNpYW4ueSwgY29zaW5lICogY2FydGVzaWFuLnkgKyBzaW5lICogY2FydGVzaWFuLngpO1xuICAgICAgdmFyIGRzdElkeCA9IGJXICogKHkgLSAxKSArIHggLSAxIDw8IDI7XG5cbiAgICAgIGlmIChzb3VyY2UueCA+PSAwICYmIHNvdXJjZS54IDwgYlcgJiYgc291cmNlLnkgPj0gMCAmJiBzb3VyY2UueSA8IGJIKSB7XG4gICAgICAgIHZhciBzcmNJZHggPSAoYlcgKiAoc291cmNlLnkgfCAwKSArIHNvdXJjZS54IHwgMCkgPDwgMjtcbiAgICAgICAgdmFyIHBpeGVsUkdCQSA9IHRoaXMuYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKHNyY0lkeCk7XG4gICAgICAgIGRzdEJ1ZmZlci53cml0ZVVJbnQzMkJFKHBpeGVsUkdCQSwgZHN0SWR4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc2V0IG9mZi1pbWFnZSBwaXhlbHNcbiAgICAgICAgZHN0QnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5fYmFja2dyb3VuZCwgZHN0SWR4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmJpdG1hcC5kYXRhID0gZHN0QnVmZmVyO1xuXG4gIGlmIChtb2RlID09PSB0cnVlIHx8IHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJykge1xuICAgIC8vIG5vdyBjcm9wIHRoZSBpbWFnZSB0byB0aGUgZmluYWwgc2l6ZVxuICAgIHZhciBfeCA9IGJXIC8gMiAtIHcgLyAyO1xuXG4gICAgdmFyIF95ID0gYkggLyAyIC0gaCAvIDI7XG5cbiAgICB0aGlzLmNyb3AoX3gsIF95LCB3LCBoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGltYWdlIGNsb2Nrd2lzZSBieSBhIG51bWJlciBvZiBkZWdyZWVzLiBCeSBkZWZhdWx0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgYXBwcm9wcmlhdGVseS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVnIHRoZSBudW1iZXIgb2YgZGVncmVlcyB0byByb3RhdGUgdGhlIGltYWdlIGJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gbW9kZSAob3B0aW9uYWwpIHJlc2l6ZSBtb2RlIG9yIGEgYm9vbGVhbiwgaWYgZmFsc2UgdGhlbiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgaW1hZ2Ugd2lsbCBub3QgYmUgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKGRlZywgbW9kZSwgY2IpIHtcbiAgICAgIC8vIGVuYWJsZSBvdmVybG9hZGluZ1xuICAgICAgaWYgKHR5cGVvZiBtb2RlID09PSAndW5kZWZpbmVkJyB8fCBtb2RlID09PSBudWxsKSB7XG4gICAgICAgIC8vIGUuZy4gaW1hZ2UucmVzaXplKDEyMCk7XG4gICAgICAgIC8vIGUuZy4gaW1hZ2UucmVzaXplKDEyMCwgbnVsbCwgY2IpO1xuICAgICAgICAvLyBlLmcuIGltYWdlLnJlc2l6ZSgxMjAsIHVuZGVmaW5lZCwgY2IpO1xuICAgICAgICBtb2RlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gZS5nLiBpbWFnZS5yZXNpemUoMTIwLCBjYik7XG4gICAgICAgIGNiID0gbW9kZTtcbiAgICAgICAgbW9kZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVnICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsICdkZWcgbXVzdCBiZSBhIG51bWJlcicsIGNiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBtb2RlICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIG1vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ21vZGUgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBzdHJpbmcnLCBjYik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWcgJSA5MCA9PT0gMCAmJiBCb29sZWFuKG1vZGUpID09PSBmYWxzZSkge1xuICAgICAgICBzaW1wbGVSb3RhdGUuY2FsbCh0aGlzLCBkZWcsIGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkdmFuY2VkUm90YXRlLmNhbGwodGhpcywgZGVnLCBtb2RlLCBjYik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tICdAamltcC91dGlscyc7XG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFVuaWZvcm1seSBzY2FsZXMgdGhlIGltYWdlIGJ5IGEgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmIHRoZSBmYWN0b3IgdG8gc2NhbGUgdGhlIGltYWdlIGJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgKG9wdGlvbmFsKSBhIHNjYWxpbmcgbWV0aG9kIChlLmcuIEppbXAuUkVTSVpFX0JFWklFUilcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24gc2NhbGUoZiwgbW9kZSwgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgZiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnZiBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZiA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnZiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJywgY2IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYiA9IG1vZGU7XG4gICAgICAgIG1vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdyA9IHRoaXMuYml0bWFwLndpZHRoICogZjtcbiAgICAgIHZhciBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0ICogZjtcbiAgICAgIHRoaXMucmVzaXplKHcsIGgsIG1vZGUpO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBpbWFnZSB0byB0aGUgbGFyZ2VzdCBzaXplIHRoYXQgZml0cyBpbnNpZGUgdGhlIHJlY3RhbmdsZSB0aGF0IGhhcyB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyB0aGUgd2lkdGggdG8gcmVzaXplIHRoZSBpbWFnZSB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoIHRoZSBoZWlnaHQgdG8gcmVzaXplIHRoZSBpbWFnZSB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIChvcHRpb25hbCkgYSBzY2FsaW5nIG1ldGhvZCAoZS5nLiBKaW1wLlJFU0laRV9CRVpJRVIpXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgc2NhbGVUb0ZpdDogZnVuY3Rpb24gc2NhbGVUb0ZpdCh3LCBoLCBtb2RlLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiB3ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgaCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAndyBhbmQgaCBtdXN0IGJlIG51bWJlcnMnLCBjYik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNiID0gbW9kZTtcbiAgICAgICAgbW9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBmID0gdyAvIGggPiB0aGlzLmJpdG1hcC53aWR0aCAvIHRoaXMuYml0bWFwLmhlaWdodCA/IGggLyB0aGlzLmJpdG1hcC5oZWlnaHQgOiB3IC8gdGhpcy5iaXRtYXAud2lkdGg7XG4gICAgICB0aGlzLnNjYWxlKGYsIG1vZGUpO1xuXG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gfVxuXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICd0aW1tJztcbmltcG9ydCBkaXRoZXIgZnJvbSAnQGppbXAvcGx1Z2luLWRpdGhlcic7XG5pbXBvcnQgcmVzaXplIGZyb20gJ0BqaW1wL3BsdWdpbi1yZXNpemUnO1xuaW1wb3J0IGJsaXQgZnJvbSAnQGppbXAvcGx1Z2luLWJsaXQnO1xuaW1wb3J0IHJvdGF0ZSBmcm9tICdAamltcC9wbHVnaW4tcm90YXRlJztcbmltcG9ydCBjb2xvciBmcm9tICdAamltcC9wbHVnaW4tY29sb3InO1xuaW1wb3J0IHByaW50IGZyb20gJ0BqaW1wL3BsdWdpbi1wcmludCc7XG5pbXBvcnQgYmx1ciBmcm9tICdAamltcC9wbHVnaW4tYmx1cic7XG5pbXBvcnQgY3JvcCBmcm9tICdAamltcC9wbHVnaW4tY3JvcCc7XG5pbXBvcnQgbm9ybWFsaXplIGZyb20gJ0BqaW1wL3BsdWdpbi1ub3JtYWxpemUnO1xuaW1wb3J0IGludmVydCBmcm9tICdAamltcC9wbHVnaW4taW52ZXJ0JztcbmltcG9ydCBnYXVzc2lhbiBmcm9tICdAamltcC9wbHVnaW4tZ2F1c3NpYW4nO1xuaW1wb3J0IGZsaXAgZnJvbSAnQGppbXAvcGx1Z2luLWZsaXAnO1xuaW1wb3J0IG1hc2sgZnJvbSAnQGppbXAvcGx1Z2luLW1hc2snO1xuaW1wb3J0IHNjYWxlIGZyb20gJ0BqaW1wL3BsdWdpbi1zY2FsZSc7XG5pbXBvcnQgZGlzcGxhY2UgZnJvbSAnQGppbXAvcGx1Z2luLWRpc3BsYWNlJztcbmltcG9ydCBjb250YWluIGZyb20gJ0BqaW1wL3BsdWdpbi1jb250YWluJztcbmltcG9ydCBjb3ZlciBmcm9tICdAamltcC9wbHVnaW4tY292ZXInO1xudmFyIHBsdWdpbnMgPSBbZGl0aGVyLCByZXNpemUsIGJsaXQsIHJvdGF0ZSwgY29sb3IsIHByaW50LCBibHVyLCBjcm9wLCBub3JtYWxpemUsIGludmVydCwgZ2F1c3NpYW4sIGZsaXAsIG1hc2ssIHNjYWxlLCBkaXNwbGFjZSwgY29udGFpbiwgY292ZXJdO1xuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIChqaW1wRXZDaGFuZ2UpIHtcbiAgdmFyIGluaXRpYWxpemVkUGx1Z2lucyA9IHBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW5Nb2R1bGUpIHtcbiAgICB2YXIgcGx1Z2luID0gcGx1Z2luTW9kdWxlKGppbXBFdkNoYW5nZSkgfHwge307XG5cbiAgICBpZiAoIXBsdWdpbi5jbGFzcyAmJiAhcGx1Z2luLmNvbnN0YW50cykge1xuICAgICAgLy8gRGVmYXVsdCB0byBjbGFzcyBmdW5jdGlvblxuICAgICAgcGx1Z2luID0ge1xuICAgICAgICBjbGFzczogcGx1Z2luXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwbHVnaW47XG4gIH0pO1xuICByZXR1cm4gbWVyZ2VEZWVwLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGluaXRpYWxpemVkUGx1Z2lucykpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBQTkcgfSBmcm9tICdwbmdqcyc7XG5pbXBvcnQgeyB0aHJvd0Vycm9yLCBpc05vZGVQYXR0ZXJuIH0gZnJvbSAnQGppbXAvdXRpbHMnO1xudmFyIE1JTUVfVFlQRSA9ICdpbWFnZS9wbmcnOyAvLyBQTkcgZmlsdGVyIHR5cGVzXG5cbnZhciBQTkdfRklMVEVSX0FVVE8gPSAtMTtcbnZhciBQTkdfRklMVEVSX05PTkUgPSAwO1xudmFyIFBOR19GSUxURVJfU1VCID0gMTtcbnZhciBQTkdfRklMVEVSX1VQID0gMjtcbnZhciBQTkdfRklMVEVSX0FWRVJBR0UgPSAzO1xudmFyIFBOR19GSUxURVJfUEFUSCA9IDQ7XG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIG1pbWU6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgTUlNRV9UWVBFLCBbJ3BuZyddKSxcbiAgICBjb25zdGFudHM6IHtcbiAgICAgIE1JTUVfUE5HOiBNSU1FX1RZUEUsXG4gICAgICBQTkdfRklMVEVSX0FVVE86IFBOR19GSUxURVJfQVVUTyxcbiAgICAgIFBOR19GSUxURVJfTk9ORTogUE5HX0ZJTFRFUl9OT05FLFxuICAgICAgUE5HX0ZJTFRFUl9TVUI6IFBOR19GSUxURVJfU1VCLFxuICAgICAgUE5HX0ZJTFRFUl9VUDogUE5HX0ZJTFRFUl9VUCxcbiAgICAgIFBOR19GSUxURVJfQVZFUkFHRTogUE5HX0ZJTFRFUl9BVkVSQUdFLFxuICAgICAgUE5HX0ZJTFRFUl9QQVRIOiBQTkdfRklMVEVSX1BBVEhcbiAgICB9LFxuICAgIGhhc0FscGhhOiBfZGVmaW5lUHJvcGVydHkoe30sIE1JTUVfVFlQRSwgdHJ1ZSksXG4gICAgZGVjb2RlcnM6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgTUlNRV9UWVBFLCBQTkcuc3luYy5yZWFkKSxcbiAgICBlbmNvZGVyczogX2RlZmluZVByb3BlcnR5KHt9LCBNSU1FX1RZUEUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgcG5nID0gbmV3IFBORyh7XG4gICAgICAgIHdpZHRoOiBkYXRhLmJpdG1hcC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkYXRhLmJpdG1hcC5oZWlnaHRcbiAgICAgIH0pO1xuICAgICAgcG5nLmRhdGEgPSBkYXRhLmJpdG1hcC5kYXRhO1xuICAgICAgcmV0dXJuIFBORy5zeW5jLndyaXRlKHBuZywge1xuICAgICAgICB3aWR0aDogZGF0YS5iaXRtYXAud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YS5iaXRtYXAuaGVpZ2h0LFxuICAgICAgICBkZWZsYXRlTGV2ZWw6IGRhdGEuX2RlZmxhdGVMZXZlbCxcbiAgICAgICAgZGVmbGF0ZVN0cmF0ZWd5OiBkYXRhLl9kZWZsYXRlU3RyYXRlZ3ksXG4gICAgICAgIGZpbHRlclR5cGU6IGRhdGEuX2ZpbHRlclR5cGUsXG4gICAgICAgIGNvbG9yVHlwZTogdHlwZW9mIGRhdGEuX2NvbG9yVHlwZSA9PT0gJ251bWJlcicgPyBkYXRhLl9jb2xvclR5cGUgOiBkYXRhLl9yZ2JhID8gNiA6IDIsXG4gICAgICAgIGlucHV0SGFzQWxwaGE6IGRhdGEuX3JnYmFcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGNsYXNzOiB7XG4gICAgICBfZGVmbGF0ZUxldmVsOiA5LFxuICAgICAgX2RlZmxhdGVTdHJhdGVneTogMyxcbiAgICAgIF9maWx0ZXJUeXBlOiBQTkdfRklMVEVSX0FVVE8sXG4gICAgICBfY29sb3JUeXBlOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGRlZmxhdGUgbGV2ZWwgdXNlZCB3aGVuIHNhdmluZyBhcyBQTkcgZm9ybWF0IChkZWZhdWx0IGlzIDkpXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbCBEZWZsYXRlIGxldmVsIHRvIHVzZSAwLTkuIDAgaXMgbm8gY29tcHJlc3Npb24uIDkgKGRlZmF1bHQpIGlzIG1heGltdW0gY29tcHJlc3Npb24uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAgICovXG4gICAgICBkZWZsYXRlTGV2ZWw6IGZ1bmN0aW9uIGRlZmxhdGVMZXZlbChsLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnbCBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGwgPCAwIHx8IGwgPiA5KSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnbCBtdXN0IGJlIGEgbnVtYmVyIDAgLSA5JywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVmbGF0ZUxldmVsID0gTWF0aC5yb3VuZChsKTtcblxuICAgICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGRlZmxhdGUgc3RyYXRlZ3kgdXNlZCB3aGVuIHNhdmluZyBhcyBQTkcgZm9ybWF0IChkZWZhdWx0IGlzIDMpXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcyBEZWZsYXRlIHN0cmF0ZWd5IHRvIHVzZSAwLTMuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAgICovXG4gICAgICBkZWZsYXRlU3RyYXRlZ3k6IGZ1bmN0aW9uIGRlZmxhdGVTdHJhdGVneShzLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIHMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAncyBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHMgPCAwIHx8IHMgPiAzKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAncyBtdXN0IGJlIGEgbnVtYmVyIDAgLSAzJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVmbGF0ZVN0cmF0ZWd5ID0gTWF0aC5yb3VuZChzKTtcblxuICAgICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGZpbHRlciB0eXBlIHVzZWQgd2hlbiBzYXZpbmcgYXMgUE5HIGZvcm1hdCAoZGVmYXVsdCBpcyBhdXRvbWF0aWMgZmlsdGVycylcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSBxdWFsaXR5IHRvIHVzZSAtMS00LlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgICAqL1xuICAgICAgZmlsdGVyVHlwZTogZnVuY3Rpb24gZmlsdGVyVHlwZShmLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGYgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAnbiBtdXN0IGJlIGEgbnVtYmVyJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGYgPCAtMSB8fCBmID4gNCkge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ24gbXVzdCBiZSAtMSAoYXV0bykgb3IgYSBudW1iZXIgMCAtIDQnLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maWx0ZXJUeXBlID0gTWF0aC5yb3VuZChmKTtcblxuICAgICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGNvbG9yIHR5cGUgdXNlZCB3aGVuIHNhdmluZyBhcyBQTkcgZm9ybWF0XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcyBjb2xvciB0eXBlIHRvIHVzZSAwLCAyLCA0LCA2LlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgICAqL1xuICAgICAgY29sb3JUeXBlOiBmdW5jdGlvbiBjb2xvclR5cGUocywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgJ3MgbXVzdCBiZSBhIG51bWJlcicsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzICE9PSAwICYmIHMgIT09IDIgJiYgcyAhPT0gNCAmJiBzICE9PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCAncyBtdXN0IGJlIGEgbnVtYmVyIDAsIDIsIDQsIDYuJywgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29sb3JUeXBlID0gTWF0aC5yb3VuZChzKTtcblxuICAgICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgVVRJRiBmcm9tICd1dGlmJztcbnZhciBNSU1FX1RZUEUgPSAnaW1hZ2UvdGlmZic7XG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIG1pbWU6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgTUlNRV9UWVBFLCBbJ3RpZmYnLCAndGlmJ10pLFxuICAgIGNvbnN0YW50czoge1xuICAgICAgTUlNRV9USUZGOiBNSU1FX1RZUEVcbiAgICB9LFxuICAgIGRlY29kZXJzOiBfZGVmaW5lUHJvcGVydHkoe30sIE1JTUVfVFlQRSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBpZmRzID0gVVRJRi5kZWNvZGUoZGF0YSk7XG4gICAgICB2YXIgcGFnZSA9IGlmZHNbMF07XG4gICAgICBVVElGLmRlY29kZUltYWdlcyhkYXRhLCBpZmRzKTtcbiAgICAgIHZhciByZ2JhID0gVVRJRi50b1JHQkE4KHBhZ2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogQnVmZmVyLmZyb20ocmdiYSksXG4gICAgICAgIHdpZHRoOiBwYWdlLnQyNTZbMF0sXG4gICAgICAgIGhlaWdodDogcGFnZS50MjU3WzBdXG4gICAgICB9O1xuICAgIH0pLFxuICAgIGVuY29kZXJzOiBfZGVmaW5lUHJvcGVydHkoe30sIE1JTUVfVFlQRSwgZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICB2YXIgdGlmZiA9IFVUSUYuZW5jb2RlSW1hZ2UoaW1hZ2UuYml0bWFwLmRhdGEsIGltYWdlLmJpdG1hcC53aWR0aCwgaW1hZ2UuYml0bWFwLmhlaWdodCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odGlmZik7XG4gICAgfSlcbiAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAndGltbSc7XG5pbXBvcnQganBlZyBmcm9tICdAamltcC9qcGVnJztcbmltcG9ydCBwbmcgZnJvbSAnQGppbXAvcG5nJztcbmltcG9ydCBibXAgZnJvbSAnQGppbXAvYm1wJztcbmltcG9ydCB0aWZmIGZyb20gJ0BqaW1wL3RpZmYnO1xuaW1wb3J0IGdpZiBmcm9tICdAamltcC9naWYnO1xuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG1lcmdlRGVlcChqcGVnKCksIHBuZygpLCBibXAoKSwgdGlmZigpLCBnaWYoKSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBpc05vZGVQYXR0ZXJuKGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gdGhyb3dFcnJvcihlcnJvciwgY2IpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cblxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNiLmNhbGwodGhpcywgZXJyb3IpO1xuICB9XG5cbiAgdGhyb3cgZXJyb3I7XG59XG5leHBvcnQgZnVuY3Rpb24gc2NhbihpbWFnZSwgeCwgeSwgdywgaCwgZikge1xuICAvLyByb3VuZCBpbnB1dFxuICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgeSA9IE1hdGgucm91bmQoeSk7XG4gIHcgPSBNYXRoLnJvdW5kKHcpO1xuICBoID0gTWF0aC5yb3VuZChoKTtcblxuICBmb3IgKHZhciBfeSA9IHk7IF95IDwgeSArIGg7IF95KyspIHtcbiAgICBmb3IgKHZhciBfeCA9IHg7IF94IDwgeCArIHc7IF94KyspIHtcbiAgICAgIHZhciBpZHggPSBpbWFnZS5iaXRtYXAud2lkdGggKiBfeSArIF94IDw8IDI7XG4gICAgICBmLmNhbGwoaW1hZ2UsIF94LCBfeSwgaWR4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW1hZ2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgQ29udmVydGVyID0gcmVxdWlyZSgnLi9zcmMvY29udmVydGVyJyk7XG5cbi8qKlxuICogRnVuY3Rpb24gZ2V0IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gYWxwaGFiZXQgYW5kIHJldHVybiBjb252ZXJ0IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHNyY0FscGhhYmV0XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gZHN0QWxwaGFiZXRcbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyfEFycmF5KX1cbiAqL1xuZnVuY3Rpb24gYW55QmFzZShzcmNBbHBoYWJldCwgZHN0QWxwaGFiZXQpIHtcbiAgICB2YXIgY29udmVydGVyID0gbmV3IENvbnZlcnRlcihzcmNBbHBoYWJldCwgZHN0QWxwaGFiZXQpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xBcnJheX0gbnVtYmVyXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5jb252ZXJ0KG51bWJlcik7XG4gICAgfVxufTtcblxuYW55QmFzZS5CSU4gPSAnMDEnO1xuYW55QmFzZS5PQ1QgPSAnMDEyMzQ1NjcnO1xuYW55QmFzZS5ERUMgPSAnMDEyMzQ1Njc4OSc7XG5hbnlCYXNlLkhFWCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxubW9kdWxlLmV4cG9ydHMgPSBhbnlCYXNlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb252ZXJ0ZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gc3JjQWxwaGFiZXRcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBkc3RBbHBoYWJldFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRlcihzcmNBbHBoYWJldCwgZHN0QWxwaGFiZXQpIHtcbiAgICBpZiAoIXNyY0FscGhhYmV0IHx8ICFkc3RBbHBoYWJldCB8fCAhc3JjQWxwaGFiZXQubGVuZ3RoIHx8ICFkc3RBbHBoYWJldC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgYWxwaGFiZXQnKTtcbiAgICB9XG4gICAgdGhpcy5zcmNBbHBoYWJldCA9IHNyY0FscGhhYmV0O1xuICAgIHRoaXMuZHN0QWxwaGFiZXQgPSBkc3RBbHBoYWJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG51bWJlciBmcm9tIHNvdXJjZSBhbHBoYWJldCB0byBkZXN0aW5hdGlvbiBhbHBoYWJldFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBudW1iZXIgLSBudW1iZXIgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgcG9pbnRzXG4gKlxuICogQHJldHVybnMge3N0cmluZ3xBcnJheX1cbiAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgdmFyIGksIGRpdmlkZSwgbmV3bGVuLFxuICAgIG51bWJlck1hcCA9IHt9LFxuICAgIGZyb21CYXNlID0gdGhpcy5zcmNBbHBoYWJldC5sZW5ndGgsXG4gICAgdG9CYXNlID0gdGhpcy5kc3RBbHBoYWJldC5sZW5ndGgsXG4gICAgbGVuZ3RoID0gbnVtYmVyLmxlbmd0aCxcbiAgICByZXN1bHQgPSB0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJyA/ICcnIDogW107XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZChudW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIFwiJyArIG51bWJlciArICdcIiBjb250YWlucyBvZiBub24tYWxwaGFiZXRpYyBkaWdpdHMgKCcgKyB0aGlzLnNyY0FscGhhYmV0ICsgJyknKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zcmNBbHBoYWJldCA9PT0gdGhpcy5kc3RBbHBoYWJldCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBudW1iZXJNYXBbaV0gPSB0aGlzLnNyY0FscGhhYmV0LmluZGV4T2YobnVtYmVyW2ldKTtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgICBkaXZpZGUgPSAwO1xuICAgICAgICBuZXdsZW4gPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpdmlkZSA9IGRpdmlkZSAqIGZyb21CYXNlICsgbnVtYmVyTWFwW2ldO1xuICAgICAgICAgICAgaWYgKGRpdmlkZSA+PSB0b0Jhc2UpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJNYXBbbmV3bGVuKytdID0gcGFyc2VJbnQoZGl2aWRlIC8gdG9CYXNlLCAxMCk7XG4gICAgICAgICAgICAgICAgZGl2aWRlID0gZGl2aWRlICUgdG9CYXNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTWFwW25ld2xlbisrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gbmV3bGVuO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmRzdEFscGhhYmV0LnNsaWNlKGRpdmlkZSwgZGl2aWRlICsgMSkuY29uY2F0KHJlc3VsdCk7XG4gICAgfSB3aGlsZSAobmV3bGVuICE9PSAwKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkIG51bWJlciB3aXRoIHNvdXJjZSBhbHBoYWJldFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbnVtYmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0aGlzLnNyY0FscGhhYmV0LmluZGV4T2YobnVtYmVyW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmVydGVyOyIsIi8qKlxuICogQGF1dGhvciBzaGFvemlsZWVcbiAqXG4gKiBzdXBwb3J0IDFiaXQgNGJpdCA4Yml0IDI0Yml0IGRlY29kZVxuICogZW5jb2RlIHdpdGggMjRiaXRcbiAqIFxuICovXG5cbnZhciBlbmNvZGUgPSByZXF1aXJlKCcuL2xpYi9lbmNvZGVyJyksXG4gICAgZGVjb2RlID0gcmVxdWlyZSgnLi9saWIvZGVjb2RlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGRlY29kZTogZGVjb2RlXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIHNoYW96aWxlZVxuICpcbiAqIEJtcCBmb3JtYXQgZGVjb2RlcixzdXBwb3J0IDFiaXQgNGJpdCA4Yml0IDI0Yml0IGJtcFxuICpcbiAqL1xuXG5mdW5jdGlvbiBCbXBEZWNvZGVyKGJ1ZmZlcixpc193aXRoX2FscGhhKSB7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gIHRoaXMuaXNfd2l0aF9hbHBoYSA9ICEhaXNfd2l0aF9hbHBoYTtcbiAgdGhpcy5ib3R0b21fdXAgPSB0cnVlO1xuICB0aGlzLmZsYWcgPSB0aGlzLmJ1ZmZlci50b1N0cmluZyhcInV0Zi04XCIsIDAsIHRoaXMucG9zICs9IDIpO1xuICBpZiAodGhpcy5mbGFnICE9IFwiQk1cIikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBCTVAgRmlsZVwiKTtcbiAgdGhpcy5wYXJzZUhlYWRlcigpO1xuICB0aGlzLnBhcnNlUkdCQSgpO1xufVxuXG5CbXBEZWNvZGVyLnByb3RvdHlwZS5wYXJzZUhlYWRlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZpbGVTaXplID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy5yZXNlcnZlZCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zICs9IDQ7XG4gIHRoaXMub2Zmc2V0ID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy5oZWFkZXJTaXplID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy53aWR0aCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zICs9IDQ7XG4gIHRoaXMuaGVpZ2h0ID0gdGhpcy5idWZmZXIucmVhZEludDMyTEUodGhpcy5wb3MpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLnBsYW5lcyA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MTZMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zICs9IDI7XG4gIHRoaXMuYml0UFAgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDE2TEUodGhpcy5wb3MpO1xuICB0aGlzLnBvcyArPSAyO1xuICB0aGlzLmNvbXByZXNzID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy5yYXdTaXplID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy5ociA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zICs9IDQ7XG4gIHRoaXMudnIgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLmNvbG9ycyA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zICs9IDQ7XG4gIHRoaXMuaW1wb3J0YW50Q29sb3JzID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgdGhpcy5wb3MgKz0gNDtcblxuICBpZih0aGlzLmJpdFBQID09PSAxNiAmJiB0aGlzLmlzX3dpdGhfYWxwaGEpe1xuICAgIHRoaXMuYml0UFAgPSAxNVxuICB9XG4gIGlmICh0aGlzLmJpdFBQIDwgMTUpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5jb2xvcnMgPT09IDAgPyAxIDw8IHRoaXMuYml0UFAgOiB0aGlzLmNvbG9ycztcbiAgICB0aGlzLnBhbGV0dGUgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYmx1ZSA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgIHZhciBncmVlbiA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgIHZhciByZWQgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICB2YXIgcXVhZCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgIHRoaXMucGFsZXR0ZVtpXSA9IHtcbiAgICAgICAgcmVkOiByZWQsXG4gICAgICAgIGdyZWVuOiBncmVlbixcbiAgICAgICAgYmx1ZTogYmx1ZSxcbiAgICAgICAgcXVhZDogcXVhZFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYodGhpcy5oZWlnaHQgPCAwKSB7XG4gICAgdGhpcy5oZWlnaHQgKj0gLTE7XG4gICAgdGhpcy5ib3R0b21fdXAgPSBmYWxzZTtcbiAgfVxuXG59XG5cbkJtcERlY29kZXIucHJvdG90eXBlLnBhcnNlUkdCQSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiaXRuID0gXCJiaXRcIiArIHRoaXMuYml0UFA7XG4gICAgdmFyIGxlbiA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIDQ7XG4gICAgdGhpcy5kYXRhID0gbmV3IEJ1ZmZlcihsZW4pO1xuICAgIHRoaXNbYml0bl0oKTtcbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmJpdDEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHhsZW4gPSBNYXRoLmNlaWwodGhpcy53aWR0aCAvIDgpO1xuICB2YXIgbW9kZSA9IHhsZW4lNDtcbiAgdmFyIHkgPSB0aGlzLmhlaWdodCA+PSAwID8gdGhpcy5oZWlnaHQgLSAxIDogLXRoaXMuaGVpZ2h0XG4gIGZvciAodmFyIHkgPSB0aGlzLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmJvdHRvbV91cCA/IHkgOiB0aGlzLmhlaWdodCAtIDEgLSB5XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB4bGVuOyB4KyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgdmFyIGxvY2F0aW9uID0gbGluZSAqIHRoaXMud2lkdGggKiA0ICsgeCo4KjQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICBpZih4KjgraTx0aGlzLndpZHRoKXtcbiAgICAgICAgICB2YXIgcmdiID0gdGhpcy5wYWxldHRlWygoYj4+KDctaSkpJjB4MSldO1xuXG4gICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uK2kqNF0gPSAwO1xuICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbitpKjQgKyAxXSA9IHJnYi5ibHVlO1xuICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbitpKjQgKyAyXSA9IHJnYi5ncmVlbjtcbiAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24raSo0ICsgM10gPSByZ2IucmVkO1xuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgIT0gMCl7XG4gICAgICB0aGlzLnBvcys9KDQgLSBtb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmJpdDQgPSBmdW5jdGlvbigpIHtcbiAgICAvL1JMRS00XG4gICAgaWYodGhpcy5jb21wcmVzcyA9PSAyKXtcbiAgICAgICAgdGhpcy5kYXRhLmZpbGwoMHhmZik7XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gMDtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5ib3R0b21fdXA/dGhpcy5oZWlnaHQtMTowO1xuICAgICAgICB2YXIgbG93X25pYmJsZSA9IGZhbHNlOy8vZm9yIGFsbCBjb3VudCBvZiBwaXhlbFxuXG4gICAgICAgIHdoaWxlKGxvY2F0aW9uPHRoaXMuZGF0YS5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgIC8vYWJzb2x1dGUgbW9kZVxuICAgICAgICAgICAgaWYoYSA9PSAwKXtcbiAgICAgICAgICAgICAgICBpZihiID09IDApey8vbGluZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ib3R0b21fdXApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMtLTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbGluZXMqdGhpcy53aWR0aCo0O1xuICAgICAgICAgICAgICAgICAgICBsb3dfbmliYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGIgPT0gMSl7Ly9pbWFnZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoYiA9PTIpe1xuICAgICAgICAgICAgICAgICAgICAvL29mZnNldCB4LHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmJvdHRvbV91cCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy09eTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcys9eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uICs9KHkqdGhpcy53aWR0aCo0K3gqNCk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDtpPGI7aSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb3dfbmliYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UGl4ZWxEYXRhLmNhbGwodGhpcywgKGMgJiAweDBmKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFBpeGVsRGF0YS5jYWxsKHRoaXMsIChjICYgMHhmMCk+PjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkgJiAxKSAmJiAoaSsxIDwgYikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd19uaWJibGUgPSAhbG93X25pYmJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKChiKzEpID4+IDEpICYgMSApID09IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MrK1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9ZWxzZXsvL2VuY29kZWQgbW9kZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dfbmliYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQaXhlbERhdGEuY2FsbCh0aGlzLCAoYiAmIDB4MGYpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFBpeGVsRGF0YS5jYWxsKHRoaXMsIChiICYgMHhmMCk+PjQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvd19uaWJibGUgPSAhbG93X25pYmJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHNldFBpeGVsRGF0YShyZ2JJbmRleCl7XG4gICAgICAgICAgICB2YXIgcmdiID0gdGhpcy5wYWxldHRlW3JnYkluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbl0gPSAwO1xuICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSByZ2IuYmx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDJdID0gcmdiLmdyZWVuO1xuICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgM10gPSByZ2IucmVkO1xuICAgICAgICAgICAgbG9jYXRpb24rPTQ7XG4gICAgICAgIH1cbiAgICB9ZWxzZXtcblxuICAgICAgdmFyIHhsZW4gPSBNYXRoLmNlaWwodGhpcy53aWR0aC8yKTtcbiAgICAgIHZhciBtb2RlID0geGxlbiU0O1xuICAgICAgZm9yICh2YXIgeSA9IHRoaXMuaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmJvdHRvbV91cCA/IHkgOiB0aGlzLmhlaWdodCAtIDEgLSB5XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgeGxlbjsgeCsrKSB7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICAgICAgdmFyIGxvY2F0aW9uID0gbGluZSAqIHRoaXMud2lkdGggKiA0ICsgeCoyKjQ7XG5cbiAgICAgICAgICB2YXIgYmVmb3JlID0gYj4+NDtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBiJjB4MEY7XG5cbiAgICAgICAgICB2YXIgcmdiID0gdGhpcy5wYWxldHRlW2JlZm9yZV07XG4gICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uXSA9IDA7XG4gICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSByZ2IuYmx1ZTtcbiAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAyXSA9IHJnYi5ncmVlbjtcbiAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAzXSA9IHJnYi5yZWQ7XG5cblxuICAgICAgICAgIGlmKHgqMisxPj10aGlzLndpZHRoKWJyZWFrO1xuXG4gICAgICAgICAgcmdiID0gdGhpcy5wYWxldHRlW2FmdGVyXTtcblxuICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbis0XSA9IDA7XG4gICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uKzQgKyAxXSA9IHJnYi5ibHVlO1xuICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbis0ICsgMl0gPSByZ2IuZ3JlZW47XG4gICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uKzQgKyAzXSA9IHJnYi5yZWQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlICE9IDApe1xuICAgICAgICAgIHRoaXMucG9zKz0oNCAtIG1vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmJpdDggPSBmdW5jdGlvbigpIHtcbiAgICAvL1JMRS04XG4gICAgaWYodGhpcy5jb21wcmVzcyA9PSAxKXtcbiAgICAgICAgdGhpcy5kYXRhLmZpbGwoMHhmZik7XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gMDtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5ib3R0b21fdXA/dGhpcy5oZWlnaHQtMTowO1xuXG4gICAgICAgIHdoaWxlKGxvY2F0aW9uPHRoaXMuZGF0YS5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgIC8vYWJzb2x1dGUgbW9kZVxuICAgICAgICAgICAgaWYoYSA9PSAwKXtcbiAgICAgICAgICAgICAgICBpZihiID09IDApey8vbGluZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ib3R0b21fdXApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMtLTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbGluZXMqdGhpcy53aWR0aCo0O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZihiID09IDEpey8vaW1hZ2UgZW5kXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGIgPT0yKXtcbiAgICAgICAgICAgICAgICAgICAgLy9vZmZzZXQgeCx5XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ib3R0b21fdXApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMtPXk7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMrPXk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiArPSh5KnRoaXMud2lkdGgqNCt4KjQpO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDtpPGI7aSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UGl4ZWxEYXRhLmNhbGwodGhpcywgYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoYiYxID09IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9ZWxzZXsvL2VuY29kZWQgbW9kZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFBpeGVsRGF0YS5jYWxsKHRoaXMsIGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgZnVuY3Rpb24gc2V0UGl4ZWxEYXRhKHJnYkluZGV4KXtcbiAgICAgICAgICAgIHZhciByZ2IgPSB0aGlzLnBhbGV0dGVbcmdiSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uXSA9IDA7XG4gICAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAxXSA9IHJnYi5ibHVlO1xuICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSByZ2IuZ3JlZW47XG4gICAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAzXSA9IHJnYi5yZWQ7XG4gICAgICAgICAgICBsb2NhdGlvbis9NDtcbiAgICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLndpZHRoICUgNDtcbiAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMuaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5ib3R0b21fdXAgPyB5IDogdGhpcy5oZWlnaHQgLSAxIC0geVxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBsaW5lICogdGhpcy53aWR0aCAqIDQgKyB4ICogNDtcbiAgICAgICAgICAgICAgICBpZiAoYiA8IHRoaXMucGFsZXR0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJnYiA9IHRoaXMucGFsZXR0ZVtiXTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSByZ2IuYmx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSByZ2IuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDNdID0gcmdiLnJlZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAxXSA9IDB4RkY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDJdID0gMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgM10gPSAweEZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlICE9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAoNCAtIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuQm1wRGVjb2Rlci5wcm90b3R5cGUuYml0MTUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRpZl93ID10aGlzLndpZHRoICUgMztcbiAgdmFyIF8xMTExMSA9IHBhcnNlSW50KFwiMTExMTFcIiwgMiksXzFfNSA9IF8xMTExMTtcbiAgZm9yICh2YXIgeSA9IHRoaXMuaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICB2YXIgbGluZSA9IHRoaXMuYm90dG9tX3VwID8geSA6IHRoaXMuaGVpZ2h0IC0gMSAtIHlcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuXG4gICAgICB2YXIgQiA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MTZMRSh0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcys9MjtcbiAgICAgIHZhciBibHVlID0gKEIgJiBfMV81KSAvIF8xXzUgKiAyNTUgfCAwO1xuICAgICAgdmFyIGdyZWVuID0gKEIgPj4gNSAmIF8xXzUgKSAvIF8xXzUgKiAyNTUgfCAwO1xuICAgICAgdmFyIHJlZCA9IChCID4+IDEwICYgXzFfNSkgLyBfMV81ICogMjU1IHwgMDtcbiAgICAgIHZhciBhbHBoYSA9IChCPj4xNSk/MHhGRjoweDAwO1xuXG4gICAgICB2YXIgbG9jYXRpb24gPSBsaW5lICogdGhpcy53aWR0aCAqIDQgKyB4ICogNDtcblxuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uXSA9IGFscGhhO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSBibHVlO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSBncmVlbjtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDNdID0gcmVkO1xuICAgIH1cbiAgICAvL3NraXAgZXh0cmEgYnl0ZXNcbiAgICB0aGlzLnBvcyArPSBkaWZfdztcbiAgfVxufTtcblxuQm1wRGVjb2Rlci5wcm90b3R5cGUuYml0MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRpZl93ID0odGhpcy53aWR0aCAlIDIpKjI7XG4gIC8vZGVmYXVsdCB4cmdiNTU1XG4gIHRoaXMubWFza1JlZCA9IDB4N0MwMDtcbiAgdGhpcy5tYXNrR3JlZW4gPSAweDNFMDtcbiAgdGhpcy5tYXNrQmx1ZSA9MHgxRjtcbiAgdGhpcy5tYXNrMCA9IDA7XG5cbiAgaWYodGhpcy5jb21wcmVzcyA9PSAzKXtcbiAgICB0aGlzLm1hc2tSZWQgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zKz00O1xuICAgIHRoaXMubWFza0dyZWVuID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcys9NDtcbiAgICB0aGlzLm1hc2tCbHVlID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcys9NDtcbiAgICB0aGlzLm1hc2swID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcys9NDtcbiAgfVxuXG5cbiAgdmFyIG5zPVswLDAsMF07XG4gIGZvciAodmFyIGk9MDtpPDE2O2krKyl7XG4gICAgaWYgKCh0aGlzLm1hc2tSZWQ+PmkpJjB4MDEpIG5zWzBdKys7XG4gICAgaWYgKCh0aGlzLm1hc2tHcmVlbj4+aSkmMHgwMSkgbnNbMV0rKztcbiAgICBpZiAoKHRoaXMubWFza0JsdWU+PmkpJjB4MDEpIG5zWzJdKys7XG4gIH1cbiAgbnNbMV0rPW5zWzBdOyBuc1syXSs9bnNbMV07XHRuc1swXT04LW5zWzBdOyBuc1sxXS09ODsgbnNbMl0tPTg7XG5cbiAgZm9yICh2YXIgeSA9IHRoaXMuaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICB2YXIgbGluZSA9IHRoaXMuYm90dG9tX3VwID8geSA6IHRoaXMuaGVpZ2h0IC0gMSAtIHk7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcblxuICAgICAgdmFyIEIgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDE2TEUodGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MrPTI7XG5cbiAgICAgIHZhciBibHVlID0gKEImdGhpcy5tYXNrQmx1ZSk8PG5zWzBdO1xuICAgICAgdmFyIGdyZWVuID0gKEImdGhpcy5tYXNrR3JlZW4pPj5uc1sxXTtcbiAgICAgIHZhciByZWQgPSAoQiZ0aGlzLm1hc2tSZWQpPj5uc1syXTtcblxuICAgICAgdmFyIGxvY2F0aW9uID0gbGluZSAqIHRoaXMud2lkdGggKiA0ICsgeCAqIDQ7XG5cbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbl0gPSAwO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSBibHVlO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSBncmVlbjtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDNdID0gcmVkO1xuICAgIH1cbiAgICAvL3NraXAgZXh0cmEgYnl0ZXNcbiAgICB0aGlzLnBvcyArPSBkaWZfdztcbiAgfVxufTtcblxuQm1wRGVjb2Rlci5wcm90b3R5cGUuYml0MjQgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgeSA9IHRoaXMuaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICB2YXIgbGluZSA9IHRoaXMuYm90dG9tX3VwID8geSA6IHRoaXMuaGVpZ2h0IC0gMSAtIHlcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgLy9MaXR0bGUgRW5kaWFuIHJnYlxuICAgICAgdmFyIGJsdWUgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICB2YXIgZ3JlZW4gPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICB2YXIgcmVkID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgdmFyIGxvY2F0aW9uID0gbGluZSAqIHRoaXMud2lkdGggKiA0ICsgeCAqIDQ7XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb25dID0gMDtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDFdID0gYmx1ZTtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDJdID0gZ3JlZW47XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAzXSA9IHJlZDtcbiAgICB9XG4gICAgLy9za2lwIGV4dHJhIGJ5dGVzXG4gICAgdGhpcy5wb3MgKz0gKHRoaXMud2lkdGggJSA0KTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIGFkZCAzMmJpdCBkZWNvZGUgZnVuY1xuICogQGF1dGhvciBzb3Vib2tcbiAqL1xuQm1wRGVjb2Rlci5wcm90b3R5cGUuYml0MzIgPSBmdW5jdGlvbigpIHtcbiAgLy9CSV9CSVRGSUVMRFNcbiAgaWYodGhpcy5jb21wcmVzcyA9PSAzKXtcbiAgICB0aGlzLm1hc2tSZWQgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zKz00O1xuICAgIHRoaXMubWFza0dyZWVuID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcys9NDtcbiAgICB0aGlzLm1hc2tCbHVlID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcys9NDtcbiAgICB0aGlzLm1hc2swID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcys9NDtcbiAgICAgIGZvciAodmFyIHkgPSB0aGlzLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmJvdHRvbV91cCA/IHkgOiB0aGlzLmhlaWdodCAtIDEgLSB5O1xuICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgIC8vTGl0dGxlIEVuZGlhbiByZ2JhXG4gICAgICAgICAgICAgIHZhciBhbHBoYSA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgICAgdmFyIGJsdWUgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICAgICAgICAgIHZhciBncmVlbiA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgICAgdmFyIHJlZCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gbGluZSAqIHRoaXMud2lkdGggKiA0ICsgeCAqIDQ7XG4gICAgICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbl0gPSBhbHBoYTtcbiAgICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSBibHVlO1xuICAgICAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAyXSA9IGdyZWVuO1xuICAgICAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAzXSA9IHJlZDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgfWVsc2V7XG4gICAgICBmb3IgKHZhciB5ID0gdGhpcy5oZWlnaHQgLSAxOyB5ID49IDA7IHktLSkge1xuICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5ib3R0b21fdXAgPyB5IDogdGhpcy5oZWlnaHQgLSAxIC0geTtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAvL0xpdHRsZSBFbmRpYW4gYXJnYlxuICAgICAgICAgICAgICB2YXIgYmx1ZSA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLnBvcysrKTtcbiAgICAgICAgICAgICAgdmFyIGdyZWVuID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgICAgICAgICB2YXIgcmVkID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMucG9zKyspO1xuICAgICAgICAgICAgICB2YXIgYWxwaGEgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5wb3MrKyk7XG4gICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGxpbmUgKiB0aGlzLndpZHRoICogNCArIHggKiA0O1xuICAgICAgICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb25dID0gYWxwaGE7XG4gICAgICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDFdID0gYmx1ZTtcbiAgICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSBncmVlbjtcbiAgICAgICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgM10gPSByZWQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cblxuXG5cblxufTtcblxuQm1wRGVjb2Rlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihibXBEYXRhKSB7XG4gIHZhciBkZWNvZGVyID0gbmV3IEJtcERlY29kZXIoYm1wRGF0YSk7XG4gIHJldHVybiBkZWNvZGVyO1xufTtcbiIsIi8qKlxuICogQGF1dGhvciBzaGFvemlsZWVcbiAqXG4gKiBCTVAgZm9ybWF0IGVuY29kZXIsZW5jb2RlIDI0Yml0IEJNUFxuICogTm90IHN1cHBvcnQgcXVhbGl0eSBjb21wcmVzc2lvblxuICpcbiAqL1xuXG5mdW5jdGlvbiBCbXBFbmNvZGVyKGltZ0RhdGEpe1xuXHR0aGlzLmJ1ZmZlciA9IGltZ0RhdGEuZGF0YTtcblx0dGhpcy53aWR0aCA9IGltZ0RhdGEud2lkdGg7XG5cdHRoaXMuaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG5cdHRoaXMuZXh0cmFCeXRlcyA9IHRoaXMud2lkdGglNDtcblx0dGhpcy5yZ2JTaXplID0gdGhpcy5oZWlnaHQqKDMqdGhpcy53aWR0aCt0aGlzLmV4dHJhQnl0ZXMpO1xuXHR0aGlzLmhlYWRlckluZm9TaXplID0gNDA7XG5cblx0dGhpcy5kYXRhID0gW107XG5cdC8qKioqKioqKioqKioqKioqKipoZWFkZXIqKioqKioqKioqKioqKioqKioqKioqKi9cblx0dGhpcy5mbGFnID0gXCJCTVwiO1xuXHR0aGlzLnJlc2VydmVkID0gMDtcblx0dGhpcy5vZmZzZXQgPSA1NDtcblx0dGhpcy5maWxlU2l6ZSA9IHRoaXMucmdiU2l6ZSt0aGlzLm9mZnNldDtcblx0dGhpcy5wbGFuZXMgPSAxO1xuXHR0aGlzLmJpdFBQID0gMjQ7XG5cdHRoaXMuY29tcHJlc3MgPSAwO1xuXHR0aGlzLmhyID0gMDtcblx0dGhpcy52ciA9IDA7XG5cdHRoaXMuY29sb3JzID0gMDtcblx0dGhpcy5pbXBvcnRhbnRDb2xvcnMgPSAwO1xufVxuXG5CbXBFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRlbXBCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMub2Zmc2V0K3RoaXMucmdiU2l6ZSk7XG5cdHRoaXMucG9zID0gMDtcblx0dGVtcEJ1ZmZlci53cml0ZSh0aGlzLmZsYWcsdGhpcy5wb3MsMik7dGhpcy5wb3MrPTI7XG5cdHRlbXBCdWZmZXIud3JpdGVVSW50MzJMRSh0aGlzLmZpbGVTaXplLHRoaXMucG9zKTt0aGlzLnBvcys9NDtcblx0dGVtcEJ1ZmZlci53cml0ZVVJbnQzMkxFKHRoaXMucmVzZXJ2ZWQsdGhpcy5wb3MpO3RoaXMucG9zKz00O1xuXHR0ZW1wQnVmZmVyLndyaXRlVUludDMyTEUodGhpcy5vZmZzZXQsdGhpcy5wb3MpO3RoaXMucG9zKz00O1xuXG5cdHRlbXBCdWZmZXIud3JpdGVVSW50MzJMRSh0aGlzLmhlYWRlckluZm9TaXplLHRoaXMucG9zKTt0aGlzLnBvcys9NDtcblx0dGVtcEJ1ZmZlci53cml0ZVVJbnQzMkxFKHRoaXMud2lkdGgsdGhpcy5wb3MpO3RoaXMucG9zKz00O1xuXHR0ZW1wQnVmZmVyLndyaXRlSW50MzJMRSgtdGhpcy5oZWlnaHQsdGhpcy5wb3MpO3RoaXMucG9zKz00O1xuXHR0ZW1wQnVmZmVyLndyaXRlVUludDE2TEUodGhpcy5wbGFuZXMsdGhpcy5wb3MpO3RoaXMucG9zKz0yO1xuXHR0ZW1wQnVmZmVyLndyaXRlVUludDE2TEUodGhpcy5iaXRQUCx0aGlzLnBvcyk7dGhpcy5wb3MrPTI7XG5cdHRlbXBCdWZmZXIud3JpdGVVSW50MzJMRSh0aGlzLmNvbXByZXNzLHRoaXMucG9zKTt0aGlzLnBvcys9NDtcblx0dGVtcEJ1ZmZlci53cml0ZVVJbnQzMkxFKHRoaXMucmdiU2l6ZSx0aGlzLnBvcyk7dGhpcy5wb3MrPTQ7XG5cdHRlbXBCdWZmZXIud3JpdGVVSW50MzJMRSh0aGlzLmhyLHRoaXMucG9zKTt0aGlzLnBvcys9NDtcblx0dGVtcEJ1ZmZlci53cml0ZVVJbnQzMkxFKHRoaXMudnIsdGhpcy5wb3MpO3RoaXMucG9zKz00O1xuXHR0ZW1wQnVmZmVyLndyaXRlVUludDMyTEUodGhpcy5jb2xvcnMsdGhpcy5wb3MpO3RoaXMucG9zKz00O1xuXHR0ZW1wQnVmZmVyLndyaXRlVUludDMyTEUodGhpcy5pbXBvcnRhbnRDb2xvcnMsdGhpcy5wb3MpO3RoaXMucG9zKz00O1xuXG5cdHZhciBpPTA7XG5cdHZhciByb3dCeXRlcyA9IDMqdGhpcy53aWR0aCt0aGlzLmV4dHJhQnl0ZXM7XG5cblx0Zm9yICh2YXIgeSA9IDA7IHkgPHRoaXMuaGVpZ2h0OyB5Kyspe1xuXHRcdGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKXtcblx0XHRcdHZhciBwID0gdGhpcy5wb3MreSpyb3dCeXRlcyt4KjM7XG5cdFx0XHRpKys7Ly9hXG5cdFx0XHR0ZW1wQnVmZmVyW3BdPSB0aGlzLmJ1ZmZlcltpKytdOy8vYlxuXHRcdFx0dGVtcEJ1ZmZlcltwKzFdID0gdGhpcy5idWZmZXJbaSsrXTsvL2dcblx0XHRcdHRlbXBCdWZmZXJbcCsyXSAgPSB0aGlzLmJ1ZmZlcltpKytdOy8vclxuXHRcdH1cblx0XHRpZih0aGlzLmV4dHJhQnl0ZXM+MCl7XG5cdFx0XHR2YXIgZmlsbE9mZnNldCA9IHRoaXMucG9zK3kqcm93Qnl0ZXMrdGhpcy53aWR0aCozO1xuXHRcdFx0dGVtcEJ1ZmZlci5maWxsKDAsZmlsbE9mZnNldCxmaWxsT2Zmc2V0K3RoaXMuZXh0cmFCeXRlcyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRlbXBCdWZmZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGltZ0RhdGEsIHF1YWxpdHkpIHtcbiAgaWYgKHR5cGVvZiBxdWFsaXR5ID09PSAndW5kZWZpbmVkJykgcXVhbGl0eSA9IDEwMDtcbiBcdHZhciBlbmNvZGVyID0gbmV3IEJtcEVuY29kZXIoaW1nRGF0YSk7XG5cdHZhciBkYXRhID0gZW5jb2Rlci5lbmNvZGUoKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHdpZHRoOiBpbWdEYXRhLndpZHRoLFxuICAgIGhlaWdodDogaW1nRGF0YS5oZWlnaHRcbiAgfTtcbn07XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyOyAvLyBmb3IgdXNlIHdpdGggYnJvd3NlcmlmeVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGEuZXF1YWxzKGIpO1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG59O1xuIiwidmFyIFBhcnNlciA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcicpO1xuXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG5cdHJldHVybiAoMSxldmFsKSgndGhpcycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlOiBmdW5jdGlvbihidWZmZXIsIGdsb2JhbCkge1xuXHRcdGdsb2JhbCA9IGdsb2JhbCB8fCBnZXRHbG9iYWwoKTtcblx0XHRpZihidWZmZXIgaW5zdGFuY2VvZiBnbG9iYWwuQXJyYXlCdWZmZXIpIHtcblx0XHRcdHZhciBET01CdWZmZXJTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9kb20tYnVmZmVyc3RyZWFtJyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBhcnNlcihuZXcgRE9NQnVmZmVyU3RyZWFtKGJ1ZmZlciwgMCwgYnVmZmVyLmJ5dGVMZW5ndGgsIHRydWUsIGdsb2JhbCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgTm9kZUJ1ZmZlclN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL2J1ZmZlcnN0cmVhbScpO1xuXHRcdFx0cmV0dXJuIG5ldyBQYXJzZXIobmV3IE5vZGVCdWZmZXJTdHJlYW0oYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCB0cnVlKSk7XG5cdFx0fVxuXHR9XG59O1xuIiwiZnVuY3Rpb24gQnVmZmVyU3RyZWFtKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIGJpZ0VuZGlhbikge1xuXHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0dGhpcy5vZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0bGVuZ3RoID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBsZW5ndGggOiBidWZmZXIubGVuZ3RoO1xuXHR0aGlzLmVuZFBvc2l0aW9uID0gdGhpcy5vZmZzZXQgKyBsZW5ndGg7XG5cdHRoaXMuc2V0QmlnRW5kaWFuKGJpZ0VuZGlhbik7XG59XG5cbkJ1ZmZlclN0cmVhbS5wcm90b3R5cGUgPSB7XG5cdHNldEJpZ0VuZGlhbjogZnVuY3Rpb24oYmlnRW5kaWFuKSB7XG5cdFx0dGhpcy5iaWdFbmRpYW4gPSAhIWJpZ0VuZGlhbjtcblx0fSxcblx0bmV4dFVJbnQ4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDE7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0SW50ODogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy5idWZmZXIucmVhZEludDgodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDE7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0VUludDE2OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmJpZ0VuZGlhbiA/IHRoaXMuYnVmZmVyLnJlYWRVSW50MTZCRSh0aGlzLm9mZnNldCkgOiB0aGlzLmJ1ZmZlci5yZWFkVUludDE2TEUodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0VUludDMyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmJpZ0VuZGlhbiA/IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJCRSh0aGlzLm9mZnNldCkgOiB0aGlzLmJ1ZmZlci5yZWFkVUludDMyTEUodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDQ7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0SW50MTY6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMuYmlnRW5kaWFuID8gdGhpcy5idWZmZXIucmVhZEludDE2QkUodGhpcy5vZmZzZXQpIDogdGhpcy5idWZmZXIucmVhZEludDE2TEUodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0SW50MzI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMuYmlnRW5kaWFuID8gdGhpcy5idWZmZXIucmVhZEludDMyQkUodGhpcy5vZmZzZXQpIDogdGhpcy5idWZmZXIucmVhZEludDMyTEUodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDQ7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0RmxvYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMuYmlnRW5kaWFuID8gdGhpcy5idWZmZXIucmVhZEZsb2F0QkUodGhpcy5vZmZzZXQpIDogdGhpcy5idWZmZXIucmVhZEZsb2F0TEUodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDQ7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0RG91YmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmJpZ0VuZGlhbiA/IHRoaXMuYnVmZmVyLnJlYWREb3VibGVCRSh0aGlzLm9mZnNldCkgOiB0aGlzLmJ1ZmZlci5yZWFkRG91YmxlTEUodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0QnVmZmVyOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHJlbWFpbmluZ0xlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW5kUG9zaXRpb24gLSB0aGlzLm9mZnNldDtcblx0fSxcblx0bmV4dFN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy5idWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdG1hcms6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRyZXR1cm4ge1xuXHRcdFx0b3BlbldpdGhPZmZzZXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0XHRvZmZzZXQgPSAob2Zmc2V0IHx8IDApICsgdGhpcy5vZmZzZXQ7XG5cdFx0XHRcdHJldHVybiBuZXcgQnVmZmVyU3RyZWFtKHNlbGYuYnVmZmVyLCBvZmZzZXQsIHNlbGYuZW5kUG9zaXRpb24gLSBvZmZzZXQsIHNlbGYuYmlnRW5kaWFuKTtcblx0XHRcdH0sXG5cdFx0XHRvZmZzZXQ6IHRoaXMub2Zmc2V0XG5cdFx0fTtcblx0fSxcblx0b2Zmc2V0RnJvbTogZnVuY3Rpb24obWFya2VyKSB7XG5cdFx0cmV0dXJuIHRoaXMub2Zmc2V0IC0gbWFya2VyLm9mZnNldDtcblx0fSxcblx0c2tpcDogZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0dGhpcy5vZmZzZXQgKz0gYW1vdW50O1xuXHR9LFxuXHRicmFuY2g6IGZ1bmN0aW9uKG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0bGVuZ3RoID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBsZW5ndGggOiB0aGlzLmVuZFBvc2l0aW9uIC0gKHRoaXMub2Zmc2V0ICsgb2Zmc2V0KTtcblx0XHRyZXR1cm4gbmV3IEJ1ZmZlclN0cmVhbSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCwgdGhpcy5iaWdFbmRpYW4pO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclN0cmVhbTtcbiIsImZ1bmN0aW9uIHBhcnNlTnVtYmVyKHMpIHtcblx0cmV0dXJuIHBhcnNlSW50KHMsIDEwKTtcbn1cblxuLy9pbiBzZWNvbmRzXG52YXIgaG91cnMgPSAzNjAwO1xudmFyIG1pbnV0ZXMgPSA2MDtcblxuLy90YWtlIGRhdGUgKHllYXIsIG1vbnRoLCBkYXkpIGFuZCB0aW1lIChob3VyLCBtaW51dGVzLCBzZWNvbmRzKSBkaWdpdHMgaW4gVVRDXG4vL2FuZCByZXR1cm4gYSB0aW1lc3RhbXAgaW4gc2Vjb25kc1xuZnVuY3Rpb24gcGFyc2VEYXRlVGltZVBhcnRzKGRhdGVQYXJ0cywgdGltZVBhcnRzKSB7XG5cdGRhdGVQYXJ0cyA9IGRhdGVQYXJ0cy5tYXAocGFyc2VOdW1iZXIpO1xuXHR0aW1lUGFydHMgPSB0aW1lUGFydHMubWFwKHBhcnNlTnVtYmVyKTtcblx0dmFyIHllYXIgPSBkYXRlUGFydHNbMF07XG5cdHZhciBtb250aCA9IGRhdGVQYXJ0c1sxXSAtIDE7XG5cdHZhciBkYXkgPSBkYXRlUGFydHNbMl07XG5cdHZhciBob3VycyA9IHRpbWVQYXJ0c1swXTtcblx0dmFyIG1pbnV0ZXMgPSB0aW1lUGFydHNbMV07XG5cdHZhciBzZWNvbmRzID0gdGltZVBhcnRzWzJdO1xuXHR2YXIgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCAwKTtcblx0dmFyIHRpbWVzdGFtcCA9IGRhdGUgLyAxMDAwO1xuXHRyZXR1cm4gdGltZXN0YW1wO1xufVxuXG4vL3BhcnNlIGRhdGUgd2l0aCBcIjIwMDQtMDktMDRUMjM6Mzk6MDYtMDg6MDBcIiBmb3JtYXQsXG4vL29uZSBvZiB0aGUgZm9ybWF0cyBzdXBwb3J0ZWQgYnkgSVNPIDg2MDEsIGFuZFxuLy9jb252ZXJ0IHRvIHV0YyB0aW1lc3RhbXAgaW4gc2Vjb25kc1xuZnVuY3Rpb24gcGFyc2VEYXRlV2l0aFRpbWV6b25lRm9ybWF0KGRhdGVUaW1lU3RyKSB7XG5cblx0dmFyIGRhdGVQYXJ0cyA9IGRhdGVUaW1lU3RyLnN1YnN0cigwLCAxMCkuc3BsaXQoJy0nKTtcblx0dmFyIHRpbWVQYXJ0cyA9IGRhdGVUaW1lU3RyLnN1YnN0cigxMSwgOCkuc3BsaXQoJzonKTtcblx0dmFyIHRpbWV6b25lU3RyID0gZGF0ZVRpbWVTdHIuc3Vic3RyKDE5LCA2KTtcblx0dmFyIHRpbWV6b25lUGFydHMgPSB0aW1lem9uZVN0ci5zcGxpdCgnOicpLm1hcChwYXJzZU51bWJlcik7XG5cdHZhciB0aW1lem9uZU9mZnNldCA9ICh0aW1lem9uZVBhcnRzWzBdICogaG91cnMpICtcblx0XHQodGltZXpvbmVQYXJ0c1sxXSAqIG1pbnV0ZXMpO1xuXG5cdHZhciB0aW1lc3RhbXAgPSBwYXJzZURhdGVUaW1lUGFydHMoZGF0ZVBhcnRzLCB0aW1lUGFydHMpO1xuXHQvL21pbnVzIGJlY2F1c2UgdGhlIHRpbWV6b25lT2Zmc2V0IGRlc2NyaWJlc1xuXHQvL2hvdyBtdWNoIHRoZSBkZXNjcmliZWQgdGltZSBpcyBhaGVhZCBvZiBVVENcblx0dGltZXN0YW1wIC09IHRpbWV6b25lT2Zmc2V0O1xuXG5cdGlmKHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInICYmICFpc05hTih0aW1lc3RhbXApKSB7XG5cdFx0cmV0dXJuIHRpbWVzdGFtcDtcblx0fVxufVxuXG4vL3BhcnNlIGRhdGUgd2l0aCBcIllZWVk6TU06REQgaGg6bW06c3NcIiBmb3JtYXQsIGNvbnZlcnQgdG8gdXRjIHRpbWVzdGFtcCBpbiBzZWNvbmRzXG5mdW5jdGlvbiBwYXJzZURhdGVXaXRoU3BlY0Zvcm1hdChkYXRlVGltZVN0cikge1xuXHR2YXIgcGFydHMgPSBkYXRlVGltZVN0ci5zcGxpdCgnICcpLFxuXHRcdGRhdGVQYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCc6JyksXG5cdFx0dGltZVBhcnRzID0gcGFydHNbMV0uc3BsaXQoJzonKTtcblxuXHR2YXIgdGltZXN0YW1wID0gcGFyc2VEYXRlVGltZVBhcnRzKGRhdGVQYXJ0cywgdGltZVBhcnRzKTtcblxuXHRpZih0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odGltZXN0YW1wKSkge1xuXHRcdHJldHVybiB0aW1lc3RhbXA7XG5cdH1cbn1cblxuZnVuY3Rpb24gcGFyc2VFeGlmRGF0ZShkYXRlVGltZVN0cikge1xuXHQvL3NvbWUgZWFzeSBjaGVja3MgdG8gZGV0ZXJtaW5lIHR3byBjb21tb24gZGF0ZSBmb3JtYXRzXG5cblx0Ly9pcyB0aGUgZGF0ZSBpbiB0aGUgc3RhbmRhcmQgXCJZWVlZOk1NOkREIGhoOm1tOnNzXCIgZm9ybWF0P1xuXHR2YXIgaXNTcGVjRm9ybWF0ID0gZGF0ZVRpbWVTdHIubGVuZ3RoID09PSAxOSAmJlxuXHRcdGRhdGVUaW1lU3RyLmNoYXJBdCg0KSA9PT0gJzonO1xuXHQvL2lzIHRoZSBkYXRlIGluIHRoZSBub24tc3RhbmRhcmQgZm9ybWF0LFxuXHQvL1wiMjAwNC0wOS0wNFQyMzozOTowNi0wODowMFwiIHRvIGluY2x1ZGUgYSB0aW1lem9uZT9cblx0dmFyIGlzVGltZXpvbmVGb3JtYXQgPSBkYXRlVGltZVN0ci5sZW5ndGggPT09IDI1ICYmXG5cdFx0ZGF0ZVRpbWVTdHIuY2hhckF0KDEwKSA9PT0gJ1QnO1xuXHR2YXIgdGltZXN0YW1wO1xuXG5cdGlmKGlzVGltZXpvbmVGb3JtYXQpIHtcblx0XHRyZXR1cm4gcGFyc2VEYXRlV2l0aFRpbWV6b25lRm9ybWF0KGRhdGVUaW1lU3RyKTtcblx0fVxuXHRlbHNlIGlmKGlzU3BlY0Zvcm1hdCkge1xuXHRcdHJldHVybiBwYXJzZURhdGVXaXRoU3BlY0Zvcm1hdChkYXRlVGltZVN0cik7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHBhcnNlRGF0ZVdpdGhTcGVjRm9ybWF0OiBwYXJzZURhdGVXaXRoU3BlY0Zvcm1hdCxcblx0cGFyc2VEYXRlV2l0aFRpbWV6b25lRm9ybWF0OiBwYXJzZURhdGVXaXRoVGltZXpvbmVGb3JtYXQsXG5cdHBhcnNlRXhpZkRhdGU6IHBhcnNlRXhpZkRhdGVcbn07XG4iLCIvKmpzbGludCBicm93c2VyOiB0cnVlLCBkZXZlbDogdHJ1ZSwgYml0d2lzZTogZmFsc2UsIGRlYnVnOiB0cnVlLCBlcWVxOiBmYWxzZSwgZXM1OiB0cnVlLCBldmlsOiBmYWxzZSwgZm9yaW46IGZhbHNlLCBuZXdjYXA6IGZhbHNlLCBub21lbjogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIHJlZ2V4cDogZmFsc2UsIHVucGFyYW06IGZhbHNlLCBzbG9wcHk6IHRydWUsIHN0dXBpZDogZmFsc2UsIHN1YjogZmFsc2UsIHRvZG86IHRydWUsIHZhcnM6IHRydWUsIHdoaXRlOiB0cnVlICovXG5cbmZ1bmN0aW9uIERPTUJ1ZmZlclN0cmVhbShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIGJpZ0VuZGlhbiwgZ2xvYmFsLCBwYXJlbnRPZmZzZXQpIHtcblx0dGhpcy5nbG9iYWwgPSBnbG9iYWw7XG5cdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRsZW5ndGggPSBsZW5ndGggfHwgKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBvZmZzZXQpO1xuXHR0aGlzLmFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuXHR0aGlzLnZpZXcgPSBuZXcgZ2xvYmFsLkRhdGFWaWV3KHRoaXMuYXJyYXlCdWZmZXIsIDAsIHRoaXMuYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG5cdHRoaXMuc2V0QmlnRW5kaWFuKGJpZ0VuZGlhbik7XG5cdHRoaXMub2Zmc2V0ID0gMDtcblx0dGhpcy5wYXJlbnRPZmZzZXQgPSAocGFyZW50T2Zmc2V0IHx8IDApICsgb2Zmc2V0O1xufVxuXG5ET01CdWZmZXJTdHJlYW0ucHJvdG90eXBlID0ge1xuXHRzZXRCaWdFbmRpYW46IGZ1bmN0aW9uKGJpZ0VuZGlhbikge1xuXHRcdHRoaXMubGl0dGxlRW5kaWFuID0gIWJpZ0VuZGlhbjtcblx0fSxcblx0bmV4dFVJbnQ4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDE7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0SW50ODogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDE7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0VUludDE2OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdG5leHRVSW50MzI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuKTtcblx0XHR0aGlzLm9mZnNldCArPSA0O1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0bmV4dEludDE2OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuKTtcblx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0bmV4dEludDMyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuKTtcblx0XHR0aGlzLm9mZnNldCArPSA0O1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0bmV4dEZsb2F0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDQ7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0RG91YmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRuZXh0QnVmZmVyOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHQvL3RoaXMgd29uJ3Qgd29yayBpbiBJRTEwXG5cdFx0dmFyIHZhbHVlID0gdGhpcy5hcnJheUJ1ZmZlci5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHJlbWFpbmluZ0xlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAtIHRoaXMub2Zmc2V0O1xuXHR9LFxuXHRuZXh0U3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGxlbmd0aCk7XG5cdFx0dmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyB0aGlzLmdsb2JhbC5VaW50OEFycmF5KHZhbHVlKSk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0bWFyazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHJldHVybiB7XG5cdFx0XHRvcGVuV2l0aE9mZnNldDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdG9mZnNldCA9IChvZmZzZXQgfHwgMCkgKyB0aGlzLm9mZnNldDtcblx0XHRcdFx0cmV0dXJuIG5ldyBET01CdWZmZXJTdHJlYW0oc2VsZi5hcnJheUJ1ZmZlciwgb2Zmc2V0LCBzZWxmLmFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBvZmZzZXQsICFzZWxmLmxpdHRsZUVuZGlhbiwgc2VsZi5nbG9iYWwsIHNlbGYucGFyZW50T2Zmc2V0KTtcblx0XHRcdH0sXG5cdFx0XHRvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuXHRcdFx0Z2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYucGFyZW50T2Zmc2V0O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cdG9mZnNldEZyb206IGZ1bmN0aW9uKG1hcmtlcikge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudE9mZnNldCArIHRoaXMub2Zmc2V0IC0gKG1hcmtlci5vZmZzZXQgKyBtYXJrZXIuZ2V0UGFyZW50T2Zmc2V0KCkpO1xuXHR9LFxuXHRza2lwOiBmdW5jdGlvbihhbW91bnQpIHtcblx0XHR0aGlzLm9mZnNldCArPSBhbW91bnQ7XG5cdH0sXG5cdGJyYW5jaDogZnVuY3Rpb24ob2Zmc2V0LCBsZW5ndGgpIHtcblx0XHRsZW5ndGggPSB0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyA/IGxlbmd0aCA6IHRoaXMuYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAtICh0aGlzLm9mZnNldCArIG9mZnNldCk7XG5cdFx0cmV0dXJuIG5ldyBET01CdWZmZXJTdHJlYW0odGhpcy5hcnJheUJ1ZmZlciwgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCwgIXRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLmdsb2JhbCwgdGhpcy5wYXJlbnRPZmZzZXQpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUJ1ZmZlclN0cmVhbTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRleGlmIDoge1xuXHRcdDB4MDAwMSA6IFwiSW50ZXJvcEluZGV4XCIsXG5cdFx0MHgwMDAyIDogXCJJbnRlcm9wVmVyc2lvblwiLFxuXHRcdDB4MDAwQiA6IFwiUHJvY2Vzc2luZ1NvZnR3YXJlXCIsXG5cdFx0MHgwMEZFIDogXCJTdWJmaWxlVHlwZVwiLFxuXHRcdDB4MDBGRiA6IFwiT2xkU3ViZmlsZVR5cGVcIixcblx0XHQweDAxMDAgOiBcIkltYWdlV2lkdGhcIixcblx0XHQweDAxMDEgOiBcIkltYWdlSGVpZ2h0XCIsXG5cdFx0MHgwMTAyIDogXCJCaXRzUGVyU2FtcGxlXCIsXG5cdFx0MHgwMTAzIDogXCJDb21wcmVzc2lvblwiLFxuXHRcdDB4MDEwNiA6IFwiUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvblwiLFxuXHRcdDB4MDEwNyA6IFwiVGhyZXNob2xkaW5nXCIsXG5cdFx0MHgwMTA4IDogXCJDZWxsV2lkdGhcIixcblx0XHQweDAxMDkgOiBcIkNlbGxMZW5ndGhcIixcblx0XHQweDAxMEEgOiBcIkZpbGxPcmRlclwiLFxuXHRcdDB4MDEwRCA6IFwiRG9jdW1lbnROYW1lXCIsXG5cdFx0MHgwMTBFIDogXCJJbWFnZURlc2NyaXB0aW9uXCIsXG5cdFx0MHgwMTBGIDogXCJNYWtlXCIsXG5cdFx0MHgwMTEwIDogXCJNb2RlbFwiLFxuXHRcdDB4MDExMSA6IFwiU3RyaXBPZmZzZXRzXCIsXG5cdFx0MHgwMTEyIDogXCJPcmllbnRhdGlvblwiLFxuXHRcdDB4MDExNSA6IFwiU2FtcGxlc1BlclBpeGVsXCIsXG5cdFx0MHgwMTE2IDogXCJSb3dzUGVyU3RyaXBcIixcblx0XHQweDAxMTcgOiBcIlN0cmlwQnl0ZUNvdW50c1wiLFxuXHRcdDB4MDExOCA6IFwiTWluU2FtcGxlVmFsdWVcIixcblx0XHQweDAxMTkgOiBcIk1heFNhbXBsZVZhbHVlXCIsXG5cdFx0MHgwMTFBIDogXCJYUmVzb2x1dGlvblwiLFxuXHRcdDB4MDExQiA6IFwiWVJlc29sdXRpb25cIixcblx0XHQweDAxMUMgOiBcIlBsYW5hckNvbmZpZ3VyYXRpb25cIixcblx0XHQweDAxMUQgOiBcIlBhZ2VOYW1lXCIsXG5cdFx0MHgwMTFFIDogXCJYUG9zaXRpb25cIixcblx0XHQweDAxMUYgOiBcIllQb3NpdGlvblwiLFxuXHRcdDB4MDEyMCA6IFwiRnJlZU9mZnNldHNcIixcblx0XHQweDAxMjEgOiBcIkZyZWVCeXRlQ291bnRzXCIsXG5cdFx0MHgwMTIyIDogXCJHcmF5UmVzcG9uc2VVbml0XCIsXG5cdFx0MHgwMTIzIDogXCJHcmF5UmVzcG9uc2VDdXJ2ZVwiLFxuXHRcdDB4MDEyNCA6IFwiVDRPcHRpb25zXCIsXG5cdFx0MHgwMTI1IDogXCJUNk9wdGlvbnNcIixcblx0XHQweDAxMjggOiBcIlJlc29sdXRpb25Vbml0XCIsXG5cdFx0MHgwMTI5IDogXCJQYWdlTnVtYmVyXCIsXG5cdFx0MHgwMTJDIDogXCJDb2xvclJlc3BvbnNlVW5pdFwiLFxuXHRcdDB4MDEyRCA6IFwiVHJhbnNmZXJGdW5jdGlvblwiLFxuXHRcdDB4MDEzMSA6IFwiU29mdHdhcmVcIixcblx0XHQweDAxMzIgOiBcIk1vZGlmeURhdGVcIixcblx0XHQweDAxM0IgOiBcIkFydGlzdFwiLFxuXHRcdDB4MDEzQyA6IFwiSG9zdENvbXB1dGVyXCIsXG5cdFx0MHgwMTNEIDogXCJQcmVkaWN0b3JcIixcblx0XHQweDAxM0UgOiBcIldoaXRlUG9pbnRcIixcblx0XHQweDAxM0YgOiBcIlByaW1hcnlDaHJvbWF0aWNpdGllc1wiLFxuXHRcdDB4MDE0MCA6IFwiQ29sb3JNYXBcIixcblx0XHQweDAxNDEgOiBcIkhhbGZ0b25lSGludHNcIixcblx0XHQweDAxNDIgOiBcIlRpbGVXaWR0aFwiLFxuXHRcdDB4MDE0MyA6IFwiVGlsZUxlbmd0aFwiLFxuXHRcdDB4MDE0NCA6IFwiVGlsZU9mZnNldHNcIixcblx0XHQweDAxNDUgOiBcIlRpbGVCeXRlQ291bnRzXCIsXG5cdFx0MHgwMTQ2IDogXCJCYWRGYXhMaW5lc1wiLFxuXHRcdDB4MDE0NyA6IFwiQ2xlYW5GYXhEYXRhXCIsXG5cdFx0MHgwMTQ4IDogXCJDb25zZWN1dGl2ZUJhZEZheExpbmVzXCIsXG5cdFx0MHgwMTRBIDogXCJTdWJJRkRcIixcblx0XHQweDAxNEMgOiBcIklua1NldFwiLFxuXHRcdDB4MDE0RCA6IFwiSW5rTmFtZXNcIixcblx0XHQweDAxNEUgOiBcIk51bWJlcm9mSW5rc1wiLFxuXHRcdDB4MDE1MCA6IFwiRG90UmFuZ2VcIixcblx0XHQweDAxNTEgOiBcIlRhcmdldFByaW50ZXJcIixcblx0XHQweDAxNTIgOiBcIkV4dHJhU2FtcGxlc1wiLFxuXHRcdDB4MDE1MyA6IFwiU2FtcGxlRm9ybWF0XCIsXG5cdFx0MHgwMTU0IDogXCJTTWluU2FtcGxlVmFsdWVcIixcblx0XHQweDAxNTUgOiBcIlNNYXhTYW1wbGVWYWx1ZVwiLFxuXHRcdDB4MDE1NiA6IFwiVHJhbnNmZXJSYW5nZVwiLFxuXHRcdDB4MDE1NyA6IFwiQ2xpcFBhdGhcIixcblx0XHQweDAxNTggOiBcIlhDbGlwUGF0aFVuaXRzXCIsXG5cdFx0MHgwMTU5IDogXCJZQ2xpcFBhdGhVbml0c1wiLFxuXHRcdDB4MDE1QSA6IFwiSW5kZXhlZFwiLFxuXHRcdDB4MDE1QiA6IFwiSlBFR1RhYmxlc1wiLFxuXHRcdDB4MDE1RiA6IFwiT1BJUHJveHlcIixcblx0XHQweDAxOTAgOiBcIkdsb2JhbFBhcmFtZXRlcnNJRkRcIixcblx0XHQweDAxOTEgOiBcIlByb2ZpbGVUeXBlXCIsXG5cdFx0MHgwMTkyIDogXCJGYXhQcm9maWxlXCIsXG5cdFx0MHgwMTkzIDogXCJDb2RpbmdNZXRob2RzXCIsXG5cdFx0MHgwMTk0IDogXCJWZXJzaW9uWWVhclwiLFxuXHRcdDB4MDE5NSA6IFwiTW9kZU51bWJlclwiLFxuXHRcdDB4MDFCMSA6IFwiRGVjb2RlXCIsXG5cdFx0MHgwMUIyIDogXCJEZWZhdWx0SW1hZ2VDb2xvclwiLFxuXHRcdDB4MDFCMyA6IFwiVDgyT3B0aW9uc1wiLFxuXHRcdDB4MDFCNSA6IFwiSlBFR1RhYmxlc1wiLFxuXHRcdDB4MDIwMCA6IFwiSlBFR1Byb2NcIixcblx0XHQweDAyMDEgOiBcIlRodW1ibmFpbE9mZnNldFwiLFxuXHRcdDB4MDIwMiA6IFwiVGh1bWJuYWlsTGVuZ3RoXCIsXG5cdFx0MHgwMjAzIDogXCJKUEVHUmVzdGFydEludGVydmFsXCIsXG5cdFx0MHgwMjA1IDogXCJKUEVHTG9zc2xlc3NQcmVkaWN0b3JzXCIsXG5cdFx0MHgwMjA2IDogXCJKUEVHUG9pbnRUcmFuc2Zvcm1zXCIsXG5cdFx0MHgwMjA3IDogXCJKUEVHUVRhYmxlc1wiLFxuXHRcdDB4MDIwOCA6IFwiSlBFR0RDVGFibGVzXCIsXG5cdFx0MHgwMjA5IDogXCJKUEVHQUNUYWJsZXNcIixcblx0XHQweDAyMTEgOiBcIllDYkNyQ29lZmZpY2llbnRzXCIsXG5cdFx0MHgwMjEyIDogXCJZQ2JDclN1YlNhbXBsaW5nXCIsXG5cdFx0MHgwMjEzIDogXCJZQ2JDclBvc2l0aW9uaW5nXCIsXG5cdFx0MHgwMjE0IDogXCJSZWZlcmVuY2VCbGFja1doaXRlXCIsXG5cdFx0MHgwMjJGIDogXCJTdHJpcFJvd0NvdW50c1wiLFxuXHRcdDB4MDJCQyA6IFwiQXBwbGljYXRpb25Ob3Rlc1wiLFxuXHRcdDB4MDNFNyA6IFwiVVNQVE9NaXNjZWxsYW5lb3VzXCIsXG5cdFx0MHgxMDAwIDogXCJSZWxhdGVkSW1hZ2VGaWxlRm9ybWF0XCIsXG5cdFx0MHgxMDAxIDogXCJSZWxhdGVkSW1hZ2VXaWR0aFwiLFxuXHRcdDB4MTAwMiA6IFwiUmVsYXRlZEltYWdlSGVpZ2h0XCIsXG5cdFx0MHg0NzQ2IDogXCJSYXRpbmdcIixcblx0XHQweDQ3NDcgOiBcIlhQX0RJUF9YTUxcIixcblx0XHQweDQ3NDggOiBcIlN0aXRjaEluZm9cIixcblx0XHQweDQ3NDkgOiBcIlJhdGluZ1BlcmNlbnRcIixcblx0XHQweDgwMEQgOiBcIkltYWdlSURcIixcblx0XHQweDgwQTMgOiBcIldhbmdUYWcxXCIsXG5cdFx0MHg4MEE0IDogXCJXYW5nQW5ub3RhdGlvblwiLFxuXHRcdDB4ODBBNSA6IFwiV2FuZ1RhZzNcIixcblx0XHQweDgwQTYgOiBcIldhbmdUYWc0XCIsXG5cdFx0MHg4MEUzIDogXCJNYXR0ZWluZ1wiLFxuXHRcdDB4ODBFNCA6IFwiRGF0YVR5cGVcIixcblx0XHQweDgwRTUgOiBcIkltYWdlRGVwdGhcIixcblx0XHQweDgwRTYgOiBcIlRpbGVEZXB0aFwiLFxuXHRcdDB4ODI3RCA6IFwiTW9kZWwyXCIsXG5cdFx0MHg4MjhEIDogXCJDRkFSZXBlYXRQYXR0ZXJuRGltXCIsXG5cdFx0MHg4MjhFIDogXCJDRkFQYXR0ZXJuMlwiLFxuXHRcdDB4ODI4RiA6IFwiQmF0dGVyeUxldmVsXCIsXG5cdFx0MHg4MjkwIDogXCJLb2Rha0lGRFwiLFxuXHRcdDB4ODI5OCA6IFwiQ29weXJpZ2h0XCIsXG5cdFx0MHg4MjlBIDogXCJFeHBvc3VyZVRpbWVcIixcblx0XHQweDgyOUQgOiBcIkZOdW1iZXJcIixcblx0XHQweDgyQTUgOiBcIk1ERmlsZVRhZ1wiLFxuXHRcdDB4ODJBNiA6IFwiTURTY2FsZVBpeGVsXCIsXG5cdFx0MHg4MkE3IDogXCJNRENvbG9yVGFibGVcIixcblx0XHQweDgyQTggOiBcIk1ETGFiTmFtZVwiLFxuXHRcdDB4ODJBOSA6IFwiTURTYW1wbGVJbmZvXCIsXG5cdFx0MHg4MkFBIDogXCJNRFByZXBEYXRlXCIsXG5cdFx0MHg4MkFCIDogXCJNRFByZXBUaW1lXCIsXG5cdFx0MHg4MkFDIDogXCJNREZpbGVVbml0c1wiLFxuXHRcdDB4ODMwRSA6IFwiUGl4ZWxTY2FsZVwiLFxuXHRcdDB4ODMzNSA6IFwiQWR2ZW50U2NhbGVcIixcblx0XHQweDgzMzYgOiBcIkFkdmVudFJldmlzaW9uXCIsXG5cdFx0MHg4MzVDIDogXCJVSUMxVGFnXCIsXG5cdFx0MHg4MzVEIDogXCJVSUMyVGFnXCIsXG5cdFx0MHg4MzVFIDogXCJVSUMzVGFnXCIsXG5cdFx0MHg4MzVGIDogXCJVSUM0VGFnXCIsXG5cdFx0MHg4M0JCIDogXCJJUFRDLU5BQVwiLFxuXHRcdDB4ODQ3RSA6IFwiSW50ZXJncmFwaFBhY2tldERhdGFcIixcblx0XHQweDg0N0YgOiBcIkludGVyZ3JhcGhGbGFnUmVnaXN0ZXJzXCIsXG5cdFx0MHg4NDgwIDogXCJJbnRlcmdyYXBoTWF0cml4XCIsXG5cdFx0MHg4NDgxIDogXCJJTkdSUmVzZXJ2ZWRcIixcblx0XHQweDg0ODIgOiBcIk1vZGVsVGllUG9pbnRcIixcblx0XHQweDg0RTAgOiBcIlNpdGVcIixcblx0XHQweDg0RTEgOiBcIkNvbG9yU2VxdWVuY2VcIixcblx0XHQweDg0RTIgOiBcIklUOEhlYWRlclwiLFxuXHRcdDB4ODRFMyA6IFwiUmFzdGVyUGFkZGluZ1wiLFxuXHRcdDB4ODRFNCA6IFwiQml0c1BlclJ1bkxlbmd0aFwiLFxuXHRcdDB4ODRFNSA6IFwiQml0c1BlckV4dGVuZGVkUnVuTGVuZ3RoXCIsXG5cdFx0MHg4NEU2IDogXCJDb2xvclRhYmxlXCIsXG5cdFx0MHg4NEU3IDogXCJJbWFnZUNvbG9ySW5kaWNhdG9yXCIsXG5cdFx0MHg4NEU4IDogXCJCYWNrZ3JvdW5kQ29sb3JJbmRpY2F0b3JcIixcblx0XHQweDg0RTkgOiBcIkltYWdlQ29sb3JWYWx1ZVwiLFxuXHRcdDB4ODRFQSA6IFwiQmFja2dyb3VuZENvbG9yVmFsdWVcIixcblx0XHQweDg0RUIgOiBcIlBpeGVsSW50ZW5zaXR5UmFuZ2VcIixcblx0XHQweDg0RUMgOiBcIlRyYW5zcGFyZW5jeUluZGljYXRvclwiLFxuXHRcdDB4ODRFRCA6IFwiQ29sb3JDaGFyYWN0ZXJpemF0aW9uXCIsXG5cdFx0MHg4NEVFIDogXCJIQ1VzYWdlXCIsXG5cdFx0MHg4NEVGIDogXCJUcmFwSW5kaWNhdG9yXCIsXG5cdFx0MHg4NEYwIDogXCJDTVlLRXF1aXZhbGVudFwiLFxuXHRcdDB4ODU0NiA6IFwiU0VNSW5mb1wiLFxuXHRcdDB4ODU2OCA6IFwiQUZDUF9JUFRDXCIsXG5cdFx0MHg4NUI4IDogXCJQaXhlbE1hZ2ljSkJJR09wdGlvbnNcIixcblx0XHQweDg1RDggOiBcIk1vZGVsVHJhbnNmb3JtXCIsXG5cdFx0MHg4NjAyIDogXCJXQl9HUkdCTGV2ZWxzXCIsXG5cdFx0MHg4NjA2IDogXCJMZWFmRGF0YVwiLFxuXHRcdDB4ODY0OSA6IFwiUGhvdG9zaG9wU2V0dGluZ3NcIixcblx0XHQweDg3NjkgOiBcIkV4aWZPZmZzZXRcIixcblx0XHQweDg3NzMgOiBcIklDQ19Qcm9maWxlXCIsXG5cdFx0MHg4NzdGIDogXCJUSUZGX0ZYRXh0ZW5zaW9uc1wiLFxuXHRcdDB4ODc4MCA6IFwiTXVsdGlQcm9maWxlc1wiLFxuXHRcdDB4ODc4MSA6IFwiU2hhcmVkRGF0YVwiLFxuXHRcdDB4ODc4MiA6IFwiVDg4T3B0aW9uc1wiLFxuXHRcdDB4ODdBQyA6IFwiSW1hZ2VMYXllclwiLFxuXHRcdDB4ODdBRiA6IFwiR2VvVGlmZkRpcmVjdG9yeVwiLFxuXHRcdDB4ODdCMCA6IFwiR2VvVGlmZkRvdWJsZVBhcmFtc1wiLFxuXHRcdDB4ODdCMSA6IFwiR2VvVGlmZkFzY2lpUGFyYW1zXCIsXG5cdFx0MHg4ODIyIDogXCJFeHBvc3VyZVByb2dyYW1cIixcblx0XHQweDg4MjQgOiBcIlNwZWN0cmFsU2Vuc2l0aXZpdHlcIixcblx0XHQweDg4MjUgOiBcIkdQU0luZm9cIixcblx0XHQweDg4MjcgOiBcIklTT1wiLFxuXHRcdDB4ODgyOCA6IFwiT3B0by1FbGVjdHJpY0NvbnZGYWN0b3JcIixcblx0XHQweDg4MjkgOiBcIkludGVybGFjZVwiLFxuXHRcdDB4ODgyQSA6IFwiVGltZVpvbmVPZmZzZXRcIixcblx0XHQweDg4MkIgOiBcIlNlbGZUaW1lck1vZGVcIixcblx0XHQweDg4MzAgOiBcIlNlbnNpdGl2aXR5VHlwZVwiLFxuXHRcdDB4ODgzMSA6IFwiU3RhbmRhcmRPdXRwdXRTZW5zaXRpdml0eVwiLFxuXHRcdDB4ODgzMiA6IFwiUmVjb21tZW5kZWRFeHBvc3VyZUluZGV4XCIsXG5cdFx0MHg4ODMzIDogXCJJU09TcGVlZFwiLFxuXHRcdDB4ODgzNCA6IFwiSVNPU3BlZWRMYXRpdHVkZXl5eVwiLFxuXHRcdDB4ODgzNSA6IFwiSVNPU3BlZWRMYXRpdHVkZXp6elwiLFxuXHRcdDB4ODg1QyA6IFwiRmF4UmVjdlBhcmFtc1wiLFxuXHRcdDB4ODg1RCA6IFwiRmF4U3ViQWRkcmVzc1wiLFxuXHRcdDB4ODg1RSA6IFwiRmF4UmVjdlRpbWVcIixcblx0XHQweDg4OEEgOiBcIkxlYWZTdWJJRkRcIixcblx0XHQweDkwMDAgOiBcIkV4aWZWZXJzaW9uXCIsXG5cdFx0MHg5MDAzIDogXCJEYXRlVGltZU9yaWdpbmFsXCIsXG5cdFx0MHg5MDA0IDogXCJDcmVhdGVEYXRlXCIsXG5cdFx0MHg5MTAxIDogXCJDb21wb25lbnRzQ29uZmlndXJhdGlvblwiLFxuXHRcdDB4OTEwMiA6IFwiQ29tcHJlc3NlZEJpdHNQZXJQaXhlbFwiLFxuXHRcdDB4OTIwMSA6IFwiU2h1dHRlclNwZWVkVmFsdWVcIixcblx0XHQweDkyMDIgOiBcIkFwZXJ0dXJlVmFsdWVcIixcblx0XHQweDkyMDMgOiBcIkJyaWdodG5lc3NWYWx1ZVwiLFxuXHRcdDB4OTIwNCA6IFwiRXhwb3N1cmVDb21wZW5zYXRpb25cIixcblx0XHQweDkyMDUgOiBcIk1heEFwZXJ0dXJlVmFsdWVcIixcblx0XHQweDkyMDYgOiBcIlN1YmplY3REaXN0YW5jZVwiLFxuXHRcdDB4OTIwNyA6IFwiTWV0ZXJpbmdNb2RlXCIsXG5cdFx0MHg5MjA4IDogXCJMaWdodFNvdXJjZVwiLFxuXHRcdDB4OTIwOSA6IFwiRmxhc2hcIixcblx0XHQweDkyMEEgOiBcIkZvY2FsTGVuZ3RoXCIsXG5cdFx0MHg5MjBCIDogXCJGbGFzaEVuZXJneVwiLFxuXHRcdDB4OTIwQyA6IFwiU3BhdGlhbEZyZXF1ZW5jeVJlc3BvbnNlXCIsXG5cdFx0MHg5MjBEIDogXCJOb2lzZVwiLFxuXHRcdDB4OTIwRSA6IFwiRm9jYWxQbGFuZVhSZXNvbHV0aW9uXCIsXG5cdFx0MHg5MjBGIDogXCJGb2NhbFBsYW5lWVJlc29sdXRpb25cIixcblx0XHQweDkyMTAgOiBcIkZvY2FsUGxhbmVSZXNvbHV0aW9uVW5pdFwiLFxuXHRcdDB4OTIxMSA6IFwiSW1hZ2VOdW1iZXJcIixcblx0XHQweDkyMTIgOiBcIlNlY3VyaXR5Q2xhc3NpZmljYXRpb25cIixcblx0XHQweDkyMTMgOiBcIkltYWdlSGlzdG9yeVwiLFxuXHRcdDB4OTIxNCA6IFwiU3ViamVjdEFyZWFcIixcblx0XHQweDkyMTUgOiBcIkV4cG9zdXJlSW5kZXhcIixcblx0XHQweDkyMTYgOiBcIlRJRkYtRVBTdGFuZGFyZElEXCIsXG5cdFx0MHg5MjE3IDogXCJTZW5zaW5nTWV0aG9kXCIsXG5cdFx0MHg5MjNBIDogXCJDSVAzRGF0YUZpbGVcIixcblx0XHQweDkyM0IgOiBcIkNJUDNTaGVldFwiLFxuXHRcdDB4OTIzQyA6IFwiQ0lQM1NpZGVcIixcblx0XHQweDkyM0YgOiBcIlN0b05pdHNcIixcblx0XHQweDkyN0MgOiBcIk1ha2VyTm90ZVwiLFxuXHRcdDB4OTI4NiA6IFwiVXNlckNvbW1lbnRcIixcblx0XHQweDkyOTAgOiBcIlN1YlNlY1RpbWVcIixcblx0XHQweDkyOTEgOiBcIlN1YlNlY1RpbWVPcmlnaW5hbFwiLFxuXHRcdDB4OTI5MiA6IFwiU3ViU2VjVGltZURpZ2l0aXplZFwiLFxuXHRcdDB4OTMyRiA6IFwiTVNEb2N1bWVudFRleHRcIixcblx0XHQweDkzMzAgOiBcIk1TUHJvcGVydHlTZXRTdG9yYWdlXCIsXG5cdFx0MHg5MzMxIDogXCJNU0RvY3VtZW50VGV4dFBvc2l0aW9uXCIsXG5cdFx0MHg5MzVDIDogXCJJbWFnZVNvdXJjZURhdGFcIixcblx0XHQweDlDOUIgOiBcIlhQVGl0bGVcIixcblx0XHQweDlDOUMgOiBcIlhQQ29tbWVudFwiLFxuXHRcdDB4OUM5RCA6IFwiWFBBdXRob3JcIixcblx0XHQweDlDOUUgOiBcIlhQS2V5d29yZHNcIixcblx0XHQweDlDOUYgOiBcIlhQU3ViamVjdFwiLFxuXHRcdDB4QTAwMCA6IFwiRmxhc2hwaXhWZXJzaW9uXCIsXG5cdFx0MHhBMDAxIDogXCJDb2xvclNwYWNlXCIsXG5cdFx0MHhBMDAyIDogXCJFeGlmSW1hZ2VXaWR0aFwiLFxuXHRcdDB4QTAwMyA6IFwiRXhpZkltYWdlSGVpZ2h0XCIsXG5cdFx0MHhBMDA0IDogXCJSZWxhdGVkU291bmRGaWxlXCIsXG5cdFx0MHhBMDA1IDogXCJJbnRlcm9wT2Zmc2V0XCIsXG5cdFx0MHhBMjBCIDogXCJGbGFzaEVuZXJneVwiLFxuXHRcdDB4QTIwQyA6IFwiU3BhdGlhbEZyZXF1ZW5jeVJlc3BvbnNlXCIsXG5cdFx0MHhBMjBEIDogXCJOb2lzZVwiLFxuXHRcdDB4QTIwRSA6IFwiRm9jYWxQbGFuZVhSZXNvbHV0aW9uXCIsXG5cdFx0MHhBMjBGIDogXCJGb2NhbFBsYW5lWVJlc29sdXRpb25cIixcblx0XHQweEEyMTAgOiBcIkZvY2FsUGxhbmVSZXNvbHV0aW9uVW5pdFwiLFxuXHRcdDB4QTIxMSA6IFwiSW1hZ2VOdW1iZXJcIixcblx0XHQweEEyMTIgOiBcIlNlY3VyaXR5Q2xhc3NpZmljYXRpb25cIixcblx0XHQweEEyMTMgOiBcIkltYWdlSGlzdG9yeVwiLFxuXHRcdDB4QTIxNCA6IFwiU3ViamVjdExvY2F0aW9uXCIsXG5cdFx0MHhBMjE1IDogXCJFeHBvc3VyZUluZGV4XCIsXG5cdFx0MHhBMjE2IDogXCJUSUZGLUVQU3RhbmRhcmRJRFwiLFxuXHRcdDB4QTIxNyA6IFwiU2Vuc2luZ01ldGhvZFwiLFxuXHRcdDB4QTMwMCA6IFwiRmlsZVNvdXJjZVwiLFxuXHRcdDB4QTMwMSA6IFwiU2NlbmVUeXBlXCIsXG5cdFx0MHhBMzAyIDogXCJDRkFQYXR0ZXJuXCIsXG5cdFx0MHhBNDAxIDogXCJDdXN0b21SZW5kZXJlZFwiLFxuXHRcdDB4QTQwMiA6IFwiRXhwb3N1cmVNb2RlXCIsXG5cdFx0MHhBNDAzIDogXCJXaGl0ZUJhbGFuY2VcIixcblx0XHQweEE0MDQgOiBcIkRpZ2l0YWxab29tUmF0aW9cIixcblx0XHQweEE0MDUgOiBcIkZvY2FsTGVuZ3RoSW4zNW1tRm9ybWF0XCIsXG5cdFx0MHhBNDA2IDogXCJTY2VuZUNhcHR1cmVUeXBlXCIsXG5cdFx0MHhBNDA3IDogXCJHYWluQ29udHJvbFwiLFxuXHRcdDB4QTQwOCA6IFwiQ29udHJhc3RcIixcblx0XHQweEE0MDkgOiBcIlNhdHVyYXRpb25cIixcblx0XHQweEE0MEEgOiBcIlNoYXJwbmVzc1wiLFxuXHRcdDB4QTQwQiA6IFwiRGV2aWNlU2V0dGluZ0Rlc2NyaXB0aW9uXCIsXG5cdFx0MHhBNDBDIDogXCJTdWJqZWN0RGlzdGFuY2VSYW5nZVwiLFxuXHRcdDB4QTQyMCA6IFwiSW1hZ2VVbmlxdWVJRFwiLFxuXHRcdDB4QTQzMCA6IFwiT3duZXJOYW1lXCIsXG5cdFx0MHhBNDMxIDogXCJTZXJpYWxOdW1iZXJcIixcblx0XHQweEE0MzIgOiBcIkxlbnNJbmZvXCIsXG5cdFx0MHhBNDMzIDogXCJMZW5zTWFrZVwiLFxuXHRcdDB4QTQzNCA6IFwiTGVuc01vZGVsXCIsXG5cdFx0MHhBNDM1IDogXCJMZW5zU2VyaWFsTnVtYmVyXCIsXG5cdFx0MHhBNDgwIDogXCJHREFMTWV0YWRhdGFcIixcblx0XHQweEE0ODEgOiBcIkdEQUxOb0RhdGFcIixcblx0XHQweEE1MDAgOiBcIkdhbW1hXCIsXG5cdFx0MHhBRkMwIDogXCJFeHBhbmRTb2Z0d2FyZVwiLFxuXHRcdDB4QUZDMSA6IFwiRXhwYW5kTGVuc1wiLFxuXHRcdDB4QUZDMiA6IFwiRXhwYW5kRmlsbVwiLFxuXHRcdDB4QUZDMyA6IFwiRXhwYW5kRmlsdGVyTGVuc1wiLFxuXHRcdDB4QUZDNCA6IFwiRXhwYW5kU2Nhbm5lclwiLFxuXHRcdDB4QUZDNSA6IFwiRXhwYW5kRmxhc2hMYW1wXCIsXG5cdFx0MHhCQzAxIDogXCJQaXhlbEZvcm1hdFwiLFxuXHRcdDB4QkMwMiA6IFwiVHJhbnNmb3JtYXRpb25cIixcblx0XHQweEJDMDMgOiBcIlVuY29tcHJlc3NlZFwiLFxuXHRcdDB4QkMwNCA6IFwiSW1hZ2VUeXBlXCIsXG5cdFx0MHhCQzgwIDogXCJJbWFnZVdpZHRoXCIsXG5cdFx0MHhCQzgxIDogXCJJbWFnZUhlaWdodFwiLFxuXHRcdDB4QkM4MiA6IFwiV2lkdGhSZXNvbHV0aW9uXCIsXG5cdFx0MHhCQzgzIDogXCJIZWlnaHRSZXNvbHV0aW9uXCIsXG5cdFx0MHhCQ0MwIDogXCJJbWFnZU9mZnNldFwiLFxuXHRcdDB4QkNDMSA6IFwiSW1hZ2VCeXRlQ291bnRcIixcblx0XHQweEJDQzIgOiBcIkFscGhhT2Zmc2V0XCIsXG5cdFx0MHhCQ0MzIDogXCJBbHBoYUJ5dGVDb3VudFwiLFxuXHRcdDB4QkNDNCA6IFwiSW1hZ2VEYXRhRGlzY2FyZFwiLFxuXHRcdDB4QkNDNSA6IFwiQWxwaGFEYXRhRGlzY2FyZFwiLFxuXHRcdDB4QzQyNyA6IFwiT2NlU2NhbmpvYkRlc2NcIixcblx0XHQweEM0MjggOiBcIk9jZUFwcGxpY2F0aW9uU2VsZWN0b3JcIixcblx0XHQweEM0MjkgOiBcIk9jZUlETnVtYmVyXCIsXG5cdFx0MHhDNDJBIDogXCJPY2VJbWFnZUxvZ2ljXCIsXG5cdFx0MHhDNDRGIDogXCJBbm5vdGF0aW9uc1wiLFxuXHRcdDB4QzRBNSA6IFwiUHJpbnRJTVwiLFxuXHRcdDB4QzU4MCA6IFwiVVNQVE9PcmlnaW5hbENvbnRlbnRUeXBlXCIsXG5cdFx0MHhDNjEyIDogXCJETkdWZXJzaW9uXCIsXG5cdFx0MHhDNjEzIDogXCJETkdCYWNrd2FyZFZlcnNpb25cIixcblx0XHQweEM2MTQgOiBcIlVuaXF1ZUNhbWVyYU1vZGVsXCIsXG5cdFx0MHhDNjE1IDogXCJMb2NhbGl6ZWRDYW1lcmFNb2RlbFwiLFxuXHRcdDB4QzYxNiA6IFwiQ0ZBUGxhbmVDb2xvclwiLFxuXHRcdDB4QzYxNyA6IFwiQ0ZBTGF5b3V0XCIsXG5cdFx0MHhDNjE4IDogXCJMaW5lYXJpemF0aW9uVGFibGVcIixcblx0XHQweEM2MTkgOiBcIkJsYWNrTGV2ZWxSZXBlYXREaW1cIixcblx0XHQweEM2MUEgOiBcIkJsYWNrTGV2ZWxcIixcblx0XHQweEM2MUIgOiBcIkJsYWNrTGV2ZWxEZWx0YUhcIixcblx0XHQweEM2MUMgOiBcIkJsYWNrTGV2ZWxEZWx0YVZcIixcblx0XHQweEM2MUQgOiBcIldoaXRlTGV2ZWxcIixcblx0XHQweEM2MUUgOiBcIkRlZmF1bHRTY2FsZVwiLFxuXHRcdDB4QzYxRiA6IFwiRGVmYXVsdENyb3BPcmlnaW5cIixcblx0XHQweEM2MjAgOiBcIkRlZmF1bHRDcm9wU2l6ZVwiLFxuXHRcdDB4QzYyMSA6IFwiQ29sb3JNYXRyaXgxXCIsXG5cdFx0MHhDNjIyIDogXCJDb2xvck1hdHJpeDJcIixcblx0XHQweEM2MjMgOiBcIkNhbWVyYUNhbGlicmF0aW9uMVwiLFxuXHRcdDB4QzYyNCA6IFwiQ2FtZXJhQ2FsaWJyYXRpb24yXCIsXG5cdFx0MHhDNjI1IDogXCJSZWR1Y3Rpb25NYXRyaXgxXCIsXG5cdFx0MHhDNjI2IDogXCJSZWR1Y3Rpb25NYXRyaXgyXCIsXG5cdFx0MHhDNjI3IDogXCJBbmFsb2dCYWxhbmNlXCIsXG5cdFx0MHhDNjI4IDogXCJBc1Nob3ROZXV0cmFsXCIsXG5cdFx0MHhDNjI5IDogXCJBc1Nob3RXaGl0ZVhZXCIsXG5cdFx0MHhDNjJBIDogXCJCYXNlbGluZUV4cG9zdXJlXCIsXG5cdFx0MHhDNjJCIDogXCJCYXNlbGluZU5vaXNlXCIsXG5cdFx0MHhDNjJDIDogXCJCYXNlbGluZVNoYXJwbmVzc1wiLFxuXHRcdDB4QzYyRCA6IFwiQmF5ZXJHcmVlblNwbGl0XCIsXG5cdFx0MHhDNjJFIDogXCJMaW5lYXJSZXNwb25zZUxpbWl0XCIsXG5cdFx0MHhDNjJGIDogXCJDYW1lcmFTZXJpYWxOdW1iZXJcIixcblx0XHQweEM2MzAgOiBcIkROR0xlbnNJbmZvXCIsXG5cdFx0MHhDNjMxIDogXCJDaHJvbWFCbHVyUmFkaXVzXCIsXG5cdFx0MHhDNjMyIDogXCJBbnRpQWxpYXNTdHJlbmd0aFwiLFxuXHRcdDB4QzYzMyA6IFwiU2hhZG93U2NhbGVcIixcblx0XHQweEM2MzQgOiBcIkROR1ByaXZhdGVEYXRhXCIsXG5cdFx0MHhDNjM1IDogXCJNYWtlck5vdGVTYWZldHlcIixcblx0XHQweEM2NDAgOiBcIlJhd0ltYWdlU2VnbWVudGF0aW9uXCIsXG5cdFx0MHhDNjVBIDogXCJDYWxpYnJhdGlvbklsbHVtaW5hbnQxXCIsXG5cdFx0MHhDNjVCIDogXCJDYWxpYnJhdGlvbklsbHVtaW5hbnQyXCIsXG5cdFx0MHhDNjVDIDogXCJCZXN0UXVhbGl0eVNjYWxlXCIsXG5cdFx0MHhDNjVEIDogXCJSYXdEYXRhVW5pcXVlSURcIixcblx0XHQweEM2NjAgOiBcIkFsaWFzTGF5ZXJNZXRhZGF0YVwiLFxuXHRcdDB4QzY4QiA6IFwiT3JpZ2luYWxSYXdGaWxlTmFtZVwiLFxuXHRcdDB4QzY4QyA6IFwiT3JpZ2luYWxSYXdGaWxlRGF0YVwiLFxuXHRcdDB4QzY4RCA6IFwiQWN0aXZlQXJlYVwiLFxuXHRcdDB4QzY4RSA6IFwiTWFza2VkQXJlYXNcIixcblx0XHQweEM2OEYgOiBcIkFzU2hvdElDQ1Byb2ZpbGVcIixcblx0XHQweEM2OTAgOiBcIkFzU2hvdFByZVByb2ZpbGVNYXRyaXhcIixcblx0XHQweEM2OTEgOiBcIkN1cnJlbnRJQ0NQcm9maWxlXCIsXG5cdFx0MHhDNjkyIDogXCJDdXJyZW50UHJlUHJvZmlsZU1hdHJpeFwiLFxuXHRcdDB4QzZCRiA6IFwiQ29sb3JpbWV0cmljUmVmZXJlbmNlXCIsXG5cdFx0MHhDNkQyIDogXCJQYW5hc29uaWNUaXRsZVwiLFxuXHRcdDB4QzZEMyA6IFwiUGFuYXNvbmljVGl0bGUyXCIsXG5cdFx0MHhDNkYzIDogXCJDYW1lcmFDYWxpYnJhdGlvblNpZ1wiLFxuXHRcdDB4QzZGNCA6IFwiUHJvZmlsZUNhbGlicmF0aW9uU2lnXCIsXG5cdFx0MHhDNkY1IDogXCJQcm9maWxlSUZEXCIsXG5cdFx0MHhDNkY2IDogXCJBc1Nob3RQcm9maWxlTmFtZVwiLFxuXHRcdDB4QzZGNyA6IFwiTm9pc2VSZWR1Y3Rpb25BcHBsaWVkXCIsXG5cdFx0MHhDNkY4IDogXCJQcm9maWxlTmFtZVwiLFxuXHRcdDB4QzZGOSA6IFwiUHJvZmlsZUh1ZVNhdE1hcERpbXNcIixcblx0XHQweEM2RkEgOiBcIlByb2ZpbGVIdWVTYXRNYXBEYXRhMVwiLFxuXHRcdDB4QzZGQiA6IFwiUHJvZmlsZUh1ZVNhdE1hcERhdGEyXCIsXG5cdFx0MHhDNkZDIDogXCJQcm9maWxlVG9uZUN1cnZlXCIsXG5cdFx0MHhDNkZEIDogXCJQcm9maWxlRW1iZWRQb2xpY3lcIixcblx0XHQweEM2RkUgOiBcIlByb2ZpbGVDb3B5cmlnaHRcIixcblx0XHQweEM3MTQgOiBcIkZvcndhcmRNYXRyaXgxXCIsXG5cdFx0MHhDNzE1IDogXCJGb3J3YXJkTWF0cml4MlwiLFxuXHRcdDB4QzcxNiA6IFwiUHJldmlld0FwcGxpY2F0aW9uTmFtZVwiLFxuXHRcdDB4QzcxNyA6IFwiUHJldmlld0FwcGxpY2F0aW9uVmVyc2lvblwiLFxuXHRcdDB4QzcxOCA6IFwiUHJldmlld1NldHRpbmdzTmFtZVwiLFxuXHRcdDB4QzcxOSA6IFwiUHJldmlld1NldHRpbmdzRGlnZXN0XCIsXG5cdFx0MHhDNzFBIDogXCJQcmV2aWV3Q29sb3JTcGFjZVwiLFxuXHRcdDB4QzcxQiA6IFwiUHJldmlld0RhdGVUaW1lXCIsXG5cdFx0MHhDNzFDIDogXCJSYXdJbWFnZURpZ2VzdFwiLFxuXHRcdDB4QzcxRCA6IFwiT3JpZ2luYWxSYXdGaWxlRGlnZXN0XCIsXG5cdFx0MHhDNzFFIDogXCJTdWJUaWxlQmxvY2tTaXplXCIsXG5cdFx0MHhDNzFGIDogXCJSb3dJbnRlcmxlYXZlRmFjdG9yXCIsXG5cdFx0MHhDNzI1IDogXCJQcm9maWxlTG9va1RhYmxlRGltc1wiLFxuXHRcdDB4QzcyNiA6IFwiUHJvZmlsZUxvb2tUYWJsZURhdGFcIixcblx0XHQweEM3NDAgOiBcIk9wY29kZUxpc3QxXCIsXG5cdFx0MHhDNzQxIDogXCJPcGNvZGVMaXN0MlwiLFxuXHRcdDB4Qzc0RSA6IFwiT3Bjb2RlTGlzdDNcIixcblx0XHQweEM3NjEgOiBcIk5vaXNlUHJvZmlsZVwiLFxuXHRcdDB4Qzc2MyA6IFwiVGltZUNvZGVzXCIsXG5cdFx0MHhDNzY0IDogXCJGcmFtZVJhdGVcIixcblx0XHQweEM3NzIgOiBcIlRTdG9wXCIsXG5cdFx0MHhDNzg5IDogXCJSZWVsTmFtZVwiLFxuXHRcdDB4Qzc5MSA6IFwiT3JpZ2luYWxEZWZhdWx0RmluYWxTaXplXCIsXG5cdFx0MHhDNzkyIDogXCJPcmlnaW5hbEJlc3RRdWFsaXR5U2l6ZVwiLFxuXHRcdDB4Qzc5MyA6IFwiT3JpZ2luYWxEZWZhdWx0Q3JvcFNpemVcIixcblx0XHQweEM3QTEgOiBcIkNhbWVyYUxhYmVsXCIsXG5cdFx0MHhDN0EzIDogXCJQcm9maWxlSHVlU2F0TWFwRW5jb2RpbmdcIixcblx0XHQweEM3QTQgOiBcIlByb2ZpbGVMb29rVGFibGVFbmNvZGluZ1wiLFxuXHRcdDB4QzdBNSA6IFwiQmFzZWxpbmVFeHBvc3VyZU9mZnNldFwiLFxuXHRcdDB4QzdBNiA6IFwiRGVmYXVsdEJsYWNrUmVuZGVyXCIsXG5cdFx0MHhDN0E3IDogXCJOZXdSYXdJbWFnZURpZ2VzdFwiLFxuXHRcdDB4QzdBOCA6IFwiUmF3VG9QcmV2aWV3R2FpblwiLFxuXHRcdDB4QzdCNSA6IFwiRGVmYXVsdFVzZXJDcm9wXCIsXG5cdFx0MHhFQTFDIDogXCJQYWRkaW5nXCIsXG5cdFx0MHhFQTFEIDogXCJPZmZzZXRTY2hlbWFcIixcblx0XHQweEZERTggOiBcIk93bmVyTmFtZVwiLFxuXHRcdDB4RkRFOSA6IFwiU2VyaWFsTnVtYmVyXCIsXG5cdFx0MHhGREVBIDogXCJMZW5zXCIsXG5cdFx0MHhGRTAwIDogXCJLRENfSUZEXCIsXG5cdFx0MHhGRTRDIDogXCJSYXdGaWxlXCIsXG5cdFx0MHhGRTREIDogXCJDb252ZXJ0ZXJcIixcblx0XHQweEZFNEUgOiBcIldoaXRlQmFsYW5jZVwiLFxuXHRcdDB4RkU1MSA6IFwiRXhwb3N1cmVcIixcblx0XHQweEZFNTIgOiBcIlNoYWRvd3NcIixcblx0XHQweEZFNTMgOiBcIkJyaWdodG5lc3NcIixcblx0XHQweEZFNTQgOiBcIkNvbnRyYXN0XCIsXG5cdFx0MHhGRTU1IDogXCJTYXR1cmF0aW9uXCIsXG5cdFx0MHhGRTU2IDogXCJTaGFycG5lc3NcIixcblx0XHQweEZFNTcgOiBcIlNtb290aG5lc3NcIixcblx0XHQweEZFNTggOiBcIk1vaXJlRmlsdGVyXCJcblx0XHRcblx0fSxcblx0Z3BzIDoge1x0XG5cdFx0MHgwMDAwIDogJ0dQU1ZlcnNpb25JRCcsXG5cdFx0MHgwMDAxIDogJ0dQU0xhdGl0dWRlUmVmJyxcblx0XHQweDAwMDIgOiAnR1BTTGF0aXR1ZGUnLFxuXHRcdDB4MDAwMyA6ICdHUFNMb25naXR1ZGVSZWYnLFxuXHRcdDB4MDAwNCA6ICdHUFNMb25naXR1ZGUnLFxuXHRcdDB4MDAwNSA6ICdHUFNBbHRpdHVkZVJlZicsXG5cdFx0MHgwMDA2IDogJ0dQU0FsdGl0dWRlJyxcblx0XHQweDAwMDcgOiAnR1BTVGltZVN0YW1wJyxcblx0XHQweDAwMDggOiAnR1BTU2F0ZWxsaXRlcycsXG5cdFx0MHgwMDA5IDogJ0dQU1N0YXR1cycsXG5cdFx0MHgwMDBBIDogJ0dQU01lYXN1cmVNb2RlJyxcblx0XHQweDAwMEIgOiAnR1BTRE9QJyxcblx0XHQweDAwMEMgOiAnR1BTU3BlZWRSZWYnLFxuXHRcdDB4MDAwRCA6ICdHUFNTcGVlZCcsXG5cdFx0MHgwMDBFIDogJ0dQU1RyYWNrUmVmJyxcblx0XHQweDAwMEYgOiAnR1BTVHJhY2snLFxuXHRcdDB4MDAxMCA6ICdHUFNJbWdEaXJlY3Rpb25SZWYnLFxuXHRcdDB4MDAxMSA6ICdHUFNJbWdEaXJlY3Rpb24nLFxuXHRcdDB4MDAxMiA6ICdHUFNNYXBEYXR1bScsXG5cdFx0MHgwMDEzIDogJ0dQU0Rlc3RMYXRpdHVkZVJlZicsXG5cdFx0MHgwMDE0IDogJ0dQU0Rlc3RMYXRpdHVkZScsXG5cdFx0MHgwMDE1IDogJ0dQU0Rlc3RMb25naXR1ZGVSZWYnLFxuXHRcdDB4MDAxNiA6ICdHUFNEZXN0TG9uZ2l0dWRlJyxcblx0XHQweDAwMTcgOiAnR1BTRGVzdEJlYXJpbmdSZWYnLFxuXHRcdDB4MDAxOCA6ICdHUFNEZXN0QmVhcmluZycsXG5cdFx0MHgwMDE5IDogJ0dQU0Rlc3REaXN0YW5jZVJlZicsXG5cdFx0MHgwMDFBIDogJ0dQU0Rlc3REaXN0YW5jZScsXG5cdFx0MHgwMDFCIDogJ0dQU1Byb2Nlc3NpbmdNZXRob2QnLFxuXHRcdDB4MDAxQyA6ICdHUFNBcmVhSW5mb3JtYXRpb24nLFxuXHRcdDB4MDAxRCA6ICdHUFNEYXRlU3RhbXAnLFxuXHRcdDB4MDAxRSA6ICdHUFNEaWZmZXJlbnRpYWwnLFxuXHRcdDB4MDAxRiA6ICdHUFNIUG9zaXRpb25pbmdFcnJvcidcblx0fVxufTsiLCIvKmpzbGludCBicm93c2VyOiB0cnVlLCBkZXZlbDogdHJ1ZSwgYml0d2lzZTogZmFsc2UsIGRlYnVnOiB0cnVlLCBlcWVxOiBmYWxzZSwgZXM1OiB0cnVlLCBldmlsOiBmYWxzZSwgZm9yaW46IGZhbHNlLCBuZXdjYXA6IGZhbHNlLCBub21lbjogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIHJlZ2V4cDogZmFsc2UsIHVucGFyYW06IGZhbHNlLCBzbG9wcHk6IHRydWUsIHN0dXBpZDogZmFsc2UsIHN1YjogZmFsc2UsIHRvZG86IHRydWUsIHZhcnM6IHRydWUsIHdoaXRlOiB0cnVlICovXG5cbmZ1bmN0aW9uIHJlYWRFeGlmVmFsdWUoZm9ybWF0LCBzdHJlYW0pIHtcblx0c3dpdGNoKGZvcm1hdCkge1xuXHRcdGNhc2UgMTogcmV0dXJuIHN0cmVhbS5uZXh0VUludDgoKTtcblx0XHRjYXNlIDM6IHJldHVybiBzdHJlYW0ubmV4dFVJbnQxNigpO1xuXHRcdGNhc2UgNDogcmV0dXJuIHN0cmVhbS5uZXh0VUludDMyKCk7XG5cdFx0Y2FzZSA1OiByZXR1cm4gW3N0cmVhbS5uZXh0VUludDMyKCksIHN0cmVhbS5uZXh0VUludDMyKCldO1xuXHRcdGNhc2UgNjogcmV0dXJuIHN0cmVhbS5uZXh0SW50OCgpO1xuXHRcdGNhc2UgODogcmV0dXJuIHN0cmVhbS5uZXh0VUludDE2KCk7XG5cdFx0Y2FzZSA5OiByZXR1cm4gc3RyZWFtLm5leHRVSW50MzIoKTtcblx0XHRjYXNlIDEwOiByZXR1cm4gW3N0cmVhbS5uZXh0SW50MzIoKSwgc3RyZWFtLm5leHRJbnQzMigpXTtcblx0XHRjYXNlIDExOiByZXR1cm4gc3RyZWFtLm5leHRGbG9hdCgpO1xuXHRcdGNhc2UgMTI6IHJldHVybiBzdHJlYW0ubmV4dERvdWJsZSgpO1xuXHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQgd2hpbGUgZGVjb2Rpbmc6ICcgKyBmb3JtYXQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldEJ5dGVzUGVyQ29tcG9uZW50KGZvcm1hdCkge1xuXHRzd2l0Y2goZm9ybWF0KSB7XG5cdFx0Y2FzZSAxOlxuXHRcdGNhc2UgMjpcblx0XHRjYXNlIDY6XG5cdFx0Y2FzZSA3OlxuXHRcdFx0cmV0dXJuIDE7XG5cdFx0Y2FzZSAzOlxuXHRcdGNhc2UgODpcblx0XHRcdHJldHVybiAyO1xuXHRcdGNhc2UgNDpcblx0XHRjYXNlIDk6XG5cdFx0Y2FzZSAxMTpcblx0XHRcdHJldHVybiA0O1xuXHRcdGNhc2UgNTpcblx0XHRjYXNlIDEwOlxuXHRcdGNhc2UgMTI6XG5cdFx0XHRyZXR1cm4gODtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIDA7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVhZEV4aWZUYWcodGlmZk1hcmtlciwgc3RyZWFtKSB7XG5cdHZhciB0YWdUeXBlID0gc3RyZWFtLm5leHRVSW50MTYoKSxcblx0XHRmb3JtYXQgPSBzdHJlYW0ubmV4dFVJbnQxNigpLFxuXHRcdGJ5dGVzUGVyQ29tcG9uZW50ID0gZ2V0Qnl0ZXNQZXJDb21wb25lbnQoZm9ybWF0KSxcblx0XHRjb21wb25lbnRzID0gc3RyZWFtLm5leHRVSW50MzIoKSxcblx0XHR2YWx1ZUJ5dGVzID0gYnl0ZXNQZXJDb21wb25lbnQgKiBjb21wb25lbnRzLFxuXHRcdHZhbHVlcyxcblx0XHR2YWx1ZSxcblx0XHRjO1xuXG5cdC8qIGlmIHRoZSB2YWx1ZSBpcyBiaWdnZXIgdGhlbiA0IGJ5dGVzLCB0aGUgdmFsdWUgaXMgaW4gdGhlIGRhdGEgc2VjdGlvbiBvZiB0aGUgSUZEXG5cdGFuZCB0aGUgdmFsdWUgcHJlc2VudCBpbiB0aGUgdGFnIGlzIHRoZSBvZmZzZXQgc3RhcnRpbmcgZnJvbSB0aGUgdGlmZiBoZWFkZXIuIFNvIHdlIHJlcGxhY2UgdGhlIHN0cmVhbVxuXHR3aXRoIGEgc3RyZWFtIHRoYXQgaXMgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGluIHRoZSBkYXRhIHNlY3Rpb24uIHMqL1xuXHRpZih2YWx1ZUJ5dGVzID4gNCkge1xuXHRcdHN0cmVhbSA9IHRpZmZNYXJrZXIub3BlbldpdGhPZmZzZXQoc3RyZWFtLm5leHRVSW50MzIoKSk7XG5cdH1cblx0Ly93ZSBkb24ndCB3YW50IHRvIHJlYWQgc3RyaW5ncyBhcyBhcnJheXNcblx0aWYoZm9ybWF0ID09PSAyKSB7XG5cdFx0dmFsdWVzID0gc3RyZWFtLm5leHRTdHJpbmcoY29tcG9uZW50cyk7XG5cdFx0Ly9jdXQgb2ZmIFxcMCBjaGFyYWN0ZXJzXG5cdFx0dmFyIGxhc3ROdWxsID0gdmFsdWVzLmluZGV4T2YoJ1xcMCcpO1xuXHRcdGlmKGxhc3ROdWxsICE9PSAtMSkge1xuXHRcdFx0dmFsdWVzID0gdmFsdWVzLnN1YnN0cigwLCBsYXN0TnVsbCk7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYoZm9ybWF0ID09PSA3KSB7XG5cdFx0dmFsdWVzID0gc3RyZWFtLm5leHRCdWZmZXIoY29tcG9uZW50cyk7XG5cdH1cblx0ZWxzZSBpZihmb3JtYXQgIT09IDApIHtcblx0XHR2YWx1ZXMgPSBbXTtcblx0XHRmb3IoYyA9IDA7IGMgPCBjb21wb25lbnRzOyArK2MpIHtcblx0XHRcdHZhbHVlcy5wdXNoKHJlYWRFeGlmVmFsdWUoZm9ybWF0LCBzdHJlYW0pKTtcblx0XHR9XG5cdH1cblx0Ly9zaW5jZSBvdXIgc3RyZWFtIGlzIGEgc3RhdGVmdWwgb2JqZWN0LCB3ZSBuZWVkIHRvIHNraXAgcmVtYWluaW5nIGJ5dGVzXG5cdC8vc28gb3VyIG9mZnNldCBzdGF5cyBjb3JyZWN0XG5cdGlmKHZhbHVlQnl0ZXMgPCA0KSB7XG5cdFx0c3RyZWFtLnNraXAoNCAtIHZhbHVlQnl0ZXMpO1xuXHR9XG5cblx0cmV0dXJuIFt0YWdUeXBlLCB2YWx1ZXMsIGZvcm1hdF07XG59XG5cbmZ1bmN0aW9uIHJlYWRJRkRTZWN0aW9uKHRpZmZNYXJrZXIsIHN0cmVhbSwgaXRlcmF0b3IpIHtcblx0dmFyIG51bWJlck9mRW50cmllcyA9IHN0cmVhbS5uZXh0VUludDE2KCksIHRhZywgaTtcblx0Zm9yKGkgPSAwOyBpIDwgbnVtYmVyT2ZFbnRyaWVzOyArK2kpIHtcblx0XHR0YWcgPSByZWFkRXhpZlRhZyh0aWZmTWFya2VyLCBzdHJlYW0pO1xuXHRcdGl0ZXJhdG9yKHRhZ1swXSwgdGFnWzFdLCB0YWdbMl0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRIZWFkZXIoc3RyZWFtKSB7XG5cdHZhciBleGlmSGVhZGVyID0gc3RyZWFtLm5leHRTdHJpbmcoNik7XG5cdGlmKGV4aWZIZWFkZXIgIT09ICdFeGlmXFwwXFwwJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFWElGIGhlYWRlcicpO1xuXHR9XG5cblx0dmFyIHRpZmZNYXJrZXIgPSBzdHJlYW0ubWFyaygpO1xuXHR2YXIgdGlmZkhlYWRlciA9IHN0cmVhbS5uZXh0VUludDE2KCk7XG5cdGlmKHRpZmZIZWFkZXIgPT09IDB4NDk0OSkge1xuXHRcdHN0cmVhbS5zZXRCaWdFbmRpYW4oZmFsc2UpO1xuXHR9IGVsc2UgaWYodGlmZkhlYWRlciA9PT0gMHg0RDREKSB7XG5cdFx0c3RyZWFtLnNldEJpZ0VuZGlhbih0cnVlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVElGRiBoZWFkZXInKTtcblx0fVxuXHRpZihzdHJlYW0ubmV4dFVJbnQxNigpICE9PSAweDAwMkEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVElGRiBkYXRhJyk7XG5cdH1cblx0cmV0dXJuIHRpZmZNYXJrZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRJRkQwOiAxLFxuXHRJRkQxOiAyLFxuXHRHUFNJRkQ6IDMsXG5cdFN1YklGRDogNCxcblx0SW50ZXJvcElGRDogNSxcblx0cGFyc2VUYWdzOiBmdW5jdGlvbihzdHJlYW0sIGl0ZXJhdG9yKSB7XG5cdFx0dmFyIHRpZmZNYXJrZXI7XG5cdFx0dHJ5IHtcblx0XHRcdHRpZmZNYXJrZXIgPSByZWFkSGVhZGVyKHN0cmVhbSk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XHQvL2lnbm9yZSBBUFAxIHNlY3Rpb25zIHdpdGggaW52YWxpZCBoZWFkZXJzXG5cdFx0fVxuXHRcdHZhciBzdWJJZmRPZmZzZXQsIGdwc09mZnNldCwgaW50ZXJvcE9mZnNldDtcblx0XHR2YXIgaWZkMFN0cmVhbSA9IHRpZmZNYXJrZXIub3BlbldpdGhPZmZzZXQoc3RyZWFtLm5leHRVSW50MzIoKSksXG5cdFx0XHRJRkQwID0gdGhpcy5JRkQwO1xuXHRcdHJlYWRJRkRTZWN0aW9uKHRpZmZNYXJrZXIsIGlmZDBTdHJlYW0sIGZ1bmN0aW9uKHRhZ1R5cGUsIHZhbHVlLCBmb3JtYXQpIHtcblx0XHRcdHN3aXRjaCh0YWdUeXBlKSB7XG5cdFx0XHRcdGNhc2UgMHg4ODI1OiBncHNPZmZzZXQgPSB2YWx1ZVswXTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMHg4NzY5OiBzdWJJZmRPZmZzZXQgPSB2YWx1ZVswXTsgYnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6IGl0ZXJhdG9yKElGRDAsIHRhZ1R5cGUsIHZhbHVlLCBmb3JtYXQpOyBicmVhaztcblx0XHRcdH1cblx0XHR9KTtcblx0XHR2YXIgaWZkMU9mZnNldCA9IGlmZDBTdHJlYW0ubmV4dFVJbnQzMigpO1xuXHRcdGlmKGlmZDFPZmZzZXQgIT09IDApIHtcblx0XHRcdHZhciBpZmQxU3RyZWFtID0gdGlmZk1hcmtlci5vcGVuV2l0aE9mZnNldChpZmQxT2Zmc2V0KTtcblx0XHRcdHJlYWRJRkRTZWN0aW9uKHRpZmZNYXJrZXIsIGlmZDFTdHJlYW0sIGl0ZXJhdG9yLmJpbmQobnVsbCwgdGhpcy5JRkQxKSk7XG5cdFx0fVxuXG5cdFx0aWYoZ3BzT2Zmc2V0KSB7XG5cdFx0XHR2YXIgZ3BzU3RyZWFtID0gdGlmZk1hcmtlci5vcGVuV2l0aE9mZnNldChncHNPZmZzZXQpO1xuXHRcdFx0cmVhZElGRFNlY3Rpb24odGlmZk1hcmtlciwgZ3BzU3RyZWFtLCBpdGVyYXRvci5iaW5kKG51bGwsIHRoaXMuR1BTSUZEKSk7XG5cdFx0fVxuXG5cdFx0aWYoc3ViSWZkT2Zmc2V0KSB7XG5cdFx0XHR2YXIgc3ViSWZkU3RyZWFtID0gdGlmZk1hcmtlci5vcGVuV2l0aE9mZnNldChzdWJJZmRPZmZzZXQpLCBJbnRlcm9wSUZEID0gdGhpcy5JbnRlcm9wSUZEO1xuXHRcdFx0cmVhZElGRFNlY3Rpb24odGlmZk1hcmtlciwgc3ViSWZkU3RyZWFtLCBmdW5jdGlvbih0YWdUeXBlLCB2YWx1ZSwgZm9ybWF0KSB7XG5cdFx0XHRcdGlmKHRhZ1R5cGUgPT09IDB4QTAwNSkge1xuXHRcdFx0XHRcdGludGVyb3BPZmZzZXQgPSB2YWx1ZVswXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpdGVyYXRvcihJbnRlcm9wSUZELCB0YWdUeXBlLCB2YWx1ZSwgZm9ybWF0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYoaW50ZXJvcE9mZnNldCkge1xuXHRcdFx0dmFyIGludGVyb3BTdHJlYW0gPSB0aWZmTWFya2VyLm9wZW5XaXRoT2Zmc2V0KGludGVyb3BPZmZzZXQpO1xuXHRcdFx0cmVhZElGRFNlY3Rpb24odGlmZk1hcmtlciwgaW50ZXJvcFN0cmVhbSwgaXRlcmF0b3IuYmluZChudWxsLCB0aGlzLkludGVyb3BJRkQpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07IiwiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgZGV2ZWw6IHRydWUsIGJpdHdpc2U6IGZhbHNlLCBkZWJ1ZzogdHJ1ZSwgZXFlcTogZmFsc2UsIGVzNTogdHJ1ZSwgZXZpbDogZmFsc2UsIGZvcmluOiBmYWxzZSwgbmV3Y2FwOiBmYWxzZSwgbm9tZW46IHRydWUsIHBsdXNwbHVzOiB0cnVlLCByZWdleHA6IGZhbHNlLCB1bnBhcmFtOiBmYWxzZSwgc2xvcHB5OiB0cnVlLCBzdHVwaWQ6IGZhbHNlLCBzdWI6IGZhbHNlLCB0b2RvOiB0cnVlLCB2YXJzOiB0cnVlLCB3aGl0ZTogdHJ1ZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cGFyc2VTZWN0aW9uczogZnVuY3Rpb24oc3RyZWFtLCBpdGVyYXRvcikge1xuXHRcdHZhciBsZW4sIG1hcmtlclR5cGU7XG5cdFx0c3RyZWFtLnNldEJpZ0VuZGlhbih0cnVlKTtcblx0XHQvL3N0b3AgcmVhZGluZyB0aGUgc3RyZWFtIGF0IHRoZSBTT1MgKFN0YXJ0IG9mIFN0cmVhbSkgbWFya2VyLFxuXHRcdC8vYmVjYXVzZSBpdHMgbGVuZ3RoIGlzIG5vdCBzdG9yZWQgaW4gdGhlIGhlYWRlciBzbyB3ZSBjYW4ndFxuXHRcdC8va25vdyB3aGVyZSB0byBqdW1wIHRvLiBUaGUgb25seSBtYXJrZXIgYWZ0ZXIgdGhhdCBpcyBqdXN0IEVPSSAoRW5kIE9mIEltYWdlKSBhbnl3YXlcblx0XHR3aGlsZShzdHJlYW0ucmVtYWluaW5nTGVuZ3RoKCkgPiAwICYmIG1hcmtlclR5cGUgIT09IDB4REEpIHtcblx0XHRcdGlmKHN0cmVhbS5uZXh0VUludDgoKSAhPT0gMHhGRikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlBFRyBzZWN0aW9uIG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdFx0bWFya2VyVHlwZSA9IHN0cmVhbS5uZXh0VUludDgoKTtcblx0XHRcdC8vZG9uJ3QgcmVhZCBzaXplIGZyb20gbWFya2VycyB0aGF0IGhhdmUgbm8gZGF0YXNcblx0XHRcdGlmKChtYXJrZXJUeXBlID49IDB4RDAgJiYgbWFya2VyVHlwZSA8PSAweEQ5KSB8fCBtYXJrZXJUeXBlID09PSAweERBKSB7XG5cdFx0XHRcdGxlbiA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZW4gPSBzdHJlYW0ubmV4dFVJbnQxNigpIC0gMjtcblx0XHRcdH1cblx0XHRcdGl0ZXJhdG9yKG1hcmtlclR5cGUsIHN0cmVhbS5icmFuY2goMCwgbGVuKSk7XG5cdFx0XHRzdHJlYW0uc2tpcChsZW4pO1xuXHRcdH1cblx0fSxcblx0Ly9zdHJlYW0gc2hvdWxkIGJlIGxvY2F0ZWQgYWZ0ZXIgU09GIHNlY3Rpb24gc2l6ZSBhbmQgaW4gYmlnIGVuZGlhbiBtb2RlLCBsaWtlIHBhc3NlZCB0byBwYXJzZVNlY3Rpb25zIGl0ZXJhdG9yXG5cdGdldFNpemVGcm9tU09GU2VjdGlvbjogZnVuY3Rpb24oc3RyZWFtKSB7XG5cdFx0c3RyZWFtLnNraXAoMSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlaWdodDogc3RyZWFtLm5leHRVSW50MTYoKSxcblx0XHRcdHdpZHRoOiBzdHJlYW0ubmV4dFVJbnQxNigpXG5cdFx0fTtcblx0fSxcblx0Z2V0U2VjdGlvbk5hbWU6IGZ1bmN0aW9uKG1hcmtlclR5cGUpIHtcblx0XHR2YXIgbmFtZSwgaW5kZXg7XG5cdFx0c3dpdGNoKG1hcmtlclR5cGUpIHtcblx0XHRcdGNhc2UgMHhEODogbmFtZSA9ICdTT0knOyBicmVhaztcblx0XHRcdGNhc2UgMHhDNDogbmFtZSA9ICdESFQnOyBicmVhaztcblx0XHRcdGNhc2UgMHhEQjogbmFtZSA9ICdEUVQnOyBicmVhaztcblx0XHRcdGNhc2UgMHhERDogbmFtZSA9ICdEUkknOyBicmVhaztcblx0XHRcdGNhc2UgMHhEQTogbmFtZSA9ICdTT1MnOyBicmVhaztcblx0XHRcdGNhc2UgMHhGRTogbmFtZSA9ICdDT00nOyBicmVhaztcblx0XHRcdGNhc2UgMHhEOTogbmFtZSA9ICdFT0knOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGlmKG1hcmtlclR5cGUgPj0gMHhFMCAmJiBtYXJrZXJUeXBlIDw9IDB4RUYpIHtcblx0XHRcdFx0XHRuYW1lID0gJ0FQUCc7XG5cdFx0XHRcdFx0aW5kZXggPSBtYXJrZXJUeXBlIC0gMHhFMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKG1hcmtlclR5cGUgPj0gMHhDMCAmJiBtYXJrZXJUeXBlIDw9IDB4Q0YgJiYgbWFya2VyVHlwZSAhPT0gMHhDNCAmJiBtYXJrZXJUeXBlICE9PSAweEM4ICYmIG1hcmtlclR5cGUgIT09IDB4Q0MpIHtcblx0XHRcdFx0XHRuYW1lID0gJ1NPRic7XG5cdFx0XHRcdFx0aW5kZXggPSBtYXJrZXJUeXBlIC0gMHhDMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKG1hcmtlclR5cGUgPj0gMHhEMCAmJiBtYXJrZXJUeXBlIDw9IDB4RDcpIHtcblx0XHRcdFx0XHRuYW1lID0gJ1JTVCc7XG5cdFx0XHRcdFx0aW5kZXggPSBtYXJrZXJUeXBlIC0gMHhEMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dmFyIG5hbWVTdHJ1Y3QgPSB7XG5cdFx0XHRuYW1lOiBuYW1lXG5cdFx0fTtcblx0XHRpZih0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG5cdFx0XHRuYW1lU3RydWN0LmluZGV4ID0gaW5kZXg7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lU3RydWN0O1xuXHR9XG59OyIsIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIGRldmVsOiB0cnVlLCBiaXR3aXNlOiBmYWxzZSwgZGVidWc6IHRydWUsIGVxZXE6IGZhbHNlLCBlczU6IHRydWUsIGV2aWw6IGZhbHNlLCBmb3JpbjogZmFsc2UsIG5ld2NhcDogZmFsc2UsIG5vbWVuOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSwgcmVnZXhwOiBmYWxzZSwgdW5wYXJhbTogZmFsc2UsIHNsb3BweTogdHJ1ZSwgc3R1cGlkOiBmYWxzZSwgc3ViOiBmYWxzZSwgdG9kbzogdHJ1ZSwgdmFyczogdHJ1ZSwgd2hpdGU6IHRydWUgKi9cblxudmFyIGpwZWcgPSByZXF1aXJlKCcuL2pwZWcnKSxcblx0ZXhpZiA9IHJlcXVpcmUoJy4vZXhpZicpLFxuXHRzaW1wbGlmeSA9IHJlcXVpcmUoJy4vc2ltcGxpZnknKTtcblxuZnVuY3Rpb24gRXhpZlJlc3VsdChzdGFydE1hcmtlciwgdGFncywgaW1hZ2VTaXplLCB0aHVtYm5haWxPZmZzZXQsIHRodW1ibmFpbExlbmd0aCwgdGh1bWJuYWlsVHlwZSwgYXBwMU9mZnNldCkge1xuXHR0aGlzLnN0YXJ0TWFya2VyID0gc3RhcnRNYXJrZXI7XG5cdHRoaXMudGFncyA9IHRhZ3M7XG5cdHRoaXMuaW1hZ2VTaXplID0gaW1hZ2VTaXplO1xuXHR0aGlzLnRodW1ibmFpbE9mZnNldCA9IHRodW1ibmFpbE9mZnNldDtcblx0dGhpcy50aHVtYm5haWxMZW5ndGggPSB0aHVtYm5haWxMZW5ndGg7XG5cdHRoaXMudGh1bWJuYWlsVHlwZSA9IHRodW1ibmFpbFR5cGU7XG5cdHRoaXMuYXBwMU9mZnNldCA9IGFwcDFPZmZzZXQ7XG59XG5cbkV4aWZSZXN1bHQucHJvdG90eXBlID0ge1xuXHRoYXNUaHVtYm5haWw6IGZ1bmN0aW9uKG1pbWUpIHtcblx0XHRpZighdGhpcy50aHVtYm5haWxPZmZzZXQgfHwgIXRoaXMudGh1bWJuYWlsTGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBtaW1lICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmKG1pbWUudG9Mb3dlckNhc2UoKS50cmltKCkgPT09ICdpbWFnZS9qcGVnJykge1xuXHRcdFx0cmV0dXJuIHRoaXMudGh1bWJuYWlsVHlwZSA9PT0gNjtcblx0XHR9XG5cdFx0aWYobWltZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSA9PT0gJ2ltYWdlL3RpZmYnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aHVtYm5haWxUeXBlID09PSAxO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdGdldFRodW1ibmFpbE9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwMU9mZnNldCArIDYgKyB0aGlzLnRodW1ibmFpbE9mZnNldDtcblx0fSxcblx0Z2V0VGh1bWJuYWlsTGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50aHVtYm5haWxMZW5ndGg7XG5cdH0sXG5cdGdldFRodW1ibmFpbEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldFRodW1ibmFpbFN0cmVhbSgpLm5leHRCdWZmZXIodGhpcy50aHVtYm5haWxMZW5ndGgpO1xuXHR9LFxuXHRfZ2V0VGh1bWJuYWlsU3RyZWFtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGFydE1hcmtlci5vcGVuV2l0aE9mZnNldCh0aGlzLmdldFRodW1ibmFpbE9mZnNldCgpKTtcblx0fSxcblx0Z2V0SW1hZ2VTaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pbWFnZVNpemU7XG5cdH0sXG5cdGdldFRodW1ibmFpbFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdHJlYW0gPSB0aGlzLl9nZXRUaHVtYm5haWxTdHJlYW0oKSwgc2l6ZTtcblx0XHRqcGVnLnBhcnNlU2VjdGlvbnMoc3RyZWFtLCBmdW5jdGlvbihzZWN0aW9uVHlwZSwgc2VjdGlvblN0cmVhbSkge1xuXHRcdFx0aWYoanBlZy5nZXRTZWN0aW9uTmFtZShzZWN0aW9uVHlwZSkubmFtZSA9PT0gJ1NPRicpIHtcblx0XHRcdFx0c2l6ZSA9IGpwZWcuZ2V0U2l6ZUZyb21TT0ZTZWN0aW9uKHNlY3Rpb25TdHJlYW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzaXplO1xuXHR9XG59O1xuXG5mdW5jdGlvbiBQYXJzZXIoc3RyZWFtKSB7XG5cdHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuXHR0aGlzLmZsYWdzID0ge1xuXHRcdHJlYWRCaW5hcnlUYWdzOiBmYWxzZSxcblx0XHRyZXNvbHZlVGFnTmFtZXM6IHRydWUsXG5cdFx0c2ltcGxpZnlWYWx1ZXM6IHRydWUsXG5cdFx0aW1hZ2VTaXplOiB0cnVlLFxuXHRcdGhpZGVQb2ludGVyczogdHJ1ZSxcblx0XHRyZXR1cm5UYWdzOiB0cnVlXG5cdH07XG59XG5cblBhcnNlci5wcm90b3R5cGUgPSB7XG5cdGVuYWJsZUJpbmFyeUZpZWxkczogZnVuY3Rpb24oZW5hYmxlKSB7XG5cdFx0dGhpcy5mbGFncy5yZWFkQmluYXJ5VGFncyA9ICEhZW5hYmxlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRlbmFibGVQb2ludGVyczogZnVuY3Rpb24oZW5hYmxlKSB7XG5cdFx0dGhpcy5mbGFncy5oaWRlUG9pbnRlcnMgPSAhZW5hYmxlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRlbmFibGVUYWdOYW1lczogZnVuY3Rpb24oZW5hYmxlKSB7XG5cdFx0dGhpcy5mbGFncy5yZXNvbHZlVGFnTmFtZXMgPSAhIWVuYWJsZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0ZW5hYmxlSW1hZ2VTaXplOiBmdW5jdGlvbihlbmFibGUpIHtcblx0XHR0aGlzLmZsYWdzLmltYWdlU2l6ZSA9ICEhZW5hYmxlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRlbmFibGVSZXR1cm5UYWdzOiBmdW5jdGlvbihlbmFibGUpIHtcblx0XHR0aGlzLmZsYWdzLnJldHVyblRhZ3MgPSAhIWVuYWJsZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0ZW5hYmxlU2ltcGxlVmFsdWVzOiBmdW5jdGlvbihlbmFibGUpIHtcblx0XHR0aGlzLmZsYWdzLnNpbXBsaWZ5VmFsdWVzID0gISFlbmFibGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdHBhcnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLnN0cmVhbS5tYXJrKCksXG5cdFx0XHRzdHJlYW0gPSBzdGFydC5vcGVuV2l0aE9mZnNldCgwKSxcblx0XHRcdGZsYWdzID0gdGhpcy5mbGFncyxcblx0XHRcdHRhZ3MsXG5cdFx0XHRpbWFnZVNpemUsXG5cdFx0XHR0aHVtYm5haWxPZmZzZXQsXG5cdFx0XHR0aHVtYm5haWxMZW5ndGgsXG5cdFx0XHR0aHVtYm5haWxUeXBlLFxuXHRcdFx0YXBwMU9mZnNldCxcblx0XHRcdHRhZ05hbWVzLFxuXHRcdFx0Z2V0VGFnVmFsdWUsIHNldFRhZ1ZhbHVlO1xuXHRcdGlmKGZsYWdzLnJlc29sdmVUYWdOYW1lcykge1xuXHRcdFx0dGFnTmFtZXMgPSByZXF1aXJlKCcuL2V4aWYtdGFncycpO1xuXHRcdH1cblx0XHRpZihmbGFncy5yZXNvbHZlVGFnTmFtZXMpIHtcblx0XHRcdHRhZ3MgPSB7fTtcblx0XHRcdGdldFRhZ1ZhbHVlID0gZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdGFnc1t0Lm5hbWVdO1xuXHRcdFx0fTtcblx0XHRcdHNldFRhZ1ZhbHVlID0gZnVuY3Rpb24odCwgdmFsdWUpIHtcblx0XHRcdFx0dGFnc1t0Lm5hbWVdID0gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWdzID0gW107XG5cdFx0XHRnZXRUYWdWYWx1ZSA9IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGZvcihpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRpZih0YWdzW2ldLnR5cGUgPT09IHQudHlwZSAmJiB0YWdzW2ldLnNlY3Rpb24gPT09IHQuc2VjdGlvbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRhZ3MudmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0c2V0VGFnVmFsdWUgPSBmdW5jdGlvbih0LCB2YWx1ZSkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGlmKHRhZ3NbaV0udHlwZSA9PT0gdC50eXBlICYmIHRhZ3NbaV0uc2VjdGlvbiA9PT0gdC5zZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHR0YWdzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGpwZWcucGFyc2VTZWN0aW9ucyhzdHJlYW0sIGZ1bmN0aW9uKHNlY3Rpb25UeXBlLCBzZWN0aW9uU3RyZWFtKSB7XG5cdFx0XHR2YXIgdmFsaWRFeGlmSGVhZGVycywgc2VjdGlvbk9mZnNldCA9IHNlY3Rpb25TdHJlYW0ub2Zmc2V0RnJvbShzdGFydCk7XG5cdFx0XHRpZihzZWN0aW9uVHlwZSA9PT0gMHhFMSkge1xuXHRcdFx0XHR2YWxpZEV4aWZIZWFkZXJzID0gZXhpZi5wYXJzZVRhZ3Moc2VjdGlvblN0cmVhbSwgZnVuY3Rpb24oaWZkU2VjdGlvbiwgdGFnVHlwZSwgdmFsdWUsIGZvcm1hdCkge1xuXHRcdFx0XHRcdC8vaWdub3JlIGJpbmFyeSBmaWVsZHMgaWYgZGlzYWJsZWRcblx0XHRcdFx0XHRpZighZmxhZ3MucmVhZEJpbmFyeVRhZ3MgJiYgZm9ybWF0ID09PSA3KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYodGFnVHlwZSA9PT0gMHgwMjAxKSB7XG5cdFx0XHRcdFx0XHR0aHVtYm5haWxPZmZzZXQgPSB2YWx1ZVswXTtcblx0XHRcdFx0XHRcdGlmKGZsYWdzLmhpZGVQb2ludGVycykge3JldHVybjt9XG5cdFx0XHRcdFx0fSBlbHNlIGlmKHRhZ1R5cGUgPT09IDB4MDIwMikge1xuXHRcdFx0XHRcdFx0dGh1bWJuYWlsTGVuZ3RoID0gdmFsdWVbMF07XG5cdFx0XHRcdFx0XHRpZihmbGFncy5oaWRlUG9pbnRlcnMpIHtyZXR1cm47fVxuXHRcdFx0XHRcdH0gZWxzZSBpZih0YWdUeXBlID09PSAweDAxMDMpIHtcblx0XHRcdFx0XHRcdHRodW1ibmFpbFR5cGUgPSB2YWx1ZVswXTtcblx0XHRcdFx0XHRcdGlmKGZsYWdzLmhpZGVQb2ludGVycykge3JldHVybjt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaWYgZmxhZyBpcyBzZXQgdG8gbm90IHN0b3JlIHRhZ3MsIHJldHVybiBoZXJlIGFmdGVyIHN0b3JpbmcgcG9pbnRlcnNcblx0XHRcdFx0XHRpZighZmxhZ3MucmV0dXJuVGFncykge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGZsYWdzLnNpbXBsaWZ5VmFsdWVzKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHNpbXBsaWZ5LnNpbXBsaWZ5VmFsdWUodmFsdWUsIGZvcm1hdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGZsYWdzLnJlc29sdmVUYWdOYW1lcykge1xuXHRcdFx0XHRcdFx0dmFyIHNlY3Rpb25UYWdOYW1lcyA9IGlmZFNlY3Rpb24gPT09IGV4aWYuR1BTSUZEID8gdGFnTmFtZXMuZ3BzIDogdGFnTmFtZXMuZXhpZjtcblx0XHRcdFx0XHRcdHZhciBuYW1lID0gc2VjdGlvblRhZ05hbWVzW3RhZ1R5cGVdO1xuXHRcdFx0XHRcdFx0aWYoIW5hbWUpIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IHRhZ05hbWVzLmV4aWZbdGFnVHlwZV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0dGFnc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YWdzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRzZWN0aW9uOiBpZmRTZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiB0YWdUeXBlLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmKHZhbGlkRXhpZkhlYWRlcnMpIHtcblx0XHRcdFx0XHRhcHAxT2Zmc2V0ID0gc2VjdGlvbk9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihmbGFncy5pbWFnZVNpemUgJiYganBlZy5nZXRTZWN0aW9uTmFtZShzZWN0aW9uVHlwZSkubmFtZSA9PT0gJ1NPRicpIHtcblx0XHRcdFx0aW1hZ2VTaXplID0ganBlZy5nZXRTaXplRnJvbVNPRlNlY3Rpb24oc2VjdGlvblN0cmVhbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZihmbGFncy5zaW1wbGlmeVZhbHVlcykge1xuXHRcdFx0c2ltcGxpZnkuY2FzdERlZ3JlZVZhbHVlcyhnZXRUYWdWYWx1ZSwgc2V0VGFnVmFsdWUpO1xuXHRcdFx0c2ltcGxpZnkuY2FzdERhdGVWYWx1ZXMoZ2V0VGFnVmFsdWUsIHNldFRhZ1ZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEV4aWZSZXN1bHQoc3RhcnQsIHRhZ3MsIGltYWdlU2l6ZSwgdGh1bWJuYWlsT2Zmc2V0LCB0aHVtYm5haWxMZW5ndGgsIHRodW1ibmFpbFR5cGUsIGFwcDFPZmZzZXQpO1xuXHR9XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG4iLCJ2YXIgZXhpZiA9IHJlcXVpcmUoJy4vZXhpZicpO1xudmFyIGRhdGUgPSByZXF1aXJlKCcuL2RhdGUnKTtcblxudmFyIGRlZ3JlZVRhZ3MgPSBbe1xuXHRzZWN0aW9uOiBleGlmLkdQU0lGRCxcblx0dHlwZTogMHgwMDAyLFxuXHRuYW1lOiAnR1BTTGF0aXR1ZGUnLFxuXHRyZWZUeXBlOiAweDAwMDEsXG5cdHJlZk5hbWU6ICdHUFNMYXRpdHVkZVJlZicsXG5cdHBvc1ZhbDogJ04nXG59LFxue1xuXHRzZWN0aW9uOiBleGlmLkdQU0lGRCxcblx0dHlwZTogMHgwMDA0LFxuXHRuYW1lOiAnR1BTTG9uZ2l0dWRlJyxcblx0cmVmVHlwZTogMHgwMDAzLFxuXHRyZWZOYW1lOiAnR1BTTG9uZ2l0dWRlUmVmJyxcblx0cG9zVmFsOiAnRSdcbn1dO1xudmFyIGRhdGVUYWdzID0gW3tcblx0c2VjdGlvbjogZXhpZi5TdWJJRkQsXG5cdHR5cGU6IDB4MDEzMixcblx0bmFtZTogJ01vZGlmeURhdGUnXG59LFxue1xuXHRzZWN0aW9uOiBleGlmLlN1YklGRCxcblx0dHlwZTogMHg5MDAzLFxuXHRuYW1lOiAnRGF0ZVRpbWVPcmlnaW5hbCdcbn0sXG57XG5cdHNlY3Rpb246IGV4aWYuU3ViSUZELFxuXHR0eXBlOiAweDkwMDQsXG5cdG5hbWU6ICdDcmVhdGVEYXRlJ1xufSxcbntcblx0c2VjdGlvbjogZXhpZi5TdWJJRkQsXG5cdHR5cGU6IDB4MDEzMixcblx0bmFtZSA6ICdNb2RpZnlEYXRlJyxcbn1dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y2FzdERlZ3JlZVZhbHVlczogZnVuY3Rpb24oZ2V0VGFnVmFsdWUsIHNldFRhZ1ZhbHVlKSB7XG5cdFx0ZGVncmVlVGFncy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBkZWdyZWVWYWwgPSBnZXRUYWdWYWx1ZSh0KTtcblx0XHRcdGlmKGRlZ3JlZVZhbCkge1xuXHRcdFx0XHR2YXIgZGVncmVlUmVmID0gZ2V0VGFnVmFsdWUoe3NlY3Rpb246IHQuc2VjdGlvbiwgdHlwZTogdC5yZWZUeXBlLCBuYW1lOiB0LnJlZk5hbWV9KTtcblx0XHRcdFx0dmFyIGRlZ3JlZU51bVJlZiA9IGRlZ3JlZVJlZiA9PT0gdC5wb3NWYWwgPyAxIDogLTE7XG5cdFx0XHRcdHZhciBkZWdyZWUgPSAoZGVncmVlVmFsWzBdICsgKGRlZ3JlZVZhbFsxXSAvIDYwKSArIChkZWdyZWVWYWxbMl0gLyAzNjAwKSkgKiBkZWdyZWVOdW1SZWY7XG5cdFx0XHRcdHNldFRhZ1ZhbHVlKHQsIGRlZ3JlZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGNhc3REYXRlVmFsdWVzOiBmdW5jdGlvbihnZXRUYWdWYWx1ZSwgc2V0VGFnVmFsdWUpIHtcblx0XHRkYXRlVGFncy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBkYXRlU3RyVmFsID0gZ2V0VGFnVmFsdWUodCk7XG5cdFx0XHRpZihkYXRlU3RyVmFsKSB7XG5cdFx0XHRcdC8vc29tZSBlYXN5IGNoZWNrcyB0byBkZXRlcm1pbmUgdHdvIGNvbW1vbiBkYXRlIGZvcm1hdHNcblx0XHRcdFx0dmFyIHRpbWVzdGFtcCA9IGRhdGUucGFyc2VFeGlmRGF0ZShkYXRlU3RyVmFsKTtcblx0XHRcdFx0aWYodHlwZW9mIHRpbWVzdGFtcCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRzZXRUYWdWYWx1ZSh0LCB0aW1lc3RhbXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdHNpbXBsaWZ5VmFsdWU6IGZ1bmN0aW9uKHZhbHVlcywgZm9ybWF0KSB7XG5cdFx0aWYoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHR2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmKGZvcm1hdCA9PT0gMTAgfHwgZm9ybWF0ID09PSA1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlWzBdIC8gdmFsdWVbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSk7XG5cdFx0XHRpZih2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHZhbHVlcyA9IHZhbHVlc1swXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHRvQnl0ZXMgPSBzID0+IFsuLi5zXS5tYXAoYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuY29uc3QgeHBpWmlwRmlsZW5hbWUgPSB0b0J5dGVzKCdNRVRBLUlORi9tb3ppbGxhLnJzYScpO1xuY29uc3Qgb3htbENvbnRlbnRUeXBlcyA9IHRvQnl0ZXMoJ1tDb250ZW50X1R5cGVzXS54bWwnKTtcbmNvbnN0IG94bWxSZWxzID0gdG9CeXRlcygnX3JlbHMvLnJlbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnB1dCA9PiB7XG5cdGNvbnN0IGJ1ZiA9IGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGlucHV0IDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuXG5cdGlmICghKGJ1ZiAmJiBidWYubGVuZ3RoID4gMSkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IGNoZWNrID0gKGhlYWRlciwgb3B0aW9ucykgPT4ge1xuXHRcdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdG9mZnNldDogMFxuXHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdC8vIElmIGEgYml0bWFzayBpcyBzZXRcblx0XHRcdGlmIChvcHRpb25zLm1hc2spIHtcblx0XHRcdFx0Ly8gSWYgaGVhZGVyIGRvZXNuJ3QgZXF1YWwgYGJ1ZmAgd2l0aCBiaXRzIG1hc2tlZCBvZmZcblx0XHRcdFx0aWYgKGhlYWRlcltpXSAhPT0gKG9wdGlvbnMubWFza1tpXSAmIGJ1ZltpICsgb3B0aW9ucy5vZmZzZXRdKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChoZWFkZXJbaV0gIT09IGJ1ZltpICsgb3B0aW9ucy5vZmZzZXRdKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRjb25zdCBjaGVja1N0cmluZyA9IChoZWFkZXIsIG9wdGlvbnMpID0+IGNoZWNrKHRvQnl0ZXMoaGVhZGVyKSwgb3B0aW9ucyk7XG5cblx0aWYgKGNoZWNrKFsweEZGLCAweEQ4LCAweEZGXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnanBnJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9qcGVnJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4ODksIDB4NTAsIDB4NEUsIDB4NDcsIDB4MEQsIDB4MEEsIDB4MUEsIDB4MEFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdwbmcnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3BuZydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQ3LCAweDQ5LCAweDQ2XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnZ2lmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9naWYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg1NywgMHg0NSwgMHg0MiwgMHg1MF0sIHtvZmZzZXQ6IDh9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3ZWJwJyxcblx0XHRcdG1pbWU6ICdpbWFnZS93ZWJwJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDYsIDB4NEMsIDB4NDksIDB4NDZdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdmbGlmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9mbGlmJ1xuXHRcdH07XG5cdH1cblxuXHQvLyBOZWVkcyB0byBiZSBiZWZvcmUgYHRpZmAgY2hlY2tcblx0aWYgKFxuXHRcdChjaGVjayhbMHg0OSwgMHg0OSwgMHgyQSwgMHgwXSkgfHwgY2hlY2soWzB4NEQsIDB4NEQsIDB4MCwgMHgyQV0pKSAmJlxuXHRcdGNoZWNrKFsweDQzLCAweDUyXSwge29mZnNldDogOH0pXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdjcjInLFxuXHRcdFx0bWltZTogJ2ltYWdlL3gtY2Fub24tY3IyJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4NDksIDB4NDksIDB4MkEsIDB4MF0pIHx8XG5cdFx0Y2hlY2soWzB4NEQsIDB4NEQsIDB4MCwgMHgyQV0pXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd0aWYnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3RpZmYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0MiwgMHg0RF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2JtcCcsXG5cdFx0XHRtaW1lOiAnaW1hZ2UvYm1wJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDksIDB4NDksIDB4QkNdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdqeHInLFxuXHRcdFx0bWltZTogJ2ltYWdlL3ZuZC5tcy1waG90bydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDM4LCAweDQyLCAweDUwLCAweDUzXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncHNkJyxcblx0XHRcdG1pbWU6ICdpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wJ1xuXHRcdH07XG5cdH1cblxuXHQvLyBaaXAtYmFzZWQgZmlsZSBmb3JtYXRzXG5cdC8vIE5lZWQgdG8gYmUgYmVmb3JlIHRoZSBgemlwYCBjaGVja1xuXHRpZiAoY2hlY2soWzB4NTAsIDB4NEIsIDB4MywgMHg0XSkpIHtcblx0XHRpZiAoXG5cdFx0XHRjaGVjayhbMHg2RCwgMHg2OSwgMHg2RCwgMHg2NSwgMHg3NCwgMHg3OSwgMHg3MCwgMHg2NSwgMHg2MSwgMHg3MCwgMHg3MCwgMHg2QywgMHg2OSwgMHg2MywgMHg2MSwgMHg3NCwgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRiwgMHg2NSwgMHg3MCwgMHg3NSwgMHg2MiwgMHgyQiwgMHg3QSwgMHg2OSwgMHg3MF0sIHtvZmZzZXQ6IDMwfSlcblx0XHQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2VwdWInLFxuXHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vZXB1Yit6aXAnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEFzc3VtZXMgc2lnbmVkIGAueHBpYCBmcm9tIGFkZG9ucy5tb3ppbGxhLm9yZ1xuXHRcdGlmIChjaGVjayh4cGlaaXBGaWxlbmFtZSwge29mZnNldDogMzB9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAneHBpJyxcblx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gteHBpbnN0YWxsJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2tTdHJpbmcoJ21pbWV0eXBlYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0Jywge29mZnNldDogMzB9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2R0Jyxcblx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dCdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrU3RyaW5nKCdtaW1ldHlwZWFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXQnLCB7b2Zmc2V0OiAzMH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdvZHMnLFxuXHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrU3RyaW5nKCdtaW1ldHlwZWFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uJywge29mZnNldDogMzB9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2RwJyxcblx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBUaGUgZG9jeCwgeGxzeCBhbmQgcHB0eCBmaWxlIHR5cGVzIGV4dGVuZCB0aGUgT2ZmaWNlIE9wZW4gWE1MIGZpbGUgZm9ybWF0OlxuXHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09mZmljZV9PcGVuX1hNTF9maWxlX2Zvcm1hdHNcblx0XHQvLyBXZSBsb29rIGZvcjpcblx0XHQvLyAtIG9uZSBlbnRyeSBuYW1lZCAnW0NvbnRlbnRfVHlwZXNdLnhtbCcgb3IgJ19yZWxzLy5yZWxzJyxcblx0XHQvLyAtIG9uZSBlbnRyeSBpbmRpY2F0aW5nIHNwZWNpZmljIHR5cGUgb2YgZmlsZS5cblx0XHQvLyBNUyBPZmZpY2UsIE9wZW5PZmZpY2UgYW5kIExpYnJlT2ZmaWNlIG1heSBwdXQgdGhlIHBhcnRzIGluIGRpZmZlcmVudCBvcmRlciwgc28gdGhlIGNoZWNrIHNob3VsZCBub3QgcmVseSBvbiBpdC5cblx0XHRjb25zdCBmaW5kTmV4dFppcEhlYWRlckluZGV4ID0gKGFyciwgc3RhcnRBdCA9IDApID0+IGFyci5maW5kSW5kZXgoKGVsLCBpLCBhcnIpID0+IGkgPj0gc3RhcnRBdCAmJiBhcnJbaV0gPT09IDB4NTAgJiYgYXJyW2kgKyAxXSA9PT0gMHg0QiAmJiBhcnJbaSArIDJdID09PSAweDMgJiYgYXJyW2kgKyAzXSA9PT0gMHg0KTtcblxuXHRcdGxldCB6aXBIZWFkZXJJbmRleCA9IDA7IC8vIFRoZSBmaXJzdCB6aXAgaGVhZGVyIHdhcyBhbHJlYWR5IGZvdW5kIGF0IGluZGV4IDBcblx0XHRsZXQgb3htbEZvdW5kID0gZmFsc2U7XG5cdFx0bGV0IHR5cGUgPSBudWxsO1xuXG5cdFx0ZG8ge1xuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gemlwSGVhZGVySW5kZXggKyAzMDtcblxuXHRcdFx0aWYgKCFveG1sRm91bmQpIHtcblx0XHRcdFx0b3htbEZvdW5kID0gKGNoZWNrKG94bWxDb250ZW50VHlwZXMsIHtvZmZzZXR9KSB8fCBjaGVjayhveG1sUmVscywge29mZnNldH0pKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0eXBlKSB7XG5cdFx0XHRcdGlmIChjaGVja1N0cmluZygnd29yZC8nLCB7b2Zmc2V0fSkpIHtcblx0XHRcdFx0XHR0eXBlID0ge1xuXHRcdFx0XHRcdFx0ZXh0OiAnZG9jeCcsXG5cdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaGVja1N0cmluZygncHB0LycsIHtvZmZzZXR9KSkge1xuXHRcdFx0XHRcdHR5cGUgPSB7XG5cdFx0XHRcdFx0XHRleHQ6ICdwcHR4Jyxcblx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hlY2tTdHJpbmcoJ3hsLycsIHtvZmZzZXR9KSkge1xuXHRcdFx0XHRcdHR5cGUgPSB7XG5cdFx0XHRcdFx0XHRleHQ6ICd4bHN4Jyxcblx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChveG1sRm91bmQgJiYgdHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gdHlwZTtcblx0XHRcdH1cblxuXHRcdFx0emlwSGVhZGVySW5kZXggPSBmaW5kTmV4dFppcEhlYWRlckluZGV4KGJ1Ziwgb2Zmc2V0KTtcblx0XHR9IHdoaWxlICh6aXBIZWFkZXJJbmRleCA+PSAwKTtcblxuXHRcdC8vIE5vIG1vcmUgemlwIHBhcnRzIGF2YWlsYWJsZSBpbiB0aGUgYnVmZmVyLCBidXQgbWF5YmUgd2UgYXJlIGFsbW9zdCBjZXJ0YWluIGFib3V0IHRoZSB0eXBlP1xuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4NTAsIDB4NEJdKSAmJlxuXHRcdChidWZbMl0gPT09IDB4MyB8fCBidWZbMl0gPT09IDB4NSB8fCBidWZbMl0gPT09IDB4NykgJiZcblx0XHQoYnVmWzNdID09PSAweDQgfHwgYnVmWzNdID09PSAweDYgfHwgYnVmWzNdID09PSAweDgpXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd6aXAnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ppcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDc1LCAweDczLCAweDc0LCAweDYxLCAweDcyXSwge29mZnNldDogMjU3fSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAndGFyJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXRhcidcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweDUyLCAweDYxLCAweDcyLCAweDIxLCAweDFBLCAweDddKSAmJlxuXHRcdChidWZbNl0gPT09IDB4MCB8fCBidWZbNl0gPT09IDB4MSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3JhcicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDFGLCAweDhCLCAweDhdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdneicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vZ3ppcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQyLCAweDVBLCAweDY4XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYnoyJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWJ6aXAyJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MzcsIDB4N0EsIDB4QkMsIDB4QUYsIDB4MjcsIDB4MUNdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICc3eicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NzgsIDB4MDFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdkbWcnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtYXBwbGUtZGlza2ltYWdlJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MzMsIDB4NjcsIDB4NzAsIDB4MzVdKSB8fCAvLyAzZ3A1XG5cdFx0KFxuXHRcdFx0Y2hlY2soWzB4MCwgMHgwLCAweDBdKSAmJiBjaGVjayhbMHg2NiwgMHg3NCwgMHg3OSwgMHg3MF0sIHtvZmZzZXQ6IDR9KSAmJlxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0Y2hlY2soWzB4NkQsIDB4NzAsIDB4MzQsIDB4MzFdLCB7b2Zmc2V0OiA4fSkgfHwgLy8gTVA0MVxuXHRcdFx0XHRcdGNoZWNrKFsweDZELCAweDcwLCAweDM0LCAweDMyXSwge29mZnNldDogOH0pIHx8IC8vIE1QNDJcblx0XHRcdFx0XHRjaGVjayhbMHg2OSwgMHg3MywgMHg2RiwgMHg2RF0sIHtvZmZzZXQ6IDh9KSB8fCAvLyBJU09NXG5cdFx0XHRcdFx0Y2hlY2soWzB4NjksIDB4NzMsIDB4NkYsIDB4MzJdLCB7b2Zmc2V0OiA4fSkgfHwgLy8gSVNPMlxuXHRcdFx0XHRcdGNoZWNrKFsweDZELCAweDZELCAweDcwLCAweDM0XSwge29mZnNldDogOH0pIHx8IC8vIE1NUDRcblx0XHRcdFx0XHRjaGVjayhbMHg0RCwgMHgzNCwgMHg1Nl0sIHtvZmZzZXQ6IDh9KSB8fCAvLyBNNFZcblx0XHRcdFx0XHRjaGVjayhbMHg2NCwgMHg2MSwgMHg3MywgMHg2OF0sIHtvZmZzZXQ6IDh9KSAvLyBEQVNIXG5cdFx0XHRcdClcblx0XHQpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21wNCcsXG5cdFx0XHRtaW1lOiAndmlkZW8vbXA0J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NEQsIDB4NTQsIDB4NjgsIDB4NjRdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdtaWQnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL21pZGknXG5cdFx0fTtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aHJlYXRzdGFjay9saWJtYWdpYy9ibG9iL21hc3Rlci9tYWdpYy9NYWdkaXIvbWF0cm9za2Fcblx0aWYgKGNoZWNrKFsweDFBLCAweDQ1LCAweERGLCAweEEzXSkpIHtcblx0XHRjb25zdCBzbGljZWQgPSBidWYuc3ViYXJyYXkoNCwgNCArIDQwOTYpO1xuXHRcdGNvbnN0IGlkUG9zID0gc2xpY2VkLmZpbmRJbmRleCgoZWwsIGksIGFycikgPT4gYXJyW2ldID09PSAweDQyICYmIGFycltpICsgMV0gPT09IDB4ODIpO1xuXG5cdFx0aWYgKGlkUG9zICE9PSAtMSkge1xuXHRcdFx0Y29uc3QgZG9jVHlwZVBvcyA9IGlkUG9zICsgMztcblx0XHRcdGNvbnN0IGZpbmREb2NUeXBlID0gdHlwZSA9PiBbLi4udHlwZV0uZXZlcnkoKGMsIGkpID0+IHNsaWNlZFtkb2NUeXBlUG9zICsgaV0gPT09IGMuY2hhckNvZGVBdCgwKSk7XG5cblx0XHRcdGlmIChmaW5kRG9jVHlwZSgnbWF0cm9za2EnKSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGV4dDogJ21rdicsXG5cdFx0XHRcdFx0bWltZTogJ3ZpZGVvL3gtbWF0cm9za2EnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmaW5kRG9jVHlwZSgnd2VibScpKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXh0OiAnd2VibScsXG5cdFx0XHRcdFx0bWltZTogJ3ZpZGVvL3dlYm0nXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAsIDB4MCwgMHgwLCAweDE0LCAweDY2LCAweDc0LCAweDc5LCAweDcwLCAweDcxLCAweDc0LCAweDIwLCAweDIwXSkgfHxcblx0XHRjaGVjayhbMHg2NiwgMHg3MiwgMHg2NSwgMHg2NV0sIHtvZmZzZXQ6IDR9KSB8fFxuXHRcdGNoZWNrKFsweDY2LCAweDc0LCAweDc5LCAweDcwLCAweDcxLCAweDc0LCAweDIwLCAweDIwXSwge29mZnNldDogNH0pIHx8XG5cdFx0Y2hlY2soWzB4NkQsIDB4NjQsIDB4NjEsIDB4NzRdLCB7b2Zmc2V0OiA0fSkgfHwgLy8gTUpQRUdcblx0XHRjaGVjayhbMHg3NywgMHg2OSwgMHg2NCwgMHg2NV0sIHtvZmZzZXQ6IDR9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdtb3YnLFxuXHRcdFx0bWltZTogJ3ZpZGVvL3F1aWNrdGltZSdcblx0XHR9O1xuXHR9XG5cblx0Ly8gUklGRiBmaWxlIGZvcm1hdCB3aGljaCBtaWdodCBiZSBBVkksIFdBViwgUUNQLCBldGNcblx0aWYgKGNoZWNrKFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSkpIHtcblx0XHRpZiAoY2hlY2soWzB4NDEsIDB4NTYsIDB4NDldLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2F2aScsXG5cdFx0XHRcdG1pbWU6ICd2aWRlby92bmQuYXZpJ1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0aWYgKGNoZWNrKFsweDU3LCAweDQxLCAweDU2LCAweDQ1XSwge29mZnNldDogOH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICd3YXYnLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vdm5kLndhdmUnXG5cdFx0XHR9O1xuXHRcdH1cblx0XHQvLyBRTENNLCBRQ1AgZmlsZVxuXHRcdGlmIChjaGVjayhbMHg1MSwgMHg0QywgMHg0MywgMHg0RF0sIHtvZmZzZXQ6IDh9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAncWNwJyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL3FjZWxwJ1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MzAsIDB4MjYsIDB4QjIsIDB4NzUsIDB4OEUsIDB4NjYsIDB4Q0YsIDB4MTEsIDB4QTYsIDB4RDldKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3bXYnLFxuXHRcdFx0bWltZTogJ3ZpZGVvL3gtbXMtd212J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4MCwgMHgwLCAweDEsIDB4QkFdKSB8fFxuXHRcdGNoZWNrKFsweDAsIDB4MCwgMHgxLCAweEIzXSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21wZycsXG5cdFx0XHRtaW1lOiAndmlkZW8vbXBlZydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDY2LCAweDc0LCAweDc5LCAweDcwLCAweDMzLCAweDY3XSwge29mZnNldDogNH0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJzNncCcsXG5cdFx0XHRtaW1lOiAndmlkZW8vM2dwcCdcblx0XHR9O1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIE1QRUcgaGVhZGVyIGF0IGRpZmZlcmVudCBzdGFydGluZyBvZmZzZXRzXG5cdGZvciAobGV0IHN0YXJ0ID0gMDsgc3RhcnQgPCAyICYmIHN0YXJ0IDwgKGJ1Zi5sZW5ndGggLSAxNik7IHN0YXJ0KyspIHtcblx0XHRpZiAoXG5cdFx0XHRjaGVjayhbMHg0OSwgMHg0NCwgMHgzM10sIHtvZmZzZXQ6IHN0YXJ0fSkgfHwgLy8gSUQzIGhlYWRlclxuXHRcdFx0Y2hlY2soWzB4RkYsIDB4RTJdLCB7b2Zmc2V0OiBzdGFydCwgbWFzazogWzB4RkYsIDB4RTJdfSkgLy8gTVBFRyAxIG9yIDIgTGF5ZXIgMyBoZWFkZXJcblx0XHQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ21wMycsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby9tcGVnJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRjaGVjayhbMHhGRiwgMHhFNF0sIHtvZmZzZXQ6IHN0YXJ0LCBtYXNrOiBbMHhGRiwgMHhFNF19KSAvLyBNUEVHIDEgb3IgMiBMYXllciAyIGhlYWRlclxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnbXAyJyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL21wZWcnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdGNoZWNrKFsweEZGLCAweEY4XSwge29mZnNldDogc3RhcnQsIG1hc2s6IFsweEZGLCAweEZDXX0pIC8vIE1QRUcgMiBsYXllciAwIHVzaW5nIEFEVFNcblx0XHQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ21wMicsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby9tcGVnJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRjaGVjayhbMHhGRiwgMHhGMF0sIHtvZmZzZXQ6IHN0YXJ0LCBtYXNrOiBbMHhGRiwgMHhGQ119KSAvLyBNUEVHIDQgbGF5ZXIgMCB1c2luZyBBRFRTXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdtcDQnLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vbXBlZydcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweDY2LCAweDc0LCAweDc5LCAweDcwLCAweDRELCAweDM0LCAweDQxXSwge29mZnNldDogNH0pIHx8XG5cdFx0Y2hlY2soWzB4NEQsIDB4MzQsIDB4NDEsIDB4MjBdKVxuXHQpIHtcblx0XHRyZXR1cm4geyAvLyBNUEVHLTQgbGF5ZXIgMyAoYXVkaW8pXG5cdFx0XHRleHQ6ICdtNGEnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL21wNCcgLy8gUkZDIDQzMzdcblx0XHR9O1xuXHR9XG5cblx0Ly8gTmVlZHMgdG8gYmUgYmVmb3JlIGBvZ2dgIGNoZWNrXG5cdGlmIChjaGVjayhbMHg0RiwgMHg3MCwgMHg3NSwgMHg3MywgMHg0OCwgMHg2NSwgMHg2MSwgMHg2NF0sIHtvZmZzZXQ6IDI4fSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnb3B1cycsXG5cdFx0XHRtaW1lOiAnYXVkaW8vb3B1cydcblx0XHR9O1xuXHR9XG5cblx0Ly8gSWYgJ09nZ1MnIGluIGZpcnN0ICBieXRlcywgdGhlbiBPR0cgY29udGFpbmVyXG5cdGlmIChjaGVjayhbMHg0RiwgMHg2NywgMHg2NywgMHg1M10pKSB7XG5cdFx0Ly8gVGhpcyBpcyBhIE9HRyBjb250YWluZXJcblxuXHRcdC8vIElmICcgdGhlb3JhJyBpbiBoZWFkZXIuXG5cdFx0aWYgKGNoZWNrKFsweDgwLCAweDc0LCAweDY4LCAweDY1LCAweDZGLCAweDcyLCAweDYxXSwge29mZnNldDogMjh9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2d2Jyxcblx0XHRcdFx0bWltZTogJ3ZpZGVvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXHRcdC8vIElmICdcXHgwMXZpZGVvJyBpbiBoZWFkZXIuXG5cdFx0aWYgKGNoZWNrKFsweDAxLCAweDc2LCAweDY5LCAweDY0LCAweDY1LCAweDZGLCAweDAwXSwge29mZnNldDogMjh9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2dtJyxcblx0XHRcdFx0bWltZTogJ3ZpZGVvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXHRcdC8vIElmICcgRkxBQycgaW4gaGVhZGVyICBodHRwczovL3hpcGgub3JnL2ZsYWMvZmFxLmh0bWxcblx0XHRpZiAoY2hlY2soWzB4N0YsIDB4NDYsIDB4NEMsIDB4NDEsIDB4NDNdLCB7b2Zmc2V0OiAyOH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdvZ2EnLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vb2dnJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyAnU3BlZXggICcgaW4gaGVhZGVyIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwZWV4XG5cdFx0aWYgKGNoZWNrKFsweDUzLCAweDcwLCAweDY1LCAweDY1LCAweDc4LCAweDIwLCAweDIwXSwge29mZnNldDogMjh9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnc3B4Jyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgJ1xceDAxdm9yYmlzJyBpbiBoZWFkZXJcblx0XHRpZiAoY2hlY2soWzB4MDEsIDB4NzYsIDB4NkYsIDB4NzIsIDB4NjIsIDB4NjksIDB4NzNdLCB7b2Zmc2V0OiAyOH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdvZ2cnLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vb2dnJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IE9HRyBjb250YWluZXIgaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbWVkaWEtdHlwZXMvYXBwbGljYXRpb24vb2dnXG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ29neCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vb2dnJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NjYsIDB4NEMsIDB4NjEsIDB4NDNdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdmbGFjJyxcblx0XHRcdG1pbWU6ICdhdWRpby94LWZsYWMnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0RCwgMHg0MSwgMHg0MywgMHgyMF0pKSB7IC8vICdNQUMgJ1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhcGUnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL2FwZSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDc3LCAweDc2LCAweDcwLCAweDZCXSkpIHsgLy8gJ3d2cGsnXG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3d2Jyxcblx0XHRcdG1pbWU6ICdhdWRpby93YXZwYWNrJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MjMsIDB4MjEsIDB4NDEsIDB4NEQsIDB4NTIsIDB4MEFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhbXInLFxuXHRcdFx0bWltZTogJ2F1ZGlvL2Ftcidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDI1LCAweDUwLCAweDQ0LCAweDQ2XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncGRmJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9wZGYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0RCwgMHg1QV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2V4ZScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0KGJ1ZlswXSA9PT0gMHg0MyB8fCBidWZbMF0gPT09IDB4NDYpICYmXG5cdFx0Y2hlY2soWzB4NTcsIDB4NTNdLCB7b2Zmc2V0OiAxfSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3N3ZicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg3QiwgMHg1QywgMHg3MiwgMHg3NCwgMHg2Nl0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3J0ZicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vcnRmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MDAsIDB4NjEsIDB4NzMsIDB4NkRdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3YXNtJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi93YXNtJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4NzcsIDB4NEYsIDB4NDYsIDB4NDZdKSAmJlxuXHRcdChcblx0XHRcdGNoZWNrKFsweDAwLCAweDAxLCAweDAwLCAweDAwXSwge29mZnNldDogNH0pIHx8XG5cdFx0XHRjaGVjayhbMHg0RiwgMHg1NCwgMHg1NCwgMHg0Rl0sIHtvZmZzZXQ6IDR9KVxuXHRcdClcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3dvZmYnLFxuXHRcdFx0bWltZTogJ2ZvbnQvd29mZidcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweDc3LCAweDRGLCAweDQ2LCAweDMyXSkgJiZcblx0XHQoXG5cdFx0XHRjaGVjayhbMHgwMCwgMHgwMSwgMHgwMCwgMHgwMF0sIHtvZmZzZXQ6IDR9KSB8fFxuXHRcdFx0Y2hlY2soWzB4NEYsIDB4NTQsIDB4NTQsIDB4NEZdLCB7b2Zmc2V0OiA0fSlcblx0XHQpXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3b2ZmMicsXG5cdFx0XHRtaW1lOiAnZm9udC93b2ZmMidcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweDRDLCAweDUwXSwge29mZnNldDogMzR9KSAmJlxuXHRcdChcblx0XHRcdGNoZWNrKFsweDAwLCAweDAwLCAweDAxXSwge29mZnNldDogOH0pIHx8XG5cdFx0XHRjaGVjayhbMHgwMSwgMHgwMCwgMHgwMl0sIHtvZmZzZXQ6IDh9KSB8fFxuXHRcdFx0Y2hlY2soWzB4MDIsIDB4MDAsIDB4MDJdLCB7b2Zmc2V0OiA4fSlcblx0XHQpXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdlb3QnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd0dGYnLFxuXHRcdFx0bWltZTogJ2ZvbnQvdHRmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NEYsIDB4NTQsIDB4NTQsIDB4NEYsIDB4MDBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdvdGYnLFxuXHRcdFx0bWltZTogJ2ZvbnQvb3RmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MDAsIDB4MDAsIDB4MDEsIDB4MDBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdpY28nLFxuXHRcdFx0bWltZTogJ2ltYWdlL3gtaWNvbidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDAwLCAweDAyLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnY3VyJyxcblx0XHRcdG1pbWU6ICdpbWFnZS94LWljb24nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0NiwgMHg0QywgMHg1NiwgMHgwMV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2ZsdicsXG5cdFx0XHRtaW1lOiAndmlkZW8veC1mbHYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgyNSwgMHgyMV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3BzJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9wb3N0c2NyaXB0J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4RkQsIDB4MzcsIDB4N0EsIDB4NTgsIDB4NUEsIDB4MDBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd4eicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC14eidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDUzLCAweDUxLCAweDRDLCAweDY5XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnc3FsaXRlJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXNxbGl0ZTMnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0RSwgMHg0NSwgMHg1MywgMHgxQV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ25lcycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1uaW50ZW5kby1uZXMtcm9tJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDMsIDB4NzIsIDB4MzIsIDB4MzRdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdjcngnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtZ29vZ2xlLWNocm9tZS1leHRlbnNpb24nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVjayhbMHg0RCwgMHg1MywgMHg0MywgMHg0Nl0pIHx8XG5cdFx0Y2hlY2soWzB4NDksIDB4NTMsIDB4NjMsIDB4MjhdKVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnY2FiJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnXG5cdFx0fTtcblx0fVxuXG5cdC8vIE5lZWRzIHRvIGJlIGJlZm9yZSBgYXJgIGNoZWNrXG5cdGlmIChjaGVjayhbMHgyMSwgMHgzQywgMHg2MSwgMHg3MiwgMHg2MywgMHg2OCwgMHgzRSwgMHgwQSwgMHg2NCwgMHg2NSwgMHg2MiwgMHg2OSwgMHg2MSwgMHg2RSwgMHgyRCwgMHg2MiwgMHg2OSwgMHg2RSwgMHg2MSwgMHg3MiwgMHg3OV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2RlYicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1kZWInXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgyMSwgMHgzQywgMHg2MSwgMHg3MiwgMHg2MywgMHg2OCwgMHgzRV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2FyJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXVuaXgtYXJjaGl2ZSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweEVELCAweEFCLCAweEVFLCAweERCXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncnBtJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXJwbSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweDFGLCAweEEwXSkgfHxcblx0XHRjaGVjayhbMHgxRiwgMHg5RF0pXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdaJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWNvbXByZXNzJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NEMsIDB4NUEsIDB4NDksIDB4NTBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdseicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1semlwJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4RDAsIDB4Q0YsIDB4MTEsIDB4RTAsIDB4QTEsIDB4QjEsIDB4MUEsIDB4RTFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdtc2knLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtbXNpJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MDYsIDB4MEUsIDB4MkIsIDB4MzQsIDB4MDIsIDB4MDUsIDB4MDEsIDB4MDEsIDB4MEQsIDB4MDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDJdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdteGYnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL214Zidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQ3XSwge29mZnNldDogNH0pICYmIChjaGVjayhbMHg0N10sIHtvZmZzZXQ6IDE5Mn0pIHx8IGNoZWNrKFsweDQ3XSwge29mZnNldDogMTk2fSkpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ210cycsXG5cdFx0XHRtaW1lOiAndmlkZW8vbXAydCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQyLCAweDRDLCAweDQ1LCAweDRFLCAweDQ0LCAweDQ1LCAweDUyXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYmxlbmQnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtYmxlbmRlcidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQyLCAweDUwLCAweDQ3LCAweEZCXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYnBnJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9icGcnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgwMCwgMHgwMCwgMHgwMCwgMHgwQywgMHg2QSwgMHg1MCwgMHgyMCwgMHgyMCwgMHgwRCwgMHgwQSwgMHg4NywgMHgwQV0pKSB7XG5cdFx0Ly8gSlBFRy0yMDAwIGZhbWlseVxuXG5cdFx0aWYgKGNoZWNrKFsweDZBLCAweDcwLCAweDMyLCAweDIwXSwge29mZnNldDogMjB9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnanAyJyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL2pwMidcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrKFsweDZBLCAweDcwLCAweDc4LCAweDIwXSwge29mZnNldDogMjB9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnanB4Jyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL2pweCdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrKFsweDZBLCAweDcwLCAweDZELCAweDIwXSwge29mZnNldDogMjB9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnanBtJyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL2pwbSdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrKFsweDZELCAweDZBLCAweDcwLCAweDMyXSwge29mZnNldDogMjB9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnbWoyJyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL21qMidcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQ2LCAweDRGLCAweDUyLCAweDRELCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYWlmJyxcblx0XHRcdG1pbWU6ICdhdWRpby9haWZmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJzw/eG1sICcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3htbCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veG1sJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDIsIDB4NEYsIDB4NEYsIDB4NEIsIDB4NEQsIDB4NEYsIDB4NDIsIDB4NDldLCB7b2Zmc2V0OiA2MH0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21vYmknLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtbW9iaXBvY2tldC1lYm9vaydcblx0XHR9O1xuXHR9XG5cblx0Ly8gRmlsZSBUeXBlIEJveCAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX2Jhc2VfbWVkaWFfZmlsZV9mb3JtYXQpXG5cdGlmIChjaGVjayhbMHg2NiwgMHg3NCwgMHg3OSwgMHg3MF0sIHtvZmZzZXQ6IDR9KSkge1xuXHRcdGlmIChjaGVjayhbMHg2RCwgMHg2OSwgMHg2NiwgMHgzMV0sIHtvZmZzZXQ6IDh9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnaGVpYycsXG5cdFx0XHRcdG1pbWU6ICdpbWFnZS9oZWlmJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2soWzB4NkQsIDB4NzMsIDB4NjYsIDB4MzFdLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2hlaWMnLFxuXHRcdFx0XHRtaW1lOiAnaW1hZ2UvaGVpZi1zZXF1ZW5jZSdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrKFsweDY4LCAweDY1LCAweDY5LCAweDYzXSwge29mZnNldDogOH0pIHx8IGNoZWNrKFsweDY4LCAweDY1LCAweDY5LCAweDc4XSwge29mZnNldDogOH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdoZWljJyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL2hlaWMnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmIChjaGVjayhbMHg2OCwgMHg2NSwgMHg3NiwgMHg2M10sIHtvZmZzZXQ6IDh9KSB8fCBjaGVjayhbMHg2OCwgMHg2NSwgMHg3NiwgMHg3OF0sIHtvZmZzZXQ6IDh9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnaGVpYycsXG5cdFx0XHRcdG1pbWU6ICdpbWFnZS9oZWljLXNlcXVlbmNlJ1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4QUIsIDB4NEIsIDB4NTQsIDB4NTgsIDB4MjAsIDB4MzEsIDB4MzEsIDB4QkIsIDB4MEQsIDB4MEEsIDB4MUEsIDB4MEFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdrdHgnLFxuXHRcdFx0bWltZTogJ2ltYWdlL2t0eCdcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59O1xuIiwiaW1wb3J0IGNvbmZpZ3VyZSBmcm9tICdAamltcC9jdXN0b20nO1xuaW1wb3J0IHR5cGVzIGZyb20gJ0BqaW1wL3R5cGVzJztcbmltcG9ydCBwbHVnaW5zIGZyb20gJ0BqaW1wL3BsdWdpbnMnO1xuZXhwb3J0IGRlZmF1bHQgY29uZmlndXJlKHtcbiAgdHlwZXM6IFt0eXBlc10sXG4gIHBsdWdpbnM6IFtwbHVnaW5zXVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgZW5jb2RlID0gcmVxdWlyZSgnLi9saWIvZW5jb2RlcicpLFxuICAgIGRlY29kZSA9IHJlcXVpcmUoJy4vbGliL2RlY29kZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY29kZTogZW5jb2RlLFxuICBkZWNvZGU6IGRlY29kZVxufTtcbiIsIi8qIC0qLSB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotIC9cbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cbi8qXG4gICBDb3B5cmlnaHQgMjAxMSBub3RtYXN0ZXJ5ZXRcblxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vLyAtIFRoZSBKUEVHIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBJVFUgQ0NJVFQgUmVjb21tZW5kYXRpb24gVC44MVxuLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2l0dS10ODEucGRmKVxuLy8gLSBUaGUgSkZJRiBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSlBFRyBGaWxlIEludGVyY2hhbmdlIEZvcm1hdFxuLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2pmaWYzLnBkZilcbi8vIC0gVGhlIEFkb2JlIEFwcGxpY2F0aW9uLVNwZWNpZmljIEpQRUcgbWFya2VycyBpbiB0aGUgU3VwcG9ydGluZyB0aGUgRENUIEZpbHRlcnNcbi8vICAgaW4gUG9zdFNjcmlwdCBMZXZlbCAyLCBUZWNobmljYWwgTm90ZSAjNTExNlxuLy8gICAocGFydG5lcnMuYWRvYmUuY29tL3B1YmxpYy9kZXZlbG9wZXIvZW4vcHMvc2RrLzUxMTYuRENUX0ZpbHRlci5wZGYpXG5cbnZhciBKcGVnSW1hZ2UgPSAoZnVuY3Rpb24ganBlZ0ltYWdlKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIGRjdFppZ1phZyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAgMCxcbiAgICAgMSwgIDgsXG4gICAgMTYsICA5LCAgMixcbiAgICAgMywgMTAsIDE3LCAyNCxcbiAgICAzMiwgMjUsIDE4LCAxMSwgNCxcbiAgICAgNSwgMTIsIDE5LCAyNiwgMzMsIDQwLFxuICAgIDQ4LCA0MSwgMzQsIDI3LCAyMCwgMTMsICA2LFxuICAgICA3LCAxNCwgMjEsIDI4LCAzNSwgNDIsIDQ5LCA1NixcbiAgICA1NywgNTAsIDQzLCAzNiwgMjksIDIyLCAxNSxcbiAgICAyMywgMzAsIDM3LCA0NCwgNTEsIDU4LFxuICAgIDU5LCA1MiwgNDUsIDM4LCAzMSxcbiAgICAzOSwgNDYsIDUzLCA2MCxcbiAgICA2MSwgNTQsIDQ3LFxuICAgIDU1LCA2MixcbiAgICA2M1xuICBdKTtcblxuICB2YXIgZGN0Q29zMSAgPSAgNDAxNyAgIC8vIGNvcyhwaS8xNilcbiAgdmFyIGRjdFNpbjEgID0gICA3OTkgICAvLyBzaW4ocGkvMTYpXG4gIHZhciBkY3RDb3MzICA9ICAzNDA2ICAgLy8gY29zKDMqcGkvMTYpXG4gIHZhciBkY3RTaW4zICA9ICAyMjc2ICAgLy8gc2luKDMqcGkvMTYpXG4gIHZhciBkY3RDb3M2ICA9ICAxNTY3ICAgLy8gY29zKDYqcGkvMTYpXG4gIHZhciBkY3RTaW42ICA9ICAzNzg0ICAgLy8gc2luKDYqcGkvMTYpXG4gIHZhciBkY3RTcXJ0MiA9ICA1NzkzICAgLy8gc3FydCgyKVxuICB2YXIgZGN0U3FydDFkMiA9IDI4OTYgIC8vIHNxcnQoMikgLyAyXG5cbiAgZnVuY3Rpb24gY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7XG4gICAgdmFyIGsgPSAwLCBjb2RlID0gW10sIGksIGosIGxlbmd0aCA9IDE2O1xuICAgIHdoaWxlIChsZW5ndGggPiAwICYmICFjb2RlTGVuZ3Roc1tsZW5ndGggLSAxXSlcbiAgICAgIGxlbmd0aC0tO1xuICAgIGNvZGUucHVzaCh7Y2hpbGRyZW46IFtdLCBpbmRleDogMH0pO1xuICAgIHZhciBwID0gY29kZVswXSwgcTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3Roc1tpXTsgaisrKSB7XG4gICAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdO1xuICAgICAgICB3aGlsZSAocC5pbmRleCA+IDApIHtcbiAgICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBwLmluZGV4Kys7XG4gICAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICBjb2RlLnB1c2gocSA9IHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XG4gICAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIHAgaGVyZSBwb2ludHMgdG8gbGFzdCBjb2RlXG4gICAgICAgIGNvZGUucHVzaChxID0ge2NoaWxkcmVuOiBbXSwgaW5kZXg6IDB9KTtcbiAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICAgIHAgPSBxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZVswXS5jaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZVNjYW4oZGF0YSwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLCBjb21wb25lbnRzLCByZXNldEludGVydmFsLFxuICAgICAgICAgICAgICAgICAgICAgIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLFxuICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVQcmV2LCBzdWNjZXNzaXZlKSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IGZyYW1lLnByZWNpc2lvbjtcbiAgICB2YXIgc2FtcGxlc1BlckxpbmUgPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcbiAgICB2YXIgc2NhbkxpbmVzID0gZnJhbWUuc2NhbkxpbmVzO1xuICAgIHZhciBtY3VzUGVyTGluZSA9IGZyYW1lLm1jdXNQZXJMaW5lO1xuICAgIHZhciBwcm9ncmVzc2l2ZSA9IGZyYW1lLnByb2dyZXNzaXZlO1xuICAgIHZhciBtYXhIID0gZnJhbWUubWF4SCwgbWF4ViA9IGZyYW1lLm1heFY7XG5cbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQsIGJpdHNEYXRhID0gMCwgYml0c0NvdW50ID0gMDtcbiAgICBmdW5jdGlvbiByZWFkQml0KCkge1xuICAgICAgaWYgKGJpdHNDb3VudCA+IDApIHtcbiAgICAgICAgYml0c0NvdW50LS07XG4gICAgICAgIHJldHVybiAoYml0c0RhdGEgPj4gYml0c0NvdW50KSAmIDE7XG4gICAgICB9XG4gICAgICBiaXRzRGF0YSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgaWYgKGJpdHNEYXRhID09IDB4RkYpIHtcbiAgICAgICAgdmFyIG5leHRCeXRlID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgIGlmIChuZXh0Qnl0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgbWFya2VyOiBcIiArICgoYml0c0RhdGEgPDwgOCkgfCBuZXh0Qnl0ZSkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1bnN0dWZmIDBcbiAgICAgIH1cbiAgICAgIGJpdHNDb3VudCA9IDc7XG4gICAgICByZXR1cm4gYml0c0RhdGEgPj4+IDc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUh1ZmZtYW4odHJlZSkge1xuICAgICAgdmFyIG5vZGUgPSB0cmVlLCBiaXQ7XG4gICAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVbYml0XTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnbnVtYmVyJylcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGh1ZmZtYW4gc2VxdWVuY2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjZWl2ZShsZW5ndGgpIHtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBiaXQgPSByZWFkQml0KCk7XG4gICAgICAgIGlmIChiaXQgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgbiA9IChuIDw8IDEpIHwgYml0O1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNlaXZlQW5kRXh0ZW5kKGxlbmd0aCkge1xuICAgICAgdmFyIG4gPSByZWNlaXZlKGxlbmd0aCk7XG4gICAgICBpZiAobiA+PSAxIDw8IChsZW5ndGggLSAxKSlcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlQmFzZWxpbmUoY29tcG9uZW50LCB6eikge1xuICAgICAgdmFyIHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgICB2YXIgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KTtcbiAgICAgIHp6WzBdPSAoY29tcG9uZW50LnByZWQgKz0gZGlmZik7XG4gICAgICB2YXIgayA9IDE7XG4gICAgICB3aGlsZSAoayA8IDY0KSB7XG4gICAgICAgIHZhciBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgICAgdmFyIHMgPSBycyAmIDE1LCByID0gcnMgPj4gNDtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICBpZiAociA8IDE1KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgayArPSAxNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBrICs9IHI7XG4gICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICB6elt6XSA9IHJlY2VpdmVBbmRFeHRlbmQocyk7XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRENGaXJzdChjb21wb25lbnQsIHp6KSB7XG4gICAgICB2YXIgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTtcbiAgICAgIHZhciBkaWZmID0gdCA9PT0gMCA/IDAgOiAocmVjZWl2ZUFuZEV4dGVuZCh0KSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgIHp6WzBdID0gKGNvbXBvbmVudC5wcmVkICs9IGRpZmYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVEQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikge1xuICAgICAgenpbMF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7XG4gICAgfVxuICAgIHZhciBlb2JydW4gPSAwO1xuICAgIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCB6eikge1xuICAgICAgaWYgKGVvYnJ1biA+IDApIHtcbiAgICAgICAgZW9icnVuLS07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gc3BlY3RyYWxTdGFydCwgZSA9IHNwZWN0cmFsRW5kO1xuICAgICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgIHZhciBzID0gcnMgJiAxNSwgciA9IHJzID4+IDQ7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrICs9IDE2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XG4gICAgICAgIHp6W3pdID0gcmVjZWl2ZUFuZEV4dGVuZChzKSAqICgxIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdWNjZXNzaXZlQUNTdGF0ZSA9IDAsIHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZTtcbiAgICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikge1xuICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0LCBlID0gc3BlY3RyYWxFbmQsIHIgPSAwO1xuICAgICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHp6W3pdIDwgMCA/IC0xIDogMTtcbiAgICAgICAgc3dpdGNoIChzdWNjZXNzaXZlQUNTdGF0ZSkge1xuICAgICAgICBjYXNlIDA6IC8vIGluaXRpYWwgc3RhdGVcbiAgICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgdmFyIHMgPSBycyAmIDE1LCByID0gcnMgPj4gNDtcbiAgICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcik7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHIgPSAxNjtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocyAhPT0gMSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBBQ24gZW5jb2RpbmdcIik7XG4gICAgICAgICAgICBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSByID8gMiA6IDM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIDE6IC8vIHNraXBwaW5nIHIgemVybyBpdGVtc1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKHp6W3pdKVxuICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHItLTtcbiAgICAgICAgICAgIGlmIChyID09PSAwKVxuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHN1Y2Nlc3NpdmVBQ1N0YXRlID09IDIgPyAzIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLy8gc2V0IHZhbHVlIGZvciBhIHplcm8gaXRlbVxuICAgICAgICAgIGlmICh6elt6XSlcbiAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB6elt6XSA9IHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZSA8PCBzdWNjZXNzaXZlO1xuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OiAvLyBlb2JcbiAgICAgICAgICBpZiAoenpbel0pXG4gICAgICAgICAgICB6elt6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpICogZGlyZWN0aW9uO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICAgIGlmIChzdWNjZXNzaXZlQUNTdGF0ZSA9PT0gNCkge1xuICAgICAgICBlb2JydW4tLTtcbiAgICAgICAgaWYgKGVvYnJ1biA9PT0gMClcbiAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZSwgbWN1LCByb3csIGNvbCkge1xuICAgICAgdmFyIG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xuICAgICAgdmFyIG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgICAgdmFyIGJsb2NrUm93ID0gbWN1Um93ICogY29tcG9uZW50LnYgKyByb3c7XG4gICAgICB2YXIgYmxvY2tDb2wgPSBtY3VDb2wgKiBjb21wb25lbnQuaCArIGNvbDtcbiAgICAgIGRlY29kZShjb21wb25lbnQsIGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlLCBtY3UpIHtcbiAgICAgIHZhciBibG9ja1JvdyA9IChtY3UgLyBjb21wb25lbnQuYmxvY2tzUGVyTGluZSkgfCAwO1xuICAgICAgdmFyIGJsb2NrQ29sID0gbWN1ICUgY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgICBkZWNvZGUoY29tcG9uZW50LCBjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0pO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRzTGVuZ3RoID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGNvbXBvbmVudCwgaSwgaiwgaywgbjtcbiAgICB2YXIgZGVjb2RlRm47XG4gICAgaWYgKHByb2dyZXNzaXZlKSB7XG4gICAgICBpZiAoc3BlY3RyYWxTdGFydCA9PT0gMClcbiAgICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZURDRmlyc3QgOiBkZWNvZGVEQ1N1Y2Nlc3NpdmU7XG4gICAgICBlbHNlXG4gICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVBQ0ZpcnN0IDogZGVjb2RlQUNTdWNjZXNzaXZlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNvZGVGbiA9IGRlY29kZUJhc2VsaW5lO1xuICAgIH1cblxuICAgIHZhciBtY3UgPSAwLCBtYXJrZXI7XG4gICAgdmFyIG1jdUV4cGVjdGVkO1xuICAgIGlmIChjb21wb25lbnRzTGVuZ3RoID09IDEpIHtcbiAgICAgIG1jdUV4cGVjdGVkID0gY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lICogY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG1jdUV4cGVjdGVkID0gbWN1c1BlckxpbmUgKiBmcmFtZS5tY3VzUGVyQ29sdW1uO1xuICAgIH1cbiAgICBpZiAoIXJlc2V0SW50ZXJ2YWwpIHJlc2V0SW50ZXJ2YWwgPSBtY3VFeHBlY3RlZDtcblxuICAgIHZhciBoLCB2O1xuICAgIHdoaWxlIChtY3UgPCBtY3VFeHBlY3RlZCkge1xuICAgICAgLy8gcmVzZXQgaW50ZXJ2YWwgc3R1ZmZcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspXG4gICAgICAgIGNvbXBvbmVudHNbaV0ucHJlZCA9IDA7XG4gICAgICBlb2JydW4gPSAwO1xuXG4gICAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PSAxKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCByZXNldEludGVydmFsOyBuKyspIHtcbiAgICAgICAgICBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZuLCBtY3UpO1xuICAgICAgICAgIG1jdSsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgcmVzZXRJbnRlcnZhbDsgbisrKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGggPSBjb21wb25lbnQuaDtcbiAgICAgICAgICAgIHYgPSBjb21wb25lbnQudjtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZUZuLCBtY3UsIGosIGspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1jdSsrO1xuXG4gICAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBvdXIgZXhwZWN0ZWQgTUNVJ3MsIHN0b3AgZGVjb2RpbmdcbiAgICAgICAgICBpZiAobWN1ID09PSBtY3VFeHBlY3RlZCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBtYXJrZXJcbiAgICAgIGJpdHNDb3VudCA9IDA7XG4gICAgICBtYXJrZXIgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgIGlmIChtYXJrZXIgPCAweEZGMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFya2VyIHdhcyBub3QgZm91bmRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZXIgPj0gMHhGRkQwICYmIG1hcmtlciA8PSAweEZGRDcpIHsgLy8gUlNUeFxuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgYmxvY2tzUGVyTGluZSA9IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uO1xuICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcbiAgICB2YXIgUiA9IG5ldyBJbnQzMkFycmF5KDY0KSwgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcblxuICAgIC8vIEEgcG9ydCBvZiBwb3BwbGVyJ3MgSURDVCBtZXRob2Qgd2hpY2ggaW4gdHVybiBpcyB0YWtlbiBmcm9tOlxuICAgIC8vICAgQ2hyaXN0b3BoIExvZWZmbGVyLCBBZHJpYWFuIExpZ3RlbmJlcmcsIEdlb3JnZSBTLiBNb3NjaHl0eixcbiAgICAvLyAgIFwiUHJhY3RpY2FsIEZhc3QgMS1EIERDVCBBbGdvcml0aG1zIHdpdGggMTEgTXVsdGlwbGljYXRpb25zXCIsXG4gICAgLy8gICBJRUVFIEludGwuIENvbmYuIG9uIEFjb3VzdGljcywgU3BlZWNoICYgU2lnbmFsIFByb2Nlc3NpbmcsIDE5ODksXG4gICAgLy8gICA5ODgtOTkxLlxuICAgIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZSh6eiwgZGF0YU91dCwgZGF0YUluKSB7XG4gICAgICB2YXIgcXQgPSBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGU7XG4gICAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB0O1xuICAgICAgdmFyIHAgPSBkYXRhSW47XG4gICAgICB2YXIgaTtcblxuICAgICAgLy8gZGVxdWFudFxuICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspXG4gICAgICAgIHBbaV0gPSB6eltpXSAqIHF0W2ldO1xuXG4gICAgICAvLyBpbnZlcnNlIERDVCBvbiByb3dzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIHZhciByb3cgPSA4ICogaTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICAgIGlmIChwWzEgKyByb3ddID09IDAgJiYgcFsyICsgcm93XSA9PSAwICYmIHBbMyArIHJvd10gPT0gMCAmJlxuICAgICAgICAgICAgcFs0ICsgcm93XSA9PSAwICYmIHBbNSArIHJvd10gPT0gMCAmJiBwWzYgKyByb3ddID09IDAgJiZcbiAgICAgICAgICAgIHBbNyArIHJvd10gPT0gMCkge1xuICAgICAgICAgIHQgPSAoZGN0U3FydDIgKiBwWzAgKyByb3ddICsgNTEyKSA+PiAxMDtcbiAgICAgICAgICBwWzAgKyByb3ddID0gdDtcbiAgICAgICAgICBwWzEgKyByb3ddID0gdDtcbiAgICAgICAgICBwWzIgKyByb3ddID0gdDtcbiAgICAgICAgICBwWzMgKyByb3ddID0gdDtcbiAgICAgICAgICBwWzQgKyByb3ddID0gdDtcbiAgICAgICAgICBwWzUgKyByb3ddID0gdDtcbiAgICAgICAgICBwWzYgKyByb3ddID0gdDtcbiAgICAgICAgICBwWzcgKyByb3ddID0gdDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0YWdlIDRcbiAgICAgICAgdjAgPSAoZGN0U3FydDIgKiBwWzAgKyByb3ddICsgMTI4KSA+PiA4O1xuICAgICAgICB2MSA9IChkY3RTcXJ0MiAqIHBbNCArIHJvd10gKyAxMjgpID4+IDg7XG4gICAgICAgIHYyID0gcFsyICsgcm93XTtcbiAgICAgICAgdjMgPSBwWzYgKyByb3ddO1xuICAgICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHBbMSArIHJvd10gLSBwWzcgKyByb3ddKSArIDEyOCkgPj4gODtcbiAgICAgICAgdjcgPSAoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddICsgcFs3ICsgcm93XSkgKyAxMjgpID4+IDg7XG4gICAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0O1xuICAgICAgICB2NiA9IHBbNSArIHJvd10gPDwgNDtcblxuICAgICAgICAvLyBzdGFnZSAzXG4gICAgICAgIHQgPSAodjAgLSB2MSsgMSkgPj4gMTtcbiAgICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICAgIHYxID0gdDtcbiAgICAgICAgdCA9ICh2MiAqIGRjdFNpbjYgKyB2MyAqIGRjdENvczYgKyAxMjgpID4+IDg7XG4gICAgICAgIHYyID0gKHYyICogZGN0Q29zNiAtIHYzICogZGN0U2luNiArIDEyOCkgPj4gODtcbiAgICAgICAgdjMgPSB0O1xuICAgICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcbiAgICAgICAgdjYgPSB0O1xuICAgICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcbiAgICAgICAgdjcgPSB0O1xuXG4gICAgICAgIC8vIHN0YWdlIDJcbiAgICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcbiAgICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XG4gICAgICAgIHYzID0gdDtcbiAgICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcbiAgICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XG4gICAgICAgIHYyID0gdDtcbiAgICAgICAgdCA9ICh2NCAqIGRjdFNpbjMgKyB2NyAqIGRjdENvczMgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjQgPSAodjQgKiBkY3RDb3MzIC0gdjcgKiBkY3RTaW4zICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY3ID0gdDtcbiAgICAgICAgdCA9ICh2NSAqIGRjdFNpbjEgKyB2NiAqIGRjdENvczEgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjUgPSAodjUgKiBkY3RDb3MxIC0gdjYgKiBkY3RTaW4xICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY2ID0gdDtcblxuICAgICAgICAvLyBzdGFnZSAxXG4gICAgICAgIHBbMCArIHJvd10gPSB2MCArIHY3O1xuICAgICAgICBwWzcgKyByb3ddID0gdjAgLSB2NztcbiAgICAgICAgcFsxICsgcm93XSA9IHYxICsgdjY7XG4gICAgICAgIHBbNiArIHJvd10gPSB2MSAtIHY2O1xuICAgICAgICBwWzIgKyByb3ddID0gdjIgKyB2NTtcbiAgICAgICAgcFs1ICsgcm93XSA9IHYyIC0gdjU7XG4gICAgICAgIHBbMyArIHJvd10gPSB2MyArIHY0O1xuICAgICAgICBwWzQgKyByb3ddID0gdjMgLSB2NDtcbiAgICAgIH1cblxuICAgICAgLy8gaW52ZXJzZSBEQ1Qgb24gY29sdW1uc1xuICAgICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICB2YXIgY29sID0gaTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICAgIGlmIChwWzEqOCArIGNvbF0gPT0gMCAmJiBwWzIqOCArIGNvbF0gPT0gMCAmJiBwWzMqOCArIGNvbF0gPT0gMCAmJlxuICAgICAgICAgICAgcFs0KjggKyBjb2xdID09IDAgJiYgcFs1KjggKyBjb2xdID09IDAgJiYgcFs2KjggKyBjb2xdID09IDAgJiZcbiAgICAgICAgICAgIHBbNyo4ICsgY29sXSA9PSAwKSB7XG4gICAgICAgICAgdCA9IChkY3RTcXJ0MiAqIGRhdGFJbltpKzBdICsgODE5MikgPj4gMTQ7XG4gICAgICAgICAgcFswKjggKyBjb2xdID0gdDtcbiAgICAgICAgICBwWzEqOCArIGNvbF0gPSB0O1xuICAgICAgICAgIHBbMio4ICsgY29sXSA9IHQ7XG4gICAgICAgICAgcFszKjggKyBjb2xdID0gdDtcbiAgICAgICAgICBwWzQqOCArIGNvbF0gPSB0O1xuICAgICAgICAgIHBbNSo4ICsgY29sXSA9IHQ7XG4gICAgICAgICAgcFs2KjggKyBjb2xdID0gdDtcbiAgICAgICAgICBwWzcqOCArIGNvbF0gPSB0O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RhZ2UgNFxuICAgICAgICB2MCA9IChkY3RTcXJ0MiAqIHBbMCo4ICsgY29sXSArIDIwNDgpID4+IDEyO1xuICAgICAgICB2MSA9IChkY3RTcXJ0MiAqIHBbNCo4ICsgY29sXSArIDIwNDgpID4+IDEyO1xuICAgICAgICB2MiA9IHBbMio4ICsgY29sXTtcbiAgICAgICAgdjMgPSBwWzYqOCArIGNvbF07XG4gICAgICAgIHY0ID0gKGRjdFNxcnQxZDIgKiAocFsxKjggKyBjb2xdIC0gcFs3KjggKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgICB2NyA9IChkY3RTcXJ0MWQyICogKHBbMSo4ICsgY29sXSArIHBbNyo4ICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjUgPSBwWzMqOCArIGNvbF07XG4gICAgICAgIHY2ID0gcFs1KjggKyBjb2xdO1xuXG4gICAgICAgIC8vIHN0YWdlIDNcbiAgICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcbiAgICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICAgIHYxID0gdDtcbiAgICAgICAgdCA9ICh2MiAqIGRjdFNpbjYgKyB2MyAqIGRjdENvczYgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjIgPSAodjIgKiBkY3RDb3M2IC0gdjMgKiBkY3RTaW42ICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHYzID0gdDtcbiAgICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcbiAgICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICAgIHY2ID0gdDtcbiAgICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcbiAgICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICAgIHY3ID0gdDtcblxuICAgICAgICAvLyBzdGFnZSAyXG4gICAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgICB2MyA9IHQ7XG4gICAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICAgIHYxID0gKHYxICsgdjIgKyAxKSA+PiAxO1xuICAgICAgICB2MiA9IHQ7XG4gICAgICAgIHQgPSAodjQgKiBkY3RTaW4zICsgdjcgKiBkY3RDb3MzICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY0ID0gKHY0ICogZGN0Q29zMyAtIHY3ICogZGN0U2luMyArIDIwNDgpID4+IDEyO1xuICAgICAgICB2NyA9IHQ7XG4gICAgICAgIHQgPSAodjUgKiBkY3RTaW4xICsgdjYgKiBkY3RDb3MxICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY1ID0gKHY1ICogZGN0Q29zMSAtIHY2ICogZGN0U2luMSArIDIwNDgpID4+IDEyO1xuICAgICAgICB2NiA9IHQ7XG5cbiAgICAgICAgLy8gc3RhZ2UgMVxuICAgICAgICBwWzAqOCArIGNvbF0gPSB2MCArIHY3O1xuICAgICAgICBwWzcqOCArIGNvbF0gPSB2MCAtIHY3O1xuICAgICAgICBwWzEqOCArIGNvbF0gPSB2MSArIHY2O1xuICAgICAgICBwWzYqOCArIGNvbF0gPSB2MSAtIHY2O1xuICAgICAgICBwWzIqOCArIGNvbF0gPSB2MiArIHY1O1xuICAgICAgICBwWzUqOCArIGNvbF0gPSB2MiAtIHY1O1xuICAgICAgICBwWzMqOCArIGNvbF0gPSB2MyArIHY0O1xuICAgICAgICBwWzQqOCArIGNvbF0gPSB2MyAtIHY0O1xuICAgICAgfVxuXG4gICAgICAvLyBjb252ZXJ0IHRvIDgtYml0IGludGVnZXJzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICB2YXIgc2FtcGxlID0gMTI4ICsgKChwW2ldICsgOCkgPj4gNCk7XG4gICAgICAgIGRhdGFPdXRbaV0gPSBzYW1wbGUgPCAwID8gMCA6IHNhbXBsZSA+IDB4RkYgPyAweEZGIDogc2FtcGxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpLCBqO1xuICAgIGZvciAodmFyIGJsb2NrUm93ID0gMDsgYmxvY2tSb3cgPCBibG9ja3NQZXJDb2x1bW47IGJsb2NrUm93KyspIHtcbiAgICAgIHZhciBzY2FuTGluZSA9IGJsb2NrUm93IDw8IDM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBVaW50OEFycmF5KHNhbXBsZXNQZXJMaW5lKSk7XG4gICAgICBmb3IgKHZhciBibG9ja0NvbCA9IDA7IGJsb2NrQ29sIDwgYmxvY2tzUGVyTGluZTsgYmxvY2tDb2wrKykge1xuICAgICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdLCByLCBSKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gMCwgc2FtcGxlID0gYmxvY2tDb2wgPDwgMztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbc2NhbkxpbmUgKyBqXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgbGluZVtzYW1wbGUgKyBpXSA9IHJbb2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYW1wVG84Yml0KGEpIHtcbiAgICByZXR1cm4gYSA8IDAgPyAwIDogYSA+IDI1NSA/IDI1NSA6IGE7XG4gIH1cblxuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSB7XG4gICAgbG9hZDogZnVuY3Rpb24gbG9hZChwYXRoKSB7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbihcIkdFVFwiLCBwYXRoLCB0cnVlKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICB4aHIub25sb2FkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPIGNhdGNoIHBhcnNlIGVycm9yXG4gICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlIHx8IHhoci5tb3pSZXNwb25zZUFycmF5QnVmZmVyKTtcbiAgICAgICAgdGhpcy5wYXJzZShkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMub25sb2FkKVxuICAgICAgICAgIHRoaXMub25sb2FkKCk7XG4gICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoZGF0YSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgZnVuY3Rpb24gcmVhZFVpbnQxNigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWFkRGF0YUJsb2NrKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICB2YXIgYXJyYXkgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoIC0gMik7XG4gICAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XG4gICAgICAgIHZhciBtYXhIID0gMCwgbWF4ViA9IDA7XG4gICAgICAgIHZhciBjb21wb25lbnQsIGNvbXBvbmVudElkO1xuICAgICAgICBmb3IgKGNvbXBvbmVudElkIGluIGZyYW1lLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICBpZiAoZnJhbWUuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnRJZCkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdO1xuICAgICAgICAgICAgaWYgKG1heEggPCBjb21wb25lbnQuaCkgbWF4SCA9IGNvbXBvbmVudC5oO1xuICAgICAgICAgICAgaWYgKG1heFYgPCBjb21wb25lbnQudikgbWF4ViA9IGNvbXBvbmVudC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWN1c1BlckxpbmUgPSBNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4IC8gbWF4SCk7XG4gICAgICAgIHZhciBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBtYXhWKTtcbiAgICAgICAgZm9yIChjb21wb25lbnRJZCBpbiBmcmFtZS5jb21wb25lbnRzKSB7XG4gICAgICAgICAgaWYgKGZyYW1lLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkoY29tcG9uZW50SWQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXTtcbiAgICAgICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDgpICogY29tcG9uZW50LmggLyBtYXhIKTtcbiAgICAgICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAgLyA4KSAqIGNvbXBvbmVudC52IC8gbWF4Vik7XG4gICAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZUZvck1jdSA9IG1jdXNQZXJMaW5lICogY29tcG9uZW50Lmg7XG4gICAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uRm9yTWN1ID0gbWN1c1BlckNvbHVtbiAqIGNvbXBvbmVudC52O1xuICAgICAgICAgICAgdmFyIGJsb2NrcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NQZXJDb2x1bW5Gb3JNY3U7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tzUGVyTGluZUZvck1jdTsgaisrKVxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKG5ldyBJbnQzMkFycmF5KDY0KSk7XG4gICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuYmxvY2tzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmU7XG4gICAgICAgICAgICBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uID0gYmxvY2tzUGVyQ29sdW1uO1xuICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrcyA9IGJsb2NrcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUubWF4SCA9IG1heEg7XG4gICAgICAgIGZyYW1lLm1heFYgPSBtYXhWO1xuICAgICAgICBmcmFtZS5tY3VzUGVyTGluZSA9IG1jdXNQZXJMaW5lO1xuICAgICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjtcbiAgICAgIH1cbiAgICAgIHZhciBqZmlmID0gbnVsbDtcbiAgICAgIHZhciBhZG9iZSA9IG51bGw7XG4gICAgICB2YXIgcGl4ZWxzID0gbnVsbDtcbiAgICAgIHZhciBmcmFtZSwgcmVzZXRJbnRlcnZhbDtcbiAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXMgPSBbXSwgZnJhbWVzID0gW107XG4gICAgICB2YXIgaHVmZm1hblRhYmxlc0FDID0gW10sIGh1ZmZtYW5UYWJsZXNEQyA9IFtdO1xuICAgICAgdmFyIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgICBpZiAoZmlsZU1hcmtlciAhPSAweEZGRDgpIHsgLy8gU09JIChTdGFydCBvZiBJbWFnZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU09JIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cblxuICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICAgIHdoaWxlIChmaWxlTWFya2VyICE9IDB4RkZEOSkgeyAvLyBFT0kgKEVuZCBvZiBpbWFnZSlcbiAgICAgICAgdmFyIGksIGosIGw7XG4gICAgICAgIHN3aXRjaChmaWxlTWFya2VyKSB7XG4gICAgICAgICAgY2FzZSAweEZGMDA6IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHhGRkUwOiAvLyBBUFAwIChBcHBsaWNhdGlvbiBTcGVjaWZpYylcbiAgICAgICAgICBjYXNlIDB4RkZFMTogLy8gQVBQMVxuICAgICAgICAgIGNhc2UgMHhGRkUyOiAvLyBBUFAyXG4gICAgICAgICAgY2FzZSAweEZGRTM6IC8vIEFQUDNcbiAgICAgICAgICBjYXNlIDB4RkZFNDogLy8gQVBQNFxuICAgICAgICAgIGNhc2UgMHhGRkU1OiAvLyBBUFA1XG4gICAgICAgICAgY2FzZSAweEZGRTY6IC8vIEFQUDZcbiAgICAgICAgICBjYXNlIDB4RkZFNzogLy8gQVBQN1xuICAgICAgICAgIGNhc2UgMHhGRkU4OiAvLyBBUFA4XG4gICAgICAgICAgY2FzZSAweEZGRTk6IC8vIEFQUDlcbiAgICAgICAgICBjYXNlIDB4RkZFQTogLy8gQVBQMTBcbiAgICAgICAgICBjYXNlIDB4RkZFQjogLy8gQVBQMTFcbiAgICAgICAgICBjYXNlIDB4RkZFQzogLy8gQVBQMTJcbiAgICAgICAgICBjYXNlIDB4RkZFRDogLy8gQVBQMTNcbiAgICAgICAgICBjYXNlIDB4RkZFRTogLy8gQVBQMTRcbiAgICAgICAgICBjYXNlIDB4RkZFRjogLy8gQVBQMTVcbiAgICAgICAgICBjYXNlIDB4RkZGRTogLy8gQ09NIChDb21tZW50KVxuICAgICAgICAgICAgdmFyIGFwcERhdGEgPSByZWFkRGF0YUJsb2NrKCk7XG5cbiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRTApIHtcbiAgICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NEEgJiYgYXBwRGF0YVsxXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzJdID09PSAweDQ5ICYmXG4gICAgICAgICAgICAgICAgYXBwRGF0YVszXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzRdID09PSAwKSB7IC8vICdKRklGXFx4MDAnXG4gICAgICAgICAgICAgICAgamZpZiA9IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb246IHsgbWFqb3I6IGFwcERhdGFbNV0sIG1pbm9yOiBhcHBEYXRhWzZdIH0sXG4gICAgICAgICAgICAgICAgICBkZW5zaXR5VW5pdHM6IGFwcERhdGFbN10sXG4gICAgICAgICAgICAgICAgICB4RGVuc2l0eTogKGFwcERhdGFbOF0gPDwgOCkgfCBhcHBEYXRhWzldLFxuICAgICAgICAgICAgICAgICAgeURlbnNpdHk6IChhcHBEYXRhWzEwXSA8PCA4KSB8IGFwcERhdGFbMTFdLFxuICAgICAgICAgICAgICAgICAgdGh1bWJXaWR0aDogYXBwRGF0YVsxMl0sXG4gICAgICAgICAgICAgICAgICB0aHVtYkhlaWdodDogYXBwRGF0YVsxM10sXG4gICAgICAgICAgICAgICAgICB0aHVtYkRhdGE6IGFwcERhdGEuc3ViYXJyYXkoMTQsIDE0ICsgMyAqIGFwcERhdGFbMTJdICogYXBwRGF0YVsxM10pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyBBUFAxIC0gRXhpZlxuICAgICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFRSkge1xuICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0MSAmJiBhcHBEYXRhWzFdID09PSAweDY0ICYmIGFwcERhdGFbMl0gPT09IDB4NkYgJiZcbiAgICAgICAgICAgICAgICBhcHBEYXRhWzNdID09PSAweDYyICYmIGFwcERhdGFbNF0gPT09IDB4NjUgJiYgYXBwRGF0YVs1XSA9PT0gMCkgeyAvLyAnQWRvYmVcXHgwMCdcbiAgICAgICAgICAgICAgICBhZG9iZSA9IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb246IGFwcERhdGFbNl0sXG4gICAgICAgICAgICAgICAgICBmbGFnczA6IChhcHBEYXRhWzddIDw8IDgpIHwgYXBwRGF0YVs4XSxcbiAgICAgICAgICAgICAgICAgIGZsYWdzMTogKGFwcERhdGFbOV0gPDwgOCkgfCBhcHBEYXRhWzEwXSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUNvZGU6IGFwcERhdGFbMTFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZEQjogLy8gRFFUIChEZWZpbmUgUXVhbnRpemF0aW9uIFRhYmxlcylcbiAgICAgICAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXNMZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBxdWFudGl6YXRpb25UYWJsZXNFbmQpIHtcbiAgICAgICAgICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICB2YXIgdGFibGVEYXRhID0gbmV3IEludDMyQXJyYXkoNjQpO1xuICAgICAgICAgICAgICBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkgeyAvLyA4IGJpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdbal07XG4gICAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMSkgeyAvLzE2IGJpdFxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICAgIHRhYmxlRGF0YVt6XSA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRRVDogaW52YWxpZCB0YWJsZSBzcGVjXCIpO1xuICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZXNbcXVhbnRpemF0aW9uVGFibGVTcGVjICYgMTVdID0gdGFibGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZDMDogLy8gU09GMCAoU3RhcnQgb2YgRnJhbWUsIEJhc2VsaW5lIERDVClcbiAgICAgICAgICBjYXNlIDB4RkZDMTogLy8gU09GMSAoU3RhcnQgb2YgRnJhbWUsIEV4dGVuZGVkIERDVClcbiAgICAgICAgICBjYXNlIDB4RkZDMjogLy8gU09GMiAoU3RhcnQgb2YgRnJhbWUsIFByb2dyZXNzaXZlIERDVClcbiAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgICAgZnJhbWUgPSB7fTtcbiAgICAgICAgICAgIGZyYW1lLmV4dGVuZGVkID0gKGZpbGVNYXJrZXIgPT09IDB4RkZDMSk7XG4gICAgICAgICAgICBmcmFtZS5wcm9ncmVzc2l2ZSA9IChmaWxlTWFya2VyID09PSAweEZGQzIpO1xuICAgICAgICAgICAgZnJhbWUucHJlY2lzaW9uID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBmcmFtZS5zY2FuTGluZXMgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICBmcmFtZS5zYW1wbGVzUGVyTGluZSA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNPcmRlciA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IGRhdGFbb2Zmc2V0KytdLCBjb21wb25lbnRJZDtcbiAgICAgICAgICAgIHZhciBtYXhIID0gMCwgbWF4ViA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50SWQgPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgIHZhciBoID0gZGF0YVtvZmZzZXQgKyAxXSA+PiA0O1xuICAgICAgICAgICAgICB2YXIgdiA9IGRhdGFbb2Zmc2V0ICsgMV0gJiAxNTtcbiAgICAgICAgICAgICAgdmFyIHFJZCA9IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNPcmRlci5wdXNoKGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaDogaCxcbiAgICAgICAgICAgICAgICB2OiB2LFxuICAgICAgICAgICAgICAgIHF1YW50aXphdGlvbklkeDogcUlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpO1xuICAgICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZDNDogLy8gREhUIChEZWZpbmUgSHVmZm1hbiBUYWJsZXMpXG4gICAgICAgICAgICB2YXIgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDI7IGkgPCBodWZmbWFuTGVuZ3RoOykge1xuICAgICAgICAgICAgICB2YXIgaHVmZm1hblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICB2YXIgY29kZUxlbmd0aHMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICAgIHZhciBjb2RlTGVuZ3RoU3VtID0gMDtcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyssIG9mZnNldCsrKVxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhTdW0gKz0gKGNvZGVMZW5ndGhzW2pdID0gZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICAgICAgdmFyIGh1ZmZtYW5WYWx1ZXMgPSBuZXcgVWludDhBcnJheShjb2RlTGVuZ3RoU3VtKTtcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvZGVMZW5ndGhTdW07IGorKywgb2Zmc2V0KyspXG4gICAgICAgICAgICAgICAgaHVmZm1hblZhbHVlc1tqXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgaSArPSAxNyArIGNvZGVMZW5ndGhTdW07XG5cbiAgICAgICAgICAgICAgKChodWZmbWFuVGFibGVTcGVjID4+IDQpID09PSAwID9cbiAgICAgICAgICAgICAgICBodWZmbWFuVGFibGVzREMgOiBodWZmbWFuVGFibGVzQUMpW2h1ZmZtYW5UYWJsZVNwZWMgJiAxNV0gPVxuICAgICAgICAgICAgICAgIGJ1aWxkSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweEZGREQ6IC8vIERSSSAoRGVmaW5lIFJlc3RhcnQgSW50ZXJ2YWwpXG4gICAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgZGF0YSBsZW5ndGhcbiAgICAgICAgICAgIHJlc2V0SW50ZXJ2YWwgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhGRkRBOiAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pXG4gICAgICAgICAgICB2YXIgc2Nhbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcnNDb3VudCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXSwgY29tcG9uZW50O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9yc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tkYXRhW29mZnNldCsrXV07XG4gICAgICAgICAgICAgIHZhciB0YWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDID0gaHVmZm1hblRhYmxlc0RDW3RhYmxlU3BlYyA+PiA0XTtcbiAgICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gaHVmZm1hblRhYmxlc0FDW3RhYmxlU3BlYyAmIDE1XTtcbiAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3BlY3RyYWxTdGFydCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgdmFyIHNwZWN0cmFsRW5kID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICB2YXIgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzZWQgPSBkZWNvZGVTY2FuKGRhdGEsIG9mZnNldCxcbiAgICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXG4gICAgICAgICAgICAgIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLFxuICAgICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTtcbiAgICAgICAgICAgIG9mZnNldCArPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhGRkZGOiAvLyBGaWxsIGJ5dGVzXG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdICE9PSAweEZGKSB7IC8vIEF2b2lkIHNraXBwaW5nIGEgdmFsaWQgbWFya2VyLlxuICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChkYXRhW29mZnNldCAtIDNdID09IDB4RkYgJiZcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCAtIDJdID49IDB4QzAgJiYgZGF0YVtvZmZzZXQgLSAyXSA8PSAweEZFKSB7XG4gICAgICAgICAgICAgIC8vIGNvdWxkIGJlIGluY29ycmVjdCBlbmNvZGluZyAtLSBsYXN0IDB4RkYgYnl0ZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgLy8gYmxvY2sgd2FzIGVhdGVuIGJ5IHRoZSBlbmNvZGVyXG4gICAgICAgICAgICAgIG9mZnNldCAtPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gSlBFRyBtYXJrZXIgXCIgKyBmaWxlTWFya2VyLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZXMubGVuZ3RoICE9IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9ubHkgc2luZ2xlIGZyYW1lIEpQRUdzIHN1cHBvcnRlZFwiKTtcblxuICAgICAgLy8gc2V0IGVhY2ggZnJhbWUncyBjb21wb25lbnRzIHF1YW50aXphdGlvbiB0YWJsZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNwID0gZnJhbWVzW2ldLmNvbXBvbmVudHM7XG4gICAgICAgIGZvciAodmFyIGogaW4gY3ApIHtcbiAgICAgICAgICBjcFtqXS5xdWFudGl6YXRpb25UYWJsZSA9IHF1YW50aXphdGlvblRhYmxlc1tjcFtqXS5xdWFudGl6YXRpb25JZHhdO1xuICAgICAgICAgIGRlbGV0ZSBjcFtqXS5xdWFudGl6YXRpb25JZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lO1xuICAgICAgdGhpcy5oZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7XG4gICAgICB0aGlzLmpmaWYgPSBqZmlmO1xuICAgICAgdGhpcy5hZG9iZSA9IGFkb2JlO1xuICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHNPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tmcmFtZS5jb21wb25lbnRzT3JkZXJbaV1dO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgbGluZXM6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSxcbiAgICAgICAgICBzY2FsZVg6IGNvbXBvbmVudC5oIC8gZnJhbWUubWF4SCxcbiAgICAgICAgICBzY2FsZVk6IGNvbXBvbmVudC52IC8gZnJhbWUubWF4VlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldERhdGE6IGZ1bmN0aW9uIGdldERhdGEod2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIHNjYWxlWCA9IHRoaXMud2lkdGggLyB3aWR0aCwgc2NhbGVZID0gdGhpcy5oZWlnaHQgLyBoZWlnaHQ7XG5cbiAgICAgIHZhciBjb21wb25lbnQxLCBjb21wb25lbnQyLCBjb21wb25lbnQzLCBjb21wb25lbnQ0O1xuICAgICAgdmFyIGNvbXBvbmVudDFMaW5lLCBjb21wb25lbnQyTGluZSwgY29tcG9uZW50M0xpbmUsIGNvbXBvbmVudDRMaW5lO1xuICAgICAgdmFyIHgsIHk7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBZLCBDYiwgQ3IsIEssIEMsIE0sIFllLCBSLCBHLCBCO1xuICAgICAgdmFyIGNvbG9yVHJhbnNmb3JtO1xuICAgICAgdmFyIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIHRoaXMuY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgc3dpdGNoICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjb21wb25lbnQxID0gdGhpcy5jb21wb25lbnRzWzBdO1xuICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50MUxpbmUgPSBjb21wb25lbnQxLmxpbmVzWzAgfCAoeSAqIGNvbXBvbmVudDEuc2NhbGVZICogc2NhbGVZKV07XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICBZID0gY29tcG9uZW50MUxpbmVbMCB8ICh4ICogY29tcG9uZW50MS5zY2FsZVggKiBzY2FsZVgpXTtcblxuICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXSA9IFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgLy8gUERGIG1pZ2h0IGNvbXByZXNzIHR3byBjb21wb25lbnQgZGF0YSBpbiBjdXN0b20gY29sb3JzcGFjZVxuICAgICAgICAgIGNvbXBvbmVudDEgPSB0aGlzLmNvbXBvbmVudHNbMF07XG4gICAgICAgICAgY29tcG9uZW50MiA9IHRoaXMuY29tcG9uZW50c1sxXTtcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudDFMaW5lID0gY29tcG9uZW50MS5saW5lc1swIHwgKHkgKiBjb21wb25lbnQxLnNjYWxlWSAqIHNjYWxlWSldO1xuICAgICAgICAgICAgY29tcG9uZW50MkxpbmUgPSBjb21wb25lbnQyLmxpbmVzWzAgfCAoeSAqIGNvbXBvbmVudDIuc2NhbGVZICogc2NhbGVZKV07XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICBZID0gY29tcG9uZW50MUxpbmVbMCB8ICh4ICogY29tcG9uZW50MS5zY2FsZVggKiBzY2FsZVgpXTtcbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPSBZO1xuICAgICAgICAgICAgICBZID0gY29tcG9uZW50MkxpbmVbMCB8ICh4ICogY29tcG9uZW50Mi5zY2FsZVggKiBzY2FsZVgpXTtcbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPSBZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHRyYW5zZm9ybSBmb3IgdGhyZWUgY29tcG9uZW50cyBpcyB0cnVlXG4gICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgIC8vIFRoZSBhZG9iZSB0cmFuc2Zvcm0gbWFya2VyIG92ZXJyaWRlcyBhbnkgcHJldmlvdXMgc2V0dGluZ1xuICAgICAgICAgIGlmICh0aGlzLmFkb2JlICYmIHRoaXMuYWRvYmUudHJhbnNmb3JtQ29kZSlcbiAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb2xvclRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9ICEhdGhpcy5jb2xvclRyYW5zZm9ybTtcblxuICAgICAgICAgIGNvbXBvbmVudDEgPSB0aGlzLmNvbXBvbmVudHNbMF07XG4gICAgICAgICAgY29tcG9uZW50MiA9IHRoaXMuY29tcG9uZW50c1sxXTtcbiAgICAgICAgICBjb21wb25lbnQzID0gdGhpcy5jb21wb25lbnRzWzJdO1xuICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50MUxpbmUgPSBjb21wb25lbnQxLmxpbmVzWzAgfCAoeSAqIGNvbXBvbmVudDEuc2NhbGVZICogc2NhbGVZKV07XG4gICAgICAgICAgICBjb21wb25lbnQyTGluZSA9IGNvbXBvbmVudDIubGluZXNbMCB8ICh5ICogY29tcG9uZW50Mi5zY2FsZVkgKiBzY2FsZVkpXTtcbiAgICAgICAgICAgIGNvbXBvbmVudDNMaW5lID0gY29tcG9uZW50My5saW5lc1swIHwgKHkgKiBjb21wb25lbnQzLnNjYWxlWSAqIHNjYWxlWSldO1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjb2xvclRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIFIgPSBjb21wb25lbnQxTGluZVswIHwgKHggKiBjb21wb25lbnQxLnNjYWxlWCAqIHNjYWxlWCldO1xuICAgICAgICAgICAgICAgIEcgPSBjb21wb25lbnQyTGluZVswIHwgKHggKiBjb21wb25lbnQyLnNjYWxlWCAqIHNjYWxlWCldO1xuICAgICAgICAgICAgICAgIEIgPSBjb21wb25lbnQzTGluZVswIHwgKHggKiBjb21wb25lbnQzLnNjYWxlWCAqIHNjYWxlWCldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFkgPSBjb21wb25lbnQxTGluZVswIHwgKHggKiBjb21wb25lbnQxLnNjYWxlWCAqIHNjYWxlWCldO1xuICAgICAgICAgICAgICAgIENiID0gY29tcG9uZW50MkxpbmVbMCB8ICh4ICogY29tcG9uZW50Mi5zY2FsZVggKiBzY2FsZVgpXTtcbiAgICAgICAgICAgICAgICBDciA9IGNvbXBvbmVudDNMaW5lWzAgfCAoeCAqIGNvbXBvbmVudDMuc2NhbGVYICogc2NhbGVYKV07XG5cbiAgICAgICAgICAgICAgICBSID0gY2xhbXBUbzhiaXQoWSArIDEuNDAyICogKENyIC0gMTI4KSk7XG4gICAgICAgICAgICAgICAgRyA9IGNsYW1wVG84Yml0KFkgLSAwLjM0NDEzNjMgKiAoQ2IgLSAxMjgpIC0gMC43MTQxMzYzNiAqIChDciAtIDEyOCkpO1xuICAgICAgICAgICAgICAgIEIgPSBjbGFtcFRvOGJpdChZICsgMS43NzIgKiAoQ2IgLSAxMjgpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdID0gUjtcbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPSBHO1xuICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXSA9IEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgaWYgKCF0aGlzLmFkb2JlKVxuICAgICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUgKDQgY29tcG9uZW50cyknO1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHRyYW5zZm9ybSBmb3IgZm91ciBjb21wb25lbnRzIGlzIGZhbHNlXG4gICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAvLyBUaGUgYWRvYmUgdHJhbnNmb3JtIG1hcmtlciBvdmVycmlkZXMgYW55IHByZXZpb3VzIHNldHRpbmdcbiAgICAgICAgICBpZiAodGhpcy5hZG9iZSAmJiB0aGlzLmFkb2JlLnRyYW5zZm9ybUNvZGUpXG4gICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuY29sb3JUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSAhIXRoaXMuY29sb3JUcmFuc2Zvcm07XG5cbiAgICAgICAgICBjb21wb25lbnQxID0gdGhpcy5jb21wb25lbnRzWzBdO1xuICAgICAgICAgIGNvbXBvbmVudDIgPSB0aGlzLmNvbXBvbmVudHNbMV07XG4gICAgICAgICAgY29tcG9uZW50MyA9IHRoaXMuY29tcG9uZW50c1syXTtcbiAgICAgICAgICBjb21wb25lbnQ0ID0gdGhpcy5jb21wb25lbnRzWzNdO1xuICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50MUxpbmUgPSBjb21wb25lbnQxLmxpbmVzWzAgfCAoeSAqIGNvbXBvbmVudDEuc2NhbGVZICogc2NhbGVZKV07XG4gICAgICAgICAgICBjb21wb25lbnQyTGluZSA9IGNvbXBvbmVudDIubGluZXNbMCB8ICh5ICogY29tcG9uZW50Mi5zY2FsZVkgKiBzY2FsZVkpXTtcbiAgICAgICAgICAgIGNvbXBvbmVudDNMaW5lID0gY29tcG9uZW50My5saW5lc1swIHwgKHkgKiBjb21wb25lbnQzLnNjYWxlWSAqIHNjYWxlWSldO1xuICAgICAgICAgICAgY29tcG9uZW50NExpbmUgPSBjb21wb25lbnQ0LmxpbmVzWzAgfCAoeSAqIGNvbXBvbmVudDQuc2NhbGVZICogc2NhbGVZKV07XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICBpZiAoIWNvbG9yVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgQyA9IGNvbXBvbmVudDFMaW5lWzAgfCAoeCAqIGNvbXBvbmVudDEuc2NhbGVYICogc2NhbGVYKV07XG4gICAgICAgICAgICAgICAgTSA9IGNvbXBvbmVudDJMaW5lWzAgfCAoeCAqIGNvbXBvbmVudDIuc2NhbGVYICogc2NhbGVYKV07XG4gICAgICAgICAgICAgICAgWWUgPSBjb21wb25lbnQzTGluZVswIHwgKHggKiBjb21wb25lbnQzLnNjYWxlWCAqIHNjYWxlWCldO1xuICAgICAgICAgICAgICAgIEsgPSBjb21wb25lbnQ0TGluZVswIHwgKHggKiBjb21wb25lbnQ0LnNjYWxlWCAqIHNjYWxlWCldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFkgPSBjb21wb25lbnQxTGluZVswIHwgKHggKiBjb21wb25lbnQxLnNjYWxlWCAqIHNjYWxlWCldO1xuICAgICAgICAgICAgICAgIENiID0gY29tcG9uZW50MkxpbmVbMCB8ICh4ICogY29tcG9uZW50Mi5zY2FsZVggKiBzY2FsZVgpXTtcbiAgICAgICAgICAgICAgICBDciA9IGNvbXBvbmVudDNMaW5lWzAgfCAoeCAqIGNvbXBvbmVudDMuc2NhbGVYICogc2NhbGVYKV07XG4gICAgICAgICAgICAgICAgSyA9IGNvbXBvbmVudDRMaW5lWzAgfCAoeCAqIGNvbXBvbmVudDQuc2NhbGVYICogc2NhbGVYKV07XG5cbiAgICAgICAgICAgICAgICBDID0gMjU1IC0gY2xhbXBUbzhiaXQoWSArIDEuNDAyICogKENyIC0gMTI4KSk7XG4gICAgICAgICAgICAgICAgTSA9IDI1NSAtIGNsYW1wVG84Yml0KFkgLSAwLjM0NDEzNjMgKiAoQ2IgLSAxMjgpIC0gMC43MTQxMzYzNiAqIChDciAtIDEyOCkpO1xuICAgICAgICAgICAgICAgIFllID0gMjU1IC0gY2xhbXBUbzhiaXQoWSArIDEuNzcyICogKENiIC0gMTI4KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPSAyNTUtQztcbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPSAyNTUtTTtcbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPSAyNTUtWWU7XG4gICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdID0gMjU1LUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gICAgY29weVRvSW1hZ2VEYXRhOiBmdW5jdGlvbiBjb3B5VG9JbWFnZURhdGEoaW1hZ2VEYXRhKSB7XG4gICAgICB2YXIgd2lkdGggPSBpbWFnZURhdGEud2lkdGgsIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgaW1hZ2VEYXRhQXJyYXkgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGkgPSAwLCBqID0gMCwgeCwgeTtcbiAgICAgIHZhciBZLCBLLCBDLCBNLCBSLCBHLCBCO1xuICAgICAgc3dpdGNoICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgIFkgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IFk7XG4gICAgICAgICAgICAgIGltYWdlRGF0YUFycmF5W2orK10gPSBZO1xuICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gWTtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgIFIgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgIEcgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgIEIgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IFI7XG4gICAgICAgICAgICAgIGltYWdlRGF0YUFycmF5W2orK10gPSBHO1xuICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gQjtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgIEMgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgIE0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgIFkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgIEsgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgUiA9IDI1NSAtIGNsYW1wVG84Yml0KEMgKiAoMSAtIEsgLyAyNTUpICsgSyk7XG4gICAgICAgICAgICAgIEcgPSAyNTUgLSBjbGFtcFRvOGJpdChNICogKDEgLSBLIC8gMjU1KSArIEspO1xuICAgICAgICAgICAgICBCID0gMjU1IC0gY2xhbXBUbzhiaXQoWSAqICgxIC0gSyAvIDI1NSkgKyBLKTtcblxuICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gUjtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IEc7XG4gICAgICAgICAgICAgIGltYWdlRGF0YUFycmF5W2orK10gPSBCO1xuICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgY29sb3IgbW9kZSc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcblxuZnVuY3Rpb24gZGVjb2RlKGpwZWdEYXRhLCB1c2VUQXJyYXkpIHtcbiAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGpwZWdEYXRhKTtcbiAgdmFyIGRlY29kZXIgPSBuZXcgSnBlZ0ltYWdlKCk7XG4gIGRlY29kZXIucGFyc2UoYXJyKTtcblxuICB2YXIgaW1hZ2UgPSB7XG4gICAgd2lkdGg6IGRlY29kZXIud2lkdGgsXG4gICAgaGVpZ2h0OiBkZWNvZGVyLmhlaWdodCxcbiAgICBkYXRhOiB1c2VUQXJyYXkgP1xuICAgICAgbmV3IFVpbnQ4QXJyYXkoZGVjb2Rlci53aWR0aCAqIGRlY29kZXIuaGVpZ2h0ICogNCkgOlxuICAgICAgbmV3IEJ1ZmZlcihkZWNvZGVyLndpZHRoICogZGVjb2Rlci5oZWlnaHQgKiA0KVxuICB9O1xuXG4gIGRlY29kZXIuY29weVRvSW1hZ2VEYXRhKGltYWdlKTtcblxuICByZXR1cm4gaW1hZ2U7XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgKGMpIDIwMDgsIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIFxuICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gIFxuICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgbm9yIHRoZSBuYW1lcyBvZiBpdHMgXG4gICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gXG4gICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVNcbiAgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SIFxuICBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuLypcbkpQRUcgZW5jb2RlciBwb3J0ZWQgdG8gSmF2YVNjcmlwdCBhbmQgb3B0aW1pemVkIGJ5IEFuZHJlYXMgUml0dGVyLCB3d3cuYnl0ZXN0cm9tLmV1LCAxMS8yMDA5XG5cbkJhc2ljIEdVSSBibG9ja2luZyBqcGVnIGVuY29kZXJcbiovXG5cbnZhciBidG9hID0gYnRvYSB8fCBmdW5jdGlvbihidWYpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIoYnVmKS50b1N0cmluZygnYmFzZTY0Jyk7XG59O1xuXG5mdW5jdGlvbiBKUEVHRW5jb2RlcihxdWFsaXR5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblx0dmFyIGZyb3VuZCA9IE1hdGgucm91bmQ7XG5cdHZhciBmZmxvb3IgPSBNYXRoLmZsb29yO1xuXHR2YXIgWVRhYmxlID0gbmV3IEFycmF5KDY0KTtcblx0dmFyIFVWVGFibGUgPSBuZXcgQXJyYXkoNjQpO1xuXHR2YXIgZmR0YmxfWSA9IG5ldyBBcnJheSg2NCk7XG5cdHZhciBmZHRibF9VViA9IG5ldyBBcnJheSg2NCk7XG5cdHZhciBZRENfSFQ7XG5cdHZhciBVVkRDX0hUO1xuXHR2YXIgWUFDX0hUO1xuXHR2YXIgVVZBQ19IVDtcblx0XG5cdHZhciBiaXRjb2RlID0gbmV3IEFycmF5KDY1NTM1KTtcblx0dmFyIGNhdGVnb3J5ID0gbmV3IEFycmF5KDY1NTM1KTtcblx0dmFyIG91dHB1dGZEQ1RRdWFudCA9IG5ldyBBcnJheSg2NCk7XG5cdHZhciBEVSA9IG5ldyBBcnJheSg2NCk7XG5cdHZhciBieXRlb3V0ID0gW107XG5cdHZhciBieXRlbmV3ID0gMDtcblx0dmFyIGJ5dGVwb3MgPSA3O1xuXHRcblx0dmFyIFlEVSA9IG5ldyBBcnJheSg2NCk7XG5cdHZhciBVRFUgPSBuZXcgQXJyYXkoNjQpO1xuXHR2YXIgVkRVID0gbmV3IEFycmF5KDY0KTtcblx0dmFyIGNsdCA9IG5ldyBBcnJheSgyNTYpO1xuXHR2YXIgUkdCX1lVVl9UQUJMRSA9IG5ldyBBcnJheSgyMDQ4KTtcblx0dmFyIGN1cnJlbnRRdWFsaXR5O1xuXHRcblx0dmFyIFppZ1phZyA9IFtcblx0XHRcdCAwLCAxLCA1LCA2LDE0LDE1LDI3LDI4LFxuXHRcdFx0IDIsIDQsIDcsMTMsMTYsMjYsMjksNDIsXG5cdFx0XHQgMywgOCwxMiwxNywyNSwzMCw0MSw0Myxcblx0XHRcdCA5LDExLDE4LDI0LDMxLDQwLDQ0LDUzLFxuXHRcdFx0MTAsMTksMjMsMzIsMzksNDUsNTIsNTQsXG5cdFx0XHQyMCwyMiwzMywzOCw0Niw1MSw1NSw2MCxcblx0XHRcdDIxLDM0LDM3LDQ3LDUwLDU2LDU5LDYxLFxuXHRcdFx0MzUsMzYsNDgsNDksNTcsNTgsNjIsNjNcblx0XHRdO1xuXHRcblx0dmFyIHN0ZF9kY19sdW1pbmFuY2VfbnJjb2RlcyA9IFswLDAsMSw1LDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDBdO1xuXHR2YXIgc3RkX2RjX2x1bWluYW5jZV92YWx1ZXMgPSBbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMV07XG5cdHZhciBzdGRfYWNfbHVtaW5hbmNlX25yY29kZXMgPSBbMCwwLDIsMSwzLDMsMiw0LDMsNSw1LDQsNCwwLDAsMSwweDdkXTtcblx0dmFyIHN0ZF9hY19sdW1pbmFuY2VfdmFsdWVzID0gW1xuXHRcdFx0MHgwMSwweDAyLDB4MDMsMHgwMCwweDA0LDB4MTEsMHgwNSwweDEyLFxuXHRcdFx0MHgyMSwweDMxLDB4NDEsMHgwNiwweDEzLDB4NTEsMHg2MSwweDA3LFxuXHRcdFx0MHgyMiwweDcxLDB4MTQsMHgzMiwweDgxLDB4OTEsMHhhMSwweDA4LFxuXHRcdFx0MHgyMywweDQyLDB4YjEsMHhjMSwweDE1LDB4NTIsMHhkMSwweGYwLFxuXHRcdFx0MHgyNCwweDMzLDB4NjIsMHg3MiwweDgyLDB4MDksMHgwYSwweDE2LFxuXHRcdFx0MHgxNywweDE4LDB4MTksMHgxYSwweDI1LDB4MjYsMHgyNywweDI4LFxuXHRcdFx0MHgyOSwweDJhLDB4MzQsMHgzNSwweDM2LDB4MzcsMHgzOCwweDM5LFxuXHRcdFx0MHgzYSwweDQzLDB4NDQsMHg0NSwweDQ2LDB4NDcsMHg0OCwweDQ5LFxuXHRcdFx0MHg0YSwweDUzLDB4NTQsMHg1NSwweDU2LDB4NTcsMHg1OCwweDU5LFxuXHRcdFx0MHg1YSwweDYzLDB4NjQsMHg2NSwweDY2LDB4NjcsMHg2OCwweDY5LFxuXHRcdFx0MHg2YSwweDczLDB4NzQsMHg3NSwweDc2LDB4NzcsMHg3OCwweDc5LFxuXHRcdFx0MHg3YSwweDgzLDB4ODQsMHg4NSwweDg2LDB4ODcsMHg4OCwweDg5LFxuXHRcdFx0MHg4YSwweDkyLDB4OTMsMHg5NCwweDk1LDB4OTYsMHg5NywweDk4LFxuXHRcdFx0MHg5OSwweDlhLDB4YTIsMHhhMywweGE0LDB4YTUsMHhhNiwweGE3LFxuXHRcdFx0MHhhOCwweGE5LDB4YWEsMHhiMiwweGIzLDB4YjQsMHhiNSwweGI2LFxuXHRcdFx0MHhiNywweGI4LDB4YjksMHhiYSwweGMyLDB4YzMsMHhjNCwweGM1LFxuXHRcdFx0MHhjNiwweGM3LDB4YzgsMHhjOSwweGNhLDB4ZDIsMHhkMywweGQ0LFxuXHRcdFx0MHhkNSwweGQ2LDB4ZDcsMHhkOCwweGQ5LDB4ZGEsMHhlMSwweGUyLFxuXHRcdFx0MHhlMywweGU0LDB4ZTUsMHhlNiwweGU3LDB4ZTgsMHhlOSwweGVhLFxuXHRcdFx0MHhmMSwweGYyLDB4ZjMsMHhmNCwweGY1LDB4ZjYsMHhmNywweGY4LFxuXHRcdFx0MHhmOSwweGZhXG5cdFx0XTtcblx0XG5cdHZhciBzdGRfZGNfY2hyb21pbmFuY2VfbnJjb2RlcyA9IFswLDAsMywxLDEsMSwxLDEsMSwxLDEsMSwwLDAsMCwwLDBdO1xuXHR2YXIgc3RkX2RjX2Nocm9taW5hbmNlX3ZhbHVlcyA9IFswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExXTtcblx0dmFyIHN0ZF9hY19jaHJvbWluYW5jZV9ucmNvZGVzID0gWzAsMCwyLDEsMiw0LDQsMyw0LDcsNSw0LDQsMCwxLDIsMHg3N107XG5cdHZhciBzdGRfYWNfY2hyb21pbmFuY2VfdmFsdWVzID0gW1xuXHRcdFx0MHgwMCwweDAxLDB4MDIsMHgwMywweDExLDB4MDQsMHgwNSwweDIxLFxuXHRcdFx0MHgzMSwweDA2LDB4MTIsMHg0MSwweDUxLDB4MDcsMHg2MSwweDcxLFxuXHRcdFx0MHgxMywweDIyLDB4MzIsMHg4MSwweDA4LDB4MTQsMHg0MiwweDkxLFxuXHRcdFx0MHhhMSwweGIxLDB4YzEsMHgwOSwweDIzLDB4MzMsMHg1MiwweGYwLFxuXHRcdFx0MHgxNSwweDYyLDB4NzIsMHhkMSwweDBhLDB4MTYsMHgyNCwweDM0LFxuXHRcdFx0MHhlMSwweDI1LDB4ZjEsMHgxNywweDE4LDB4MTksMHgxYSwweDI2LFxuXHRcdFx0MHgyNywweDI4LDB4MjksMHgyYSwweDM1LDB4MzYsMHgzNywweDM4LFxuXHRcdFx0MHgzOSwweDNhLDB4NDMsMHg0NCwweDQ1LDB4NDYsMHg0NywweDQ4LFxuXHRcdFx0MHg0OSwweDRhLDB4NTMsMHg1NCwweDU1LDB4NTYsMHg1NywweDU4LFxuXHRcdFx0MHg1OSwweDVhLDB4NjMsMHg2NCwweDY1LDB4NjYsMHg2NywweDY4LFxuXHRcdFx0MHg2OSwweDZhLDB4NzMsMHg3NCwweDc1LDB4NzYsMHg3NywweDc4LFxuXHRcdFx0MHg3OSwweDdhLDB4ODIsMHg4MywweDg0LDB4ODUsMHg4NiwweDg3LFxuXHRcdFx0MHg4OCwweDg5LDB4OGEsMHg5MiwweDkzLDB4OTQsMHg5NSwweDk2LFxuXHRcdFx0MHg5NywweDk4LDB4OTksMHg5YSwweGEyLDB4YTMsMHhhNCwweGE1LFxuXHRcdFx0MHhhNiwweGE3LDB4YTgsMHhhOSwweGFhLDB4YjIsMHhiMywweGI0LFxuXHRcdFx0MHhiNSwweGI2LDB4YjcsMHhiOCwweGI5LDB4YmEsMHhjMiwweGMzLFxuXHRcdFx0MHhjNCwweGM1LDB4YzYsMHhjNywweGM4LDB4YzksMHhjYSwweGQyLFxuXHRcdFx0MHhkMywweGQ0LDB4ZDUsMHhkNiwweGQ3LDB4ZDgsMHhkOSwweGRhLFxuXHRcdFx0MHhlMiwweGUzLDB4ZTQsMHhlNSwweGU2LDB4ZTcsMHhlOCwweGU5LFxuXHRcdFx0MHhlYSwweGYyLDB4ZjMsMHhmNCwweGY1LDB4ZjYsMHhmNywweGY4LFxuXHRcdFx0MHhmOSwweGZhXG5cdFx0XTtcblx0XG5cdGZ1bmN0aW9uIGluaXRRdWFudFRhYmxlcyhzZil7XG5cdFx0XHR2YXIgWVFUID0gW1xuXHRcdFx0XHQxNiwgMTEsIDEwLCAxNiwgMjQsIDQwLCA1MSwgNjEsXG5cdFx0XHRcdDEyLCAxMiwgMTQsIDE5LCAyNiwgNTgsIDYwLCA1NSxcblx0XHRcdFx0MTQsIDEzLCAxNiwgMjQsIDQwLCA1NywgNjksIDU2LFxuXHRcdFx0XHQxNCwgMTcsIDIyLCAyOSwgNTEsIDg3LCA4MCwgNjIsXG5cdFx0XHRcdDE4LCAyMiwgMzcsIDU2LCA2OCwxMDksMTAzLCA3Nyxcblx0XHRcdFx0MjQsIDM1LCA1NSwgNjQsIDgxLDEwNCwxMTMsIDkyLFxuXHRcdFx0XHQ0OSwgNjQsIDc4LCA4NywxMDMsMTIxLDEyMCwxMDEsXG5cdFx0XHRcdDcyLCA5MiwgOTUsIDk4LDExMiwxMDAsMTAzLCA5OVxuXHRcdFx0XTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdFx0XHRcdHZhciB0ID0gZmZsb29yKChZUVRbaV0qc2YrNTApLzEwMCk7XG5cdFx0XHRcdGlmICh0IDwgMSkge1xuXHRcdFx0XHRcdHQgPSAxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQgPiAyNTUpIHtcblx0XHRcdFx0XHR0ID0gMjU1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdFlUYWJsZVtaaWdaYWdbaV1dID0gdDtcblx0XHRcdH1cblx0XHRcdHZhciBVVlFUID0gW1xuXHRcdFx0XHQxNywgMTgsIDI0LCA0NywgOTksIDk5LCA5OSwgOTksXG5cdFx0XHRcdDE4LCAyMSwgMjYsIDY2LCA5OSwgOTksIDk5LCA5OSxcblx0XHRcdFx0MjQsIDI2LCA1NiwgOTksIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0XHQ0NywgNjYsIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksXG5cdFx0XHRcdDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSxcblx0XHRcdFx0OTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0XHQ5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksXG5cdFx0XHRcdDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OVxuXHRcdFx0XTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuXHRcdFx0XHR2YXIgdSA9IGZmbG9vcigoVVZRVFtqXSpzZis1MCkvMTAwKTtcblx0XHRcdFx0aWYgKHUgPCAxKSB7XG5cdFx0XHRcdFx0dSA9IDE7XG5cdFx0XHRcdH0gZWxzZSBpZiAodSA+IDI1NSkge1xuXHRcdFx0XHRcdHUgPSAyNTU7XG5cdFx0XHRcdH1cblx0XHRcdFx0VVZUYWJsZVtaaWdaYWdbal1dID0gdTtcblx0XHRcdH1cblx0XHRcdHZhciBhYXNmID0gW1xuXHRcdFx0XHQxLjAsIDEuMzg3MDM5ODQ1LCAxLjMwNjU2Mjk2NSwgMS4xNzU4NzU2MDIsXG5cdFx0XHRcdDEuMCwgMC43ODU2OTQ5NTgsIDAuNTQxMTk2MTAwLCAwLjI3NTg5OTM3OVxuXHRcdFx0XTtcblx0XHRcdHZhciBrID0gMDtcblx0XHRcdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IDg7IHJvdysrKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCA4OyBjb2wrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZkdGJsX1lba10gID0gKDEuMCAvIChZVGFibGUgW1ppZ1phZ1trXV0gKiBhYXNmW3Jvd10gKiBhYXNmW2NvbF0gKiA4LjApKTtcblx0XHRcdFx0XHRmZHRibF9VVltrXSA9ICgxLjAgLyAoVVZUYWJsZVtaaWdaYWdba11dICogYWFzZltyb3ddICogYWFzZltjb2xdICogOC4wKSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGZ1bmN0aW9uIGNvbXB1dGVIdWZmbWFuVGJsKG5yY29kZXMsIHN0ZF90YWJsZSl7XG5cdFx0XHR2YXIgY29kZXZhbHVlID0gMDtcblx0XHRcdHZhciBwb3NfaW5fdGFibGUgPSAwO1xuXHRcdFx0dmFyIEhUID0gbmV3IEFycmF5KCk7XG5cdFx0XHRmb3IgKHZhciBrID0gMTsgayA8PSAxNjsgaysrKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAxOyBqIDw9IG5yY29kZXNba107IGorKykge1xuXHRcdFx0XHRcdEhUW3N0ZF90YWJsZVtwb3NfaW5fdGFibGVdXSA9IFtdO1xuXHRcdFx0XHRcdEhUW3N0ZF90YWJsZVtwb3NfaW5fdGFibGVdXVswXSA9IGNvZGV2YWx1ZTtcblx0XHRcdFx0XHRIVFtzdGRfdGFibGVbcG9zX2luX3RhYmxlXV1bMV0gPSBrO1xuXHRcdFx0XHRcdHBvc19pbl90YWJsZSsrO1xuXHRcdFx0XHRcdGNvZGV2YWx1ZSsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvZGV2YWx1ZSo9Mjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBIVDtcblx0XHR9XG5cdFx0XG5cdFx0ZnVuY3Rpb24gaW5pdEh1ZmZtYW5UYmwoKVxuXHRcdHtcblx0XHRcdFlEQ19IVCA9IGNvbXB1dGVIdWZmbWFuVGJsKHN0ZF9kY19sdW1pbmFuY2VfbnJjb2RlcyxzdGRfZGNfbHVtaW5hbmNlX3ZhbHVlcyk7XG5cdFx0XHRVVkRDX0hUID0gY29tcHV0ZUh1ZmZtYW5UYmwoc3RkX2RjX2Nocm9taW5hbmNlX25yY29kZXMsc3RkX2RjX2Nocm9taW5hbmNlX3ZhbHVlcyk7XG5cdFx0XHRZQUNfSFQgPSBjb21wdXRlSHVmZm1hblRibChzdGRfYWNfbHVtaW5hbmNlX25yY29kZXMsc3RkX2FjX2x1bWluYW5jZV92YWx1ZXMpO1xuXHRcdFx0VVZBQ19IVCA9IGNvbXB1dGVIdWZmbWFuVGJsKHN0ZF9hY19jaHJvbWluYW5jZV9ucmNvZGVzLHN0ZF9hY19jaHJvbWluYW5jZV92YWx1ZXMpO1xuXHRcdH1cblx0XG5cdFx0ZnVuY3Rpb24gaW5pdENhdGVnb3J5TnVtYmVyKClcblx0XHR7XG5cdFx0XHR2YXIgbnJsb3dlciA9IDE7XG5cdFx0XHR2YXIgbnJ1cHBlciA9IDI7XG5cdFx0XHRmb3IgKHZhciBjYXQgPSAxOyBjYXQgPD0gMTU7IGNhdCsrKSB7XG5cdFx0XHRcdC8vUG9zaXRpdmUgbnVtYmVyc1xuXHRcdFx0XHRmb3IgKHZhciBuciA9IG5ybG93ZXI7IG5yPG5ydXBwZXI7IG5yKyspIHtcblx0XHRcdFx0XHRjYXRlZ29yeVszMjc2Nytucl0gPSBjYXQ7XG5cdFx0XHRcdFx0Yml0Y29kZVszMjc2Nytucl0gPSBbXTtcblx0XHRcdFx0XHRiaXRjb2RlWzMyNzY3K25yXVsxXSA9IGNhdDtcblx0XHRcdFx0XHRiaXRjb2RlWzMyNzY3K25yXVswXSA9IG5yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vTmVnYXRpdmUgbnVtYmVyc1xuXHRcdFx0XHRmb3IgKHZhciBucm5lZyA9LShucnVwcGVyLTEpOyBucm5lZzw9LW5ybG93ZXI7IG5ybmVnKyspIHtcblx0XHRcdFx0XHRjYXRlZ29yeVszMjc2Nytucm5lZ10gPSBjYXQ7XG5cdFx0XHRcdFx0Yml0Y29kZVszMjc2Nytucm5lZ10gPSBbXTtcblx0XHRcdFx0XHRiaXRjb2RlWzMyNzY3K25ybmVnXVsxXSA9IGNhdDtcblx0XHRcdFx0XHRiaXRjb2RlWzMyNzY3K25ybmVnXVswXSA9IG5ydXBwZXItMStucm5lZztcblx0XHRcdFx0fVxuXHRcdFx0XHRucmxvd2VyIDw8PSAxO1xuXHRcdFx0XHRucnVwcGVyIDw8PSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRmdW5jdGlvbiBpbml0UkdCWVVWVGFibGUoKSB7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgMjU2O2krKykge1xuXHRcdFx0XHRSR0JfWVVWX1RBQkxFW2ldICAgICAgXHRcdD0gIDE5NTk1ICogaTtcblx0XHRcdFx0UkdCX1lVVl9UQUJMRVsoaSsgMjU2KT4+MF0gXHQ9ICAzODQ3MCAqIGk7XG5cdFx0XHRcdFJHQl9ZVVZfVEFCTEVbKGkrIDUxMik+PjBdIFx0PSAgIDc0NzEgKiBpICsgMHg4MDAwO1xuXHRcdFx0XHRSR0JfWVVWX1RBQkxFWyhpKyA3NjgpPj4wXSBcdD0gLTExMDU5ICogaTtcblx0XHRcdFx0UkdCX1lVVl9UQUJMRVsoaSsxMDI0KT4+MF0gXHQ9IC0yMTcwOSAqIGk7XG5cdFx0XHRcdFJHQl9ZVVZfVEFCTEVbKGkrMTI4MCk+PjBdIFx0PSAgMzI3NjggKiBpICsgMHg4MDdGRkY7XG5cdFx0XHRcdFJHQl9ZVVZfVEFCTEVbKGkrMTUzNik+PjBdIFx0PSAtMjc0MzkgKiBpO1xuXHRcdFx0XHRSR0JfWVVWX1RBQkxFWyhpKzE3OTIpPj4wXSBcdD0gLSA1MzI5ICogaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gSU8gZnVuY3Rpb25zXG5cdFx0ZnVuY3Rpb24gd3JpdGVCaXRzKGJzKVxuXHRcdHtcblx0XHRcdHZhciB2YWx1ZSA9IGJzWzBdO1xuXHRcdFx0dmFyIHBvc3ZhbCA9IGJzWzFdLTE7XG5cdFx0XHR3aGlsZSAoIHBvc3ZhbCA+PSAwICkge1xuXHRcdFx0XHRpZiAodmFsdWUgJiAoMSA8PCBwb3N2YWwpICkge1xuXHRcdFx0XHRcdGJ5dGVuZXcgfD0gKDEgPDwgYnl0ZXBvcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zdmFsLS07XG5cdFx0XHRcdGJ5dGVwb3MtLTtcblx0XHRcdFx0aWYgKGJ5dGVwb3MgPCAwKSB7XG5cdFx0XHRcdFx0aWYgKGJ5dGVuZXcgPT0gMHhGRikge1xuXHRcdFx0XHRcdFx0d3JpdGVCeXRlKDB4RkYpO1xuXHRcdFx0XHRcdFx0d3JpdGVCeXRlKDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHdyaXRlQnl0ZShieXRlbmV3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ynl0ZXBvcz03O1xuXHRcdFx0XHRcdGJ5dGVuZXc9MDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0ZnVuY3Rpb24gd3JpdGVCeXRlKHZhbHVlKVxuXHRcdHtcblx0XHRcdC8vYnl0ZW91dC5wdXNoKGNsdFt2YWx1ZV0pOyAvLyB3cml0ZSBjaGFyIGRpcmVjdGx5IGluc3RlYWQgb2YgY29udmVydGluZyBsYXRlclxuICAgICAgYnl0ZW91dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIHdyaXRlV29yZCh2YWx1ZSlcblx0XHR7XG5cdFx0XHR3cml0ZUJ5dGUoKHZhbHVlPj44KSYweEZGKTtcblx0XHRcdHdyaXRlQnl0ZSgodmFsdWUgICApJjB4RkYpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBEQ1QgJiBxdWFudGl6YXRpb24gY29yZVxuXHRcdGZ1bmN0aW9uIGZEQ1RRdWFudChkYXRhLCBmZHRibClcblx0XHR7XG5cdFx0XHR2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3O1xuXHRcdFx0LyogUGFzcyAxOiBwcm9jZXNzIHJvd3MuICovXG5cdFx0XHR2YXIgZGF0YU9mZj0wO1xuXHRcdFx0dmFyIGk7XG5cdFx0XHR2YXIgSTggPSA4O1xuXHRcdFx0dmFyIEk2NCA9IDY0O1xuXHRcdFx0Zm9yIChpPTA7IGk8STg7ICsraSlcblx0XHRcdHtcblx0XHRcdFx0ZDAgPSBkYXRhW2RhdGFPZmZdO1xuXHRcdFx0XHRkMSA9IGRhdGFbZGF0YU9mZisxXTtcblx0XHRcdFx0ZDIgPSBkYXRhW2RhdGFPZmYrMl07XG5cdFx0XHRcdGQzID0gZGF0YVtkYXRhT2ZmKzNdO1xuXHRcdFx0XHRkNCA9IGRhdGFbZGF0YU9mZis0XTtcblx0XHRcdFx0ZDUgPSBkYXRhW2RhdGFPZmYrNV07XG5cdFx0XHRcdGQ2ID0gZGF0YVtkYXRhT2ZmKzZdO1xuXHRcdFx0XHRkNyA9IGRhdGFbZGF0YU9mZis3XTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciB0bXAwID0gZDAgKyBkNztcblx0XHRcdFx0dmFyIHRtcDcgPSBkMCAtIGQ3O1xuXHRcdFx0XHR2YXIgdG1wMSA9IGQxICsgZDY7XG5cdFx0XHRcdHZhciB0bXA2ID0gZDEgLSBkNjtcblx0XHRcdFx0dmFyIHRtcDIgPSBkMiArIGQ1O1xuXHRcdFx0XHR2YXIgdG1wNSA9IGQyIC0gZDU7XG5cdFx0XHRcdHZhciB0bXAzID0gZDMgKyBkNDtcblx0XHRcdFx0dmFyIHRtcDQgPSBkMyAtIGQ0O1xuXHRcblx0XHRcdFx0LyogRXZlbiBwYXJ0ICovXG5cdFx0XHRcdHZhciB0bXAxMCA9IHRtcDAgKyB0bXAzO1x0LyogcGhhc2UgMiAqL1xuXHRcdFx0XHR2YXIgdG1wMTMgPSB0bXAwIC0gdG1wMztcblx0XHRcdFx0dmFyIHRtcDExID0gdG1wMSArIHRtcDI7XG5cdFx0XHRcdHZhciB0bXAxMiA9IHRtcDEgLSB0bXAyO1xuXHRcblx0XHRcdFx0ZGF0YVtkYXRhT2ZmXSA9IHRtcDEwICsgdG1wMTE7IC8qIHBoYXNlIDMgKi9cblx0XHRcdFx0ZGF0YVtkYXRhT2ZmKzRdID0gdG1wMTAgLSB0bXAxMTtcblx0XG5cdFx0XHRcdHZhciB6MSA9ICh0bXAxMiArIHRtcDEzKSAqIDAuNzA3MTA2NzgxOyAvKiBjNCAqL1xuXHRcdFx0XHRkYXRhW2RhdGFPZmYrMl0gPSB0bXAxMyArIHoxOyAvKiBwaGFzZSA1ICovXG5cdFx0XHRcdGRhdGFbZGF0YU9mZis2XSA9IHRtcDEzIC0gejE7XG5cdFxuXHRcdFx0XHQvKiBPZGQgcGFydCAqL1xuXHRcdFx0XHR0bXAxMCA9IHRtcDQgKyB0bXA1OyAvKiBwaGFzZSAyICovXG5cdFx0XHRcdHRtcDExID0gdG1wNSArIHRtcDY7XG5cdFx0XHRcdHRtcDEyID0gdG1wNiArIHRtcDc7XG5cdFxuXHRcdFx0XHQvKiBUaGUgcm90YXRvciBpcyBtb2RpZmllZCBmcm9tIGZpZyA0LTggdG8gYXZvaWQgZXh0cmEgbmVnYXRpb25zLiAqL1xuXHRcdFx0XHR2YXIgejUgPSAodG1wMTAgLSB0bXAxMikgKiAwLjM4MjY4MzQzMzsgLyogYzYgKi9cblx0XHRcdFx0dmFyIHoyID0gMC41NDExOTYxMDAgKiB0bXAxMCArIHo1OyAvKiBjMi1jNiAqL1xuXHRcdFx0XHR2YXIgejQgPSAxLjMwNjU2Mjk2NSAqIHRtcDEyICsgejU7IC8qIGMyK2M2ICovXG5cdFx0XHRcdHZhciB6MyA9IHRtcDExICogMC43MDcxMDY3ODE7IC8qIGM0ICovXG5cdFxuXHRcdFx0XHR2YXIgejExID0gdG1wNyArIHozO1x0LyogcGhhc2UgNSAqL1xuXHRcdFx0XHR2YXIgejEzID0gdG1wNyAtIHozO1xuXHRcblx0XHRcdFx0ZGF0YVtkYXRhT2ZmKzVdID0gejEzICsgejI7XHQvKiBwaGFzZSA2ICovXG5cdFx0XHRcdGRhdGFbZGF0YU9mZiszXSA9IHoxMyAtIHoyO1xuXHRcdFx0XHRkYXRhW2RhdGFPZmYrMV0gPSB6MTEgKyB6NDtcblx0XHRcdFx0ZGF0YVtkYXRhT2ZmKzddID0gejExIC0gejQ7XG5cdFxuXHRcdFx0XHRkYXRhT2ZmICs9IDg7IC8qIGFkdmFuY2UgcG9pbnRlciB0byBuZXh0IHJvdyAqL1xuXHRcdFx0fVxuXHRcblx0XHRcdC8qIFBhc3MgMjogcHJvY2VzcyBjb2x1bW5zLiAqL1xuXHRcdFx0ZGF0YU9mZiA9IDA7XG5cdFx0XHRmb3IgKGk9MDsgaTxJODsgKytpKVxuXHRcdFx0e1xuXHRcdFx0XHRkMCA9IGRhdGFbZGF0YU9mZl07XG5cdFx0XHRcdGQxID0gZGF0YVtkYXRhT2ZmICsgOF07XG5cdFx0XHRcdGQyID0gZGF0YVtkYXRhT2ZmICsgMTZdO1xuXHRcdFx0XHRkMyA9IGRhdGFbZGF0YU9mZiArIDI0XTtcblx0XHRcdFx0ZDQgPSBkYXRhW2RhdGFPZmYgKyAzMl07XG5cdFx0XHRcdGQ1ID0gZGF0YVtkYXRhT2ZmICsgNDBdO1xuXHRcdFx0XHRkNiA9IGRhdGFbZGF0YU9mZiArIDQ4XTtcblx0XHRcdFx0ZDcgPSBkYXRhW2RhdGFPZmYgKyA1Nl07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgdG1wMHAyID0gZDAgKyBkNztcblx0XHRcdFx0dmFyIHRtcDdwMiA9IGQwIC0gZDc7XG5cdFx0XHRcdHZhciB0bXAxcDIgPSBkMSArIGQ2O1xuXHRcdFx0XHR2YXIgdG1wNnAyID0gZDEgLSBkNjtcblx0XHRcdFx0dmFyIHRtcDJwMiA9IGQyICsgZDU7XG5cdFx0XHRcdHZhciB0bXA1cDIgPSBkMiAtIGQ1O1xuXHRcdFx0XHR2YXIgdG1wM3AyID0gZDMgKyBkNDtcblx0XHRcdFx0dmFyIHRtcDRwMiA9IGQzIC0gZDQ7XG5cdFxuXHRcdFx0XHQvKiBFdmVuIHBhcnQgKi9cblx0XHRcdFx0dmFyIHRtcDEwcDIgPSB0bXAwcDIgKyB0bXAzcDI7XHQvKiBwaGFzZSAyICovXG5cdFx0XHRcdHZhciB0bXAxM3AyID0gdG1wMHAyIC0gdG1wM3AyO1xuXHRcdFx0XHR2YXIgdG1wMTFwMiA9IHRtcDFwMiArIHRtcDJwMjtcblx0XHRcdFx0dmFyIHRtcDEycDIgPSB0bXAxcDIgLSB0bXAycDI7XG5cdFxuXHRcdFx0XHRkYXRhW2RhdGFPZmZdID0gdG1wMTBwMiArIHRtcDExcDI7IC8qIHBoYXNlIDMgKi9cblx0XHRcdFx0ZGF0YVtkYXRhT2ZmKzMyXSA9IHRtcDEwcDIgLSB0bXAxMXAyO1xuXHRcblx0XHRcdFx0dmFyIHoxcDIgPSAodG1wMTJwMiArIHRtcDEzcDIpICogMC43MDcxMDY3ODE7IC8qIGM0ICovXG5cdFx0XHRcdGRhdGFbZGF0YU9mZisxNl0gPSB0bXAxM3AyICsgejFwMjsgLyogcGhhc2UgNSAqL1xuXHRcdFx0XHRkYXRhW2RhdGFPZmYrNDhdID0gdG1wMTNwMiAtIHoxcDI7XG5cdFxuXHRcdFx0XHQvKiBPZGQgcGFydCAqL1xuXHRcdFx0XHR0bXAxMHAyID0gdG1wNHAyICsgdG1wNXAyOyAvKiBwaGFzZSAyICovXG5cdFx0XHRcdHRtcDExcDIgPSB0bXA1cDIgKyB0bXA2cDI7XG5cdFx0XHRcdHRtcDEycDIgPSB0bXA2cDIgKyB0bXA3cDI7XG5cdFxuXHRcdFx0XHQvKiBUaGUgcm90YXRvciBpcyBtb2RpZmllZCBmcm9tIGZpZyA0LTggdG8gYXZvaWQgZXh0cmEgbmVnYXRpb25zLiAqL1xuXHRcdFx0XHR2YXIgejVwMiA9ICh0bXAxMHAyIC0gdG1wMTJwMikgKiAwLjM4MjY4MzQzMzsgLyogYzYgKi9cblx0XHRcdFx0dmFyIHoycDIgPSAwLjU0MTE5NjEwMCAqIHRtcDEwcDIgKyB6NXAyOyAvKiBjMi1jNiAqL1xuXHRcdFx0XHR2YXIgejRwMiA9IDEuMzA2NTYyOTY1ICogdG1wMTJwMiArIHo1cDI7IC8qIGMyK2M2ICovXG5cdFx0XHRcdHZhciB6M3AyID0gdG1wMTFwMiAqIDAuNzA3MTA2NzgxOyAvKiBjNCAqL1xuXHRcblx0XHRcdFx0dmFyIHoxMXAyID0gdG1wN3AyICsgejNwMjtcdC8qIHBoYXNlIDUgKi9cblx0XHRcdFx0dmFyIHoxM3AyID0gdG1wN3AyIC0gejNwMjtcblx0XG5cdFx0XHRcdGRhdGFbZGF0YU9mZis0MF0gPSB6MTNwMiArIHoycDI7IC8qIHBoYXNlIDYgKi9cblx0XHRcdFx0ZGF0YVtkYXRhT2ZmKzI0XSA9IHoxM3AyIC0gejJwMjtcblx0XHRcdFx0ZGF0YVtkYXRhT2ZmKyA4XSA9IHoxMXAyICsgejRwMjtcblx0XHRcdFx0ZGF0YVtkYXRhT2ZmKzU2XSA9IHoxMXAyIC0gejRwMjtcblx0XG5cdFx0XHRcdGRhdGFPZmYrKzsgLyogYWR2YW5jZSBwb2ludGVyIHRvIG5leHQgY29sdW1uICovXG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUXVhbnRpemUvZGVzY2FsZSB0aGUgY29lZmZpY2llbnRzXG5cdFx0XHR2YXIgZkRDVFF1YW50O1xuXHRcdFx0Zm9yIChpPTA7IGk8STY0OyArK2kpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEFwcGx5IHRoZSBxdWFudGl6YXRpb24gYW5kIHNjYWxpbmcgZmFjdG9yICYgUm91bmQgdG8gbmVhcmVzdCBpbnRlZ2VyXG5cdFx0XHRcdGZEQ1RRdWFudCA9IGRhdGFbaV0qZmR0YmxbaV07XG5cdFx0XHRcdG91dHB1dGZEQ1RRdWFudFtpXSA9IChmRENUUXVhbnQgPiAwLjApID8gKChmRENUUXVhbnQgKyAwLjUpfDApIDogKChmRENUUXVhbnQgLSAwLjUpfDApO1xuXHRcdFx0XHQvL291dHB1dGZEQ1RRdWFudFtpXSA9IGZyb3VuZChmRENUUXVhbnQpO1xuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0ZkRDVFF1YW50O1xuXHRcdH1cblx0XHRcblx0XHRmdW5jdGlvbiB3cml0ZUFQUDAoKVxuXHRcdHtcblx0XHRcdHdyaXRlV29yZCgweEZGRTApOyAvLyBtYXJrZXJcblx0XHRcdHdyaXRlV29yZCgxNik7IC8vIGxlbmd0aFxuXHRcdFx0d3JpdGVCeXRlKDB4NEEpOyAvLyBKXG5cdFx0XHR3cml0ZUJ5dGUoMHg0Nik7IC8vIEZcblx0XHRcdHdyaXRlQnl0ZSgweDQ5KTsgLy8gSVxuXHRcdFx0d3JpdGVCeXRlKDB4NDYpOyAvLyBGXG5cdFx0XHR3cml0ZUJ5dGUoMCk7IC8vID0gXCJKRklGXCIsJ1xcMCdcblx0XHRcdHdyaXRlQnl0ZSgxKTsgLy8gdmVyc2lvbmhpXG5cdFx0XHR3cml0ZUJ5dGUoMSk7IC8vIHZlcnNpb25sb1xuXHRcdFx0d3JpdGVCeXRlKDApOyAvLyB4eXVuaXRzXG5cdFx0XHR3cml0ZVdvcmQoMSk7IC8vIHhkZW5zaXR5XG5cdFx0XHR3cml0ZVdvcmQoMSk7IC8vIHlkZW5zaXR5XG5cdFx0XHR3cml0ZUJ5dGUoMCk7IC8vIHRodW1ibndpZHRoXG5cdFx0XHR3cml0ZUJ5dGUoMCk7IC8vIHRodW1ibmhlaWdodFxuXHRcdH1cblx0XG5cdFx0ZnVuY3Rpb24gd3JpdGVTT0YwKHdpZHRoLCBoZWlnaHQpXG5cdFx0e1xuXHRcdFx0d3JpdGVXb3JkKDB4RkZDMCk7IC8vIG1hcmtlclxuXHRcdFx0d3JpdGVXb3JkKDE3KTsgICAvLyBsZW5ndGgsIHRydWVjb2xvciBZVVYgSlBHXG5cdFx0XHR3cml0ZUJ5dGUoOCk7ICAgIC8vIHByZWNpc2lvblxuXHRcdFx0d3JpdGVXb3JkKGhlaWdodCk7XG5cdFx0XHR3cml0ZVdvcmQod2lkdGgpO1xuXHRcdFx0d3JpdGVCeXRlKDMpOyAgICAvLyBucm9mY29tcG9uZW50c1xuXHRcdFx0d3JpdGVCeXRlKDEpOyAgICAvLyBJZFlcblx0XHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFZZXG5cdFx0XHR3cml0ZUJ5dGUoMCk7ICAgIC8vIFFUWVxuXHRcdFx0d3JpdGVCeXRlKDIpOyAgICAvLyBJZFVcblx0XHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFZVXG5cdFx0XHR3cml0ZUJ5dGUoMSk7ICAgIC8vIFFUVVxuXHRcdFx0d3JpdGVCeXRlKDMpOyAgICAvLyBJZFZcblx0XHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFZWXG5cdFx0XHR3cml0ZUJ5dGUoMSk7ICAgIC8vIFFUVlxuXHRcdH1cblx0XG5cdFx0ZnVuY3Rpb24gd3JpdGVEUVQoKVxuXHRcdHtcblx0XHRcdHdyaXRlV29yZCgweEZGREIpOyAvLyBtYXJrZXJcblx0XHRcdHdyaXRlV29yZCgxMzIpO1x0ICAgLy8gbGVuZ3RoXG5cdFx0XHR3cml0ZUJ5dGUoMCk7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8NjQ7IGkrKykge1xuXHRcdFx0XHR3cml0ZUJ5dGUoWVRhYmxlW2ldKTtcblx0XHRcdH1cblx0XHRcdHdyaXRlQnl0ZSgxKTtcblx0XHRcdGZvciAodmFyIGo9MDsgajw2NDsgaisrKSB7XG5cdFx0XHRcdHdyaXRlQnl0ZShVVlRhYmxlW2pdKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIHdyaXRlREhUKClcblx0XHR7XG5cdFx0XHR3cml0ZVdvcmQoMHhGRkM0KTsgLy8gbWFya2VyXG5cdFx0XHR3cml0ZVdvcmQoMHgwMUEyKTsgLy8gbGVuZ3RoXG5cdFxuXHRcdFx0d3JpdGVCeXRlKDApOyAvLyBIVFlEQ2luZm9cblx0XHRcdGZvciAodmFyIGk9MDsgaTwxNjsgaSsrKSB7XG5cdFx0XHRcdHdyaXRlQnl0ZShzdGRfZGNfbHVtaW5hbmNlX25yY29kZXNbaSsxXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBqPTA7IGo8PTExOyBqKyspIHtcblx0XHRcdFx0d3JpdGVCeXRlKHN0ZF9kY19sdW1pbmFuY2VfdmFsdWVzW2pdKTtcblx0XHRcdH1cblx0XG5cdFx0XHR3cml0ZUJ5dGUoMHgxMCk7IC8vIEhUWUFDaW5mb1xuXHRcdFx0Zm9yICh2YXIgaz0wOyBrPDE2OyBrKyspIHtcblx0XHRcdFx0d3JpdGVCeXRlKHN0ZF9hY19sdW1pbmFuY2VfbnJjb2Rlc1trKzFdKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGw9MDsgbDw9MTYxOyBsKyspIHtcblx0XHRcdFx0d3JpdGVCeXRlKHN0ZF9hY19sdW1pbmFuY2VfdmFsdWVzW2xdKTtcblx0XHRcdH1cblx0XG5cdFx0XHR3cml0ZUJ5dGUoMSk7IC8vIEhUVURDaW5mb1xuXHRcdFx0Zm9yICh2YXIgbT0wOyBtPDE2OyBtKyspIHtcblx0XHRcdFx0d3JpdGVCeXRlKHN0ZF9kY19jaHJvbWluYW5jZV9ucmNvZGVzW20rMV0pO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgbj0wOyBuPD0xMTsgbisrKSB7XG5cdFx0XHRcdHdyaXRlQnl0ZShzdGRfZGNfY2hyb21pbmFuY2VfdmFsdWVzW25dKTtcblx0XHRcdH1cblx0XG5cdFx0XHR3cml0ZUJ5dGUoMHgxMSk7IC8vIEhUVUFDaW5mb1xuXHRcdFx0Zm9yICh2YXIgbz0wOyBvPDE2OyBvKyspIHtcblx0XHRcdFx0d3JpdGVCeXRlKHN0ZF9hY19jaHJvbWluYW5jZV9ucmNvZGVzW28rMV0pO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcD0wOyBwPD0xNjE7IHArKykge1xuXHRcdFx0XHR3cml0ZUJ5dGUoc3RkX2FjX2Nocm9taW5hbmNlX3ZhbHVlc1twXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRmdW5jdGlvbiB3cml0ZVNPUygpXG5cdFx0e1xuXHRcdFx0d3JpdGVXb3JkKDB4RkZEQSk7IC8vIG1hcmtlclxuXHRcdFx0d3JpdGVXb3JkKDEyKTsgLy8gbGVuZ3RoXG5cdFx0XHR3cml0ZUJ5dGUoMyk7IC8vIG5yb2Zjb21wb25lbnRzXG5cdFx0XHR3cml0ZUJ5dGUoMSk7IC8vIElkWVxuXHRcdFx0d3JpdGVCeXRlKDApOyAvLyBIVFlcblx0XHRcdHdyaXRlQnl0ZSgyKTsgLy8gSWRVXG5cdFx0XHR3cml0ZUJ5dGUoMHgxMSk7IC8vIEhUVVxuXHRcdFx0d3JpdGVCeXRlKDMpOyAvLyBJZFZcblx0XHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFRWXG5cdFx0XHR3cml0ZUJ5dGUoMCk7IC8vIFNzXG5cdFx0XHR3cml0ZUJ5dGUoMHgzZik7IC8vIFNlXG5cdFx0XHR3cml0ZUJ5dGUoMCk7IC8vIEJmXG5cdFx0fVxuXHRcdFxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NEVShDRFUsIGZkdGJsLCBEQywgSFREQywgSFRBQyl7XG5cdFx0XHR2YXIgRU9CID0gSFRBQ1sweDAwXTtcblx0XHRcdHZhciBNMTZ6ZXJvZXMgPSBIVEFDWzB4RjBdO1xuXHRcdFx0dmFyIHBvcztcblx0XHRcdHZhciBJMTYgPSAxNjtcblx0XHRcdHZhciBJNjMgPSA2Mztcblx0XHRcdHZhciBJNjQgPSA2NDtcblx0XHRcdHZhciBEVV9EQ1QgPSBmRENUUXVhbnQoQ0RVLCBmZHRibCk7XG5cdFx0XHQvL1ppZ1phZyByZW9yZGVyXG5cdFx0XHRmb3IgKHZhciBqPTA7ajxJNjQ7KytqKSB7XG5cdFx0XHRcdERVW1ppZ1phZ1tqXV09RFVfRENUW2pdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIERpZmYgPSBEVVswXSAtIERDOyBEQyA9IERVWzBdO1xuXHRcdFx0Ly9FbmNvZGUgRENcblx0XHRcdGlmIChEaWZmPT0wKSB7XG5cdFx0XHRcdHdyaXRlQml0cyhIVERDWzBdKTsgLy8gRGlmZiBtaWdodCBiZSAwXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3MgPSAzMjc2NytEaWZmO1xuXHRcdFx0XHR3cml0ZUJpdHMoSFREQ1tjYXRlZ29yeVtwb3NdXSk7XG5cdFx0XHRcdHdyaXRlQml0cyhiaXRjb2RlW3Bvc10pO1xuXHRcdFx0fVxuXHRcdFx0Ly9FbmNvZGUgQUNzXG5cdFx0XHR2YXIgZW5kMHBvcyA9IDYzOyAvLyB3YXMgY29uc3QuLi4gd2hpY2ggaXMgY3Jhenlcblx0XHRcdGZvciAoOyAoZW5kMHBvcz4wKSYmKERVW2VuZDBwb3NdPT0wKTsgZW5kMHBvcy0tKSB7fTtcblx0XHRcdC8vZW5kMHBvcyA9IGZpcnN0IGVsZW1lbnQgaW4gcmV2ZXJzZSBvcmRlciAhPTBcblx0XHRcdGlmICggZW5kMHBvcyA9PSAwKSB7XG5cdFx0XHRcdHdyaXRlQml0cyhFT0IpO1xuXHRcdFx0XHRyZXR1cm4gREM7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHR2YXIgbG5nO1xuXHRcdFx0d2hpbGUgKCBpIDw9IGVuZDBwb3MgKSB7XG5cdFx0XHRcdHZhciBzdGFydHBvcyA9IGk7XG5cdFx0XHRcdGZvciAoOyAoRFVbaV09PTApICYmIChpPD1lbmQwcG9zKTsgKytpKSB7fVxuXHRcdFx0XHR2YXIgbnJ6ZXJvZXMgPSBpLXN0YXJ0cG9zO1xuXHRcdFx0XHRpZiAoIG5yemVyb2VzID49IEkxNiApIHtcblx0XHRcdFx0XHRsbmcgPSBucnplcm9lcz4+NDtcblx0XHRcdFx0XHRmb3IgKHZhciBucm1hcmtlcj0xOyBucm1hcmtlciA8PSBsbmc7ICsrbnJtYXJrZXIpXG5cdFx0XHRcdFx0XHR3cml0ZUJpdHMoTTE2emVyb2VzKTtcblx0XHRcdFx0XHRucnplcm9lcyA9IG5yemVyb2VzJjB4Rjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3MgPSAzMjc2NytEVVtpXTtcblx0XHRcdFx0d3JpdGVCaXRzKEhUQUNbKG5yemVyb2VzPDw0KStjYXRlZ29yeVtwb3NdXSk7XG5cdFx0XHRcdHdyaXRlQml0cyhiaXRjb2RlW3Bvc10pO1xuXHRcdFx0XHRpKys7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVuZDBwb3MgIT0gSTYzICkge1xuXHRcdFx0XHR3cml0ZUJpdHMoRU9CKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBEQztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbml0Q2hhckxvb2t1cFRhYmxlKCl7XG5cdFx0XHR2YXIgc2ZjYyA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cdFx0XHRmb3IodmFyIGk9MDsgaSA8IDI1NjsgaSsrKXsgLy8vLy8gQUNIVFVORyAvLyAyNTVcblx0XHRcdFx0Y2x0W2ldID0gc2ZjYyhpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5lbmNvZGUgPSBmdW5jdGlvbihpbWFnZSxxdWFsaXR5KSAvLyBpbWFnZSBkYXRhIG9iamVjdFxuXHRcdHtcblx0XHRcdHZhciB0aW1lX3N0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRcblx0XHRcdGlmKHF1YWxpdHkpIHNldFF1YWxpdHkocXVhbGl0eSk7XG5cdFx0XHRcblx0XHRcdC8vIEluaXRpYWxpemUgYml0IHdyaXRlclxuXHRcdFx0Ynl0ZW91dCA9IG5ldyBBcnJheSgpO1xuXHRcdFx0Ynl0ZW5ldz0wO1xuXHRcdFx0Ynl0ZXBvcz03O1xuXHRcblx0XHRcdC8vIEFkZCBKUEVHIGhlYWRlcnNcblx0XHRcdHdyaXRlV29yZCgweEZGRDgpOyAvLyBTT0lcblx0XHRcdHdyaXRlQVBQMCgpO1xuXHRcdFx0d3JpdGVEUVQoKTtcblx0XHRcdHdyaXRlU09GMChpbWFnZS53aWR0aCxpbWFnZS5oZWlnaHQpO1xuXHRcdFx0d3JpdGVESFQoKTtcblx0XHRcdHdyaXRlU09TKCk7XG5cblx0XG5cdFx0XHQvLyBFbmNvZGUgOHg4IG1hY3JvYmxvY2tzXG5cdFx0XHR2YXIgRENZPTA7XG5cdFx0XHR2YXIgRENVPTA7XG5cdFx0XHR2YXIgRENWPTA7XG5cdFx0XHRcblx0XHRcdGJ5dGVuZXc9MDtcblx0XHRcdGJ5dGVwb3M9Nztcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR0aGlzLmVuY29kZS5kaXNwbGF5TmFtZSA9IFwiX2VuY29kZV9cIjtcblxuXHRcdFx0dmFyIGltYWdlRGF0YSA9IGltYWdlLmRhdGE7XG5cdFx0XHR2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdHZhciBxdWFkV2lkdGggPSB3aWR0aCo0O1xuXHRcdFx0dmFyIHRyaXBsZVdpZHRoID0gd2lkdGgqMztcblx0XHRcdFxuXHRcdFx0dmFyIHgsIHkgPSAwO1xuXHRcdFx0dmFyIHIsIGcsIGI7XG5cdFx0XHR2YXIgc3RhcnQscCwgY29sLHJvdyxwb3M7XG5cdFx0XHR3aGlsZSh5IDwgaGVpZ2h0KXtcblx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdHdoaWxlKHggPCBxdWFkV2lkdGgpe1xuXHRcdFx0XHRzdGFydCA9IHF1YWRXaWR0aCAqIHkgKyB4O1xuXHRcdFx0XHRwID0gc3RhcnQ7XG5cdFx0XHRcdGNvbCA9IC0xO1xuXHRcdFx0XHRyb3cgPSAwO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yKHBvcz0wOyBwb3MgPCA2NDsgcG9zKyspe1xuXHRcdFx0XHRcdHJvdyA9IHBvcyA+PiAzOy8vIC84XG5cdFx0XHRcdFx0Y29sID0gKCBwb3MgJiA3ICkgKiA0OyAvLyAlOFxuXHRcdFx0XHRcdHAgPSBzdGFydCArICggcm93ICogcXVhZFdpZHRoICkgKyBjb2w7XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKHkrcm93ID49IGhlaWdodCl7IC8vIHBhZGRpbmcgYm90dG9tXG5cdFx0XHRcdFx0XHRwLT0gKHF1YWRXaWR0aCooeSsxK3Jvdy1oZWlnaHQpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZih4K2NvbCA+PSBxdWFkV2lkdGgpeyAvLyBwYWRkaW5nIHJpZ2h0XHRcblx0XHRcdFx0XHRcdHAtPSAoKHgrY29sKSAtIHF1YWRXaWR0aCArNClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ciA9IGltYWdlRGF0YVsgcCsrIF07XG5cdFx0XHRcdFx0ZyA9IGltYWdlRGF0YVsgcCsrIF07XG5cdFx0XHRcdFx0YiA9IGltYWdlRGF0YVsgcCsrIF07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0LyogLy8gY2FsY3VsYXRlIFlVViB2YWx1ZXMgZHluYW1pY2FsbHlcblx0XHRcdFx0XHRZRFVbcG9zXT0oKCggMC4yOTkwMCkqcisoIDAuNTg3MDApKmcrKCAwLjExNDAwKSpiKSktMTI4OyAvLy0weDgwXG5cdFx0XHRcdFx0VURVW3Bvc109KCgoLTAuMTY4NzQpKnIrKC0wLjMzMTI2KSpnKyggMC41MDAwMCkqYikpO1xuXHRcdFx0XHRcdFZEVVtwb3NdPSgoKCAwLjUwMDAwKSpyKygtMC40MTg2OSkqZysoLTAuMDgxMzEpKmIpKTtcblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHVzZSBsb29rdXAgdGFibGUgKHNsaWdodGx5IGZhc3Rlcilcblx0XHRcdFx0XHRZRFVbcG9zXSA9ICgoUkdCX1lVVl9UQUJMRVtyXSAgICAgICAgICAgICArIFJHQl9ZVVZfVEFCTEVbKGcgKyAgMjU2KT4+MF0gKyBSR0JfWVVWX1RBQkxFWyhiICsgIDUxMik+PjBdKSA+PiAxNiktMTI4O1xuXHRcdFx0XHRcdFVEVVtwb3NdID0gKChSR0JfWVVWX1RBQkxFWyhyICsgIDc2OCk+PjBdICsgUkdCX1lVVl9UQUJMRVsoZyArIDEwMjQpPj4wXSArIFJHQl9ZVVZfVEFCTEVbKGIgKyAxMjgwKT4+MF0pID4+IDE2KS0xMjg7XG5cdFx0XHRcdFx0VkRVW3Bvc10gPSAoKFJHQl9ZVVZfVEFCTEVbKHIgKyAxMjgwKT4+MF0gKyBSR0JfWVVWX1RBQkxFWyhnICsgMTUzNik+PjBdICsgUkdCX1lVVl9UQUJMRVsoYiArIDE3OTIpPj4wXSkgPj4gMTYpLTEyODtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHREQ1kgPSBwcm9jZXNzRFUoWURVLCBmZHRibF9ZLCBEQ1ksIFlEQ19IVCwgWUFDX0hUKTtcblx0XHRcdFx0RENVID0gcHJvY2Vzc0RVKFVEVSwgZmR0YmxfVVYsIERDVSwgVVZEQ19IVCwgVVZBQ19IVCk7XG5cdFx0XHRcdERDViA9IHByb2Nlc3NEVShWRFUsIGZkdGJsX1VWLCBEQ1YsIFVWRENfSFQsIFVWQUNfSFQpO1xuXHRcdFx0XHR4Kz0zMjtcblx0XHRcdFx0fVxuXHRcdFx0XHR5Kz04O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0XG5cdFx0XHQvLyBEbyB0aGUgYml0IGFsaWdubWVudCBvZiB0aGUgRU9JIG1hcmtlclxuXHRcdFx0aWYgKCBieXRlcG9zID49IDAgKSB7XG5cdFx0XHRcdHZhciBmaWxsYml0cyA9IFtdO1xuXHRcdFx0XHRmaWxsYml0c1sxXSA9IGJ5dGVwb3MrMTtcblx0XHRcdFx0ZmlsbGJpdHNbMF0gPSAoMTw8KGJ5dGVwb3MrMSkpLTE7XG5cdFx0XHRcdHdyaXRlQml0cyhmaWxsYml0cyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0d3JpdGVXb3JkKDB4RkZEOSk7IC8vRU9JXG5cbiAgICAgIC8vcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVvdXQpO1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYnl0ZW91dCk7XG5cblx0XHRcdHZhciBqcGVnRGF0YVVyaSA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCcgKyBidG9hKGJ5dGVvdXQuam9pbignJykpO1xuXHRcdFx0XG5cdFx0XHRieXRlb3V0ID0gW107XG5cdFx0XHRcblx0XHRcdC8vIGJlbmNobWFya2luZ1xuXHRcdFx0dmFyIGR1cmF0aW9uID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aW1lX3N0YXJ0O1xuICAgIFx0XHQvL2NvbnNvbGUubG9nKCdFbmNvZGluZyB0aW1lOiAnKyBkdXJhdGlvbiArICdtcycpO1xuICAgIFx0XHQvL1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4ganBlZ0RhdGFVcmlcdFx0XHRcblx0fVxuXHRcblx0ZnVuY3Rpb24gc2V0UXVhbGl0eShxdWFsaXR5KXtcblx0XHRpZiAocXVhbGl0eSA8PSAwKSB7XG5cdFx0XHRxdWFsaXR5ID0gMTtcblx0XHR9XG5cdFx0aWYgKHF1YWxpdHkgPiAxMDApIHtcblx0XHRcdHF1YWxpdHkgPSAxMDA7XG5cdFx0fVxuXHRcdFxuXHRcdGlmKGN1cnJlbnRRdWFsaXR5ID09IHF1YWxpdHkpIHJldHVybiAvLyBkb24ndCByZWNhbGMgaWYgdW5jaGFuZ2VkXG5cdFx0XG5cdFx0dmFyIHNmID0gMDtcblx0XHRpZiAocXVhbGl0eSA8IDUwKSB7XG5cdFx0XHRzZiA9IE1hdGguZmxvb3IoNTAwMCAvIHF1YWxpdHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZiA9IE1hdGguZmxvb3IoMjAwIC0gcXVhbGl0eSoyKTtcblx0XHR9XG5cdFx0XG5cdFx0aW5pdFF1YW50VGFibGVzKHNmKTtcblx0XHRjdXJyZW50UXVhbGl0eSA9IHF1YWxpdHk7XG5cdFx0Ly9jb25zb2xlLmxvZygnUXVhbGl0eSBzZXQgdG86ICcrcXVhbGl0eSArJyUnKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaW5pdCgpe1xuXHRcdHZhciB0aW1lX3N0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0aWYoIXF1YWxpdHkpIHF1YWxpdHkgPSA1MDtcblx0XHQvLyBDcmVhdGUgdGFibGVzXG5cdFx0aW5pdENoYXJMb29rdXBUYWJsZSgpXG5cdFx0aW5pdEh1ZmZtYW5UYmwoKTtcblx0XHRpbml0Q2F0ZWdvcnlOdW1iZXIoKTtcblx0XHRpbml0UkdCWVVWVGFibGUoKTtcblx0XHRcblx0XHRzZXRRdWFsaXR5KHF1YWxpdHkpO1xuXHRcdHZhciBkdXJhdGlvbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGltZV9zdGFydDtcbiAgICBcdC8vY29uc29sZS5sb2coJ0luaXRpYWxpemF0aW9uICcrIGR1cmF0aW9uICsgJ21zJyk7XG5cdH1cblx0XG5cdGluaXQoKTtcblx0XG59O1xubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGU7XG5cbmZ1bmN0aW9uIGVuY29kZShpbWdEYXRhLCBxdSkge1xuICBpZiAodHlwZW9mIHF1ID09PSAndW5kZWZpbmVkJykgcXUgPSA1MDtcbiAgdmFyIGVuY29kZXIgPSBuZXcgSlBFR0VuY29kZXIocXUpO1xuXHR2YXIgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGltZ0RhdGEsIHF1KTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHdpZHRoOiBpbWdEYXRhLndpZHRoLFxuICAgIGhlaWdodDogaW1nRGF0YS5oZWlnaHRcbiAgfTtcbn1cblxuLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaW1hZ2VEYXRhIG9mIGFuIGV4aXN0aW5nIGltYWdlIG9uIHRoZSBjdXJyZW50IHBhZ2UuXG5mdW5jdGlvbiBnZXRJbWFnZURhdGFGcm9tSW1hZ2UoaWRPckVsZW1lbnQpe1xuXHR2YXIgdGhlSW1nID0gKHR5cGVvZihpZE9yRWxlbWVudCk9PSdzdHJpbmcnKT8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRPckVsZW1lbnQpOmlkT3JFbGVtZW50O1xuXHR2YXIgY3ZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdGN2cy53aWR0aCA9IHRoZUltZy53aWR0aDtcblx0Y3ZzLmhlaWdodCA9IHRoZUltZy5oZWlnaHQ7XG5cdHZhciBjdHggPSBjdnMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRjdHguZHJhd0ltYWdlKHRoZUltZywwLDApO1xuXHRcblx0cmV0dXJuIChjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGN2cy53aWR0aCwgY3ZzLmhlaWdodCkpO1xufVxuIiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdwaGluJylcbnZhciBwYXJzZUFTQ0lJID0gcmVxdWlyZSgncGFyc2UtYm1mb250LWFzY2lpJylcbnZhciBwYXJzZVhNTCA9IHJlcXVpcmUoJ3BhcnNlLWJtZm9udC14bWwnKVxudmFyIHJlYWRCaW5hcnkgPSByZXF1aXJlKCdwYXJzZS1ibWZvbnQtYmluYXJ5JylcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZScpXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge31cbnZhciBpc0JpbmFyeSA9IHJlcXVpcmUoJy4vbGliL2lzLWJpbmFyeScpXG5cbmZ1bmN0aW9uIHBhcnNlRm9udChmaWxlLCBkYXRhLCBjYikge1xuICB2YXIgcmVzdWx0LCBiaW5hcnlcblxuICBpZiAoaXNCaW5hcnkoZGF0YSkpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCAnYmluYXJ5JylcbiAgICBiaW5hcnkgPSB0cnVlXG4gIH0gZWxzZSBkYXRhID0gZGF0YS50b1N0cmluZygpLnRyaW0oKVxuXG4gIHRyeSB7XG4gICAgaWYgKGJpbmFyeSkgcmVzdWx0ID0gcmVhZEJpbmFyeShkYXRhKVxuICAgIGVsc2UgaWYgKC9qc29uLy50ZXN0KG1pbWUubG9va3VwKGZpbGUpKSB8fCBkYXRhLmNoYXJBdCgwKSA9PT0gJ3snKVxuICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKVxuICAgIGVsc2UgaWYgKC94bWwvLnRlc3QobWltZS5sb29rdXAoZmlsZSkpIHx8IGRhdGEuY2hhckF0KDApID09PSAnPCcpXG4gICAgICByZXN1bHQgPSBwYXJzZVhNTChkYXRhKVxuICAgIGVsc2UgcmVzdWx0ID0gcGFyc2VBU0NJSShkYXRhKVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2IoZSlcbiAgICBjYiA9IG5vb3BcbiAgfVxuXG4gIGNiKG51bGwsIHJlc3VsdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkRm9udChvcHQsIGNiKSB7XG4gIGNiID0gdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nID8gY2IgOiBub29wXG5cbiAgaWYgKHR5cGVvZiBvcHQgPT09ICdzdHJpbmcnKSBvcHQgPSB7IHVyaTogb3B0LCB1cmw6IG9wdCB9XG4gIGVsc2UgaWYgKCFvcHQpIG9wdCA9IHt9XG5cbiAgdmFyIGZpbGUgPSBvcHQudXJpIHx8IG9wdC51cmxcbiAgXG4gIGZ1bmN0aW9uIGhhbmRsZURhdGEoZXJyLCBkYXRhKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBwYXJzZUZvbnQoZmlsZSwgZGF0YS5ib2R5IHx8IGRhdGEsIGNiKVxuICB9XG5cbiAgaWYgKHVybC5wYXJzZShmaWxlKS5ob3N0KSB7XG4gICAgcmVxdWVzdChvcHQsIGhhbmRsZURhdGEpXG4gIH0gZWxzZSB7XG4gICAgZnMucmVhZEZpbGUoZmlsZSwgb3B0LCBoYW5kbGVEYXRhKVxuICB9XG59XG4iLCJ2YXIgZXF1YWwgPSByZXF1aXJlKCdidWZmZXItZXF1YWwnKVxudmFyIEhFQURFUiA9IG5ldyBCdWZmZXIoWzY2LCA3NywgNzAsIDNdKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1Zikge1xuICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIGJ1Zi5zdWJzdHJpbmcoMCwgMykgPT09ICdCTUYnXG4gIHJldHVybiBidWYubGVuZ3RoID4gNCAmJiBlcXVhbChidWYuc2xpY2UoMCwgNCksIEhFQURFUilcbn0iLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEdpZldyaXRlcihidWYsIHdpZHRoLCBoZWlnaHQsIGdvcHRzKSB7XG4gIHZhciBwID0gMDtcblxuICB2YXIgZ29wdHMgPSBnb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSkge1xuICAgIHZhciBudW1fY29sb3JzID0gcGFsZXR0ZS5sZW5ndGg7XG4gICAgaWYgKG51bV9jb2xvcnMgPCAyIHx8IG51bV9jb2xvcnMgPiAyNTYgfHwgIG51bV9jb2xvcnMgJiAobnVtX2NvbG9ycy0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgfVxuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NzsgYnVmW3ArK10gPSAweDQ5OyBidWZbcCsrXSA9IDB4NDY7ICAvLyBHSUZcbiAgYnVmW3ArK10gPSAweDM4OyBidWZbcCsrXSA9IDB4Mzk7IGJ1ZltwKytdID0gMHg2MTsgIC8vIDg5YVxuXG4gIC8vIEhhbmRsaW5nIG9mIEdsb2JhbCBDb2xvciBUYWJsZSAocGFsZXR0ZSkgYW5kIGJhY2tncm91bmQgaW5kZXguXG4gIHZhciBncF9udW1fY29sb3JzX3BvdzIgPSAwO1xuICB2YXIgYmFja2dyb3VuZCA9IDA7XG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBncF9udW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhnbG9iYWxfcGFsZXR0ZSk7XG4gICAgd2hpbGUgKGdwX251bV9jb2xvcnMgPj49IDEpICsrZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGdwX251bV9jb2xvcnMgPSAxIDw8IGdwX251bV9jb2xvcnNfcG93MjtcbiAgICAtLWdwX251bV9jb2xvcnNfcG93MjtcbiAgICBpZiAoZ29wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZ29wdHMuYmFja2dyb3VuZDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kID49IGdwX251bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgIC8vIFRoZSBHSUYgc3BlYyBzdGF0ZXMgdGhhdCBhIGJhY2tncm91bmQgaW5kZXggb2YgMCBzaG91bGQgYmUgaWdub3JlZCwgc29cbiAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgYSBtaXN0YWtlIGFuZCB5b3UgcmVhbGx5IHdhbnQgdG8gc2V0IGl0IHRvIGFub3RoZXJcbiAgICAgIC8vIHNsb3QgaW4gdGhlIHBhbGV0dGUuICBCdXQgYWN0dWFsbHkgaW4gdGhlIGVuZCBtb3N0IGJyb3dzZXJzLCBldGMgZW5kXG4gICAgICAvLyB1cCBpZ25vcmluZyB0aGlzIGFsbW9zdCBjb21wbGV0ZWx5IChpbmNsdWRpbmcgZm9yIGRpc3Bvc2UgYmFja2dyb3VuZCkuXG4gICAgICBpZiAoYmFja2dyb3VuZCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBleHBsaWNpdGx5IHBhc3NlZCBhcyAwLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIC8vIE5PVEUoZGVhbm0pOiB3L2ggYXBwYXJlbnRseSBpZ25vcmVkIGJ5IGltcGxlbWVudGF0aW9ucywgYnV0IHNldCBhbnl3YXkuXG4gIGJ1ZltwKytdID0gd2lkdGggJiAweGZmOyBidWZbcCsrXSA9IHdpZHRoID4+IDggJiAweGZmO1xuICBidWZbcCsrXSA9IGhlaWdodCAmIDB4ZmY7IGJ1ZltwKytdID0gaGVpZ2h0ID4+IDggJiAweGZmO1xuICAvLyBOT1RFOiBJbmRpY2F0ZXMgMC1icHAgb3JpZ2luYWwgY29sb3IgcmVzb2x1dGlvbiAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gKGdsb2JhbF9wYWxldHRlICE9PSBudWxsID8gMHg4MCA6IDApIHwgIC8vIEdsb2JhbCBDb2xvciBUYWJsZSBGbGFnLlxuICAgICAgICAgICAgIGdwX251bV9jb2xvcnNfcG93MjsgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gYmFja2dyb3VuZDsgIC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgLy8gLSBHbG9iYWwgQ29sb3IgVGFibGVcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZ2xvYmFsX3BhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIHJnYiA9IGdsb2JhbF9wYWxldHRlW2ldO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3BfY291bnQgIT09IG51bGwpIHsgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb29wIGNvdW50IGludmFsaWQuXCIpXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGZmOyBidWZbcCsrXSA9IDB4MGI7XG4gICAgLy8gTkVUU0NBUEUyLjBcbiAgICBidWZbcCsrXSA9IDB4NGU7IGJ1ZltwKytdID0gMHg0NTsgYnVmW3ArK10gPSAweDU0OyBidWZbcCsrXSA9IDB4NTM7XG4gICAgYnVmW3ArK10gPSAweDQzOyBidWZbcCsrXSA9IDB4NDE7IGJ1ZltwKytdID0gMHg1MDsgYnVmW3ArK10gPSAweDQ1O1xuICAgIGJ1ZltwKytdID0gMHgzMjsgYnVmW3ArK10gPSAweDJlOyBidWZbcCsrXSA9IDB4MzA7XG4gICAgLy8gU3ViLWJsb2NrXG4gICAgYnVmW3ArK10gPSAweDAzOyBidWZbcCsrXSA9IDB4MDE7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ICYgMHhmZjsgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgIC8vIFRlcm1pbmF0b3IuXG4gIH1cblxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCBpbmRleGVkX3BpeGVscywgb3B0cykge1xuICAgIGlmIChlbmRlZCA9PT0gdHJ1ZSkgeyAtLXA7IGVuZGVkID0gZmFsc2U7IH0gIC8vIFVuLWVuZC5cblxuICAgIG9wdHMgPSBvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngveSBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKHcgPD0gMCB8fCBoIDw9IDAgfHwgdyA+IDY1NTM1IHx8IGggPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKGluZGV4ZWRfcGl4ZWxzLmxlbmd0aCA8IHcgKiBoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiKTtcblxuICAgIHZhciB1c2luZ19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZTtcbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpIHtcbiAgICAgIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgIHBhbGV0dGUgPSBnbG9iYWxfcGFsZXR0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIik7XG5cbiAgICB2YXIgbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtaW5fY29kZV9zaXplIChwb3dlciBvZiAyKSwgZGVzdHJveWluZyBudW1fY29sb3JzLlxuICAgIHZhciBtaW5fY29kZV9zaXplID0gMDtcbiAgICB3aGlsZSAobnVtX2NvbG9ycyA+Pj0gMSkgKyttaW5fY29kZV9zaXplO1xuICAgIG51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7ICAvLyBOb3cgd2UgY2FuIGVhc2lseSBnZXQgaXQgYmFjay5cblxuICAgIHZhciBkZWxheSA9IG9wdHMuZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRlbGF5O1xuXG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyAgICAgMCAtICAgTm8gZGlzcG9zYWwgc3BlY2lmaWVkLiBUaGUgZGVjb2RlciBpc1xuICAgIC8vICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgIC8vICAgICAxIC0gICBEbyBub3QgZGlzcG9zZS4gVGhlIGdyYXBoaWMgaXMgdG8gYmUgbGVmdFxuICAgIC8vICAgICAgICAgICBpbiBwbGFjZS5cbiAgICAvLyAgICAgMiAtICAgUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgIC8vICAgICAgICAgICBncmFwaGljIG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgIDMgLSAgIFJlc3RvcmUgdG8gcHJldmlvdXMuIFRoZSBkZWNvZGVyIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgIC8vICAgICAgICAgICB3aGF0IHdhcyB0aGVyZSBwcmlvciB0byByZW5kZXJpbmcgdGhlIGdyYXBoaWMuXG4gICAgLy8gIDQtNyAtICAgIFRvIGJlIGRlZmluZWQuXG4gICAgLy8gTk9URShkZWFubSk6IERpc3Bvc2UgYmFja2dyb3VuZCBkb2Vzbid0IHJlYWxseSB3b3JrLCBhcHBhcmVudGx5IG1vc3RcbiAgICAvLyBicm93c2VycyBpZ25vcmUgdGhlIGJhY2tncm91bmQgcGFsZXR0ZSBpbmRleCBhbmQgY2xlYXIgdG8gdHJhbnNwYXJlbmN5LlxuICAgIHZhciBkaXNwb3NhbCA9IG9wdHMuZGlzcG9zYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRpc3Bvc2FsO1xuICAgIGlmIChkaXNwb3NhbCA8IDAgfHwgZGlzcG9zYWwgPiAzKSAgLy8gNC03IGlzIHJlc2VydmVkLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiKTtcblxuICAgIHZhciB1c2VfdHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gMDtcbiAgICBpZiAob3B0cy50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudHJhbnNwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVzZV90cmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBvcHRzLnRyYW5zcGFyZW50O1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2luZGV4IDwgMCB8fCB0cmFuc3BhcmVudF9pbmRleCA+PSBudW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGY5OyAgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7ICAvLyBCeXRlIHNpemUuXG5cbiAgICAgIGJ1ZltwKytdID0gZGlzcG9zYWwgPDwgMiB8ICh1c2VfdHJhbnNwYXJlbmN5ID09PSB0cnVlID8gMSA6IDApO1xuICAgICAgYnVmW3ArK10gPSBkZWxheSAmIDB4ZmY7IGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAgLy8gVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXG4gICAgICBidWZbcCsrXSA9IDA7ICAvLyBCbG9jayBUZXJtaW5hdG9yLlxuICAgIH1cblxuICAgIC8vIC0gSW1hZ2UgRGVzY3JpcHRvclxuICAgIGJ1ZltwKytdID0gMHgyYzsgIC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmOyBidWZbcCsrXSA9IHggPj4gOCAmIDB4ZmY7ICAvLyBMZWZ0LlxuICAgIGJ1ZltwKytdID0geSAmIDB4ZmY7IGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgIC8vIFRvcC5cbiAgICBidWZbcCsrXSA9IHcgJiAweGZmOyBidWZbcCsrXSA9IHcgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoICYgMHhmZjsgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/ICgweDgwIHwgKG1pbl9jb2RlX3NpemUtMSkpIDogMDtcblxuICAgIC8vIC0gTG9jYWwgQ29sb3IgVGFibGVcbiAgICBpZiAodXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciByZ2IgPSBwYWxldHRlW2ldO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oXG4gICAgICAgICAgICBidWYsIHAsIG1pbl9jb2RlX3NpemUgPCAyID8gMiA6IG1pbl9jb2RlX3NpemUsIGluZGV4ZWRfcGl4ZWxzKTtcblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVuZGVkID09PSBmYWxzZSkge1xuICAgICAgYnVmW3ArK10gPSAweDNiOyAgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1ZjsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbih2KSB7IGJ1ZiA9IHY7IH07XG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHA7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbih2KSB7IHAgPSB2OyB9O1xufVxuXG4vLyBNYWluIGNvbXByZXNzaW9uIHJvdXRpbmUsIHBhbGV0dGUgaW5kZXhlcyAtPiBMWlcgY29kZSBzdHJlYW0uXG4vLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuZnVuY3Rpb24gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShidWYsIHAsIG1pbl9jb2RlX3NpemUsIGluZGV4X3N0cmVhbSkge1xuICBidWZbcCsrXSA9IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7ICAvLyBQb2ludGluZyBhdCB0aGUgbGVuZ3RoIGZpZWxkLlxuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgLy8gYml0cyBoZXJlIChhbmQgdGhlbiB3ZSB3b3VsZCB3cml0ZSBvdXQpLlxuICB2YXIgY3VyID0gMDtcblxuICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gYml0X2Jsb2NrX3NpemUpIHtcbiAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgY3VyIHw9IGMgPDwgY3VyX3NoaWZ0O1xuICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICB9XG5cbiAgLy8gSSBhbSBub3QgYW4gZXhwZXJ0IG9uIHRoZSB0b3BpYywgYW5kIEkgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIHRoZXNpcy5cbiAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gIC8vIHN0cnVjdHVyZXMgYW5kIG9wdGltaXphdGlvbnMgaGVyZSB0aGF0IG1ha2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBmYXN0LlxuICAvLyBUaGUgYmFzaWMgaWRlYSBiZWhpbmQgTFpXIGlzIHRvIGJ1aWxkIGEgdGFibGUgb2YgcHJldmlvdXNseSBzZWVuIHJ1bnNcbiAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgLy8gcmVmZXJlbmNlZCBieSBhIGNvZGUsIHdoaWNoIHJlcHJlc2VudHMgb25lIG9yIG1vcmUgdmFsdWVzIGZyb20gdGhlXG4gIC8vIG9yaWdpbmFsIGlucHV0IHN0cmVhbS4gIEFsbCBpbnB1dCBieXRlcyBjYW4gYmUgcmVmZXJlbmNlZCBhcyB0aGUgc2FtZVxuICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAvLyBjb3VsZCBtb3JlIG9yIGxlc3MganVzdCBvdXRwdXQgdGhlIG9yaWdpbmFsIGJ5dGVzIGFzIGNvZGVzICh0aGVyZSBhcmVcbiAgLy8gc29tZSBkZXRhaWxzIHRvIHRoaXMsIGJ1dCBpdCBpcyB0aGUgaWRlYSkuICBJbiBvcmRlciB0byBhY2hpZXZlXG4gIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gIC8vIDEyLWJpdCB3aGlsZSBpbnB1dCBvbmx5IDgtYml0KSByZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBwcmV2aW91c2x5IHNlZW5cbiAgLy8gaW5wdXRzLiAgVGhlIGRlY29tcHJlc3NvciBpcyBhYmxlIHRvIGJ1aWxkIHRoZSBzYW1lIG1hcHBpbmcgd2hpbGVcbiAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gIC8vIGVuY29kaW5nIGFuZCBkZWNvZGVyLCB3aGljaCBpcyBhbHNvIGltcG9ydGFudCBmb3IgXCJ0aW1pbmdcIiBhc3BlY3RzIGxpa2VcbiAgLy8gaG93IHRvIGhhbmRsZSB2YXJpYWJsZSBiaXQgd2lkdGggY29kZSBlbmNvZGluZy5cbiAgLy9cbiAgLy8gT25lIG9idmlvdXMgYnV0IHZlcnkgaW1wb3J0YW50IGNvbnNlcXVlbmNlIG9mIHRoZSB0YWJsZSBzeXN0ZW0gaXMgdGhlcmVcbiAgLy8gaXMgYWx3YXlzIGEgdW5pcXVlIGlkIChhdCBtb3N0IDEyLWJpdHMpIHRvIG1hcCB0aGUgcnVucy4gICdBJyBtaWdodCBiZVxuICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gIC8vIGNhbiBiZSB1c2VkIGZvciBhbiBlZmZlY2llbnQgbG9va3VwIHN0cmF0ZWd5IGZvciB0aGUgY29kZSBtYXBwaW5nLiAgV2VcbiAgLy8gbmVlZCB0byBrbm93IGlmIGEgcnVuIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBhbmQgYmUgYWJsZSB0byBtYXAgdGhhdCBydW5cbiAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gIC8vIGFuZCB0aGVuIGZyb20gdGhvc2UgYnVpbGQgbW9yZSB1bmlxdWUgaWRzICh0YWJsZSBlbnRyaWVzKSwgd2UgY2FuXG4gIC8vIGNvbnRpbnVlIHRoaXMgY2hhaW4gKGFsbW9zdCBsaWtlIGEgbGlua2VkIGxpc3QpIHRvIGFsd2F5cyBoYXZlIHNtYWxsXG4gIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAvLyBUaGlzIG1lYW5zIGluc3RlYWQgb2YgdHJhY2tpbmcgdGhlIGlucHV0IGJ5dGVzIChBQUFBQkNEKSB0byBrbm93IG91clxuICAvLyBjdXJyZW50IHN0YXRlLCB3ZSBjYW4gdHJhY2sgdGhlIHRhYmxlIGVudHJ5IGZvciBBQUFBQkMgKGl0IGlzIGd1YXJhbnRlZWRcbiAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gIC8vIFRoZXJlZm9yIHRoZSB0dXBsZSBvZiAodGFibGVfZW50cnksIGJ5dGUpIGlzIGd1YXJhbnRlZWQgdG8gYWxzbyBiZVxuICAvLyB1bmlxdWUuICBUaGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIGtleSBmb3IgbWFwcGluZyBpbnB1dFxuICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAvLyBhbnkgb2YgdGhlIGNvZGUgc2VxdWVuY2VzLiAgU28gaWYgJ0FBQUEnIGhhcyBhIHRhYmxlIGVudHJ5IG9mIDEyLCB0aGVcbiAgLy8gdHVwbGUgb2YgKCdBQUFBJywgSykgZm9yIGFueSBpbnB1dCBieXRlIEsgd2lsbCBiZSB1bmlxdWUsIGFuZCBjYW4gYmUgb3VyXG4gIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAvLyBmaXQgaW4gYW4gU01JIHZhbHVlIGFuZCBiZSB1c2VkIGFzIGEgZmFzdCBzcGFyc2UgYXJyYXkgLyBvYmplY3Qga2V5LlxuXG4gIC8vIE91dHB1dCBjb2RlIGZvciB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgaW5kZXggYnVmZmVyLlxuICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgIC8vIExvYWQgZmlyc3QgaW5wdXQgaW5kZXguXG4gIHZhciBjb2RlX3RhYmxlID0geyB9OyAgLy8gS2V5J2Qgb24gb3VyIDIwLWJpdCBcInR1cGxlXCIuXG5cbiAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpOyAgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAvLyBGaXJzdCBpbmRleCBhbHJlYWR5IGxvYWRlZCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgc3RyZWFtLlxuICBmb3IgKHZhciBpID0gMSwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgIHZhciBjdXJfa2V5ID0gaWJfY29kZSA8PCA4IHwgazsgIC8vIChwcmV2LCBrKSB1bmlxdWUgdHVwbGUuXG4gICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgIC8vIGJ1ZmZlciArIGsuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBjb2RlIHRhYmxlIGVudHJ5LlxuICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBXZSBkb24ndCBoYXZlIGJ1ZmZlciArIGsuXG4gICAgICAvLyBFbWl0IGluZGV4IGJ1ZmZlciAod2l0aG91dCBrKS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgIC8vIHdyaXRpbmcgcm91dGluZSBvZiB0aGUgY29tcHJlc3NvciAoYW5kIFY4IGNhbm5vdCBpbmxpbmUgZW1pdF9jb2RlXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgY2xvc3VyZSBoZXJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQpLiAgQWRkaXRpb25hbGx5XG4gICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgIC8vIDMwLWJpdHMgKGZyb20gb3VyIDMxLWJpdCBzaWduZWQgU01JKSwgYW5kIHdlIGtub3cgb3VyIGNvZGVzIHdpbGwgb25seVxuICAgICAgLy8gYmUgMTItYml0cywgc28gY2FuIHNhZmVseSBoYXZlIDE4LWJpdHMgdGhlcmUgd2l0aG91dCBvdmVyZmxvdy5cbiAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgIGN1ciB8PSBpYl9jb2RlIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5NikgeyAgLy8gVGFibGUgZnVsbCwgbmVlZCBhIGNsZWFyLlxuICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgICBjb2RlX3RhYmxlID0geyB9O1xuICAgICAgfSBlbHNlIHsgIC8vIFRhYmxlIG5vdCBmdWxsLCBpbnNlcnQgYSBuZXcgZW50cnkuXG4gICAgICAgIC8vIEluY3JlYXNlIG91ciB2YXJpYWJsZSBiaXQgY29kZSBzaXplcyBpZiBuZWNlc3NhcnkuICBUaGlzIGlzIGEgYml0XG4gICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAvLyBkZWNvZGVyLiAgRnJvbSB0aGUgZW5jb2RlcnMgcGVyc3BlY3RpdmUgdGhpcyBzaG91bGQgaGFwcGVuIGFmdGVyXG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCB0aGUgaW5kZXggYnVmZmVyIGFuZCBhcmUgYWJvdXQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgIGlmIChuZXh0X2NvZGUgPj0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV90YWJsZVtjdXJfa2V5XSA9IG5leHRfY29kZSsrOyAgLy8gSW5zZXJ0IGludG8gY29kZSB0YWJsZS5cbiAgICAgIH1cblxuICAgICAgaWJfY29kZSA9IGs7ICAvLyBJbmRleCBidWZmZXIgdG8gc2luZ2xlIGlucHV0IGsuXG4gICAgfSBlbHNlIHtcbiAgICAgIGliX2NvZGUgPSBjdXJfY29kZTsgIC8vIEluZGV4IGJ1ZmZlciB0byBzZXF1ZW5jZSBpbiBjb2RlIHRhYmxlLlxuICAgIH1cbiAgfVxuXG4gIGVtaXRfY29kZShpYl9jb2RlKTsgIC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gIGVtaXRfY29kZShlb2lfY29kZSk7ICAvLyBFbmQgT2YgSW5mb3JtYXRpb24uXG5cbiAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgZW1pdF9ieXRlc190b19idWZmZXIoMSk7XG5cbiAgLy8gRmluaXNoIHRoZSBzdWItYmxvY2tzLCB3cml0aW5nIG91dCBhbnkgdW5maW5pc2hlZCBsZW5ndGhzIGFuZFxuICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgLy8gYnV0IG5vdCB5ZXQgdXNlZCBhIHN1Yi1ibG9jayBpdCBjYW4ganVzdCBiZWNvbWUgdGhlIHRlcm1pbmF0b3IuXG4gIGlmIChjdXJfc3ViYmxvY2sgKyAxID09PSBwKSB7ICAvLyBTdGFydGVkIGJ1dCB1bnVzZWQuXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICB9IGVsc2UgeyAgLy8gU3RhcnRlZCBhbmQgdXNlZCwgd3JpdGUgbGVuZ3RoIGFuZCBhZGRpdGlvbmFsIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSBwIC0gY3VyX3N1YmJsb2NrIC0gMTtcbiAgICBidWZbcCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlcihidWYpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIC8vIC0gSGVhZGVyIChHSUY4N2Egb3IgR0lGODlhKS5cbiAgaWYgKGJ1ZltwKytdICE9PSAweDQ3IHx8ICAgICAgICAgICAgYnVmW3ArK10gIT09IDB4NDkgfHwgYnVmW3ArK10gIT09IDB4NDYgfHxcbiAgICAgIGJ1ZltwKytdICE9PSAweDM4IHx8IChidWZbcCsrXSsxICYgMHhmZCkgIT09IDB4MzggfHwgYnVmW3ArK10gIT09IDB4NjEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdJRiA4N2EvODlhIGhlYWRlci5cIik7XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIHZhciB3aWR0aCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIGhlaWdodCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIHBmMCA9IGJ1ZltwKytdOyAgLy8gPFBhY2tlZCBGaWVsZHM+LlxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfZmxhZyA9IHBmMCA+PiA3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnNfcG93MiA9IHBmMCAmIDB4NztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzID0gMSA8PCAobnVtX2dsb2JhbF9jb2xvcnNfcG93MiArIDEpO1xuICB2YXIgYmFja2dyb3VuZCA9IGJ1ZltwKytdO1xuICBidWZbcCsrXTsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IG51bGw7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9zaXplICAgPSBudWxsO1xuXG4gIGlmIChnbG9iYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gcDtcbiAgICBnbG9iYWxfcGFsZXR0ZV9zaXplID0gbnVtX2dsb2JhbF9jb2xvcnM7XG4gICAgcCArPSBudW1fZ2xvYmFsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgfVxuXG4gIHZhciBub19lb2YgPSB0cnVlO1xuXG4gIHZhciBmcmFtZXMgPSBbIF07XG5cbiAgdmFyIGRlbGF5ID0gMDtcbiAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgdmFyIGRpc3Bvc2FsID0gMDsgIC8vIDAgLSBObyBkaXNwb3NhbCBzcGVjaWZpZWQuXG4gIHZhciBsb29wX2NvdW50ID0gbnVsbDtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHdoaWxlIChub19lb2YgJiYgcCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICBjYXNlIDB4MjE6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvbiBCbG9ja1xuICAgICAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICAgICAgY2FzZSAweGZmOiAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRyeSBpZiBpdCdzIGEgTmV0c2NhcGUgYmxvY2sgKHdpdGggYW5pbWF0aW9uIGxvb3AgY291bnRlcikuXG4gICAgICAgICAgICBpZiAoYnVmW3AgICBdICE9PSAweDBiIHx8ICAvLyAyMSBGRiBhbHJlYWR5IHJlYWQsIGNoZWNrIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgLy8gTkVUU0NBUEUyLjBcbiAgICAgICAgICAgICAgICBidWZbcCsxIF0gPT0gMHg0ZSAmJiBidWZbcCsyIF0gPT0gMHg0NSAmJiBidWZbcCszIF0gPT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzQgXSA9PSAweDUzICYmIGJ1ZltwKzUgXSA9PSAweDQzICYmIGJ1ZltwKzYgXSA9PSAweDQxICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNyBdID09IDB4NTAgJiYgYnVmW3ArOCBdID09IDB4NDUgJiYgYnVmW3ArOSBdID09IDB4MzIgJiZcbiAgICAgICAgICAgICAgICBidWZbcCsxMF0gPT0gMHgyZSAmJiBidWZbcCsxMV0gPT0gMHgzMCAmJlxuICAgICAgICAgICAgICAgIC8vIFN1Yi1ibG9ja1xuICAgICAgICAgICAgICAgIGJ1ZltwKzEyXSA9PSAweDAzICYmIGJ1ZltwKzEzXSA9PSAweDAxICYmIGJ1ZltwKzE2XSA9PSAwKSB7XG4gICAgICAgICAgICAgIHAgKz0gMTQ7XG4gICAgICAgICAgICAgIGxvb3BfY291bnQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBXZSBkb24ndCBrbm93IHdoYXQgaXQgaXMsIGp1c3QgdHJ5IHRvIGdldCBwYXN0IGl0LlxuICAgICAgICAgICAgICBwICs9IDEyO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4Zjk6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGJ1ZltwKytdICE9PSAweDQgfHwgYnVmW3ArNF0gIT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgIHZhciBwZjEgPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGRlbGF5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGlmICgocGYxICYgMSkgPT09IDApIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3Bvc2FsID0gcGYxID4+IDIgJiAweDc7XG4gICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZTogIC8vIENvbW1lbnQgRXh0ZW5zaW9uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ1Zi5zbGljZShwLCBwK2Jsb2NrX3NpemUpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MmM6ICAvLyBJbWFnZSBEZXNjcmlwdG9yLlxuICAgICAgICB2YXIgeCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB3ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgaCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHBmMiA9IGJ1ZltwKytdO1xuICAgICAgICB2YXIgbG9jYWxfcGFsZXR0ZV9mbGFnID0gcGYyID4+IDc7XG4gICAgICAgIHZhciBpbnRlcmxhY2VfZmxhZyA9IHBmMiA+PiA2ICYgMTtcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnNfcG93MiA9IHBmMiAmIDB4NztcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnMgPSAxIDw8IChudW1fbG9jYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgICAgICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0O1xuICAgICAgICB2YXIgcGFsZXR0ZV9zaXplID0gZ2xvYmFsX3BhbGV0dGVfc2l6ZTtcbiAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2NhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0ID0gcDsgIC8vIE92ZXJyaWRlIHdpdGggbG9jYWwgcGFsZXR0ZS5cbiAgICAgICAgICBwYWxldHRlX3NpemUgPSBudW1fbG9jYWxfY29sb3JzO1xuICAgICAgICAgIHAgKz0gbnVtX2xvY2FsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhX29mZnNldCA9IHA7XG5cbiAgICAgICAgcCsrOyAgLy8gY29kZXNpemVcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lcy5wdXNoKHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgaGFzX2xvY2FsX3BhbGV0dGU6IGhhc19sb2NhbF9wYWxldHRlLFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9vZmZzZXQ6IHBhbGV0dGVfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9zaXplOiBwYWxldHRlX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX29mZnNldDogZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aDogcCAtIGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXg6IHRyYW5zcGFyZW50X2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYWNlZDogISFpbnRlcmxhY2VfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsOiBkaXNwb3NhbH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDNiOiAgLy8gVHJhaWxlciBNYXJrZXIgKGVuZCBvZiBmaWxlKS5cbiAgICAgICAgbm9fZW9mID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubnVtRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5sZW5ndGg7XG4gIH07XG5cbiAgdGhpcy5sb29wQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9vcF9jb3VudDtcbiAgfTtcblxuICB0aGlzLmZyYW1lSW5mbyA9IGZ1bmN0aW9uKGZyYW1lX251bSkge1xuICAgIGlmIChmcmFtZV9udW0gPCAwIHx8IGZyYW1lX251bSA+PSBmcmFtZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gZnJhbWVzW2ZyYW1lX251bV07XG4gIH1cblxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSSB3aWxsIGdvIHRvIGNvcHkgYW5kIHBhc3RlIGhlbGwgb25lIGRheS4uLlxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKGNvZGVfc3RyZWFtLCBwLCBvdXRwdXQsIG91dHB1dF9sZW5ndGgpIHtcbiAgdmFyIG1pbl9jb2RlX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIC8vIE5PVEU6IFRoaXMgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGVuY29kZXIsIGJ1dCBoYXMgYSBkaWZmZXJlbnRcbiAgLy8gbWVhbmluZyBoZXJlLiAgSGVyZSB0aGlzIG1hc2tzIGVhY2ggY29kZSBjb21pbmcgZnJvbSB0aGUgY29kZSBzdHJlYW0uXG4gIHZhciBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICB2YXIgY3VyID0gMDtcblxuICB2YXIgb3AgPSAwOyAgLy8gT3V0cHV0IHBvaW50ZXIuXG5cbiAgdmFyIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIC8vIFRPRE8oZGVhbm0pOiBXb3VsZCB1c2luZyBhIFR5cGVkQXJyYXkgYmUgYW55IGZhc3Rlcj8gIEF0IGxlYXN0IGl0IHdvdWxkXG4gIC8vIHNvbHZlIHRoZSBmYXN0IG1vZGUgLyBiYWNraW5nIHN0b3JlIHVuY2VydGFpbnR5LlxuICAvLyB2YXIgY29kZV90YWJsZSA9IEFycmF5KDQwOTYpO1xuICB2YXIgY29kZV90YWJsZSA9IG5ldyBJbnQzMkFycmF5KDQwOTYpOyAgLy8gQ2FuIGJlIHNpZ25lZCwgd2Ugb25seSB1c2UgMjAgYml0cy5cblxuICB2YXIgcHJldl9jb2RlID0gbnVsbDsgIC8vIFRyYWNrIGNvZGUtMS5cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFJlYWQgdXAgdG8gdHdvIGJ5dGVzLCBtYWtpbmcgc3VyZSB3ZSBhbHdheXMgMTItYml0cyBmb3IgbWF4IHNpemVkIGNvZGUuXG4gICAgd2hpbGUgKGN1cl9zaGlmdCA8IDE2KSB7XG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyBObyBtb3JlIGRhdGEgdG8gYmUgcmVhZC5cblxuICAgICAgY3VyIHw9IGNvZGVfc3RyZWFtW3ArK10gPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IDg7XG5cbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAxKSB7ICAvLyBOZXZlciBsZXQgaXQgZ2V0IHRvIDAgdG8gaG9sZCBsb2dpYyBhYm92ZS5cbiAgICAgICAgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107ICAvLyBOZXh0IHN1YmJsb2NrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1zdWJibG9ja19zaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8oZGVhbm0pOiBXZSBzaG91bGQgbmV2ZXIgcmVhbGx5IGdldCBoZXJlLCB3ZSBzaG91bGQgaGF2ZSByZWNlaXZlZFxuICAgIC8vIGFuZCBFT0kuXG4gICAgaWYgKGN1cl9zaGlmdCA8IGN1cl9jb2RlX3NpemUpXG4gICAgICBicmVhaztcblxuICAgIHZhciBjb2RlID0gY3VyICYgY29kZV9tYXNrO1xuICAgIGN1ciA+Pj0gY3VyX2NvZGVfc2l6ZTtcbiAgICBjdXJfc2hpZnQgLT0gY3VyX2NvZGVfc2l6ZTtcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBNYXliZSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgZmlyc3QgY29kZSB3YXMgYSBjbGVhciBjb2RlLFxuICAgIC8vIGF0IGxlYXN0IHRoaXMgaXMgd2hhdCB5b3UncmUgc3VwcG9zZWQgdG8gZG8uICBCdXQgYWN0dWFsbHkgb3VyIGVuY29kZXJcbiAgICAvLyBub3cgZG9lc24ndCBlbWl0IGEgY2xlYXIgY29kZSBmaXJzdCBhbnl3YXkuXG4gICAgaWYgKGNvZGUgPT09IGNsZWFyX2NvZGUpIHtcbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gY2xlYXIgdGhlIHRhYmxlLiAgVGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYVxuICAgICAgLy8gZm9yIGdyZWF0ZXIgZXJyb3IgY2hlY2tpbmcsIGJ1dCB3ZSBkb24ndCByZWFsbHkgZG8gYW55IGFueXdheS4gIFdlXG4gICAgICAvLyB3aWxsIGp1c3QgdHJhY2sgaXQgd2l0aCBuZXh0X2NvZGUgYW5kIG92ZXJ3cml0ZSBvbGQgZW50cmllcy5cblxuICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJldl9jb2RlID9cbiAgICAgIHByZXZfY29kZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGVvaV9jb2RlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgc2ltaWxhciBzaXR1YXRpb24gYXMgdGhlIGRlY29kZXIsIHdoZXJlIHdlIHdhbnQgdG8gc3RvcmVcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggZW50cmllcyAoY29kZSB0YWJsZSBlbnRyaWVzKSwgYnV0IHdlIHdhbnQgdG8gZG8gaW4gYVxuICAgIC8vIGZhc3RlciBtYW5uZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuICBUaGUgY29kZSBiZWxvdyBzdG9yZXMgc29ydCBvZiBhXG4gICAgLy8gbGlua2VkIGxpc3Qgd2l0aGluIHRoZSBjb2RlIHRhYmxlLCBhbmQgdGhlbiBcImNoYXNlc1wiIHRocm91Z2ggaXQgdG9cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGRpY3Rpb25hcnkgZW50cmllcy4gIFdoZW4gYSBuZXcgZW50cnkgaXMgY3JlYXRlZCwganVzdCB0aGVcbiAgICAvLyBsYXN0IGJ5dGUgaXMgc3RvcmVkLCBhbmQgdGhlIHJlc3QgKHByZWZpeCkgb2YgdGhlIGVudHJ5IGlzIG9ubHlcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGl0cyB0YWJsZSBlbnRyeS4gIFRoZW4gdGhlIGNvZGUgY2hhc2VzIHRocm91Z2ggdGhlXG4gICAgLy8gcHJlZml4ZXMgdW50aWwgaXQgcmVhY2hlcyBhIHNpbmdsZSBieXRlIGNvZGUuICBXZSBoYXZlIHRvIGNoYXNlIHR3aWNlLFxuICAgIC8vIGZpcnN0IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCwgYW5kIHRoZW4gdG8gYWN0dWFsbHkgY29weSB0aGUgZGF0YSB0byB0aGVcbiAgICAvLyBvdXRwdXQgKGJhY2t3YXJkcywgc2luY2Ugd2Uga25vdyB0aGUgbGVuZ3RoKS4gIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZVxuICAgIC8vIHN0b3Jpbmcgc29tZXRoaW5nIGluIGFuIGludGVybWVkaWF0ZSBzdGFjaywgYnV0IHRoYXQgZG9lc24ndCBtYWtlIGFueVxuICAgIC8vIG1vcmUgc2Vuc2UuICBJIGltcGxlbWVudGVkIGFuIGFwcHJvYWNoIHdoZXJlIGl0IGFsc28gc3RvcmVkIHRoZSBsZW5ndGhcbiAgICAvLyBpbiB0aGUgY29kZSB0YWJsZSwgYWx0aG91Z2ggaXQncyBhIGJpdCB0cmlja3kgYmVjYXVzZSB5b3UgcnVuIG91dCBvZlxuICAgIC8vIGJpdHMgKDEyICsgMTIgKyA4KSwgYnV0IEkgZGlkbid0IG1lYXN1cmUgbXVjaCBpbXByb3ZlbWVudHMgKHRoZSB0YWJsZVxuICAgIC8vIGVudHJpZXMgYXJlIGdlbmVyYWxseSBub3QgdGhlIGxvbmcpLiAgRXZlbiB3aGVuIEkgY3JlYXRlZCBiZW5jaG1hcmtzIGZvclxuICAgIC8vIHZlcnkgbG9uZyB0YWJsZSBlbnRyaWVzIHRoZSBjb21wbGV4aXR5IGRpZCBub3Qgc2VlbSB3b3J0aCBpdC5cbiAgICAvLyBUaGUgY29kZSB0YWJsZSBzdG9yZXMgdGhlIHByZWZpeCBlbnRyeSBpbiAxMiBiaXRzIGFuZCB0aGVuIHRoZSBzdWZmaXhcbiAgICAvLyBieXRlIGluIDggYml0cywgc28gZWFjaCBlbnRyeSBpcyAyMCBiaXRzLlxuXG4gICAgdmFyIGNoYXNlX2NvZGUgPSBjb2RlIDwgbmV4dF9jb2RlID8gY29kZSA6IHByZXZfY29kZTtcblxuICAgIC8vIENoYXNlIHdoYXQgd2Ugd2lsbCBvdXRwdXQsIGVpdGhlciB7Q09ERX0gb3Ige0NPREUtMX0uXG4gICAgdmFyIGNoYXNlX2xlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2UgPiBjbGVhcl9jb2RlKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdID4+IDg7XG4gICAgICArK2NoYXNlX2xlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgayA9IGNoYXNlO1xuXG4gICAgdmFyIG9wX2VuZCA9IG9wICsgY2hhc2VfbGVuZ3RoICsgKGNoYXNlX2NvZGUgIT09IGNvZGUgPyAxIDogMCk7XG4gICAgaWYgKG9wX2VuZCA+IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBsb25nZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBoYXZlIHRoZSBmaXJzdCBieXRlIGZyb20gdGhlIGNoYXNlLCBtaWdodCBhcyB3ZWxsIHdyaXRlIGl0IGZhc3QuXG4gICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIG9wICs9IGNoYXNlX2xlbmd0aDtcbiAgICB2YXIgYiA9IG9wOyAgLy8gVHJhY2sgcG9pbnRlciwgd3JpdGluZyBiYWNrd2FyZHMuXG5cbiAgICBpZiAoY2hhc2VfY29kZSAhPT0gY29kZSkgIC8vIFRoZSBjYXNlIG9mIGVtaXR0aW5nIHtDT0RFLTF9ICsgay5cbiAgICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlX2xlbmd0aC0tKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdO1xuICAgICAgb3V0cHV0Wy0tYl0gPSBjaGFzZSAmIDB4ZmY7ICAvLyBXcml0ZSBiYWNrd2FyZHMuXG4gICAgICBjaGFzZSA+Pj0gODsgIC8vIFB1bGwgZG93biB0byB0aGUgcHJlZml4IGNvZGUuXG4gICAgfVxuXG4gICAgaWYgKHByZXZfY29kZSAhPT0gbnVsbCAmJiBuZXh0X2NvZGUgPCA0MDk2KSB7XG4gICAgICBjb2RlX3RhYmxlW25leHRfY29kZSsrXSA9IHByZXZfY29kZSA8PCA4IHwgaztcbiAgICAgIC8vIFRPRE8oZGVhbm0pOiBGaWd1cmUgb3V0IHRoaXMgY2xlYXJpbmcgdnMgY29kZSBncm93dGggbG9naWMgYmV0dGVyLiAgSVxuICAgICAgLy8gaGF2ZSBhbiBmZWVsaW5nIHRoYXQgaXQgc2hvdWxkIGp1c3QgaGFwcGVuIHNvbWV3aGVyZSBlbHNlLCBmb3Igbm93IGl0XG4gICAgICAvLyBpcyBhd2t3YXJkIGJldHdlZW4gd2hlbiB3ZSBncm93IHBhc3QgdGhlIG1heCBhbmQgdGhlbiBoaXQgYSBjbGVhciBjb2RlLlxuICAgICAgLy8gRm9yIG5vdyBqdXN0IGNoZWNrIGlmIHdlIGhpdCB0aGUgbWF4IDEyLWJpdHMgKHRoZW4gYSBjbGVhciBjb2RlIHNob3VsZFxuICAgICAgLy8gZm9sbG93LCBhbHNvIG9mIGNvdXJzZSBlbmNvZGVkIGluIDEyLWJpdHMpLlxuICAgICAgaWYgKG5leHRfY29kZSA+PSBjb2RlX21hc2srMSAmJiBjdXJfY29kZV9zaXplIDwgMTIpIHtcbiAgICAgICAgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX21hc2sgPSBjb2RlX21hc2sgPDwgMSB8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldl9jb2RlID0gY29kZTtcbiAgfVxuXG4gIGlmIChvcCAhPT0gb3V0cHV0X2xlbmd0aCkge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gQ29tbW9uSlMuXG50cnkgeyBleHBvcnRzLkdpZldyaXRlciA9IEdpZldyaXRlcjsgZXhwb3J0cy5HaWZSZWFkZXIgPSBHaWZSZWFkZXIgfSBjYXRjaChlKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUJNRm9udEFzY2lpKGRhdGEpIHtcbiAgaWYgKCFkYXRhKVxuICAgIHRocm93IG5ldyBFcnJvcignbm8gZGF0YSBwcm92aWRlZCcpXG4gIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCkudHJpbSgpXG5cbiAgdmFyIG91dHB1dCA9IHtcbiAgICBwYWdlczogW10sXG4gICAgY2hhcnM6IFtdLFxuICAgIGtlcm5pbmdzOiBbXVxuICB9XG5cbiAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdCgvXFxyXFxuP3xcXG4vZylcblxuICBpZiAobGluZXMubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignbm8gZGF0YSBpbiBCTUZvbnQgZmlsZScpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lRGF0YSA9IHNwbGl0TGluZShsaW5lc1tpXSwgaSlcbiAgICBpZiAoIWxpbmVEYXRhKSAvL3NraXAgZW1wdHkgbGluZXNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICBpZiAobGluZURhdGEua2V5ID09PSAncGFnZScpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZURhdGEuZGF0YS5pZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIGZpbGUgYXQgbGluZSAnICsgaSArICcgLS0gbmVlZHMgcGFnZSBpZD1OJylcbiAgICAgIGlmICh0eXBlb2YgbGluZURhdGEuZGF0YS5maWxlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgZmlsZSBhdCBsaW5lICcgKyBpICsgJyAtLSBuZWVkcyBwYWdlIGZpbGU9XCJwYXRoXCInKVxuICAgICAgb3V0cHV0LnBhZ2VzW2xpbmVEYXRhLmRhdGEuaWRdID0gbGluZURhdGEuZGF0YS5maWxlXG4gICAgfSBlbHNlIGlmIChsaW5lRGF0YS5rZXkgPT09ICdjaGFycycgfHwgbGluZURhdGEua2V5ID09PSAna2VybmluZ3MnKSB7XG4gICAgICAvLy4uLiBkbyBub3RoaW5nIGZvciB0aGVzZSB0d28gLi4uXG4gICAgfSBlbHNlIGlmIChsaW5lRGF0YS5rZXkgPT09ICdjaGFyJykge1xuICAgICAgb3V0cHV0LmNoYXJzLnB1c2gobGluZURhdGEuZGF0YSlcbiAgICB9IGVsc2UgaWYgKGxpbmVEYXRhLmtleSA9PT0gJ2tlcm5pbmcnKSB7XG4gICAgICBvdXRwdXQua2VybmluZ3MucHVzaChsaW5lRGF0YS5kYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRbbGluZURhdGEua2V5XSA9IGxpbmVEYXRhLmRhdGFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIHNwbGl0TGluZShsaW5lLCBpZHgpIHtcbiAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFx0Ky9nLCAnICcpLnRyaW0oKVxuICBpZiAoIWxpbmUpXG4gICAgcmV0dXJuIG51bGxcblxuICB2YXIgc3BhY2UgPSBsaW5lLmluZGV4T2YoJyAnKVxuICBpZiAoc3BhY2UgPT09IC0xKSBcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBuYW1lZCByb3cgYXQgbGluZSBcIiArIGlkeClcblxuICB2YXIga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgc3BhY2UpXG5cbiAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKHNwYWNlICsgMSlcbiAgLy9jbGVhciBcImxldHRlclwiIGZpZWxkIGFzIGl0IGlzIG5vbi1zdGFuZGFyZCBhbmRcbiAgLy9yZXF1aXJlcyBhZGRpdGlvbmFsIGNvbXBsZXhpdHkgdG8gcGFyc2UgXCIgLyA9IHN5bWJvbHNcbiAgbGluZSA9IGxpbmUucmVwbGFjZSgvbGV0dGVyPVtcXCdcXFwiXVxcUytbXFwnXFxcIl0vZ2ksICcnKSAgXG4gIGxpbmUgPSBsaW5lLnNwbGl0KFwiPVwiKVxuICBsaW5lID0gbGluZS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkubWF0Y2goKC8oXCIuKj9cInxbXlwiXFxzXSspKyg/PVxccyp8XFxzKiQpL2cpKVxuICB9KVxuXG4gIHZhciBkYXRhID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGR0ID0gbGluZVtpXVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBrZXk6IGR0WzBdLFxuICAgICAgICBkYXRhOiBcIlwiXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoaSA9PT0gbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uZGF0YSA9IHBhcnNlRGF0YShkdFswXSlcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmRhdGEgPSBwYXJzZURhdGEoZHRbMF0pXG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBrZXk6IGR0WzFdLFxuICAgICAgICBkYXRhOiBcIlwiXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBvdXQgPSB7XG4gICAga2V5OiBrZXksXG4gICAgZGF0YToge31cbiAgfVxuXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgb3V0LmRhdGFbdi5rZXldID0gdi5kYXRhO1xuICB9KVxuXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRhKGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBcIlwiXG5cbiAgaWYgKGRhdGEuaW5kZXhPZignXCInKSA9PT0gMCB8fCBkYXRhLmluZGV4T2YoXCInXCIpID09PSAwKVxuICAgIHJldHVybiBkYXRhLnN1YnN0cmluZygxLCBkYXRhLmxlbmd0aCAtIDEpXG4gIGlmIChkYXRhLmluZGV4T2YoJywnKSAhPT0gLTEpXG4gICAgcmV0dXJuIHBhcnNlSW50TGlzdChkYXRhKVxuICByZXR1cm4gcGFyc2VJbnQoZGF0YSwgMTApXG59XG5cbmZ1bmN0aW9uIHBhcnNlSW50TGlzdChkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKVxuICB9KVxufSIsInZhciBIRUFERVIgPSBbNjYsIDc3LCA3MF1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWFkQk1Gb250QmluYXJ5KGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA8IDYpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJ1ZmZlciBsZW5ndGggZm9yIEJNRm9udCcpXG5cbiAgdmFyIGhlYWRlciA9IEhFQURFUi5ldmVyeShmdW5jdGlvbihieXRlLCBpKSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkVUludDgoaSkgPT09IGJ5dGVcbiAgfSlcblxuICBpZiAoIWhlYWRlcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JNRm9udCBtaXNzaW5nIEJNRiBieXRlIGhlYWRlcicpXG5cbiAgdmFyIGkgPSAzXG4gIHZhciB2ZXJzID0gYnVmLnJlYWRVSW50OChpKyspXG4gIGlmICh2ZXJzID4gMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgc3VwcG9ydHMgQk1Gb250IEJpbmFyeSB2MyAoQk1Gb250IEFwcCB2MS4xMCknKVxuICBcbiAgdmFyIHRhcmdldCA9IHsga2VybmluZ3M6IFtdLCBjaGFyczogW10gfVxuICBmb3IgKHZhciBiPTA7IGI8NTsgYisrKVxuICAgIGkgKz0gcmVhZEJsb2NrKHRhcmdldCwgYnVmLCBpKVxuICByZXR1cm4gdGFyZ2V0XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9jayh0YXJnZXQsIGJ1ZiwgaSkge1xuICBpZiAoaSA+IGJ1Zi5sZW5ndGgtMSlcbiAgICByZXR1cm4gMFxuXG4gIHZhciBibG9ja0lEID0gYnVmLnJlYWRVSW50OChpKyspXG4gIHZhciBibG9ja1NpemUgPSBidWYucmVhZEludDMyTEUoaSlcbiAgaSArPSA0XG5cbiAgc3dpdGNoKGJsb2NrSUQpIHtcbiAgICBjYXNlIDE6IFxuICAgICAgdGFyZ2V0LmluZm8gPSByZWFkSW5mbyhidWYsIGkpXG4gICAgICBicmVha1xuICAgIGNhc2UgMjpcbiAgICAgIHRhcmdldC5jb21tb24gPSByZWFkQ29tbW9uKGJ1ZiwgaSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAzOlxuICAgICAgdGFyZ2V0LnBhZ2VzID0gcmVhZFBhZ2VzKGJ1ZiwgaSwgYmxvY2tTaXplKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDQ6XG4gICAgICB0YXJnZXQuY2hhcnMgPSByZWFkQ2hhcnMoYnVmLCBpLCBibG9ja1NpemUpXG4gICAgICBicmVha1xuICAgIGNhc2UgNTpcbiAgICAgIHRhcmdldC5rZXJuaW5ncyA9IHJlYWRLZXJuaW5ncyhidWYsIGksIGJsb2NrU2l6ZSlcbiAgICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIDUgKyBibG9ja1NpemVcbn1cblxuZnVuY3Rpb24gcmVhZEluZm8oYnVmLCBpKSB7XG4gIHZhciBpbmZvID0ge31cbiAgaW5mby5zaXplID0gYnVmLnJlYWRJbnQxNkxFKGkpXG5cbiAgdmFyIGJpdEZpZWxkID0gYnVmLnJlYWRVSW50OChpKzIpXG4gIGluZm8uc21vb3RoID0gKGJpdEZpZWxkID4+IDcpICYgMVxuICBpbmZvLnVuaWNvZGUgPSAoYml0RmllbGQgPj4gNikgJiAxXG4gIGluZm8uaXRhbGljID0gKGJpdEZpZWxkID4+IDUpICYgMVxuICBpbmZvLmJvbGQgPSAoYml0RmllbGQgPj4gNCkgJiAxXG4gIFxuICAvL2ZpeGVkSGVpZ2h0IGlzIG9ubHkgbWVudGlvbmVkIGluIGJpbmFyeSBzcGVjIFxuICBpZiAoKGJpdEZpZWxkID4+IDMpICYgMSlcbiAgICBpbmZvLmZpeGVkSGVpZ2h0ID0gMVxuICBcbiAgaW5mby5jaGFyc2V0ID0gYnVmLnJlYWRVSW50OChpKzMpIHx8ICcnXG4gIGluZm8uc3RyZXRjaEggPSBidWYucmVhZFVJbnQxNkxFKGkrNClcbiAgaW5mby5hYSA9IGJ1Zi5yZWFkVUludDgoaSs2KVxuICBpbmZvLnBhZGRpbmcgPSBbXG4gICAgYnVmLnJlYWRJbnQ4KGkrNyksXG4gICAgYnVmLnJlYWRJbnQ4KGkrOCksXG4gICAgYnVmLnJlYWRJbnQ4KGkrOSksXG4gICAgYnVmLnJlYWRJbnQ4KGkrMTApXG4gIF1cbiAgaW5mby5zcGFjaW5nID0gW1xuICAgIGJ1Zi5yZWFkSW50OChpKzExKSxcbiAgICBidWYucmVhZEludDgoaSsxMilcbiAgXVxuICBpbmZvLm91dGxpbmUgPSBidWYucmVhZFVJbnQ4KGkrMTMpXG4gIGluZm8uZmFjZSA9IHJlYWRTdHJpbmdOVChidWYsIGkrMTQpXG4gIHJldHVybiBpbmZvXG59XG5cbmZ1bmN0aW9uIHJlYWRDb21tb24oYnVmLCBpKSB7XG4gIHZhciBjb21tb24gPSB7fVxuICBjb21tb24ubGluZUhlaWdodCA9IGJ1Zi5yZWFkVUludDE2TEUoaSlcbiAgY29tbW9uLmJhc2UgPSBidWYucmVhZFVJbnQxNkxFKGkrMilcbiAgY29tbW9uLnNjYWxlVyA9IGJ1Zi5yZWFkVUludDE2TEUoaSs0KVxuICBjb21tb24uc2NhbGVIID0gYnVmLnJlYWRVSW50MTZMRShpKzYpXG4gIGNvbW1vbi5wYWdlcyA9IGJ1Zi5yZWFkVUludDE2TEUoaSs4KVxuICB2YXIgYml0RmllbGQgPSBidWYucmVhZFVJbnQ4KGkrMTApXG4gIGNvbW1vbi5wYWNrZWQgPSAwXG4gIGNvbW1vbi5hbHBoYUNobmwgPSBidWYucmVhZFVJbnQ4KGkrMTEpXG4gIGNvbW1vbi5yZWRDaG5sID0gYnVmLnJlYWRVSW50OChpKzEyKVxuICBjb21tb24uZ3JlZW5DaG5sID0gYnVmLnJlYWRVSW50OChpKzEzKVxuICBjb21tb24uYmx1ZUNobmwgPSBidWYucmVhZFVJbnQ4KGkrMTQpXG4gIHJldHVybiBjb21tb25cbn1cblxuZnVuY3Rpb24gcmVhZFBhZ2VzKGJ1ZiwgaSwgc2l6ZSkge1xuICB2YXIgcGFnZXMgPSBbXVxuICB2YXIgdGV4dCA9IHJlYWROYW1lTlQoYnVmLCBpKVxuICB2YXIgbGVuID0gdGV4dC5sZW5ndGgrMVxuICB2YXIgY291bnQgPSBzaXplIC8gbGVuXG4gIGZvciAodmFyIGM9MDsgYzxjb3VudDsgYysrKSB7XG4gICAgcGFnZXNbY10gPSBidWYuc2xpY2UoaSwgaSt0ZXh0Lmxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxuICAgIGkgKz0gbGVuXG4gIH1cbiAgcmV0dXJuIHBhZ2VzXG59XG5cbmZ1bmN0aW9uIHJlYWRDaGFycyhidWYsIGksIGJsb2NrU2l6ZSkge1xuICB2YXIgY2hhcnMgPSBbXVxuXG4gIHZhciBjb3VudCA9IGJsb2NrU2l6ZSAvIDIwXG4gIGZvciAodmFyIGM9MDsgYzxjb3VudDsgYysrKSB7XG4gICAgdmFyIGNoYXIgPSB7fVxuICAgIHZhciBvZmYgPSBjKjIwXG4gICAgY2hhci5pZCA9IGJ1Zi5yZWFkVUludDMyTEUoaSArIDAgKyBvZmYpXG4gICAgY2hhci54ID0gYnVmLnJlYWRVSW50MTZMRShpICsgNCArIG9mZilcbiAgICBjaGFyLnkgPSBidWYucmVhZFVJbnQxNkxFKGkgKyA2ICsgb2ZmKVxuICAgIGNoYXIud2lkdGggPSBidWYucmVhZFVJbnQxNkxFKGkgKyA4ICsgb2ZmKVxuICAgIGNoYXIuaGVpZ2h0ID0gYnVmLnJlYWRVSW50MTZMRShpICsgMTAgKyBvZmYpXG4gICAgY2hhci54b2Zmc2V0ID0gYnVmLnJlYWRJbnQxNkxFKGkgKyAxMiArIG9mZilcbiAgICBjaGFyLnlvZmZzZXQgPSBidWYucmVhZEludDE2TEUoaSArIDE0ICsgb2ZmKVxuICAgIGNoYXIueGFkdmFuY2UgPSBidWYucmVhZEludDE2TEUoaSArIDE2ICsgb2ZmKVxuICAgIGNoYXIucGFnZSA9IGJ1Zi5yZWFkVUludDgoaSArIDE4ICsgb2ZmKVxuICAgIGNoYXIuY2hubCA9IGJ1Zi5yZWFkVUludDgoaSArIDE5ICsgb2ZmKVxuICAgIGNoYXJzW2NdID0gY2hhclxuICB9XG4gIHJldHVybiBjaGFyc1xufVxuXG5mdW5jdGlvbiByZWFkS2VybmluZ3MoYnVmLCBpLCBibG9ja1NpemUpIHtcbiAgdmFyIGtlcm5pbmdzID0gW11cbiAgdmFyIGNvdW50ID0gYmxvY2tTaXplIC8gMTBcbiAgZm9yICh2YXIgYz0wOyBjPGNvdW50OyBjKyspIHtcbiAgICB2YXIga2VybiA9IHt9XG4gICAgdmFyIG9mZiA9IGMqMTBcbiAgICBrZXJuLmZpcnN0ID0gYnVmLnJlYWRVSW50MzJMRShpICsgMCArIG9mZilcbiAgICBrZXJuLnNlY29uZCA9IGJ1Zi5yZWFkVUludDMyTEUoaSArIDQgKyBvZmYpXG4gICAga2Vybi5hbW91bnQgPSBidWYucmVhZEludDE2TEUoaSArIDggKyBvZmYpXG4gICAga2VybmluZ3NbY10gPSBrZXJuXG4gIH1cbiAgcmV0dXJuIGtlcm5pbmdzXG59XG5cbmZ1bmN0aW9uIHJlYWROYW1lTlQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHBvcz1vZmZzZXRcbiAgZm9yICg7IHBvczxidWYubGVuZ3RoOyBwb3MrKykge1xuICAgIGlmIChidWZbcG9zXSA9PT0gMHgwMCkgXG4gICAgICBicmVha1xuICB9XG4gIHJldHVybiBidWYuc2xpY2Uob2Zmc2V0LCBwb3MpXG59XG5cbmZ1bmN0aW9uIHJlYWRTdHJpbmdOVChidWYsIG9mZnNldCkge1xuICByZXR1cm4gcmVhZE5hbWVOVChidWYsIG9mZnNldCkudG9TdHJpbmcoJ3V0ZjgnKVxufSIsInZhciB4bWwyanMgPSByZXF1aXJlKCd4bWwyanMnKVxudmFyIHBhcnNlQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vcGFyc2UtYXR0cmlicycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VCTUZvbnRYTUwoZGF0YSkge1xuICBkYXRhID0gZGF0YS50b1N0cmluZygpLnRyaW0oKVxuXG4gIHZhciBvdXRwdXQgPSB7XG4gICAgcGFnZXM6IFtdLFxuICAgIGNoYXJzOiBbXSxcbiAgICBrZXJuaW5nczogW11cbiAgfVxuXG4gIHhtbDJqcy5wYXJzZVN0cmluZyhkYXRhLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgIGlmIChlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICBpZiAoIXJlc3VsdC5mb250KVxuICAgICAgdGhyb3cgXCJYTUwgYml0bWFwIGZvbnQgZG9lc24ndCBoYXZlIDxmb250PiByb290XCJcbiAgICByZXN1bHQgPSByZXN1bHQuZm9udFxuXG4gICAgb3V0cHV0LmNvbW1vbiA9IHBhcnNlQXR0cmlidXRlcyhyZXN1bHQuY29tbW9uWzBdLiQpXG4gICAgb3V0cHV0LmluZm8gPSBwYXJzZUF0dHJpYnV0ZXMocmVzdWx0LmluZm9bMF0uJClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYWdlc1tpXS5wYWdlWzBdLiRcblxuICAgICAgaWYgKHR5cGVvZiBwLmlkID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYWxmb3JtZWQgZmlsZSAtLSBuZWVkcyBwYWdlIGlkPU5cIilcbiAgICAgIGlmICh0eXBlb2YgcC5maWxlICE9PSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYWxmb3JtZWQgZmlsZSAtLSBuZWVkcyBwYWdlIGZpbGU9XFxcInBhdGhcXFwiXCIpXG5cbiAgICAgIG91dHB1dC5wYWdlc1twYXJzZUludChwLmlkLCAxMCldID0gcC5maWxlXG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5jaGFycykge1xuICAgICAgdmFyIGNockFycmF5ID0gcmVzdWx0LmNoYXJzWzBdWydjaGFyJ10gfHwgW11cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hyQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0LmNoYXJzLnB1c2gocGFyc2VBdHRyaWJ1dGVzKGNockFycmF5W2ldLiQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQua2VybmluZ3MpIHtcbiAgICAgIHZhciBrZXJuQXJyYXkgPSByZXN1bHQua2VybmluZ3NbMF1bJ2tlcm5pbmcnXSB8fCBbXVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0Lmtlcm5pbmdzLnB1c2gocGFyc2VBdHRyaWJ1dGVzKGtlcm5BcnJheVtpXS4kKSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsIi8vU29tZSB2ZXJzaW9ucyBvZiBHbHlwaERlc2lnbmVyIGhhdmUgYSB0eXBvXG4vL3RoYXQgY2F1c2VzIHNvbWUgYnVncyB3aXRoIHBhcnNpbmcuIFxuLy9OZWVkIHRvIGNvbmZpcm0gd2l0aCByZWNlbnQgdmVyc2lvbiBvZiB0aGUgc29mdHdhcmVcbi8vdG8gc2VlIHdoZXRoZXIgdGhpcyBpcyBzdGlsbCBhbiBpc3N1ZSBvciBub3QuXG52YXIgR0xZUEhfREVTSUdORVJfRVJST1IgPSAnY2hhc3JzZXQnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKG9iaikge1xuICBpZiAoR0xZUEhfREVTSUdORVJfRVJST1IgaW4gb2JqKSB7XG4gICAgb2JqWydjaGFyc2V0J10gPSBvYmpbR0xZUEhfREVTSUdORVJfRVJST1JdXG4gICAgZGVsZXRlIG9ialtHTFlQSF9ERVNJR05FUl9FUlJPUl1cbiAgfVxuXG4gIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgaWYgKGsgPT09ICdmYWNlJyB8fCBrID09PSAnY2hhcnNldCcpIFxuICAgICAgY29udGludWVcbiAgICBlbHNlIGlmIChrID09PSAncGFkZGluZycgfHwgayA9PT0gJ3NwYWNpbmcnKVxuICAgICAgb2JqW2tdID0gcGFyc2VJbnRMaXN0KG9ialtrXSlcbiAgICBlbHNlXG4gICAgICBvYmpba10gPSBwYXJzZUludChvYmpba10sIDEwKSBcbiAgfVxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIHBhcnNlSW50TGlzdChkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKVxuICB9KVxufSIsIid1c2Ugc3RyaWN0Jzt2YXIgX3R5cGVvZj10eXBlb2YgU3ltYm9sPT09J2Z1bmN0aW9uJyYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PSdzeW1ib2wnP2Z1bmN0aW9uKG9iail7cmV0dXJuIHR5cGVvZiBvYmp9OmZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiYmdHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbicmJm9iai5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmb2JqIT09U3ltYm9sLnByb3RvdHlwZT8nc3ltYm9sJzp0eXBlb2Ygb2JqfTt2YXIgaHR0cD1yZXF1aXJlKCdodHRwJyk7dmFyIGh0dHBzPXJlcXVpcmUoJ2h0dHBzJyk7dmFyIHVybD1yZXF1aXJlKCd1cmwnKTt2YXIgcXM9cmVxdWlyZSgncXVlcnlzdHJpbmcnKTt2YXIgemxpYj1yZXF1aXJlKCd6bGliJyk7dmFyIHV0aWw9cmVxdWlyZSgndXRpbCcpO3ZhciBwaGluPWZ1bmN0aW9uIHBoaW4ob3B0cyxjYil7aWYodHlwZW9mIG9wdHMhPT0nc3RyaW5nJyl7aWYoIW9wdHMuaGFzT3duUHJvcGVydHkoJ3VybCcpKXt0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdXJsIG9wdGlvbiBmcm9tIG9wdGlvbnMgZm9yIHJlcXVlc3QgbWV0aG9kLicpfX12YXIgYWRkcj0odHlwZW9mIG9wdHM9PT0ndW5kZWZpbmVkJz8ndW5kZWZpbmVkJzpfdHlwZW9mKG9wdHMpKT09PSdvYmplY3QnP3VybC5wYXJzZShvcHRzLnVybCk6dXJsLnBhcnNlKG9wdHMpO3ZhciBvcHRpb25zPXsnaG9zdG5hbWUnOmFkZHIuaG9zdG5hbWUsJ3BvcnQnOmFkZHIucG9ydHx8KGFkZHIucHJvdG9jb2wudG9Mb3dlckNhc2UoKT09PSdodHRwOic/ODA6NDQzKSwncGF0aCc6YWRkci5wYXRoLCdtZXRob2QnOidHRVQnLCdoZWFkZXJzJzp7fSwnYXV0aCc6YWRkci5hdXRofHxudWxsLCdwYXJzZSc6J25vbmUnLCdzdHJlYW0nOmZhbHNlfTtpZigodHlwZW9mIG9wdHM9PT0ndW5kZWZpbmVkJz8ndW5kZWZpbmVkJzpfdHlwZW9mKG9wdHMpKT09PSdvYmplY3QnKXtvcHRpb25zPU9iamVjdC5hc3NpZ24ob3B0aW9ucyxvcHRzKX1vcHRpb25zLnBvcnQ9TnVtYmVyKG9wdGlvbnMucG9ydCk7aWYob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndGltZW91dCcpKWRlbGV0ZSBvcHRpb25zLnRpbWVvdXQ7aWYob3B0aW9ucy5jb21wcmVzc2VkPT09dHJ1ZSl7b3B0aW9ucy5oZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXT0nZ3ppcCwgZGVmbGF0ZSd9aWYob3B0cy5oYXNPd25Qcm9wZXJ0eSgnZm9ybScpKXtpZihfdHlwZW9mKG9wdHMuZm9ybSkhPT0nb2JqZWN0Jyl7dGhyb3cgbmV3IEVycm9yKCdwaGluIFxcJ2Zvcm1cXCcgb3B0aW9uIG11c3QgYmUgb2YgdHlwZSBPYmplY3QgaWYgcHJlc2VudC4nKX12YXIgZm9ybURhdGFTdHJpbmc9cXMuc3RyaW5naWZ5KG9wdHMuZm9ybSk7b3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXT0nYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ109QnVmZmVyLmJ5dGVMZW5ndGgoZm9ybURhdGFTdHJpbmcpO29wdHMuZGF0YT1mb3JtRGF0YVN0cmluZ312YXIgcmVxPXZvaWQgMDt2YXIgcmVzSGFuZGxlcj1mdW5jdGlvbiByZXNIYW5kbGVyKHJlcyl7dmFyIHN0cmVhbT1yZXM7aWYob3B0aW9ucy5jb21wcmVzc2VkPT09dHJ1ZSl7aWYocmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXT09PSdnemlwJyl7c3RyZWFtPXJlcy5waXBlKHpsaWIuY3JlYXRlR3VuemlwKCkpfWVsc2UgaWYocmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXT09PSdkZWZsYXRlJyl7c3RyZWFtPXJlcy5waXBlKHpsaWIuY3JlYXRlSW5mbGF0ZSgpKX19aWYob3B0aW9ucy5zdHJlYW09PT10cnVlKXtyZXMuc3RyZWFtPXN0cmVhbTtpZihjYiljYihudWxsLHJlcyl9ZWxzZXtyZXMuYm9keT1uZXcgQnVmZmVyKFtdKTtzdHJlYW0ub24oJ2RhdGEnLGZ1bmN0aW9uKGNodW5rKXtyZXMuYm9keT1CdWZmZXIuY29uY2F0KFtyZXMuYm9keSxjaHVua10pfSk7c3RyZWFtLm9uKCdlbmQnLGZ1bmN0aW9uKCl7aWYoY2Ipe2lmKG9wdGlvbnMucGFyc2U9PT0nanNvbicpe3RyeXtyZXMuYm9keT1KU09OLnBhcnNlKHJlcy5ib2R5LnRvU3RyaW5nKCkpfWNhdGNoKGVycil7Y2IoJ0ludmFsaWQgSlNPTiByZWNlaXZlZC4nLHJlcyk7cmV0dXJufX1jYihudWxsLHJlcyl9fSl9fTtzd2l0Y2goYWRkci5wcm90b2NvbC50b0xvd2VyQ2FzZSgpKXtjYXNlJ2h0dHA6JzpyZXE9aHR0cC5yZXF1ZXN0KG9wdGlvbnMscmVzSGFuZGxlcik7YnJlYWs7Y2FzZSdodHRwczonOnJlcT1odHRwcy5yZXF1ZXN0KG9wdGlvbnMscmVzSGFuZGxlcik7YnJlYWs7ZGVmYXVsdDppZihjYiljYihuZXcgRXJyb3IoJ0ludmFsaWQgLyB1bmtub3duIFVSTCBwcm90b2NvbC4gRXhwZWN0ZWQgSFRUUCBvciBIVFRQUy4nKSxudWxsKTtyZXR1cm47fWlmKHR5cGVvZiBvcHRzLnRpbWVvdXQ9PT0nbnVtYmVyJyl7cmVxLnNldFRpbWVvdXQob3B0cy50aW1lb3V0LGZ1bmN0aW9uKCl7cmVxLmFib3J0KCk7aWYoY2IpY2IobmV3IEVycm9yKCdUaW1lb3V0IGhhcyBiZWVuIHJlYWNoZWQuJyksbnVsbCk7Y2I9bnVsbH0pfXJlcS5vbignZXJyb3InLGZ1bmN0aW9uKGVycil7aWYoY2IpY2IoZXJyLG51bGwpfSk7aWYob3B0cy5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKXt2YXIgcG9zdERhdGE9b3B0cy5kYXRhO2lmKCEob3B0cy5kYXRhIGluc3RhbmNlb2YgQnVmZmVyKSYmX3R5cGVvZihvcHRzLmRhdGEpPT09J29iamVjdCcpe3ZhciBjb250ZW50VHlwZT1vcHRpb25zLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddfHxvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO2lmKGNvbnRlbnRUeXBlPT09J2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpe3Bvc3REYXRhPXFzLnN0cmluZ2lmeShvcHRzLmRhdGEpfWVsc2V7dHJ5e3Bvc3REYXRhPUpTT04uc3RyaW5naWZ5KG9wdHMuZGF0YSl9Y2F0Y2goZXJyKXtpZihjYiljYihuZXcgRXJyb3IoJ0NvdWxkblxcJ3Qgc3RyaW5naWZ5IG9iamVjdC4gKExpa2VseSBkdWUgdG8gYSBjaXJjdWxhciByZWZlcmVuY2UuKScpLG51bGwpfX19cmVxLndyaXRlKHBvc3REYXRhKX1yZXEuZW5kKCl9O3BoaW4ucHJvbWlzaWZpZWQ9ZnVuY3Rpb24ob3B0cyxodHRwKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe3BoaW4ob3B0cyxmdW5jdGlvbihlcnIscmVzKXtpZihlcnIpe3JlamVjdChlcnIpfWVsc2V7cmVzb2x2ZShyZXMpfX0saHR0cCl9KX07aWYodXRpbC5wcm9taXNpZnkpe3BoaW5bdXRpbC5wcm9taXNpZnkuY3VzdG9tXT1waGluLnByb21pc2lmaWVkfW1vZHVsZS5leHBvcnRzPXBoaW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGl4ZWxtYXRjaDtcblxuZnVuY3Rpb24gcGl4ZWxtYXRjaChpbWcxLCBpbWcyLCBvdXRwdXQsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gICAgdmFyIHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkID09PSB1bmRlZmluZWQgPyAwLjEgOiBvcHRpb25zLnRocmVzaG9sZDtcblxuICAgIC8vIG1heGltdW0gYWNjZXB0YWJsZSBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiB0d28gY29sb3JzO1xuICAgIC8vIDM1MjE1IGlzIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIGZvciB0aGUgWUlRIGRpZmZlcmVuY2UgbWV0cmljXG4gICAgdmFyIG1heERlbHRhID0gMzUyMTUgKiB0aHJlc2hvbGQgKiB0aHJlc2hvbGQsXG4gICAgICAgIGRpZmYgPSAwO1xuXG4gICAgLy8gY29tcGFyZSBlYWNoIHBpeGVsIG9mIG9uZSBpbWFnZSBhZ2FpbnN0IHRoZSBvdGhlciBvbmVcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuXG4gICAgICAgICAgICB2YXIgcG9zID0gKHkgKiB3aWR0aCArIHgpICogNDtcblxuICAgICAgICAgICAgLy8gc3F1YXJlZCBZVVYgZGlzdGFuY2UgYmV0d2VlbiBjb2xvcnMgYXQgdGhpcyBwaXhlbCBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGRlbHRhID0gY29sb3JEZWx0YShpbWcxLCBpbWcyLCBwb3MsIHBvcyk7XG5cbiAgICAgICAgICAgIC8vIHRoZSBjb2xvciBkaWZmZXJlbmNlIGlzIGFib3ZlIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IG1heERlbHRhKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaXQncyBhIHJlYWwgcmVuZGVyaW5nIGRpZmZlcmVuY2Ugb3IganVzdCBhbnRpLWFsaWFzaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmluY2x1ZGVBQSAmJiAoYW50aWFsaWFzZWQoaW1nMSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgaW1nMikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWFsaWFzZWQoaW1nMiwgeCwgeSwgd2lkdGgsIGhlaWdodCwgaW1nMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uZSBvZiB0aGUgcGl4ZWxzIGlzIGFudGktYWxpYXNpbmc7IGRyYXcgYXMgeWVsbG93IGFuZCBkbyBub3QgY291bnQgYXMgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0KSBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIDI1NSwgMjU1LCAwKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIHN1YnN0YW50aWFsIGRpZmZlcmVuY2Ugbm90IGNhdXNlZCBieSBhbnRpLWFsaWFzaW5nOyBkcmF3IGl0IGFzIHJlZFxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0KSBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIDI1NSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gcGl4ZWxzIGFyZSBzaW1pbGFyOyBkcmF3IGJhY2tncm91bmQgYXMgZ3JheXNjYWxlIGltYWdlIGJsZW5kZWQgd2l0aCB3aGl0ZVxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBibGVuZChncmF5UGl4ZWwoaW1nMSwgcG9zKSwgMC4xKTtcbiAgICAgICAgICAgICAgICBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIHZhbCwgdmFsLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW50IHBpeGVsc1xuICAgIHJldHVybiBkaWZmO1xufVxuXG4vLyBjaGVjayBpZiBhIHBpeGVsIGlzIGxpa2VseSBhIHBhcnQgb2YgYW50aS1hbGlhc2luZztcbi8vIGJhc2VkIG9uIFwiQW50aS1hbGlhc2VkIFBpeGVsIGFuZCBJbnRlbnNpdHkgU2xvcGUgRGV0ZWN0b3JcIiBwYXBlciBieSBWLiBWeXNuaWF1c2thcywgMjAwOVxuXG5mdW5jdGlvbiBhbnRpYWxpYXNlZChpbWcsIHgxLCB5MSwgd2lkdGgsIGhlaWdodCwgaW1nMikge1xuICAgIHZhciB4MCA9IE1hdGgubWF4KHgxIC0gMSwgMCksXG4gICAgICAgIHkwID0gTWF0aC5tYXgoeTEgLSAxLCAwKSxcbiAgICAgICAgeDIgPSBNYXRoLm1pbih4MSArIDEsIHdpZHRoIC0gMSksXG4gICAgICAgIHkyID0gTWF0aC5taW4oeTEgKyAxLCBoZWlnaHQgLSAxKSxcbiAgICAgICAgcG9zID0gKHkxICogd2lkdGggKyB4MSkgKiA0LFxuICAgICAgICB6ZXJvZXMgPSAwLFxuICAgICAgICBwb3NpdGl2ZXMgPSAwLFxuICAgICAgICBuZWdhdGl2ZXMgPSAwLFxuICAgICAgICBtaW4gPSAwLFxuICAgICAgICBtYXggPSAwLFxuICAgICAgICBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuXG4gICAgLy8gZ28gdGhyb3VnaCA4IGFkamFjZW50IHBpeGVsc1xuICAgIGZvciAodmFyIHggPSB4MDsgeCA8PSB4MjsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSB5MDsgeSA8PSB5MjsgeSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0geDEgJiYgeSA9PT0geTEpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBicmlnaHRuZXNzIGRlbHRhIGJldHdlZW4gdGhlIGNlbnRlciBwaXhlbCBhbmQgYWRqYWNlbnQgb25lXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBjb2xvckRlbHRhKGltZywgaW1nLCBwb3MsICh5ICogd2lkdGggKyB4KSAqIDQsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIGVxdWFsLCBkYXJrZXIgYW5kIGJyaWdodGVyIGFkamFjZW50IHBpeGVsc1xuICAgICAgICAgICAgaWYgKGRlbHRhID09PSAwKSB6ZXJvZXMrKztcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkgbmVnYXRpdmVzKys7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YSA+IDApIHBvc2l0aXZlcysrO1xuXG4gICAgICAgICAgICAvLyBpZiBmb3VuZCBtb3JlIHRoYW4gMiBlcXVhbCBzaWJsaW5ncywgaXQncyBkZWZpbml0ZWx5IG5vdCBhbnRpLWFsaWFzaW5nXG4gICAgICAgICAgICBpZiAoemVyb2VzID4gMikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIWltZzIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgZGFya2VzdCBwaXhlbFxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgYnJpZ2h0ZXN0IHBpeGVsXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBtYXhYID0geDtcbiAgICAgICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW1nMikgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gYm90aCBkYXJrZXIgYW5kIGJyaWdodGVyIHBpeGVscyBhbW9uZyBzaWJsaW5ncywgaXQncyBub3QgYW50aS1hbGlhc2luZ1xuICAgIGlmIChuZWdhdGl2ZXMgPT09IDAgfHwgcG9zaXRpdmVzID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBpZiBlaXRoZXIgdGhlIGRhcmtlc3Qgb3IgdGhlIGJyaWdodGVzdCBwaXhlbCBoYXMgbW9yZSB0aGFuIDIgZXF1YWwgc2libGluZ3MgaW4gYm90aCBpbWFnZXNcbiAgICAvLyAoZGVmaW5pdGVseSBub3QgYW50aS1hbGlhc2VkKSwgdGhpcyBwaXhlbCBpcyBhbnRpLWFsaWFzZWRcbiAgICByZXR1cm4gKCFhbnRpYWxpYXNlZChpbWcsIG1pblgsIG1pblksIHdpZHRoLCBoZWlnaHQpICYmICFhbnRpYWxpYXNlZChpbWcyLCBtaW5YLCBtaW5ZLCB3aWR0aCwgaGVpZ2h0KSkgfHxcbiAgICAgICAgICAgKCFhbnRpYWxpYXNlZChpbWcsIG1heFgsIG1heFksIHdpZHRoLCBoZWlnaHQpICYmICFhbnRpYWxpYXNlZChpbWcyLCBtYXhYLCBtYXhZLCB3aWR0aCwgaGVpZ2h0KSk7XG59XG5cbi8vIGNhbGN1bGF0ZSBjb2xvciBkaWZmZXJlbmNlIGFjY29yZGluZyB0byB0aGUgcGFwZXIgXCJNZWFzdXJpbmcgcGVyY2VpdmVkIGNvbG9yIGRpZmZlcmVuY2Vcbi8vIHVzaW5nIFlJUSBOVFNDIHRyYW5zbWlzc2lvbiBjb2xvciBzcGFjZSBpbiBtb2JpbGUgYXBwbGljYXRpb25zXCIgYnkgWS4gS290c2FyZW5rbyBhbmQgRi4gUmFtb3NcblxuZnVuY3Rpb24gY29sb3JEZWx0YShpbWcxLCBpbWcyLCBrLCBtLCB5T25seSkge1xuICAgIHZhciBhMSA9IGltZzFbayArIDNdIC8gMjU1LFxuICAgICAgICBhMiA9IGltZzJbbSArIDNdIC8gMjU1LFxuXG4gICAgICAgIHIxID0gYmxlbmQoaW1nMVtrICsgMF0sIGExKSxcbiAgICAgICAgZzEgPSBibGVuZChpbWcxW2sgKyAxXSwgYTEpLFxuICAgICAgICBiMSA9IGJsZW5kKGltZzFbayArIDJdLCBhMSksXG5cbiAgICAgICAgcjIgPSBibGVuZChpbWcyW20gKyAwXSwgYTIpLFxuICAgICAgICBnMiA9IGJsZW5kKGltZzJbbSArIDFdLCBhMiksXG4gICAgICAgIGIyID0gYmxlbmQoaW1nMlttICsgMl0sIGEyKSxcblxuICAgICAgICB5ID0gcmdiMnkocjEsIGcxLCBiMSkgLSByZ2IyeShyMiwgZzIsIGIyKTtcblxuICAgIGlmICh5T25seSkgcmV0dXJuIHk7IC8vIGJyaWdodG5lc3MgZGlmZmVyZW5jZSBvbmx5XG5cbiAgICB2YXIgaSA9IHJnYjJpKHIxLCBnMSwgYjEpIC0gcmdiMmkocjIsIGcyLCBiMiksXG4gICAgICAgIHEgPSByZ2IycShyMSwgZzEsIGIxKSAtIHJnYjJxKHIyLCBnMiwgYjIpO1xuXG4gICAgcmV0dXJuIDAuNTA1MyAqIHkgKiB5ICsgMC4yOTkgKiBpICogaSArIDAuMTk1NyAqIHEgKiBxO1xufVxuXG5mdW5jdGlvbiByZ2IyeShyLCBnLCBiKSB7IHJldHVybiByICogMC4yOTg4OTUzMSArIGcgKiAwLjU4NjYyMjQ3ICsgYiAqIDAuMTE0NDgyMjM7IH1cbmZ1bmN0aW9uIHJnYjJpKHIsIGcsIGIpIHsgcmV0dXJuIHIgKiAwLjU5NTk3Nzk5IC0gZyAqIDAuMjc0MTc2MTAgLSBiICogMC4zMjE4MDE4OTsgfVxuZnVuY3Rpb24gcmdiMnEociwgZywgYikgeyByZXR1cm4gciAqIDAuMjExNDcwMTcgLSBnICogMC41MjI2MTcxMSArIGIgKiAwLjMxMTE0Njk0OyB9XG5cbi8vIGJsZW5kIHNlbWktdHJhbnNwYXJlbnQgY29sb3Igd2l0aCB3aGl0ZVxuZnVuY3Rpb24gYmxlbmQoYywgYSkge1xuICAgIHJldHVybiAyNTUgKyAoYyAtIDI1NSkgKiBhO1xufVxuXG5mdW5jdGlvbiBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIHIsIGcsIGIpIHtcbiAgICBvdXRwdXRbcG9zICsgMF0gPSByO1xuICAgIG91dHB1dFtwb3MgKyAxXSA9IGc7XG4gICAgb3V0cHV0W3BvcyArIDJdID0gYjtcbiAgICBvdXRwdXRbcG9zICsgM10gPSAyNTU7XG59XG5cbmZ1bmN0aW9uIGdyYXlQaXhlbChpbWcsIGkpIHtcbiAgICB2YXIgYSA9IGltZ1tpICsgM10gLyAyNTUsXG4gICAgICAgIHIgPSBibGVuZChpbWdbaSArIDBdLCBhKSxcbiAgICAgICAgZyA9IGJsZW5kKGltZ1tpICsgMV0sIGEpLFxuICAgICAgICBiID0gYmxlbmQoaW1nW2kgKyAyXSwgYSk7XG4gICAgcmV0dXJuIHJnYjJ5KHIsIGcsIGIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50ZXJsYWNlVXRpbHMgPSByZXF1aXJlKCcuL2ludGVybGFjZScpO1xuXG52YXIgcGl4ZWxCcHBNYXAgPSB7XG4gIDE6IHsgLy8gTFxuICAgIDA6IDAsXG4gICAgMTogMCxcbiAgICAyOiAwLFxuICAgIDM6IDB4ZmZcbiAgfSxcbiAgMjogeyAvLyBMQVxuICAgIDA6IDAsXG4gICAgMTogMCxcbiAgICAyOiAwLFxuICAgIDM6IDFcbiAgfSxcbiAgMzogeyAvLyBSR0JcbiAgICAwOiAwLFxuICAgIDE6IDEsXG4gICAgMjogMixcbiAgICAzOiAweGZmXG4gIH0sXG4gIDQ6IHsgLy8gUkdCQVxuICAgIDA6IDAsXG4gICAgMTogMSxcbiAgICAyOiAyLFxuICAgIDM6IDNcbiAgfVxufTtcblxuZnVuY3Rpb24gYml0UmV0cmlldmVyKGRhdGEsIGRlcHRoKSB7XG5cbiAgdmFyIGxlZnRPdmVyID0gW107XG4gIHZhciBpID0gMDtcblxuICBmdW5jdGlvbiBzcGxpdCgpIHtcbiAgICBpZiAoaSA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmFuIG91dCBvZiBkYXRhJyk7XG4gICAgfVxuICAgIHZhciBieXRlID0gZGF0YVtpXTtcbiAgICBpKys7XG4gICAgdmFyIGJ5dGU4LCBieXRlNywgYnl0ZTYsIGJ5dGU1LCBieXRlNCwgYnl0ZTMsIGJ5dGUyLCBieXRlMTtcbiAgICBzd2l0Y2ggKGRlcHRoKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXNlZCBkZXB0aCcpO1xuICAgICAgY2FzZSAxNjpcbiAgICAgICAgYnl0ZTIgPSBkYXRhW2ldO1xuICAgICAgICBpKys7XG4gICAgICAgIGxlZnRPdmVyLnB1c2goKChieXRlIDw8IDgpICsgYnl0ZTIpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGJ5dGUyID0gYnl0ZSAmIDB4MGY7XG4gICAgICAgIGJ5dGUxID0gYnl0ZSA+PiA0O1xuICAgICAgICBsZWZ0T3Zlci5wdXNoKGJ5dGUxLCBieXRlMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBieXRlNCA9IGJ5dGUgJiAzO1xuICAgICAgICBieXRlMyA9IGJ5dGUgPj4gMiAmIDM7XG4gICAgICAgIGJ5dGUyID0gYnl0ZSA+PiA0ICYgMztcbiAgICAgICAgYnl0ZTEgPSBieXRlID4+IDYgJiAzO1xuICAgICAgICBsZWZ0T3Zlci5wdXNoKGJ5dGUxLCBieXRlMiwgYnl0ZTMsIGJ5dGU0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGJ5dGU4ID0gYnl0ZSAmIDE7XG4gICAgICAgIGJ5dGU3ID0gYnl0ZSA+PiAxICYgMTtcbiAgICAgICAgYnl0ZTYgPSBieXRlID4+IDIgJiAxO1xuICAgICAgICBieXRlNSA9IGJ5dGUgPj4gMyAmIDE7XG4gICAgICAgIGJ5dGU0ID0gYnl0ZSA+PiA0ICYgMTtcbiAgICAgICAgYnl0ZTMgPSBieXRlID4+IDUgJiAxO1xuICAgICAgICBieXRlMiA9IGJ5dGUgPj4gNiAmIDE7XG4gICAgICAgIGJ5dGUxID0gYnl0ZSA+PiA3ICYgMTtcbiAgICAgICAgbGVmdE92ZXIucHVzaChieXRlMSwgYnl0ZTIsIGJ5dGUzLCBieXRlNCwgYnl0ZTUsIGJ5dGU2LCBieXRlNywgYnl0ZTgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHdoaWxlIChsZWZ0T3Zlci5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBzcGxpdCgpO1xuICAgICAgfVxuICAgICAgdmFyIHJldHVybmVyID0gbGVmdE92ZXIuc2xpY2UoMCwgY291bnQpO1xuICAgICAgbGVmdE92ZXIgPSBsZWZ0T3Zlci5zbGljZShjb3VudCk7XG4gICAgICByZXR1cm4gcmV0dXJuZXI7XG4gICAgfSxcbiAgICByZXNldEFmdGVyTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICBsZWZ0T3Zlci5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dHJhIGRhdGEgZm91bmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcEltYWdlOEJpdChpbWFnZSwgcHhEYXRhLCBnZXRQeFBvcywgYnBwLCBkYXRhLCByYXdQb3MpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtcGFyYW1zXG4gIHZhciBpbWFnZVdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gIHZhciBpbWFnZUhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgdmFyIGltYWdlUGFzcyA9IGltYWdlLmluZGV4O1xuICBmb3IgKHZhciB5ID0gMDsgeSA8IGltYWdlSGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGltYWdlV2lkdGg7IHgrKykge1xuICAgICAgdmFyIHB4UG9zID0gZ2V0UHhQb3MoeCwgeSwgaW1hZ2VQYXNzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgdmFyIGlkeCA9IHBpeGVsQnBwTWFwW2JwcF1baV07XG4gICAgICAgIGlmIChpZHggPT09IDB4ZmYpIHtcbiAgICAgICAgICBweERhdGFbcHhQb3MgKyBpXSA9IDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRhdGFQb3MgPSBpZHggKyByYXdQb3M7XG4gICAgICAgICAgaWYgKGRhdGFQb3MgPT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhbiBvdXQgb2YgZGF0YScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBweERhdGFbcHhQb3MgKyBpXSA9IGRhdGFbZGF0YVBvc107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJhd1BvcyArPSBicHA7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3UG9zO1xufVxuXG5mdW5jdGlvbiBtYXBJbWFnZUN1c3RvbUJpdChpbWFnZSwgcHhEYXRhLCBnZXRQeFBvcywgYnBwLCBiaXRzLCBtYXhCaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtcGFyYW1zXG4gIHZhciBpbWFnZVdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gIHZhciBpbWFnZUhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgdmFyIGltYWdlUGFzcyA9IGltYWdlLmluZGV4O1xuICBmb3IgKHZhciB5ID0gMDsgeSA8IGltYWdlSGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGltYWdlV2lkdGg7IHgrKykge1xuICAgICAgdmFyIHBpeGVsRGF0YSA9IGJpdHMuZ2V0KGJwcCk7XG4gICAgICB2YXIgcHhQb3MgPSBnZXRQeFBvcyh4LCB5LCBpbWFnZVBhc3MpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB2YXIgaWR4ID0gcGl4ZWxCcHBNYXBbYnBwXVtpXTtcbiAgICAgICAgcHhEYXRhW3B4UG9zICsgaV0gPSBpZHggIT09IDB4ZmYgPyBwaXhlbERhdGFbaWR4XSA6IG1heEJpdDtcbiAgICAgIH1cbiAgICB9XG4gICAgYml0cy5yZXNldEFmdGVyTGluZSgpO1xuICB9XG59XG5cbmV4cG9ydHMuZGF0YVRvQml0TWFwID0gZnVuY3Rpb24oZGF0YSwgYml0bWFwSW5mbykge1xuXG4gIHZhciB3aWR0aCA9IGJpdG1hcEluZm8ud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBiaXRtYXBJbmZvLmhlaWdodDtcbiAgdmFyIGRlcHRoID0gYml0bWFwSW5mby5kZXB0aDtcbiAgdmFyIGJwcCA9IGJpdG1hcEluZm8uYnBwO1xuICB2YXIgaW50ZXJsYWNlID0gYml0bWFwSW5mby5pbnRlcmxhY2U7XG5cbiAgaWYgKGRlcHRoICE9PSA4KSB7XG4gICAgdmFyIGJpdHMgPSBiaXRSZXRyaWV2ZXIoZGF0YSwgZGVwdGgpO1xuICB9XG4gIHZhciBweERhdGE7XG4gIGlmIChkZXB0aCA8PSA4KSB7XG4gICAgcHhEYXRhID0gbmV3IEJ1ZmZlcih3aWR0aCAqIGhlaWdodCAqIDQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHB4RGF0YSA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICB9XG4gIHZhciBtYXhCaXQgPSBNYXRoLnBvdygyLCBkZXB0aCkgLSAxO1xuICB2YXIgcmF3UG9zID0gMDtcbiAgdmFyIGltYWdlcztcbiAgdmFyIGdldFB4UG9zO1xuXG4gIGlmIChpbnRlcmxhY2UpIHtcbiAgICBpbWFnZXMgPSBpbnRlcmxhY2VVdGlscy5nZXRJbWFnZVBhc3Nlcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBnZXRQeFBvcyA9IGludGVybGFjZVV0aWxzLmdldEludGVybGFjZUl0ZXJhdG9yKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBub25JbnRlcmxhY2VkUHhQb3MgPSAwO1xuICAgIGdldFB4UG9zID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmV0dXJuZXIgPSBub25JbnRlcmxhY2VkUHhQb3M7XG4gICAgICBub25JbnRlcmxhY2VkUHhQb3MgKz0gNDtcbiAgICAgIHJldHVybiByZXR1cm5lcjtcbiAgICB9O1xuICAgIGltYWdlcyA9IFt7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfV07XG4gIH1cblxuICBmb3IgKHZhciBpbWFnZUluZGV4ID0gMDsgaW1hZ2VJbmRleCA8IGltYWdlcy5sZW5ndGg7IGltYWdlSW5kZXgrKykge1xuICAgIGlmIChkZXB0aCA9PT0gOCkge1xuICAgICAgcmF3UG9zID0gbWFwSW1hZ2U4Qml0KGltYWdlc1tpbWFnZUluZGV4XSwgcHhEYXRhLCBnZXRQeFBvcywgYnBwLCBkYXRhLCByYXdQb3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG1hcEltYWdlQ3VzdG9tQml0KGltYWdlc1tpbWFnZUluZGV4XSwgcHhEYXRhLCBnZXRQeFBvcywgYnBwLCBiaXRzLCBtYXhCaXQpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVwdGggPT09IDgpIHtcbiAgICBpZiAocmF3UG9zICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRyYSBkYXRhIGZvdW5kJyk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGJpdHMuZW5kKCk7XG4gIH1cblxuICByZXR1cm4gcHhEYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YUluLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gIHZhciBvdXRIYXNBbHBoYSA9IFtjb25zdGFudHMuQ09MT1JUWVBFX0NPTE9SX0FMUEhBLCBjb25zdGFudHMuQ09MT1JUWVBFX0FMUEhBXS5pbmRleE9mKG9wdGlvbnMuY29sb3JUeXBlKSAhPT0gLTE7XG4gIGlmIChvcHRpb25zLmNvbG9yVHlwZSA9PT0gb3B0aW9ucy5pbnB1dENvbG9yVHlwZSkge1xuICAgIHZhciBiaWdFbmRpYW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDIpO1xuICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlIC8qIGxpdHRsZUVuZGlhbiAqLyk7XG4gICAgICAvLyBJbnQxNkFycmF5IHVzZXMgdGhlIHBsYXRmb3JtJ3MgZW5kaWFubmVzcy5cbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpWzBdICE9PSAyNTY7XG4gICAgfSkoKTtcbiAgICAvLyBJZiBubyBuZWVkIHRvIGNvbnZlcnQgdG8gZ3JheXNjYWxlIGFuZCBhbHBoYSBpcyBwcmVzZW50L2Fic2VudCBpbiBib3RoLCB0YWtlIGEgZmFzdCByb3V0ZVxuICAgICBpZiAob3B0aW9ucy5iaXREZXB0aCA9PT0gOCB8fCAob3B0aW9ucy5iaXREZXB0aCA9PT0gMTYgJiYgYmlnRW5kaWFuKSl7XG4gICAgICAgICByZXR1cm4gZGF0YUluO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1hcCB0byBhIFVJbnQxNiBhcnJheSBpZiBkYXRhIGlzIDE2Yml0LCBmaXggZW5kaWFubmVzcyBiZWxvd1xuICB2YXIgZGF0YSA9IG9wdGlvbnMuYml0RGVwdGggIT09IDE2ID8gZGF0YUluIDogbmV3IFVpbnQxNkFycmF5KGRhdGFJbi5idWZmZXIpO1xuXG4gIHZhciBtYXhWYWx1ZSA9IDI1NTtcbiAgdmFyIGluQnBwID0gY29uc3RhbnRzLkNPTE9SVFlQRV9UT19CUFBfTUFQW29wdGlvbnMuaW5wdXRDb2xvclR5cGVdO1xuICBpZiAoaW5CcHAgPT0gNCAmJiAhb3B0aW9ucy5pbnB1dEhhc0FscGhhKSBpbkJwcCA9IDM7XG4gIHZhciBvdXRCcHAgPSBjb25zdGFudHMuQ09MT1JUWVBFX1RPX0JQUF9NQVBbb3B0aW9ucy5jb2xvclR5cGVdO1xuICBpZiAob3B0aW9ucy5iaXREZXB0aCA9PT0gMTYpIHtcbiAgICBtYXhWYWx1ZSA9IDY1NTM1O1xuICAgIG91dEJwcCAqPSAyO1xuICB9XG4gIHZhciBvdXREYXRhID0gbmV3IEJ1ZmZlcih3aWR0aCAqIGhlaWdodCAqIG91dEJwcCk7XG5cbiAgdmFyIGluSW5kZXggPSAwO1xuICB2YXIgb3V0SW5kZXggPSAwO1xuXG4gIHZhciBiZ0NvbG9yID0gb3B0aW9ucy5iZ0NvbG9yIHx8IHt9O1xuICBpZiAoYmdDb2xvci5yZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIGJnQ29sb3IucmVkID0gbWF4VmFsdWU7XG4gIH1cbiAgaWYgKGJnQ29sb3IuZ3JlZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIGJnQ29sb3IuZ3JlZW4gPSBtYXhWYWx1ZTtcbiAgfVxuICBpZiAoYmdDb2xvci5ibHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBiZ0NvbG9yLmJsdWUgPSBtYXhWYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJHQkEoZGF0YSwgaW5JbmRleCkge1xuICAgIHZhciByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSA9IG1heFZhbHVlO1xuICAgIHN3aXRjaCAob3B0aW9ucy5pbnB1dENvbG9yVHlwZSkge1xuICAgICAgY2FzZSBjb25zdGFudHMuQ09MT1JUWVBFX0NPTE9SX0FMUEhBOlxuICAgICAgICBhbHBoYSA9IGRhdGFbaW5JbmRleCArIDNdO1xuICAgICAgICByZWQgPSBkYXRhW2luSW5kZXhdO1xuICAgICAgICBncmVlbiA9IGRhdGFbaW5JbmRleCsxXTtcbiAgICAgICAgYmx1ZSA9IGRhdGFbaW5JbmRleCsyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGNvbnN0YW50cy5DT0xPUlRZUEVfQ09MT1I6XG4gICAgICAgIHJlZCA9IGRhdGFbaW5JbmRleF07XG4gICAgICAgIGdyZWVuID0gZGF0YVtpbkluZGV4KzFdO1xuICAgICAgICBibHVlID0gZGF0YVtpbkluZGV4KzJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgY29uc3RhbnRzLkNPTE9SVFlQRV9BTFBIQTpcbiAgICAgICAgYWxwaGEgPSBkYXRhW2luSW5kZXggKyAxXTtcbiAgICAgICAgcmVkID0gZGF0YVtpbkluZGV4XTtcbiAgICAgICAgZ3JlZW4gPSByZWQ7XG4gICAgICAgIGJsdWUgPSByZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBjb25zdGFudHMuQ09MT1JUWVBFX0dSQVlTQ0FMRTpcbiAgICAgICAgcmVkID0gZGF0YVtpbkluZGV4XTtcbiAgICAgICAgZ3JlZW4gPSByZWQ7XG4gICAgICAgIGJsdWUgPSByZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBjb2xvciB0eXBlOicgKyBvcHRpb25zLmlucHV0Q29sb3JUeXBlICsgJyBpcyBub3Qgc3VwcG9ydGVkIGF0IHByZXNlbnQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnB1dEhhc0FscGhhKSB7XG4gICAgICBpZiAoIW91dEhhc0FscGhhKSB7XG4gICAgICAgIGFscGhhIC89IG1heFZhbHVlO1xuICAgICAgICByZWQgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLnJvdW5kKCgxIC0gYWxwaGEpICogYmdDb2xvci5yZWQgKyBhbHBoYSAqIHJlZCksIDApLCBtYXhWYWx1ZSk7XG4gICAgICAgIGdyZWVuID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5yb3VuZCgoMSAtIGFscGhhKSAqIGJnQ29sb3IuZ3JlZW4gKyBhbHBoYSAqIGdyZWVuKSwgMCksIG1heFZhbHVlKTtcbiAgICAgICAgYmx1ZSA9IE1hdGgubWluKE1hdGgubWF4KE1hdGgucm91bmQoKDEgLSBhbHBoYSkgKiBiZ0NvbG9yLmJsdWUgKyBhbHBoYSAqIGJsdWUpLCAwKSwgbWF4VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge3JlZDogcmVkLCBncmVlbjogZ3JlZW4sIGJsdWU6IGJsdWUsIGFscGhhOiBhbHBoYX07XG4gIH1cblxuICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICB2YXIgcmdiYSA9IGdldFJHQkEoZGF0YSwgaW5JbmRleCk7XG5cbiAgICAgIHN3aXRjaCAob3B0aW9ucy5jb2xvclR5cGUpIHtcbiAgICAgICAgY2FzZSBjb25zdGFudHMuQ09MT1JUWVBFX0NPTE9SX0FMUEhBOlxuICAgICAgICBjYXNlIGNvbnN0YW50cy5DT0xPUlRZUEVfQ09MT1I6XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYml0RGVwdGggPT09IDgpIHtcbiAgICAgICAgICAgIG91dERhdGFbb3V0SW5kZXhdID0gcmdiYS5yZWQ7XG4gICAgICAgICAgICBvdXREYXRhW291dEluZGV4ICsgMV0gPSByZ2JhLmdyZWVuO1xuICAgICAgICAgICAgb3V0RGF0YVtvdXRJbmRleCArIDJdID0gcmdiYS5ibHVlO1xuICAgICAgICAgICAgaWYgKG91dEhhc0FscGhhKSB7XG4gICAgICAgICAgICAgIG91dERhdGFbb3V0SW5kZXggKyAzXSA9IHJnYmEuYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dERhdGEud3JpdGVVSW50MTZCRShyZ2JhLnJlZCwgb3V0SW5kZXgpO1xuICAgICAgICAgICAgb3V0RGF0YS53cml0ZVVJbnQxNkJFKHJnYmEuZ3JlZW4sIG91dEluZGV4ICsgMik7XG4gICAgICAgICAgICBvdXREYXRhLndyaXRlVUludDE2QkUocmdiYS5ibHVlLCBvdXRJbmRleCArIDQpO1xuICAgICAgICAgICAgaWYgKG91dEhhc0FscGhhKSB7XG4gICAgICAgICAgICAgIG91dERhdGEud3JpdGVVSW50MTZCRShyZ2JhLmFscGhhLCBvdXRJbmRleCArIDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjb25zdGFudHMuQ09MT1JUWVBFX0FMUEhBOlxuICAgICAgICBjYXNlIGNvbnN0YW50cy5DT0xPUlRZUEVfR1JBWVNDQUxFOlxuICAgICAgICAgIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlIGFuZCBhbHBoYVxuICAgICAgICAgIHZhciBncmF5c2NhbGUgPSAocmdiYS5yZWQgKyByZ2JhLmdyZWVuICsgcmdiYS5ibHVlKSAvIDM7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYml0RGVwdGggPT09IDgpIHtcbiAgICAgICAgICAgIG91dERhdGFbb3V0SW5kZXhdID0gZ3JheXNjYWxlO1xuICAgICAgICAgICAgaWYgKG91dEhhc0FscGhhKSB7XG4gICAgICAgICAgICAgIG91dERhdGFbb3V0SW5kZXggKyAxXSA9IHJnYmEuYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dERhdGEud3JpdGVVSW50MTZCRShncmF5c2NhbGUsIG91dEluZGV4KTtcbiAgICAgICAgICAgIGlmIChvdXRIYXNBbHBoYSkge1xuICAgICAgICAgICAgICBvdXREYXRhLndyaXRlVUludDE2QkUocmdiYS5hbHBoYSwgb3V0SW5kZXggKyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGluSW5kZXggKz0gaW5CcHA7XG4gICAgICBvdXRJbmRleCArPSBvdXRCcHA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dERhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5cbnZhciBDaHVua1N0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuX2J1ZmZlcnMgPSBbXTtcbiAgdGhpcy5fYnVmZmVyZWQgPSAwO1xuXG4gIHRoaXMuX3JlYWRzID0gW107XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gIHRoaXMuX2VuY29kaW5nID0gJ3V0ZjgnO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbn07XG51dGlsLmluaGVyaXRzKENodW5rU3RyZWFtLCBTdHJlYW0pO1xuXG5cbkNodW5rU3RyZWFtLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obGVuZ3RoLCBjYWxsYmFjaykge1xuXG4gIHRoaXMuX3JlYWRzLnB1c2goe1xuICAgIGxlbmd0aDogTWF0aC5hYnMobGVuZ3RoKSwgIC8vIGlmIGxlbmd0aCA8IDAgdGhlbiBhdCBtb3N0IHRoaXMgbGVuZ3RoXG4gICAgYWxsb3dMZXNzOiBsZW5ndGggPCAwLFxuICAgIGZ1bmM6IGNhbGxiYWNrXG4gIH0pO1xuXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgLy8gaXRzIHBhdXNlZCBhbmQgdGhlcmUgaXMgbm90IGVub3VnaHQgZGF0YSB0aGVuIGFzayBmb3IgbW9yZVxuICAgIGlmICh0aGlzLl9wYXVzZWQgJiYgdGhpcy5fcmVhZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG5DaHVua1N0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuXG4gIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1N0cmVhbSBub3Qgd3JpdGFibGUnKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRhdGFCdWZmZXI7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBkYXRhQnVmZmVyID0gZGF0YTtcbiAgfVxuICBlbHNlIHtcbiAgICBkYXRhQnVmZmVyID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmNvZGluZyB8fCB0aGlzLl9lbmNvZGluZyk7XG4gIH1cblxuICB0aGlzLl9idWZmZXJzLnB1c2goZGF0YUJ1ZmZlcik7XG4gIHRoaXMuX2J1ZmZlcmVkICs9IGRhdGFCdWZmZXIubGVuZ3RoO1xuXG4gIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAvLyBvayBpZiB0aGVyZSBhcmUgbm8gbW9yZSByZWFkIHJlcXVlc3RzXG4gIGlmICh0aGlzLl9yZWFkcyAmJiB0aGlzLl9yZWFkcy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMud3JpdGFibGUgJiYgIXRoaXMuX3BhdXNlZDtcbn07XG5cbkNodW5rU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuXG4gIGlmIChkYXRhKSB7XG4gICAgdGhpcy53cml0ZShkYXRhLCBlbmNvZGluZyk7XG4gIH1cblxuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gYWxyZWFkeSBkZXN0cm95ZWRcbiAgaWYgKCF0aGlzLl9idWZmZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZW5xdWV1ZSBvciBoYW5kbGUgZW5kXG4gIGlmICh0aGlzLl9idWZmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2VuZCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChudWxsKTtcbiAgICB0aGlzLl9wcm9jZXNzKCk7XG4gIH1cbn07XG5cbkNodW5rU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95U29vbiA9IENodW5rU3RyZWFtLnByb3RvdHlwZS5lbmQ7XG5cbkNodW5rU3RyZWFtLnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX3JlYWRzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJyxcbiAgICAgIG5ldyBFcnJvcignVGhlcmUgYXJlIHNvbWUgcmVhZCByZXF1ZXN0cyB3YWl0aW5nIG9uIGZpbmlzaGVkIHN0cmVhbScpXG4gICAgKTtcbiAgfVxuXG4gIHRoaXMuZGVzdHJveSgpO1xufTtcblxuQ2h1bmtTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuICBpZiAoIXRoaXMuX2J1ZmZlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHRoaXMuX3JlYWRzID0gbnVsbDtcbiAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG5cbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuQ2h1bmtTdHJlYW0ucHJvdG90eXBlLl9wcm9jZXNzUmVhZEFsbG93aW5nTGVzcyA9IGZ1bmN0aW9uKHJlYWQpIHtcbiAgLy8gb2sgdGhlcmUgaXMgYW55IGRhdGEgc28gdGhhdCB3ZSBjYW4gc2F0aXNmeSB0aGlzIHJlcXVlc3RcbiAgdGhpcy5fcmVhZHMuc2hpZnQoKTsgLy8gPT0gcmVhZFxuXG4gIC8vIGZpcnN0IHdlIG5lZWQgdG8gcGVlayBpbnRvIGZpcnN0IGJ1ZmZlclxuICB2YXIgc21hbGxlckJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG5cbiAgLy8gb2sgdGhlcmUgaXMgbW9yZSBkYXRhIHRoYW4gd2UgbmVlZFxuICBpZiAoc21hbGxlckJ1Zi5sZW5ndGggPiByZWFkLmxlbmd0aCkge1xuXG4gICAgdGhpcy5fYnVmZmVyZWQgLT0gcmVhZC5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVyc1swXSA9IHNtYWxsZXJCdWYuc2xpY2UocmVhZC5sZW5ndGgpO1xuXG4gICAgcmVhZC5mdW5jLmNhbGwodGhpcywgc21hbGxlckJ1Zi5zbGljZSgwLCByZWFkLmxlbmd0aCkpO1xuXG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gb2sgdGhpcyBpcyBsZXNzIHRoYW4gbWF4aW11bSBsZW5ndGggc28gdXNlIGl0IGFsbFxuICAgIHRoaXMuX2J1ZmZlcmVkIC09IHNtYWxsZXJCdWYubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTsgLy8gPT0gc21hbGxlckJ1ZlxuXG4gICAgcmVhZC5mdW5jLmNhbGwodGhpcywgc21hbGxlckJ1Zik7XG4gIH1cbn07XG5cbkNodW5rU3RyZWFtLnByb3RvdHlwZS5fcHJvY2Vzc1JlYWQgPSBmdW5jdGlvbihyZWFkKSB7XG4gIHRoaXMuX3JlYWRzLnNoaWZ0KCk7IC8vID09IHJlYWRcblxuICB2YXIgcG9zID0gMDtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGRhdGEgPSBuZXcgQnVmZmVyKHJlYWQubGVuZ3RoKTtcblxuICAvLyBjcmVhdGUgYnVmZmVyIGZvciBhbGwgZGF0YVxuICB3aGlsZSAocG9zIDwgcmVhZC5sZW5ndGgpIHtcblxuICAgIHZhciBidWYgPSB0aGlzLl9idWZmZXJzW2NvdW50KytdO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihidWYubGVuZ3RoLCByZWFkLmxlbmd0aCAtIHBvcyk7XG5cbiAgICBidWYuY29weShkYXRhLCBwb3MsIDAsIGxlbik7XG4gICAgcG9zICs9IGxlbjtcblxuICAgIC8vIGxhc3QgYnVmZmVyIHdhc24ndCB1c2VkIGFsbCBzbyBqdXN0IHNsaWNlIGl0IGFuZCBsZWF2ZVxuICAgIGlmIChsZW4gIT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbLS1jb3VudF0gPSBidWYuc2xpY2UobGVuKTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIHVzZWQgYnVmZmVyc1xuICBpZiAoY291bnQgPiAwKSB7XG4gICAgdGhpcy5fYnVmZmVycy5zcGxpY2UoMCwgY291bnQpO1xuICB9XG5cbiAgdGhpcy5fYnVmZmVyZWQgLT0gcmVhZC5sZW5ndGg7XG5cbiAgcmVhZC5mdW5jLmNhbGwodGhpcywgZGF0YSk7XG59O1xuXG5DaHVua1N0cmVhbS5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbigpIHtcblxuICB0cnkge1xuICAgIC8vIGFzIGxvbmcgYXMgdGhlcmUgaXMgYW55IGRhdGEgYW5kIHJlYWQgcmVxdWVzdHNcbiAgICB3aGlsZSAodGhpcy5fYnVmZmVyZWQgPiAwICYmIHRoaXMuX3JlYWRzICYmIHRoaXMuX3JlYWRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgdmFyIHJlYWQgPSB0aGlzLl9yZWFkc1swXTtcblxuICAgICAgLy8gcmVhZCBhbnkgZGF0YSAoYnV0IG5vIG1vcmUgdGhhbiBsZW5ndGgpXG4gICAgICBpZiAocmVhZC5hbGxvd0xlc3MpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1JlYWRBbGxvd2luZ0xlc3MocmVhZCk7XG5cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuX2J1ZmZlcmVkID49IHJlYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIG9rIHdlIGNhbiBtZWV0IHNvbWUgZXhwZWN0YXRpb25zXG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzc1JlYWQocmVhZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbm90IGVub3VnaHQgZGF0YSB0byBzYXRpc2Z5IGZpcnN0IHJlcXVlc3QgaW4gcXVldWVcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byB3YWl0IGZvciBtb3JlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9idWZmZXJzICYmIHRoaXMuX2J1ZmZlcnMubGVuZ3RoID4gMCAmJiB0aGlzLl9idWZmZXJzWzBdID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbmQoKTtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGV4KSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGV4KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBQTkdfU0lHTkFUVVJFOiBbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0NywgMHgwZCwgMHgwYSwgMHgxYSwgMHgwYV0sXG5cbiAgVFlQRV9JSERSOiAweDQ5NDg0NDUyLFxuICBUWVBFX0lFTkQ6IDB4NDk0NTRlNDQsXG4gIFRZUEVfSURBVDogMHg0OTQ0NDE1NCxcbiAgVFlQRV9QTFRFOiAweDUwNGM1NDQ1LFxuICBUWVBFX3RSTlM6IDB4NzQ1MjRlNTMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gIFRZUEVfZ0FNQTogMHg2NzQxNGQ0MSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAvLyBjb2xvci10eXBlIGJpdHNcbiAgQ09MT1JUWVBFX0dSQVlTQ0FMRTogMCxcbiAgQ09MT1JUWVBFX1BBTEVUVEU6IDEsXG4gIENPTE9SVFlQRV9DT0xPUjogMixcbiAgQ09MT1JUWVBFX0FMUEhBOiA0LCAvLyBlLmcuIGdyYXlzY2FsZSBhbmQgYWxwaGFcblxuICAvLyBjb2xvci10eXBlIGNvbWJpbmF0aW9uc1xuICBDT0xPUlRZUEVfUEFMRVRURV9DT0xPUjogMyxcbiAgQ09MT1JUWVBFX0NPTE9SX0FMUEhBOiA2LFxuXG4gIENPTE9SVFlQRV9UT19CUFBfTUFQOiB7XG4gICAgMDogMSxcbiAgICAyOiAzLFxuICAgIDM6IDEsXG4gICAgNDogMixcbiAgICA2OiA0XG4gIH0sXG5cbiAgR0FNTUFfRElWSVNJT046IDEwMDAwMFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyY1RhYmxlID0gW107XG5cbihmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIHZhciBjdXJyZW50Q3JjID0gaTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgaWYgKGN1cnJlbnRDcmMgJiAxKSB7XG4gICAgICAgIGN1cnJlbnRDcmMgPSAweGVkYjg4MzIwIF4gKGN1cnJlbnRDcmMgPj4+IDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN1cnJlbnRDcmMgPSBjdXJyZW50Q3JjID4+PiAxO1xuICAgICAgfVxuICAgIH1cbiAgICBjcmNUYWJsZVtpXSA9IGN1cnJlbnRDcmM7XG4gIH1cbn0oKSk7XG5cbnZhciBDcmNDYWxjdWxhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3JjID0gLTE7XG59O1xuXG5DcmNDYWxjdWxhdG9yLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9jcmMgPSBjcmNUYWJsZVsodGhpcy5fY3JjIF4gZGF0YVtpXSkgJiAweGZmXSBeICh0aGlzLl9jcmMgPj4+IDgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuQ3JjQ2FsY3VsYXRvci5wcm90b3R5cGUuY3JjMzIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NyYyBeIC0xO1xufTtcblxuXG5DcmNDYWxjdWxhdG9yLmNyYzMyID0gZnVuY3Rpb24oYnVmKSB7XG5cbiAgdmFyIGNyYyA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIGNyYyA9IGNyY1RhYmxlWyhjcmMgXiBidWZbaV0pICYgMHhmZl0gXiAoY3JjID4+PiA4KTtcbiAgfVxuICByZXR1cm4gY3JjIF4gLTE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFldGhQcmVkaWN0b3IgPSByZXF1aXJlKCcuL3BhZXRoLXByZWRpY3RvcicpO1xuXG5mdW5jdGlvbiBmaWx0ZXJOb25lKHB4RGF0YSwgcHhQb3MsIGJ5dGVXaWR0aCwgcmF3RGF0YSwgcmF3UG9zKSB7XG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykgeyAgICBcbiAgICByYXdEYXRhW3Jhd1BvcyArIHhdID0gcHhEYXRhW3B4UG9zICsgeF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3VtTm9uZShweERhdGEsIHB4UG9zLCBieXRlV2lkdGgpIHtcblxuICB2YXIgc3VtID0gMDtcbiAgdmFyIGxlbmd0aCA9IHB4UG9zICsgYnl0ZVdpZHRoO1xuXG4gIGZvciAodmFyIGkgPSBweFBvczsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgc3VtICs9IE1hdGguYWJzKHB4RGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyU3ViKHB4RGF0YSwgcHhQb3MsIGJ5dGVXaWR0aCwgcmF3RGF0YSwgcmF3UG9zLCBicHApIHtcblxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ5dGVXaWR0aDsgeCsrKSB7XG5cbiAgICB2YXIgbGVmdCA9IHggPj0gYnBwID8gcHhEYXRhW3B4UG9zICsgeCAtIGJwcF0gOiAwO1xuICAgIHZhciB2YWwgPSBweERhdGFbcHhQb3MgKyB4XSAtIGxlZnQ7XG5cbiAgICByYXdEYXRhW3Jhd1BvcyArIHhdID0gdmFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN1bVN1YihweERhdGEsIHB4UG9zLCBieXRlV2lkdGgsIGJwcCkge1xuXG4gIHZhciBzdW0gPSAwO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ5dGVXaWR0aDsgeCsrKSB7XG5cbiAgICB2YXIgbGVmdCA9IHggPj0gYnBwID8gcHhEYXRhW3B4UG9zICsgeCAtIGJwcF0gOiAwO1xuICAgIHZhciB2YWwgPSBweERhdGFbcHhQb3MgKyB4XSAtIGxlZnQ7XG5cbiAgICBzdW0gKz0gTWF0aC5hYnModmFsKTtcbiAgfVxuXG4gIHJldHVybiBzdW07XG59XG5cbmZ1bmN0aW9uIGZpbHRlclVwKHB4RGF0YSwgcHhQb3MsIGJ5dGVXaWR0aCwgcmF3RGF0YSwgcmF3UG9zKSB7XG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykge1xuXG4gICAgdmFyIHVwID0gcHhQb3MgPiAwID8gcHhEYXRhW3B4UG9zICsgeCAtIGJ5dGVXaWR0aF0gOiAwO1xuICAgIHZhciB2YWwgPSBweERhdGFbcHhQb3MgKyB4XSAtIHVwO1xuXG4gICAgcmF3RGF0YVtyYXdQb3MgKyB4XSA9IHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdW1VcChweERhdGEsIHB4UG9zLCBieXRlV2lkdGgpIHtcblxuICB2YXIgc3VtID0gMDtcbiAgdmFyIGxlbmd0aCA9IHB4UG9zICsgYnl0ZVdpZHRoO1xuICBmb3IgKHZhciB4ID0gcHhQb3M7IHggPCBsZW5ndGg7IHgrKykge1xuXG4gICAgdmFyIHVwID0gcHhQb3MgPiAwID8gcHhEYXRhW3ggLSBieXRlV2lkdGhdIDogMDtcbiAgICB2YXIgdmFsID0gcHhEYXRhW3hdIC0gdXA7XG5cbiAgICBzdW0gKz0gTWF0aC5hYnModmFsKTtcbiAgfVxuXG4gIHJldHVybiBzdW07XG59XG5cbmZ1bmN0aW9uIGZpbHRlckF2ZyhweERhdGEsIHB4UG9zLCBieXRlV2lkdGgsIHJhd0RhdGEsIHJhd1BvcywgYnBwKSB7XG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykge1xuXG4gICAgdmFyIGxlZnQgPSB4ID49IGJwcCA/IHB4RGF0YVtweFBvcyArIHggLSBicHBdIDogMDtcbiAgICB2YXIgdXAgPSBweFBvcyA+IDAgPyBweERhdGFbcHhQb3MgKyB4IC0gYnl0ZVdpZHRoXSA6IDA7XG4gICAgdmFyIHZhbCA9IHB4RGF0YVtweFBvcyArIHhdIC0gKChsZWZ0ICsgdXApID4+IDEpO1xuXG4gICAgcmF3RGF0YVtyYXdQb3MgKyB4XSA9IHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdW1BdmcocHhEYXRhLCBweFBvcywgYnl0ZVdpZHRoLCBicHApIHtcblxuICB2YXIgc3VtID0gMDtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykge1xuXG4gICAgdmFyIGxlZnQgPSB4ID49IGJwcCA/IHB4RGF0YVtweFBvcyArIHggLSBicHBdIDogMDtcbiAgICB2YXIgdXAgPSBweFBvcyA+IDAgPyBweERhdGFbcHhQb3MgKyB4IC0gYnl0ZVdpZHRoXSA6IDA7XG4gICAgdmFyIHZhbCA9IHB4RGF0YVtweFBvcyArIHhdIC0gKChsZWZ0ICsgdXApID4+IDEpO1xuXG4gICAgc3VtICs9IE1hdGguYWJzKHZhbCk7XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJQYWV0aChweERhdGEsIHB4UG9zLCBieXRlV2lkdGgsIHJhd0RhdGEsIHJhd1BvcywgYnBwKSB7XG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykge1xuXG4gICAgdmFyIGxlZnQgPSB4ID49IGJwcCA/IHB4RGF0YVtweFBvcyArIHggLSBicHBdIDogMDtcbiAgICB2YXIgdXAgPSBweFBvcyA+IDAgPyBweERhdGFbcHhQb3MgKyB4IC0gYnl0ZVdpZHRoXSA6IDA7XG4gICAgdmFyIHVwbGVmdCA9IHB4UG9zID4gMCAmJiB4ID49IGJwcCA/IHB4RGF0YVtweFBvcyArIHggLSAoYnl0ZVdpZHRoICsgYnBwKV0gOiAwO1xuICAgIHZhciB2YWwgPSBweERhdGFbcHhQb3MgKyB4XSAtIHBhZXRoUHJlZGljdG9yKGxlZnQsIHVwLCB1cGxlZnQpO1xuXG4gICAgcmF3RGF0YVtyYXdQb3MgKyB4XSA9IHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdW1QYWV0aChweERhdGEsIHB4UG9zLCBieXRlV2lkdGgsIGJwcCkge1xuICB2YXIgc3VtID0gMDtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykge1xuXG4gICAgdmFyIGxlZnQgPSB4ID49IGJwcCA/IHB4RGF0YVtweFBvcyArIHggLSBicHBdIDogMDtcbiAgICB2YXIgdXAgPSBweFBvcyA+IDAgPyBweERhdGFbcHhQb3MgKyB4IC0gYnl0ZVdpZHRoXSA6IDA7XG4gICAgdmFyIHVwbGVmdCA9IHB4UG9zID4gMCAmJiB4ID49IGJwcCA/IHB4RGF0YVtweFBvcyArIHggLSAoYnl0ZVdpZHRoICsgYnBwKV0gOiAwO1xuICAgIHZhciB2YWwgPSBweERhdGFbcHhQb3MgKyB4XSAtIHBhZXRoUHJlZGljdG9yKGxlZnQsIHVwLCB1cGxlZnQpO1xuXG4gICAgc3VtICs9IE1hdGguYWJzKHZhbCk7XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuXG52YXIgZmlsdGVycyA9IHtcbiAgMDogZmlsdGVyTm9uZSxcbiAgMTogZmlsdGVyU3ViLFxuICAyOiBmaWx0ZXJVcCxcbiAgMzogZmlsdGVyQXZnLFxuICA0OiBmaWx0ZXJQYWV0aFxufTtcblxudmFyIGZpbHRlclN1bXMgPSB7XG4gIDA6IGZpbHRlclN1bU5vbmUsXG4gIDE6IGZpbHRlclN1bVN1YixcbiAgMjogZmlsdGVyU3VtVXAsXG4gIDM6IGZpbHRlclN1bUF2ZyxcbiAgNDogZmlsdGVyU3VtUGFldGhcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHhEYXRhLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zLCBicHApIHtcblxuICB2YXIgZmlsdGVyVHlwZXM7XG4gIGlmICghKCdmaWx0ZXJUeXBlJyBpbiBvcHRpb25zKSB8fCBvcHRpb25zLmZpbHRlclR5cGUgPT09IC0xKSB7XG4gICAgZmlsdGVyVHlwZXMgPSBbMCwgMSwgMiwgMywgNF07XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBmaWx0ZXJUeXBlcyA9IFtvcHRpb25zLmZpbHRlclR5cGVdO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pc2VkIGZpbHRlciB0eXBlcycpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYml0RGVwdGggPT09IDE2KSBicHAgKj0gMjtcbiAgdmFyIGJ5dGVXaWR0aCA9IHdpZHRoICogYnBwO1xuICB2YXIgcmF3UG9zID0gMDtcbiAgdmFyIHB4UG9zID0gMDtcbiAgdmFyIHJhd0RhdGEgPSBuZXcgQnVmZmVyKChieXRlV2lkdGggKyAxKSAqIGhlaWdodCk7XG5cbiAgdmFyIHNlbCA9IGZpbHRlclR5cGVzWzBdO1xuXG4gIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcblxuICAgIGlmIChmaWx0ZXJUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBmaW5kIGJlc3QgZmlsdGVyIGZvciB0aGlzIGxpbmUgKHdpdGggbG93ZXN0IHN1bSBvZiB2YWx1ZXMpXG4gICAgICB2YXIgbWluID0gSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1bSA9IGZpbHRlclN1bXNbZmlsdGVyVHlwZXNbaV1dKHB4RGF0YSwgcHhQb3MsIGJ5dGVXaWR0aCwgYnBwKTtcbiAgICAgICAgaWYgKHN1bSA8IG1pbikge1xuICAgICAgICAgIHNlbCA9IGZpbHRlclR5cGVzW2ldO1xuICAgICAgICAgIG1pbiA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJhd0RhdGFbcmF3UG9zXSA9IHNlbDtcbiAgICByYXdQb3MrKztcbiAgICBmaWx0ZXJzW3NlbF0ocHhEYXRhLCBweFBvcywgYnl0ZVdpZHRoLCByYXdEYXRhLCByYXdQb3MsIGJwcCk7XG4gICAgcmF3UG9zICs9IGJ5dGVXaWR0aDtcbiAgICBweFBvcyArPSBieXRlV2lkdGg7XG4gIH1cbiAgcmV0dXJuIHJhd0RhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBDaHVua1N0cmVhbSA9IHJlcXVpcmUoJy4vY2h1bmtzdHJlYW0nKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlci1wYXJzZScpO1xuXG5cbnZhciBGaWx0ZXJBc3luYyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwSW5mbykge1xuICBDaHVua1N0cmVhbS5jYWxsKHRoaXMpO1xuXG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdGhpcy5fZmlsdGVyID0gbmV3IEZpbHRlcihiaXRtYXBJbmZvLCB7XG4gICAgcmVhZDogdGhpcy5yZWFkLmJpbmQodGhpcyksXG4gICAgd3JpdGU6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGF0LmVtaXQoJ2NvbXBsZXRlJywgQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLl9maWx0ZXIuc3RhcnQoKTtcbn07XG51dGlsLmluaGVyaXRzKEZpbHRlckFzeW5jLCBDaHVua1N0cmVhbSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTeW5jUmVhZGVyID0gcmVxdWlyZSgnLi9zeW5jLXJlYWRlcicpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyLXBhcnNlJyk7XG5cblxuZXhwb3J0cy5wcm9jZXNzID0gZnVuY3Rpb24oaW5CdWZmZXIsIGJpdG1hcEluZm8pIHtcblxuICB2YXIgb3V0QnVmZmVycyA9IFtdO1xuICB2YXIgcmVhZGVyID0gbmV3IFN5bmNSZWFkZXIoaW5CdWZmZXIpO1xuICB2YXIgZmlsdGVyID0gbmV3IEZpbHRlcihiaXRtYXBJbmZvLCB7XG4gICAgcmVhZDogcmVhZGVyLnJlYWQuYmluZChyZWFkZXIpLFxuICAgIHdyaXRlOiBmdW5jdGlvbihidWZmZXJQYXJ0KSB7XG4gICAgICBvdXRCdWZmZXJzLnB1c2goYnVmZmVyUGFydCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgfVxuICB9KTtcblxuICBmaWx0ZXIuc3RhcnQoKTtcbiAgcmVhZGVyLnByb2Nlc3MoKTtcblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXRCdWZmZXJzKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50ZXJsYWNlVXRpbHMgPSByZXF1aXJlKCcuL2ludGVybGFjZScpO1xudmFyIHBhZXRoUHJlZGljdG9yID0gcmVxdWlyZSgnLi9wYWV0aC1wcmVkaWN0b3InKTtcblxuZnVuY3Rpb24gZ2V0Qnl0ZVdpZHRoKHdpZHRoLCBicHAsIGRlcHRoKSB7XG4gIHZhciBieXRlV2lkdGggPSB3aWR0aCAqIGJwcDtcbiAgaWYgKGRlcHRoICE9PSA4KSB7XG4gICAgYnl0ZVdpZHRoID0gTWF0aC5jZWlsKGJ5dGVXaWR0aCAvICg4IC8gZGVwdGgpKTtcbiAgfVxuICByZXR1cm4gYnl0ZVdpZHRoO1xufVxuXG52YXIgRmlsdGVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXBJbmZvLCBkZXBlbmRlbmNpZXMpIHtcblxuICB2YXIgd2lkdGggPSBiaXRtYXBJbmZvLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gYml0bWFwSW5mby5oZWlnaHQ7XG4gIHZhciBpbnRlcmxhY2UgPSBiaXRtYXBJbmZvLmludGVybGFjZTtcbiAgdmFyIGJwcCA9IGJpdG1hcEluZm8uYnBwO1xuICB2YXIgZGVwdGggPSBiaXRtYXBJbmZvLmRlcHRoO1xuXG4gIHRoaXMucmVhZCA9IGRlcGVuZGVuY2llcy5yZWFkO1xuICB0aGlzLndyaXRlID0gZGVwZW5kZW5jaWVzLndyaXRlO1xuICB0aGlzLmNvbXBsZXRlID0gZGVwZW5kZW5jaWVzLmNvbXBsZXRlO1xuXG4gIHRoaXMuX2ltYWdlSW5kZXggPSAwO1xuICB0aGlzLl9pbWFnZXMgPSBbXTtcbiAgaWYgKGludGVybGFjZSkge1xuICAgIHZhciBwYXNzZXMgPSBpbnRlcmxhY2VVdGlscy5nZXRJbWFnZVBhc3Nlcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5faW1hZ2VzLnB1c2goe1xuICAgICAgICBieXRlV2lkdGg6IGdldEJ5dGVXaWR0aChwYXNzZXNbaV0ud2lkdGgsIGJwcCwgZGVwdGgpLFxuICAgICAgICBoZWlnaHQ6IHBhc3Nlc1tpXS5oZWlnaHQsXG4gICAgICAgIGxpbmVJbmRleDogMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2ltYWdlcy5wdXNoKHtcbiAgICAgIGJ5dGVXaWR0aDogZ2V0Qnl0ZVdpZHRoKHdpZHRoLCBicHAsIGRlcHRoKSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgbGluZUluZGV4OiAwXG4gICAgfSk7XG4gIH1cblxuICAvLyB3aGVuIGZpbHRlcmluZyB0aGUgbGluZSB3ZSBsb29rIGF0IHRoZSBwaXhlbCB0byB0aGUgbGVmdFxuICAvLyB0aGUgc3BlYyBhbHNvIHNheXMgaXQgaXMgZG9uZSBvbiBhIGJ5dGUgbGV2ZWwgcmVnYXJkbGVzcyBvZiB0aGUgbnVtYmVyIG9mIHBpeGVsc1xuICAvLyBzbyBpZiB0aGUgZGVwdGggaXMgYnl0ZSBjb21wYXRpYmxlICg4IG9yIDE2KSB3ZSBzdWJ0cmFjdCB0aGUgYnBwIGluIG9yZGVyIHRvIGNvbXBhcmUgYmFja1xuICAvLyBhIHBpeGVsIHJhdGhlciB0aGFuIGp1c3QgYSBkaWZmZXJlbnQgYnl0ZSBwYXJ0LiBIb3dldmVyIGlmIHdlIGFyZSBzdWIgYnl0ZSwgd2UgaWdub3JlLlxuICBpZiAoZGVwdGggPT09IDgpIHtcbiAgICB0aGlzLl94Q29tcGFyaXNvbiA9IGJwcDtcbiAgfVxuICBlbHNlIGlmIChkZXB0aCA9PT0gMTYpIHtcbiAgICB0aGlzLl94Q29tcGFyaXNvbiA9IGJwcCAqIDI7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5feENvbXBhcmlzb24gPSAxO1xuICB9XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVhZCh0aGlzLl9pbWFnZXNbdGhpcy5faW1hZ2VJbmRleF0uYnl0ZVdpZHRoICsgMSwgdGhpcy5fcmV2ZXJzZUZpbHRlckxpbmUuYmluZCh0aGlzKSk7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLl91bkZpbHRlclR5cGUxID0gZnVuY3Rpb24ocmF3RGF0YSwgdW5maWx0ZXJlZExpbmUsIGJ5dGVXaWR0aCkge1xuXG4gIHZhciB4Q29tcGFyaXNvbiA9IHRoaXMuX3hDb21wYXJpc29uO1xuICB2YXIgeEJpZ2dlclRoYW4gPSB4Q29tcGFyaXNvbiAtIDE7XG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykge1xuICAgIHZhciByYXdCeXRlID0gcmF3RGF0YVsxICsgeF07XG4gICAgdmFyIGYxTGVmdCA9IHggPiB4QmlnZ2VyVGhhbiA/IHVuZmlsdGVyZWRMaW5lW3ggLSB4Q29tcGFyaXNvbl0gOiAwO1xuICAgIHVuZmlsdGVyZWRMaW5lW3hdID0gcmF3Qnl0ZSArIGYxTGVmdDtcbiAgfVxufTtcblxuRmlsdGVyLnByb3RvdHlwZS5fdW5GaWx0ZXJUeXBlMiA9IGZ1bmN0aW9uKHJhd0RhdGEsIHVuZmlsdGVyZWRMaW5lLCBieXRlV2lkdGgpIHtcblxuICB2YXIgbGFzdExpbmUgPSB0aGlzLl9sYXN0TGluZTtcblxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ5dGVXaWR0aDsgeCsrKSB7XG4gICAgdmFyIHJhd0J5dGUgPSByYXdEYXRhWzEgKyB4XTtcbiAgICB2YXIgZjJVcCA9IGxhc3RMaW5lID8gbGFzdExpbmVbeF0gOiAwO1xuICAgIHVuZmlsdGVyZWRMaW5lW3hdID0gcmF3Qnl0ZSArIGYyVXA7XG4gIH1cbn07XG5cbkZpbHRlci5wcm90b3R5cGUuX3VuRmlsdGVyVHlwZTMgPSBmdW5jdGlvbihyYXdEYXRhLCB1bmZpbHRlcmVkTGluZSwgYnl0ZVdpZHRoKSB7XG5cbiAgdmFyIHhDb21wYXJpc29uID0gdGhpcy5feENvbXBhcmlzb247XG4gIHZhciB4QmlnZ2VyVGhhbiA9IHhDb21wYXJpc29uIC0gMTtcbiAgdmFyIGxhc3RMaW5lID0gdGhpcy5fbGFzdExpbmU7XG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBieXRlV2lkdGg7IHgrKykge1xuICAgIHZhciByYXdCeXRlID0gcmF3RGF0YVsxICsgeF07XG4gICAgdmFyIGYzVXAgPSBsYXN0TGluZSA/IGxhc3RMaW5lW3hdIDogMDtcbiAgICB2YXIgZjNMZWZ0ID0geCA+IHhCaWdnZXJUaGFuID8gdW5maWx0ZXJlZExpbmVbeCAtIHhDb21wYXJpc29uXSA6IDA7XG4gICAgdmFyIGYzQWRkID0gTWF0aC5mbG9vcigoZjNMZWZ0ICsgZjNVcCkgLyAyKTtcbiAgICB1bmZpbHRlcmVkTGluZVt4XSA9IHJhd0J5dGUgKyBmM0FkZDtcbiAgfVxufTtcblxuRmlsdGVyLnByb3RvdHlwZS5fdW5GaWx0ZXJUeXBlNCA9IGZ1bmN0aW9uKHJhd0RhdGEsIHVuZmlsdGVyZWRMaW5lLCBieXRlV2lkdGgpIHtcblxuICB2YXIgeENvbXBhcmlzb24gPSB0aGlzLl94Q29tcGFyaXNvbjtcbiAgdmFyIHhCaWdnZXJUaGFuID0geENvbXBhcmlzb24gLSAxO1xuICB2YXIgbGFzdExpbmUgPSB0aGlzLl9sYXN0TGluZTtcblxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ5dGVXaWR0aDsgeCsrKSB7XG4gICAgdmFyIHJhd0J5dGUgPSByYXdEYXRhWzEgKyB4XTtcbiAgICB2YXIgZjRVcCA9IGxhc3RMaW5lID8gbGFzdExpbmVbeF0gOiAwO1xuICAgIHZhciBmNExlZnQgPSB4ID4geEJpZ2dlclRoYW4gPyB1bmZpbHRlcmVkTGluZVt4IC0geENvbXBhcmlzb25dIDogMDtcbiAgICB2YXIgZjRVcExlZnQgPSB4ID4geEJpZ2dlclRoYW4gJiYgbGFzdExpbmUgPyBsYXN0TGluZVt4IC0geENvbXBhcmlzb25dIDogMDtcbiAgICB2YXIgZjRBZGQgPSBwYWV0aFByZWRpY3RvcihmNExlZnQsIGY0VXAsIGY0VXBMZWZ0KTtcbiAgICB1bmZpbHRlcmVkTGluZVt4XSA9IHJhd0J5dGUgKyBmNEFkZDtcbiAgfVxufTtcblxuRmlsdGVyLnByb3RvdHlwZS5fcmV2ZXJzZUZpbHRlckxpbmUgPSBmdW5jdGlvbihyYXdEYXRhKSB7XG5cbiAgdmFyIGZpbHRlciA9IHJhd0RhdGFbMF07XG4gIHZhciB1bmZpbHRlcmVkTGluZTtcbiAgdmFyIGN1cnJlbnRJbWFnZSA9IHRoaXMuX2ltYWdlc1t0aGlzLl9pbWFnZUluZGV4XTtcbiAgdmFyIGJ5dGVXaWR0aCA9IGN1cnJlbnRJbWFnZS5ieXRlV2lkdGg7XG5cbiAgaWYgKGZpbHRlciA9PT0gMCkge1xuICAgIHVuZmlsdGVyZWRMaW5lID0gcmF3RGF0YS5zbGljZSgxLCBieXRlV2lkdGggKyAxKTtcbiAgfVxuICBlbHNlIHtcblxuICAgIHVuZmlsdGVyZWRMaW5lID0gbmV3IEJ1ZmZlcihieXRlV2lkdGgpO1xuXG4gICAgc3dpdGNoIChmaWx0ZXIpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5fdW5GaWx0ZXJUeXBlMShyYXdEYXRhLCB1bmZpbHRlcmVkTGluZSwgYnl0ZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX3VuRmlsdGVyVHlwZTIocmF3RGF0YSwgdW5maWx0ZXJlZExpbmUsIGJ5dGVXaWR0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB0aGlzLl91bkZpbHRlclR5cGUzKHJhd0RhdGEsIHVuZmlsdGVyZWRMaW5lLCBieXRlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgdGhpcy5fdW5GaWx0ZXJUeXBlNChyYXdEYXRhLCB1bmZpbHRlcmVkTGluZSwgYnl0ZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXNlZCBmaWx0ZXIgdHlwZSAtICcgKyBmaWx0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMud3JpdGUodW5maWx0ZXJlZExpbmUpO1xuXG4gIGN1cnJlbnRJbWFnZS5saW5lSW5kZXgrKztcbiAgaWYgKGN1cnJlbnRJbWFnZS5saW5lSW5kZXggPj0gY3VycmVudEltYWdlLmhlaWdodCkge1xuICAgIHRoaXMuX2xhc3RMaW5lID0gbnVsbDtcbiAgICB0aGlzLl9pbWFnZUluZGV4Kys7XG4gICAgY3VycmVudEltYWdlID0gdGhpcy5faW1hZ2VzW3RoaXMuX2ltYWdlSW5kZXhdO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2xhc3RMaW5lID0gdW5maWx0ZXJlZExpbmU7XG4gIH1cblxuICBpZiAoY3VycmVudEltYWdlKSB7XG4gICAgLy8gcmVhZCwgdXNpbmcgdGhlIGJ5dGUgd2lkdGggdGhhdCBtYXkgYmUgZnJvbSB0aGUgbmV3IGN1cnJlbnQgaW1hZ2VcbiAgICB0aGlzLnJlYWQoY3VycmVudEltYWdlLmJ5dGVXaWR0aCArIDEsIHRoaXMuX3JldmVyc2VGaWx0ZXJMaW5lLmJpbmQodGhpcykpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2xhc3RMaW5lID0gbnVsbDtcbiAgICB0aGlzLmNvbXBsZXRlKCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlUGFsZXR0ZShpbmRhdGEsIG91dGRhdGEsIHdpZHRoLCBoZWlnaHQsIHBhbGV0dGUpIHtcbiAgdmFyIHB4UG9zID0gMDtcbiAgLy8gdXNlIHZhbHVlcyBmcm9tIHBhbGV0dGVcbiAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgdmFyIGNvbG9yID0gcGFsZXR0ZVtpbmRhdGFbcHhQb3NdXTtcblxuICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4ICcgKyBpbmRhdGFbcHhQb3NdICsgJyBub3QgaW4gcGFsZXR0ZScpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBvdXRkYXRhW3B4UG9zICsgaV0gPSBjb2xvcltpXTtcbiAgICAgIH1cbiAgICAgIHB4UG9zICs9IDQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUcmFuc3BhcmVudENvbG9yKGluZGF0YSwgb3V0ZGF0YSwgd2lkdGgsIGhlaWdodCwgdHJhbnNDb2xvcikge1xuICB2YXIgcHhQb3MgPSAwO1xuICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICB2YXIgbWFrZVRyYW5zID0gZmFsc2U7XG5cbiAgICAgIGlmICh0cmFuc0NvbG9yLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHJhbnNDb2xvclswXSA9PT0gaW5kYXRhW3B4UG9zXSkge1xuICAgICAgICAgIG1ha2VUcmFucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRyYW5zQ29sb3JbMF0gPT09IGluZGF0YVtweFBvc10gJiYgdHJhbnNDb2xvclsxXSA9PT0gaW5kYXRhW3B4UG9zICsgMV0gJiYgdHJhbnNDb2xvclsyXSA9PT0gaW5kYXRhW3B4UG9zICsgMl0pIHtcbiAgICAgICAgbWFrZVRyYW5zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYWtlVHJhbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBvdXRkYXRhW3B4UG9zICsgaV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBweFBvcyArPSA0O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsZURlcHRoKGluZGF0YSwgb3V0ZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpIHtcbiAgdmFyIG1heE91dFNhbXBsZSA9IDI1NTtcbiAgdmFyIG1heEluU2FtcGxlID0gTWF0aC5wb3coMiwgZGVwdGgpIC0gMTtcbiAgdmFyIHB4UG9zID0gMDtcblxuICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBvdXRkYXRhW3B4UG9zICsgaV0gPSBNYXRoLmZsb29yKChpbmRhdGFbcHhQb3MgKyBpXSAqIG1heE91dFNhbXBsZSkgLyBtYXhJblNhbXBsZSArIDAuNSk7XG4gICAgICB9XG4gICAgICBweFBvcyArPSA0O1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGF0YSwgaW1hZ2VEYXRhKSB7XG5cbiAgdmFyIGRlcHRoID0gaW1hZ2VEYXRhLmRlcHRoO1xuICB2YXIgd2lkdGggPSBpbWFnZURhdGEud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICB2YXIgY29sb3JUeXBlID0gaW1hZ2VEYXRhLmNvbG9yVHlwZTtcbiAgdmFyIHRyYW5zQ29sb3IgPSBpbWFnZURhdGEudHJhbnNDb2xvcjtcbiAgdmFyIHBhbGV0dGUgPSBpbWFnZURhdGEucGFsZXR0ZTtcblxuICB2YXIgb3V0ZGF0YSA9IGluZGF0YTsgLy8gb25seSBkaWZmZXJlbnQgZm9yIDE2IGJpdHNcblxuICBpZiAoY29sb3JUeXBlID09PSAzKSB7IC8vIHBhbGV0dGVkXG4gICAgZGVQYWxldHRlKGluZGF0YSwgb3V0ZGF0YSwgd2lkdGgsIGhlaWdodCwgcGFsZXR0ZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRyYW5zQ29sb3IpIHtcbiAgICAgIHJlcGxhY2VUcmFuc3BhcmVudENvbG9yKGluZGF0YSwgb3V0ZGF0YSwgd2lkdGgsIGhlaWdodCwgdHJhbnNDb2xvcik7XG4gICAgfVxuICAgIC8vIGlmIGl0IG5lZWRzIHNjYWxpbmdcbiAgICBpZiAoZGVwdGggIT09IDgpIHtcbiAgICAgIC8vIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBidWZmZXIgc2l6ZVxuICAgICAgaWYgKGRlcHRoID09PSAxNikge1xuICAgICAgICBvdXRkYXRhID0gbmV3IEJ1ZmZlcih3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgfVxuICAgICAgc2NhbGVEZXB0aChpbmRhdGEsIG91dGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBBZGFtIDdcbi8vICAgMCAxIDIgMyA0IDUgNiA3XG4vLyAwIHggNiA0IDYgeCA2IDQgNlxuLy8gMSA3IDcgNyA3IDcgNyA3IDdcbi8vIDIgNSA2IDUgNiA1IDYgNSA2XG4vLyAzIDcgNyA3IDcgNyA3IDcgN1xuLy8gNCAzIDYgNCA2IDMgNiA0IDZcbi8vIDUgNyA3IDcgNyA3IDcgNyA3XG4vLyA2IDUgNiA1IDYgNSA2IDUgNlxuLy8gNyA3IDcgNyA3IDcgNyA3IDdcblxuXG52YXIgaW1hZ2VQYXNzZXMgPSBbXG4gIHsgLy8gcGFzcyAxIC0gMXB4XG4gICAgeDogWzBdLFxuICAgIHk6IFswXVxuICB9LFxuICB7IC8vIHBhc3MgMiAtIDFweFxuICAgIHg6IFs0XSxcbiAgICB5OiBbMF1cbiAgfSxcbiAgeyAvLyBwYXNzIDMgLSAycHhcbiAgICB4OiBbMCwgNF0sXG4gICAgeTogWzRdXG4gIH0sXG4gIHsgLy8gcGFzcyA0IC0gNHB4XG4gICAgeDogWzIsIDZdLFxuICAgIHk6IFswLCA0XVxuICB9LFxuICB7IC8vIHBhc3MgNSAtIDhweFxuICAgIHg6IFswLCAyLCA0LCA2XSxcbiAgICB5OiBbMiwgNl1cbiAgfSxcbiAgeyAvLyBwYXNzIDYgLSAxNnB4XG4gICAgeDogWzEsIDMsIDUsIDddLFxuICAgIHk6IFswLCAyLCA0LCA2XVxuICB9LFxuICB7IC8vIHBhc3MgNyAtIDMycHhcbiAgICB4OiBbMCwgMSwgMiwgMywgNCwgNSwgNiwgN10sXG4gICAgeTogWzEsIDMsIDUsIDddXG4gIH1cbl07XG5cbmV4cG9ydHMuZ2V0SW1hZ2VQYXNzZXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBpbWFnZXMgPSBbXTtcbiAgdmFyIHhMZWZ0T3ZlciA9IHdpZHRoICUgODtcbiAgdmFyIHlMZWZ0T3ZlciA9IGhlaWdodCAlIDg7XG4gIHZhciB4UmVwZWF0cyA9ICh3aWR0aCAtIHhMZWZ0T3ZlcikgLyA4O1xuICB2YXIgeVJlcGVhdHMgPSAoaGVpZ2h0IC0geUxlZnRPdmVyKSAvIDg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VQYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFzcyA9IGltYWdlUGFzc2VzW2ldO1xuICAgIHZhciBwYXNzV2lkdGggPSB4UmVwZWF0cyAqIHBhc3MueC5sZW5ndGg7XG4gICAgdmFyIHBhc3NIZWlnaHQgPSB5UmVwZWF0cyAqIHBhc3MueS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXNzLngubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChwYXNzLnhbal0gPCB4TGVmdE92ZXIpIHtcbiAgICAgICAgcGFzc1dpZHRoKys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaiA9IDA7IGogPCBwYXNzLnkubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChwYXNzLnlbal0gPCB5TGVmdE92ZXIpIHtcbiAgICAgICAgcGFzc0hlaWdodCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFzc1dpZHRoID4gMCAmJiBwYXNzSGVpZ2h0ID4gMCkge1xuICAgICAgaW1hZ2VzLnB1c2goeyB3aWR0aDogcGFzc1dpZHRoLCBoZWlnaHQ6IHBhc3NIZWlnaHQsIGluZGV4OiBpIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW1hZ2VzO1xufTtcblxuZXhwb3J0cy5nZXRJbnRlcmxhY2VJdGVyYXRvciA9IGZ1bmN0aW9uKHdpZHRoKSB7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5LCBwYXNzKSB7XG4gICAgdmFyIG91dGVyWExlZnRPdmVyID0geCAlIGltYWdlUGFzc2VzW3Bhc3NdLngubGVuZ3RoO1xuICAgIHZhciBvdXRlclggPSAoKCh4IC0gb3V0ZXJYTGVmdE92ZXIpIC8gaW1hZ2VQYXNzZXNbcGFzc10ueC5sZW5ndGgpICogOCkgKyBpbWFnZVBhc3Nlc1twYXNzXS54W291dGVyWExlZnRPdmVyXTtcbiAgICB2YXIgb3V0ZXJZTGVmdE92ZXIgPSB5ICUgaW1hZ2VQYXNzZXNbcGFzc10ueS5sZW5ndGg7XG4gICAgdmFyIG91dGVyWSA9ICgoKHkgLSBvdXRlcllMZWZ0T3ZlcikgLyBpbWFnZVBhc3Nlc1twYXNzXS55Lmxlbmd0aCkgKiA4KSArIGltYWdlUGFzc2VzW3Bhc3NdLnlbb3V0ZXJZTGVmdE92ZXJdO1xuICAgIHJldHVybiAob3V0ZXJYICogNCkgKyAob3V0ZXJZICogd2lkdGggKiA0KTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIFBhY2tlciA9IHJlcXVpcmUoJy4vcGFja2VyJyk7XG5cbnZhciBQYWNrZXJBc3luYyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gIHZhciBvcHRpb25zID0gb3B0IHx8IHt9O1xuXG4gIHRoaXMuX3BhY2tlciA9IG5ldyBQYWNrZXIob3B0aW9ucyk7XG4gIHRoaXMuX2RlZmxhdGUgPSB0aGlzLl9wYWNrZXIuY3JlYXRlRGVmbGF0ZSgpO1xuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xufTtcbnV0aWwuaW5oZXJpdHMoUGFja2VyQXN5bmMsIFN0cmVhbSk7XG5cblxuUGFja2VyQXN5bmMucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbihkYXRhLCB3aWR0aCwgaGVpZ2h0LCBnYW1tYSkge1xuICAvLyBTaWduYXR1cmVcbiAgdGhpcy5lbWl0KCdkYXRhJywgbmV3IEJ1ZmZlcihjb25zdGFudHMuUE5HX1NJR05BVFVSRSkpO1xuICB0aGlzLmVtaXQoJ2RhdGEnLCB0aGlzLl9wYWNrZXIucGFja0lIRFIod2lkdGgsIGhlaWdodCkpO1xuXG4gIGlmIChnYW1tYSkge1xuICAgIHRoaXMuZW1pdCgnZGF0YScsIHRoaXMuX3BhY2tlci5wYWNrR0FNQShnYW1tYSkpO1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkRGF0YSA9IHRoaXMuX3BhY2tlci5maWx0ZXJEYXRhKGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuXG4gIC8vIGNvbXByZXNzIGl0XG4gIHRoaXMuX2RlZmxhdGUub24oJ2Vycm9yJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJykpO1xuXG4gIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBmdW5jdGlvbihjb21wcmVzc2VkRGF0YSkge1xuICAgIHRoaXMuZW1pdCgnZGF0YScsIHRoaXMuX3BhY2tlci5wYWNrSURBVChjb21wcmVzc2VkRGF0YSkpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIHRoaXMuX2RlZmxhdGUub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW1pdCgnZGF0YScsIHRoaXMuX3BhY2tlci5wYWNrSUVORCgpKTtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIHRoaXMuX2RlZmxhdGUuZW5kKGZpbHRlcmVkRGF0YSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3luY1psaWIgPSB0cnVlO1xudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5pZiAoIXpsaWIuZGVmbGF0ZVN5bmMpIHtcbiAgaGFzU3luY1psaWIgPSBmYWxzZTtcbn1cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIFBhY2tlciA9IHJlcXVpcmUoJy4vcGFja2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0YURhdGEsIG9wdCkge1xuXG4gIGlmICghaGFzU3luY1psaWIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSB0aGUgc3luYyBjYXBhYmlsaXR5IG9mIHRoaXMgbGlicmFyeSBpbiBvbGQgbm9kZSB2ZXJzaW9ucywgcGxlYXNlIHBpbiBwbmdqcyB0byB2Mi4zLjAnKTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gb3B0IHx8IHt9O1xuXG4gIHZhciBwYWNrZXIgPSBuZXcgUGFja2VyKG9wdGlvbnMpO1xuXG4gIHZhciBjaHVua3MgPSBbXTtcblxuICAvLyBTaWduYXR1cmVcbiAgY2h1bmtzLnB1c2gobmV3IEJ1ZmZlcihjb25zdGFudHMuUE5HX1NJR05BVFVSRSkpO1xuXG4gIC8vIEhlYWRlclxuICBjaHVua3MucHVzaChwYWNrZXIucGFja0lIRFIobWV0YURhdGEud2lkdGgsIG1ldGFEYXRhLmhlaWdodCkpO1xuXG4gIGlmIChtZXRhRGF0YS5nYW1tYSkge1xuICAgIGNodW5rcy5wdXNoKHBhY2tlci5wYWNrR0FNQShtZXRhRGF0YS5nYW1tYSkpO1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkRGF0YSA9IHBhY2tlci5maWx0ZXJEYXRhKG1ldGFEYXRhLmRhdGEsIG1ldGFEYXRhLndpZHRoLCBtZXRhRGF0YS5oZWlnaHQpO1xuXG4gIC8vIGNvbXByZXNzIGl0XG4gIHZhciBjb21wcmVzc2VkRGF0YSA9IHpsaWIuZGVmbGF0ZVN5bmMoZmlsdGVyZWREYXRhLCBwYWNrZXIuZ2V0RGVmbGF0ZU9wdGlvbnMoKSk7XG4gIGZpbHRlcmVkRGF0YSA9IG51bGw7XG5cbiAgaWYgKCFjb21wcmVzc2VkRGF0YSB8fCAhY29tcHJlc3NlZERhdGEubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG5nIC0gaW52YWxpZCBjb21wcmVzc2VkIGRhdGEgcmVzcG9uc2UnKTtcbiAgfVxuICBjaHVua3MucHVzaChwYWNrZXIucGFja0lEQVQoY29tcHJlc3NlZERhdGEpKTtcblxuICAvLyBFbmRcbiAgY2h1bmtzLnB1c2gocGFja2VyLnBhY2tJRU5EKCkpO1xuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBDcmNTdHJlYW0gPSByZXF1aXJlKCcuL2NyYycpO1xudmFyIGJpdFBhY2tlciA9IHJlcXVpcmUoJy4vYml0cGFja2VyJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXItcGFjaycpO1xudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbnZhciBQYWNrZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgb3B0aW9ucy5kZWZsYXRlQ2h1bmtTaXplID0gb3B0aW9ucy5kZWZsYXRlQ2h1bmtTaXplIHx8IDMyICogMTAyNDtcbiAgb3B0aW9ucy5kZWZsYXRlTGV2ZWwgPSBvcHRpb25zLmRlZmxhdGVMZXZlbCAhPSBudWxsID8gb3B0aW9ucy5kZWZsYXRlTGV2ZWwgOiA5O1xuICBvcHRpb25zLmRlZmxhdGVTdHJhdGVneSA9IG9wdGlvbnMuZGVmbGF0ZVN0cmF0ZWd5ICE9IG51bGwgPyBvcHRpb25zLmRlZmxhdGVTdHJhdGVneSA6IDM7XG4gIG9wdGlvbnMuaW5wdXRIYXNBbHBoYSA9IG9wdGlvbnMuaW5wdXRIYXNBbHBoYSAhPSBudWxsID8gb3B0aW9ucy5pbnB1dEhhc0FscGhhIDogdHJ1ZTtcbiAgb3B0aW9ucy5kZWZsYXRlRmFjdG9yeSA9IG9wdGlvbnMuZGVmbGF0ZUZhY3RvcnkgfHwgemxpYi5jcmVhdGVEZWZsYXRlO1xuICBvcHRpb25zLmJpdERlcHRoID0gb3B0aW9ucy5iaXREZXB0aCB8fCA4O1xuICAvLyBUaGlzIGlzIG91dHB1dENvbG9yVHlwZVxuICBvcHRpb25zLmNvbG9yVHlwZSA9ICh0eXBlb2Ygb3B0aW9ucy5jb2xvclR5cGUgPT09ICdudW1iZXInKSA/IG9wdGlvbnMuY29sb3JUeXBlIDogY29uc3RhbnRzLkNPTE9SVFlQRV9DT0xPUl9BTFBIQTtcbiAgb3B0aW9ucy5pbnB1dENvbG9yVHlwZSA9ICh0eXBlb2Ygb3B0aW9ucy5pbnB1dENvbG9yVHlwZSA9PT0gJ251bWJlcicpID8gb3B0aW9ucy5pbnB1dENvbG9yVHlwZSA6IGNvbnN0YW50cy5DT0xPUlRZUEVfQ09MT1JfQUxQSEE7XG5cbiAgaWYgKFtcbiAgICBjb25zdGFudHMuQ09MT1JUWVBFX0dSQVlTQ0FMRSxcbiAgICBjb25zdGFudHMuQ09MT1JUWVBFX0NPTE9SLFxuICAgIGNvbnN0YW50cy5DT0xPUlRZUEVfQ09MT1JfQUxQSEEsXG4gICAgY29uc3RhbnRzLkNPTE9SVFlQRV9BTFBIQVxuICBdLmluZGV4T2Yob3B0aW9ucy5jb2xvclR5cGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uIGNvbG9yIHR5cGU6JyArIG9wdGlvbnMuY29sb3JUeXBlICsgJyBpcyBub3Qgc3VwcG9ydGVkIGF0IHByZXNlbnQnKTtcbiAgfVxuICBpZiAoW1xuICAgIGNvbnN0YW50cy5DT0xPUlRZUEVfR1JBWVNDQUxFLFxuICAgIGNvbnN0YW50cy5DT0xPUlRZUEVfQ09MT1IsXG4gICAgY29uc3RhbnRzLkNPTE9SVFlQRV9DT0xPUl9BTFBIQSxcbiAgICBjb25zdGFudHMuQ09MT1JUWVBFX0FMUEhBXG4gIF0uaW5kZXhPZihvcHRpb25zLmlucHV0Q29sb3JUeXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbiBpbnB1dCBjb2xvciB0eXBlOicgKyBvcHRpb25zLmlucHV0Q29sb3JUeXBlICsgJyBpcyBub3Qgc3VwcG9ydGVkIGF0IHByZXNlbnQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5iaXREZXB0aCAhPT0gOCAmJiBvcHRpb25zLmJpdERlcHRoICE9PSAxNikge1xuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uIGJpdCBkZXB0aDonICsgb3B0aW9ucy5iaXREZXB0aCArICcgaXMgbm90IHN1cHBvcnRlZCBhdCBwcmVzZW50Jyk7XG4gIH1cbn07XG5cblBhY2tlci5wcm90b3R5cGUuZ2V0RGVmbGF0ZU9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBjaHVua1NpemU6IHRoaXMuX29wdGlvbnMuZGVmbGF0ZUNodW5rU2l6ZSxcbiAgICBsZXZlbDogdGhpcy5fb3B0aW9ucy5kZWZsYXRlTGV2ZWwsXG4gICAgc3RyYXRlZ3k6IHRoaXMuX29wdGlvbnMuZGVmbGF0ZVN0cmF0ZWd5XG4gIH07XG59O1xuXG5QYWNrZXIucHJvdG90eXBlLmNyZWF0ZURlZmxhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZGVmbGF0ZUZhY3RvcnkodGhpcy5nZXREZWZsYXRlT3B0aW9ucygpKTtcbn07XG5cblBhY2tlci5wcm90b3R5cGUuZmlsdGVyRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgLy8gY29udmVydCB0byBjb3JyZWN0IGZvcm1hdCBmb3IgZmlsdGVyaW5nIChlLmcuIHJpZ2h0IGJwcCBhbmQgYml0IGRlcHRoKVxuICB2YXIgcGFja2VkRGF0YSA9IGJpdFBhY2tlcihkYXRhLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9vcHRpb25zKTtcblxuICAvLyBmaWx0ZXIgcGl4ZWwgZGF0YVxuICB2YXIgYnBwID0gY29uc3RhbnRzLkNPTE9SVFlQRV9UT19CUFBfTUFQW3RoaXMuX29wdGlvbnMuY29sb3JUeXBlXTtcbiAgdmFyIGZpbHRlcmVkRGF0YSA9IGZpbHRlcihwYWNrZWREYXRhLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLl9vcHRpb25zLCBicHApO1xuICByZXR1cm4gZmlsdGVyZWREYXRhO1xufTtcblxuUGFja2VyLnByb3RvdHlwZS5fcGFja0NodW5rID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuXG4gIHZhciBsZW4gPSAoZGF0YSA/IGRhdGEubGVuZ3RoIDogMCk7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbiArIDEyKTtcblxuICBidWYud3JpdGVVSW50MzJCRShsZW4sIDApO1xuICBidWYud3JpdGVVSW50MzJCRSh0eXBlLCA0KTtcblxuICBpZiAoZGF0YSkge1xuICAgIGRhdGEuY29weShidWYsIDgpO1xuICB9XG5cbiAgYnVmLndyaXRlSW50MzJCRShDcmNTdHJlYW0uY3JjMzIoYnVmLnNsaWNlKDQsIGJ1Zi5sZW5ndGggLSA0KSksIGJ1Zi5sZW5ndGggLSA0KTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblBhY2tlci5wcm90b3R5cGUucGFja0dBTUEgPSBmdW5jdGlvbihnYW1tYSkge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcig0KTtcbiAgYnVmLndyaXRlVUludDMyQkUoTWF0aC5mbG9vcihnYW1tYSAqIGNvbnN0YW50cy5HQU1NQV9ESVZJU0lPTiksIDApO1xuICByZXR1cm4gdGhpcy5fcGFja0NodW5rKGNvbnN0YW50cy5UWVBFX2dBTUEsIGJ1Zik7XG59O1xuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tJSERSID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDEzKTtcbiAgYnVmLndyaXRlVUludDMyQkUod2lkdGgsIDApO1xuICBidWYud3JpdGVVSW50MzJCRShoZWlnaHQsIDQpO1xuICBidWZbOF0gPSB0aGlzLl9vcHRpb25zLmJpdERlcHRoOyAvLyBCaXQgZGVwdGhcbiAgYnVmWzldID0gdGhpcy5fb3B0aW9ucy5jb2xvclR5cGU7IC8vIGNvbG9yVHlwZVxuICBidWZbMTBdID0gMDsgLy8gY29tcHJlc3Npb25cbiAgYnVmWzExXSA9IDA7IC8vIGZpbHRlclxuICBidWZbMTJdID0gMDsgLy8gaW50ZXJsYWNlXG5cbiAgcmV0dXJuIHRoaXMuX3BhY2tDaHVuayhjb25zdGFudHMuVFlQRV9JSERSLCBidWYpO1xufTtcblxuUGFja2VyLnByb3RvdHlwZS5wYWNrSURBVCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHRoaXMuX3BhY2tDaHVuayhjb25zdGFudHMuVFlQRV9JREFULCBkYXRhKTtcbn07XG5cblBhY2tlci5wcm90b3R5cGUucGFja0lFTkQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BhY2tDaHVuayhjb25zdGFudHMuVFlQRV9JRU5ELCBudWxsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhZXRoUHJlZGljdG9yKGxlZnQsIGFib3ZlLCB1cExlZnQpIHtcclxuXHJcbiAgdmFyIHBhZXRoID0gbGVmdCArIGFib3ZlIC0gdXBMZWZ0O1xyXG4gIHZhciBwTGVmdCA9IE1hdGguYWJzKHBhZXRoIC0gbGVmdCk7XHJcbiAgdmFyIHBBYm92ZSA9IE1hdGguYWJzKHBhZXRoIC0gYWJvdmUpO1xyXG4gIHZhciBwVXBMZWZ0ID0gTWF0aC5hYnMocGFldGggLSB1cExlZnQpO1xyXG5cclxuICBpZiAocExlZnQgPD0gcEFib3ZlICYmIHBMZWZ0IDw9IHBVcExlZnQpIHtcclxuICAgIHJldHVybiBsZWZ0O1xyXG4gIH1cclxuICBpZiAocEFib3ZlIDw9IHBVcExlZnQpIHtcclxuICAgIHJldHVybiBhYm92ZTtcclxuICB9XHJcbiAgcmV0dXJuIHVwTGVmdDtcclxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG52YXIgQ2h1bmtTdHJlYW0gPSByZXF1aXJlKCcuL2NodW5rc3RyZWFtJyk7XG52YXIgRmlsdGVyQXN5bmMgPSByZXF1aXJlKCcuL2ZpbHRlci1wYXJzZS1hc3luYycpO1xudmFyIFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG52YXIgYml0bWFwcGVyID0gcmVxdWlyZSgnLi9iaXRtYXBwZXInKTtcbnZhciBmb3JtYXROb3JtYWxpc2VyID0gcmVxdWlyZSgnLi9mb3JtYXQtbm9ybWFsaXNlcicpO1xuXG52YXIgUGFyc2VyQXN5bmMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgQ2h1bmtTdHJlYW0uY2FsbCh0aGlzKTtcblxuICB0aGlzLl9wYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIHtcbiAgICByZWFkOiB0aGlzLnJlYWQuYmluZCh0aGlzKSxcbiAgICBlcnJvcjogdGhpcy5faGFuZGxlRXJyb3IuYmluZCh0aGlzKSxcbiAgICBtZXRhZGF0YTogdGhpcy5faGFuZGxlTWV0YURhdGEuYmluZCh0aGlzKSxcbiAgICBnYW1tYTogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2dhbW1hJyksXG4gICAgcGFsZXR0ZTogdGhpcy5faGFuZGxlUGFsZXR0ZS5iaW5kKHRoaXMpLFxuICAgIHRyYW5zQ29sb3I6IHRoaXMuX2hhbmRsZVRyYW5zQ29sb3IuYmluZCh0aGlzKSxcbiAgICBmaW5pc2hlZDogdGhpcy5fZmluaXNoZWQuYmluZCh0aGlzKSxcbiAgICBpbmZsYXRlRGF0YTogdGhpcy5faW5mbGF0ZURhdGEuYmluZCh0aGlzKVxuICB9KTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIHRoaXMuX3BhcnNlci5zdGFydCgpO1xufTtcbnV0aWwuaW5oZXJpdHMoUGFyc2VyQXN5bmMsIENodW5rU3RyZWFtKTtcblxuXG5QYXJzZXJBc3luYy5wcm90b3R5cGUuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG5cbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLl9pbmZsYXRlICYmIHRoaXMuX2luZmxhdGUuZGVzdHJveSkge1xuICAgIHRoaXMuX2luZmxhdGUuZGVzdHJveSgpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZpbHRlcikge1xuICAgIHRoaXMuX2ZpbHRlci5kZXN0cm95KCk7XG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlIDcgYW5kIGJlbG93LlxuICAgIC8vIFN1cHByZXNzIGVycm9ycyBkdWUgdG8gX2luZmxhdGUgY2FsbGluZyB3cml0ZSgpIGV2ZW4gYWZ0ZXJcbiAgICAvLyBpdCdzIGRlc3Ryb3koKSdlZC5cbiAgICB0aGlzLl9maWx0ZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7fSk7XG4gIH1cblxuICB0aGlzLmVycm9yZCA9IHRydWU7XG59O1xuXG5QYXJzZXJBc3luYy5wcm90b3R5cGUuX2luZmxhdGVEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICBpZiAodGhpcy5fYml0bWFwSW5mby5pbnRlcmxhY2UpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGUoKTtcblxuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKSk7XG4gICAgICB0aGlzLl9maWx0ZXIub24oJ2NvbXBsZXRlJywgdGhpcy5fY29tcGxldGUuYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuX2luZmxhdGUucGlwZSh0aGlzLl9maWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcm93U2l6ZSA9ICgodGhpcy5fYml0bWFwSW5mby53aWR0aCAqIHRoaXMuX2JpdG1hcEluZm8uYnBwICogdGhpcy5fYml0bWFwSW5mby5kZXB0aCArIDcpID4+IDMpICsgMTtcbiAgICAgIHZhciBpbWFnZVNpemUgPSByb3dTaXplICogdGhpcy5fYml0bWFwSW5mby5oZWlnaHQ7XG4gICAgICB2YXIgY2h1bmtTaXplID0gTWF0aC5tYXgoaW1hZ2VTaXplLCB6bGliLlpfTUlOX0NIVU5LKTtcbiAgICAgIFxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZSh7IGNodW5rU2l6ZTogY2h1bmtTaXplIH0pO1xuICAgICAgdmFyIGxlZnRUb0luZmxhdGUgPSBpbWFnZVNpemU7XG5cbiAgICAgIHZhciBlbWl0RXJyb3IgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmICghbGVmdFRvSW5mbGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9maWx0ZXIub24oJ2NvbXBsZXRlJywgdGhpcy5fY29tcGxldGUuYmluZCh0aGlzKSk7XG5cbiAgICAgIHZhciBmaWx0ZXJXcml0ZSA9IHRoaXMuX2ZpbHRlci53cml0ZS5iaW5kKHRoaXMuX2ZpbHRlcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgaWYgKCFsZWZ0VG9JbmZsYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA+IGxlZnRUb0luZmxhdGUpIHtcbiAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGxlZnRUb0luZmxhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVmdFRvSW5mbGF0ZSAtPSBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgZmlsdGVyV3JpdGUoY2h1bmspO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2VuZCcsIHRoaXMuX2ZpbHRlci5lbmQuYmluZCh0aGlzLl9maWx0ZXIpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbn07XG5cblBhcnNlckFzeW5jLnByb3RvdHlwZS5faGFuZGxlTWV0YURhdGEgPSBmdW5jdGlvbihtZXRhRGF0YSkge1xuXG4gIHRoaXMuZW1pdCgnbWV0YWRhdGEnLCBtZXRhRGF0YSk7XG5cbiAgdGhpcy5fYml0bWFwSW5mbyA9IE9iamVjdC5jcmVhdGUobWV0YURhdGEpO1xuXG4gIHRoaXMuX2ZpbHRlciA9IG5ldyBGaWx0ZXJBc3luYyh0aGlzLl9iaXRtYXBJbmZvKTtcbn07XG5cblBhcnNlckFzeW5jLnByb3RvdHlwZS5faGFuZGxlVHJhbnNDb2xvciA9IGZ1bmN0aW9uKHRyYW5zQ29sb3IpIHtcbiAgdGhpcy5fYml0bWFwSW5mby50cmFuc0NvbG9yID0gdHJhbnNDb2xvcjtcbn07XG5cblBhcnNlckFzeW5jLnByb3RvdHlwZS5faGFuZGxlUGFsZXR0ZSA9IGZ1bmN0aW9uKHBhbGV0dGUpIHtcbiAgdGhpcy5fYml0bWFwSW5mby5wYWxldHRlID0gcGFsZXR0ZTtcbn07XG5cblxuUGFyc2VyQXN5bmMucHJvdG90eXBlLl9maW5pc2hlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5lcnJvcmQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgJ05vIEluZmxhdGUgYmxvY2snKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBubyBtb3JlIGRhdGEgdG8gaW5mbGF0ZVxuICAgIHRoaXMuX2luZmxhdGUuZW5kKCk7XG4gIH1cbiAgdGhpcy5kZXN0cm95U29vbigpO1xufTtcblxuUGFyc2VyQXN5bmMucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uKGZpbHRlcmVkRGF0YSkge1xuXG4gIGlmICh0aGlzLmVycm9yZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGJpdG1hcERhdGEgPSBiaXRtYXBwZXIuZGF0YVRvQml0TWFwKGZpbHRlcmVkRGF0YSwgdGhpcy5fYml0bWFwSW5mbyk7XG5cbiAgICB2YXIgbm9ybWFsaXNlZEJpdG1hcERhdGEgPSBmb3JtYXROb3JtYWxpc2VyKGJpdG1hcERhdGEsIHRoaXMuX2JpdG1hcEluZm8pO1xuICAgIGJpdG1hcERhdGEgPSBudWxsO1xuICB9XG4gIGNhdGNoIChleCkge1xuICAgIHRoaXMuX2hhbmRsZUVycm9yKGV4KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVtaXQoJ3BhcnNlZCcsIG5vcm1hbGlzZWRCaXRtYXBEYXRhKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW5jWmxpYiA9IHRydWU7XG52YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbnZhciBpbmZsYXRlU3luYyA9IHJlcXVpcmUoJy4vc3luYy1pbmZsYXRlJyk7XG5pZiAoIXpsaWIuZGVmbGF0ZVN5bmMpIHtcbiAgaGFzU3luY1psaWIgPSBmYWxzZTtcbn1cbnZhciBTeW5jUmVhZGVyID0gcmVxdWlyZSgnLi9zeW5jLXJlYWRlcicpO1xudmFyIEZpbHRlclN5bmMgPSByZXF1aXJlKCcuL2ZpbHRlci1wYXJzZS1zeW5jJyk7XG52YXIgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciBiaXRtYXBwZXIgPSByZXF1aXJlKCcuL2JpdG1hcHBlcicpO1xudmFyIGZvcm1hdE5vcm1hbGlzZXIgPSByZXF1aXJlKCcuL2Zvcm1hdC1ub3JtYWxpc2VyJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihidWZmZXIsIG9wdGlvbnMpIHtcblxuICBpZiAoIWhhc1N5bmNabGliKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUbyB1c2UgdGhlIHN5bmMgY2FwYWJpbGl0eSBvZiB0aGlzIGxpYnJhcnkgaW4gb2xkIG5vZGUgdmVyc2lvbnMsIHBsZWFzZSBwaW4gcG5nanMgdG8gdjIuMy4wJyk7XG4gIH1cblxuICB2YXIgZXJyO1xuICBmdW5jdGlvbiBoYW5kbGVFcnJvcihfZXJyXykge1xuICAgIGVyciA9IF9lcnJfO1xuICB9XG5cbiAgdmFyIG1ldGFEYXRhO1xuICBmdW5jdGlvbiBoYW5kbGVNZXRhRGF0YShfbWV0YURhdGFfKSB7XG4gICAgbWV0YURhdGEgPSBfbWV0YURhdGFfO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVHJhbnNDb2xvcih0cmFuc0NvbG9yKSB7XG4gICAgbWV0YURhdGEudHJhbnNDb2xvciA9IHRyYW5zQ29sb3I7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQYWxldHRlKHBhbGV0dGUpIHtcbiAgICBtZXRhRGF0YS5wYWxldHRlID0gcGFsZXR0ZTtcbiAgfVxuXG4gIHZhciBnYW1tYTtcbiAgZnVuY3Rpb24gaGFuZGxlR2FtbWEoX2dhbW1hXykge1xuICAgIGdhbW1hID0gX2dhbW1hXztcbiAgfVxuXG4gIHZhciBpbmZsYXRlRGF0YUxpc3QgPSBbXTtcbiAgZnVuY3Rpb24gaGFuZGxlSW5mbGF0ZURhdGEoaW5mbGF0ZWREYXRhKSB7XG4gICAgaW5mbGF0ZURhdGFMaXN0LnB1c2goaW5mbGF0ZWREYXRhKTtcbiAgfVxuXG4gIHZhciByZWFkZXIgPSBuZXcgU3luY1JlYWRlcihidWZmZXIpO1xuXG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIHtcbiAgICByZWFkOiByZWFkZXIucmVhZC5iaW5kKHJlYWRlciksXG4gICAgZXJyb3I6IGhhbmRsZUVycm9yLFxuICAgIG1ldGFkYXRhOiBoYW5kbGVNZXRhRGF0YSxcbiAgICBnYW1tYTogaGFuZGxlR2FtbWEsXG4gICAgcGFsZXR0ZTogaGFuZGxlUGFsZXR0ZSxcbiAgICB0cmFuc0NvbG9yOiBoYW5kbGVUcmFuc0NvbG9yLFxuICAgIGluZmxhdGVEYXRhOiBoYW5kbGVJbmZsYXRlRGF0YVxuICB9KTtcblxuICBwYXJzZXIuc3RhcnQoKTtcbiAgcmVhZGVyLnByb2Nlc3MoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLy9qb2luIHRvZ2V0aGVyIHRoZSBpbmZsYXRlIGRhdGFzXG4gIHZhciBpbmZsYXRlRGF0YSA9IEJ1ZmZlci5jb25jYXQoaW5mbGF0ZURhdGFMaXN0KTtcbiAgaW5mbGF0ZURhdGFMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgdmFyIGluZmxhdGVkRGF0YTtcbiAgaWYgKG1ldGFEYXRhLmludGVybGFjZSkge1xuICAgIGluZmxhdGVkRGF0YSA9IHpsaWIuaW5mbGF0ZVN5bmMoaW5mbGF0ZURhdGEpO1xuICB9IGVsc2Uge1xuICAgIHZhciByb3dTaXplID0gKChtZXRhRGF0YS53aWR0aCAqIG1ldGFEYXRhLmJwcCAqIG1ldGFEYXRhLmRlcHRoICsgNykgPj4gMykgKyAxO1xuICAgIHZhciBpbWFnZVNpemUgPSByb3dTaXplICogbWV0YURhdGEuaGVpZ2h0O1xuICAgIGluZmxhdGVkRGF0YSA9IGluZmxhdGVTeW5jKGluZmxhdGVEYXRhLCB7IGNodW5rU2l6ZTogaW1hZ2VTaXplLCBtYXhMZW5ndGg6IGltYWdlU2l6ZSB9KTtcbiAgfVxuICBpbmZsYXRlRGF0YSA9IG51bGw7XG5cbiAgaWYgKCFpbmZsYXRlZERhdGEgfHwgIWluZmxhdGVkRGF0YS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwbmcgLSBpbnZhbGlkIGluZmxhdGUgZGF0YSByZXNwb25zZScpO1xuICB9XG5cbiAgdmFyIHVuZmlsdGVyZWREYXRhID0gRmlsdGVyU3luYy5wcm9jZXNzKGluZmxhdGVkRGF0YSwgbWV0YURhdGEpO1xuICBpbmZsYXRlRGF0YSA9IG51bGw7XG5cbiAgdmFyIGJpdG1hcERhdGEgPSBiaXRtYXBwZXIuZGF0YVRvQml0TWFwKHVuZmlsdGVyZWREYXRhLCBtZXRhRGF0YSk7XG4gIHVuZmlsdGVyZWREYXRhID0gbnVsbDtcblxuICB2YXIgbm9ybWFsaXNlZEJpdG1hcERhdGEgPSBmb3JtYXROb3JtYWxpc2VyKGJpdG1hcERhdGEsIG1ldGFEYXRhKTtcblxuICBtZXRhRGF0YS5kYXRhID0gbm9ybWFsaXNlZEJpdG1hcERhdGE7XG4gIG1ldGFEYXRhLmdhbW1hID0gZ2FtbWEgfHwgMDtcblxuICByZXR1cm4gbWV0YURhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBDcmNDYWxjdWxhdG9yID0gcmVxdWlyZSgnLi9jcmMnKTtcblxuXG52YXIgUGFyc2VyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zLCBkZXBlbmRlbmNpZXMpIHtcblxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgb3B0aW9ucy5jaGVja0NSQyA9IG9wdGlvbnMuY2hlY2tDUkMgIT09IGZhbHNlO1xuXG4gIHRoaXMuX2hhc0lIRFIgPSBmYWxzZTtcbiAgdGhpcy5faGFzSUVORCA9IGZhbHNlO1xuXG4gIC8vIGlucHV0IGZsYWdzL21ldGFkYXRhXG4gIHRoaXMuX3BhbGV0dGUgPSBbXTtcbiAgdGhpcy5fY29sb3JUeXBlID0gMDtcblxuICB0aGlzLl9jaHVua3MgPSB7fTtcbiAgdGhpcy5fY2h1bmtzW2NvbnN0YW50cy5UWVBFX0lIRFJdID0gdGhpcy5faGFuZGxlSUhEUi5iaW5kKHRoaXMpO1xuICB0aGlzLl9jaHVua3NbY29uc3RhbnRzLlRZUEVfSUVORF0gPSB0aGlzLl9oYW5kbGVJRU5ELmJpbmQodGhpcyk7XG4gIHRoaXMuX2NodW5rc1tjb25zdGFudHMuVFlQRV9JREFUXSA9IHRoaXMuX2hhbmRsZUlEQVQuYmluZCh0aGlzKTtcbiAgdGhpcy5fY2h1bmtzW2NvbnN0YW50cy5UWVBFX1BMVEVdID0gdGhpcy5faGFuZGxlUExURS5iaW5kKHRoaXMpO1xuICB0aGlzLl9jaHVua3NbY29uc3RhbnRzLlRZUEVfdFJOU10gPSB0aGlzLl9oYW5kbGVUUk5TLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NodW5rc1tjb25zdGFudHMuVFlQRV9nQU1BXSA9IHRoaXMuX2hhbmRsZUdBTUEuYmluZCh0aGlzKTtcblxuICB0aGlzLnJlYWQgPSBkZXBlbmRlbmNpZXMucmVhZDtcbiAgdGhpcy5lcnJvciA9IGRlcGVuZGVuY2llcy5lcnJvcjtcbiAgdGhpcy5tZXRhZGF0YSA9IGRlcGVuZGVuY2llcy5tZXRhZGF0YTtcbiAgdGhpcy5nYW1tYSA9IGRlcGVuZGVuY2llcy5nYW1tYTtcbiAgdGhpcy50cmFuc0NvbG9yID0gZGVwZW5kZW5jaWVzLnRyYW5zQ29sb3I7XG4gIHRoaXMucGFsZXR0ZSA9IGRlcGVuZGVuY2llcy5wYWxldHRlO1xuICB0aGlzLnBhcnNlZCA9IGRlcGVuZGVuY2llcy5wYXJzZWQ7XG4gIHRoaXMuaW5mbGF0ZURhdGEgPSBkZXBlbmRlbmNpZXMuaW5mbGF0ZURhdGE7XG4gIHRoaXMuZmluaXNoZWQgPSBkZXBlbmRlbmNpZXMuZmluaXNoZWQ7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVhZChjb25zdGFudHMuUE5HX1NJR05BVFVSRS5sZW5ndGgsXG4gICAgdGhpcy5fcGFyc2VTaWduYXR1cmUuYmluZCh0aGlzKVxuICApO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTaWduYXR1cmUgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgdmFyIHNpZ25hdHVyZSA9IGNvbnN0YW50cy5QTkdfU0lHTkFUVVJFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGFbaV0gIT09IHNpZ25hdHVyZVtpXSkge1xuICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgZmlsZSBzaWduYXR1cmUnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHRoaXMucmVhZCg4LCB0aGlzLl9wYXJzZUNodW5rQmVnaW4uYmluZCh0aGlzKSk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNodW5rQmVnaW4gPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgLy8gY2h1bmsgY29udGVudCBsZW5ndGhcbiAgdmFyIGxlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkJFKDApO1xuXG4gIC8vIGNodW5rIHR5cGVcbiAgdmFyIHR5cGUgPSBkYXRhLnJlYWRVSW50MzJCRSg0KTtcbiAgdmFyIG5hbWUgPSAnJztcbiAgZm9yICh2YXIgaSA9IDQ7IGkgPCA4OyBpKyspIHtcbiAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSk7XG4gIH1cblxuICAvL2NvbnNvbGUubG9nKCdjaHVuayAnLCBuYW1lLCBsZW5ndGgpO1xuXG4gIC8vIGNodW5rIGZsYWdzXG4gIHZhciBhbmNpbGxhcnkgPSBCb29sZWFuKGRhdGFbNF0gJiAweDIwKTsgLy8gb3IgY3JpdGljYWxcbi8vICAgIHByaXYgPSBCb29sZWFuKGRhdGFbNV0gJiAweDIwKSwgLy8gb3IgcHVibGljXG4vLyAgICBzYWZlVG9Db3B5ID0gQm9vbGVhbihkYXRhWzddICYgMHgyMCk7IC8vIG9yIHVuc2FmZVxuXG4gIGlmICghdGhpcy5faGFzSUhEUiAmJiB0eXBlICE9PSBjb25zdGFudHMuVFlQRV9JSERSKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ0V4cGVjdGVkIElIRFIgb24gYmVnZ2luaW5nJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2NyYyA9IG5ldyBDcmNDYWxjdWxhdG9yKCk7XG4gIHRoaXMuX2NyYy53cml0ZShuZXcgQnVmZmVyKG5hbWUpKTtcblxuICBpZiAodGhpcy5fY2h1bmtzW3R5cGVdKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NodW5rc1t0eXBlXShsZW5ndGgpO1xuICB9XG5cbiAgaWYgKCFhbmNpbGxhcnkpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY3JpdGljYWwgY2h1bmsgdHlwZSAnICsgbmFtZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucmVhZChsZW5ndGggKyA0LCB0aGlzLl9za2lwQ2h1bmsuYmluZCh0aGlzKSk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9za2lwQ2h1bmsgPSBmdW5jdGlvbigvKmRhdGEqLykge1xuICB0aGlzLnJlYWQoOCwgdGhpcy5fcGFyc2VDaHVua0JlZ2luLmJpbmQodGhpcykpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5faGFuZGxlQ2h1bmtFbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWFkKDQsIHRoaXMuX3BhcnNlQ2h1bmtFbmQuYmluZCh0aGlzKSk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNodW5rRW5kID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gIHZhciBmaWxlQ3JjID0gZGF0YS5yZWFkSW50MzJCRSgwKTtcbiAgdmFyIGNhbGNDcmMgPSB0aGlzLl9jcmMuY3JjMzIoKTtcblxuICAvLyBjaGVjayBDUkNcbiAgaWYgKHRoaXMuX29wdGlvbnMuY2hlY2tDUkMgJiYgY2FsY0NyYyAhPT0gZmlsZUNyYykge1xuICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdDcmMgZXJyb3IgLSAnICsgZmlsZUNyYyArICcgLSAnICsgY2FsY0NyYykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdGhpcy5faGFzSUVORCkge1xuICAgIHRoaXMucmVhZCg4LCB0aGlzLl9wYXJzZUNodW5rQmVnaW4uYmluZCh0aGlzKSk7XG4gIH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2hhbmRsZUlIRFIgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgdGhpcy5yZWFkKGxlbmd0aCwgdGhpcy5fcGFyc2VJSERSLmJpbmQodGhpcykpO1xufTtcblBhcnNlci5wcm90b3R5cGUuX3BhcnNlSUhEUiA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICB0aGlzLl9jcmMud3JpdGUoZGF0YSk7XG5cbiAgdmFyIHdpZHRoID0gZGF0YS5yZWFkVUludDMyQkUoMCk7XG4gIHZhciBoZWlnaHQgPSBkYXRhLnJlYWRVSW50MzJCRSg0KTtcbiAgdmFyIGRlcHRoID0gZGF0YVs4XTtcbiAgdmFyIGNvbG9yVHlwZSA9IGRhdGFbOV07IC8vIGJpdHM6IDEgcGFsZXR0ZSwgMiBjb2xvciwgNCBhbHBoYVxuICB2YXIgY29tcHIgPSBkYXRhWzEwXTtcbiAgdmFyIGZpbHRlciA9IGRhdGFbMTFdO1xuICB2YXIgaW50ZXJsYWNlID0gZGF0YVsxMl07XG5cbiAgLy8gY29uc29sZS5sb2coJyAgICB3aWR0aCcsIHdpZHRoLCAnaGVpZ2h0JywgaGVpZ2h0LFxuICAvLyAgICAgJ2RlcHRoJywgZGVwdGgsICdjb2xvclR5cGUnLCBjb2xvclR5cGUsXG4gIC8vICAgICAnY29tcHInLCBjb21wciwgJ2ZpbHRlcicsIGZpbHRlciwgJ2ludGVybGFjZScsIGludGVybGFjZVxuICAvLyApO1xuXG4gIGlmIChkZXB0aCAhPT0gOCAmJiBkZXB0aCAhPT0gNCAmJiBkZXB0aCAhPT0gMiAmJiBkZXB0aCAhPT0gMSAmJiBkZXB0aCAhPT0gMTYpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYml0IGRlcHRoICcgKyBkZXB0aCkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShjb2xvclR5cGUgaW4gY29uc3RhbnRzLkNPTE9SVFlQRV9UT19CUFBfTUFQKSkge1xuICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjb2xvciB0eXBlJykpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY29tcHIgIT09IDApIHtcbiAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kJykpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZmlsdGVyICE9PSAwKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZpbHRlciBtZXRob2QnKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnRlcmxhY2UgIT09IDAgJiYgaW50ZXJsYWNlICE9PSAxKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGludGVybGFjZSBtZXRob2QnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY29sb3JUeXBlID0gY29sb3JUeXBlO1xuXG4gIHZhciBicHAgPSBjb25zdGFudHMuQ09MT1JUWVBFX1RPX0JQUF9NQVBbdGhpcy5fY29sb3JUeXBlXTtcblxuICB0aGlzLl9oYXNJSERSID0gdHJ1ZTtcblxuICB0aGlzLm1ldGFkYXRhKHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgZGVwdGg6IGRlcHRoLFxuICAgIGludGVybGFjZTogQm9vbGVhbihpbnRlcmxhY2UpLFxuICAgIHBhbGV0dGU6IEJvb2xlYW4oY29sb3JUeXBlICYgY29uc3RhbnRzLkNPTE9SVFlQRV9QQUxFVFRFKSxcbiAgICBjb2xvcjogQm9vbGVhbihjb2xvclR5cGUgJiBjb25zdGFudHMuQ09MT1JUWVBFX0NPTE9SKSxcbiAgICBhbHBoYTogQm9vbGVhbihjb2xvclR5cGUgJiBjb25zdGFudHMuQ09MT1JUWVBFX0FMUEhBKSxcbiAgICBicHA6IGJwcCxcbiAgICBjb2xvclR5cGU6IGNvbG9yVHlwZVxuICB9KTtcblxuICB0aGlzLl9oYW5kbGVDaHVua0VuZCgpO1xufTtcblxuXG5QYXJzZXIucHJvdG90eXBlLl9oYW5kbGVQTFRFID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHRoaXMucmVhZChsZW5ndGgsIHRoaXMuX3BhcnNlUExURS5iaW5kKHRoaXMpKTtcbn07XG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVBMVEUgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgdGhpcy5fY3JjLndyaXRlKGRhdGEpO1xuXG4gIHZhciBlbnRyaWVzID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIDMpO1xuICAvLyBjb25zb2xlLmxvZygnUGFsZXR0ZTonLCBlbnRyaWVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXM7IGkrKykge1xuICAgIHRoaXMuX3BhbGV0dGUucHVzaChbXG4gICAgICBkYXRhW2kgKiAzXSxcbiAgICAgIGRhdGFbaSAqIDMgKyAxXSxcbiAgICAgIGRhdGFbaSAqIDMgKyAyXSxcbiAgICAgIDB4ZmZcbiAgICBdKTtcbiAgfVxuXG4gIHRoaXMucGFsZXR0ZSh0aGlzLl9wYWxldHRlKTtcblxuICB0aGlzLl9oYW5kbGVDaHVua0VuZCgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5faGFuZGxlVFJOUyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB0aGlzLnJlYWQobGVuZ3RoLCB0aGlzLl9wYXJzZVRSTlMuYmluZCh0aGlzKSk7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VUUk5TID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gIHRoaXMuX2NyYy53cml0ZShkYXRhKTtcblxuICAvLyBwYWxldHRlXG4gIGlmICh0aGlzLl9jb2xvclR5cGUgPT09IGNvbnN0YW50cy5DT0xPUlRZUEVfUEFMRVRURV9DT0xPUikge1xuICAgIGlmICh0aGlzLl9wYWxldHRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1RyYW5zcGFyZW5jeSBjaHVuayBtdXN0IGJlIGFmdGVyIHBhbGV0dGUnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCA+IHRoaXMuX3BhbGV0dGUubGVuZ3RoKSB7XG4gICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignTW9yZSB0cmFuc3BhcmVudCBjb2xvcnMgdGhhbiBwYWxldHRlIHNpemUnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcGFsZXR0ZVtpXVszXSA9IGRhdGFbaV07XG4gICAgfVxuICAgIHRoaXMucGFsZXR0ZSh0aGlzLl9wYWxldHRlKTtcbiAgfVxuXG4gIC8vIGZvciBjb2xvclR5cGUgMCAoZ3JheXNjYWxlKSBhbmQgMiAocmdiKVxuICAvLyB0aGVyZSBtaWdodCBiZSBvbmUgZ3JheS9jb2xvciBkZWZpbmVkIGFzIHRyYW5zcGFyZW50XG4gIGlmICh0aGlzLl9jb2xvclR5cGUgPT09IGNvbnN0YW50cy5DT0xPUlRZUEVfR1JBWVNDQUxFKSB7XG4gICAgLy8gZ3JleSwgMiBieXRlc1xuICAgIHRoaXMudHJhbnNDb2xvcihbZGF0YS5yZWFkVUludDE2QkUoMCldKTtcbiAgfVxuICBpZiAodGhpcy5fY29sb3JUeXBlID09PSBjb25zdGFudHMuQ09MT1JUWVBFX0NPTE9SKSB7XG4gICAgdGhpcy50cmFuc0NvbG9yKFtkYXRhLnJlYWRVSW50MTZCRSgwKSwgZGF0YS5yZWFkVUludDE2QkUoMiksIGRhdGEucmVhZFVJbnQxNkJFKDQpXSk7XG4gIH1cblxuICB0aGlzLl9oYW5kbGVDaHVua0VuZCgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5faGFuZGxlR0FNQSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB0aGlzLnJlYWQobGVuZ3RoLCB0aGlzLl9wYXJzZUdBTUEuYmluZCh0aGlzKSk7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VHQU1BID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gIHRoaXMuX2NyYy53cml0ZShkYXRhKTtcbiAgdGhpcy5nYW1tYShkYXRhLnJlYWRVSW50MzJCRSgwKSAvIGNvbnN0YW50cy5HQU1NQV9ESVZJU0lPTik7XG5cbiAgdGhpcy5faGFuZGxlQ2h1bmtFbmQoKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2hhbmRsZUlEQVQgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgdGhpcy5yZWFkKC1sZW5ndGgsIHRoaXMuX3BhcnNlSURBVC5iaW5kKHRoaXMsIGxlbmd0aCkpO1xufTtcblBhcnNlci5wcm90b3R5cGUuX3BhcnNlSURBVCA9IGZ1bmN0aW9uKGxlbmd0aCwgZGF0YSkge1xuXG4gIHRoaXMuX2NyYy53cml0ZShkYXRhKTtcblxuICBpZiAodGhpcy5fY29sb3JUeXBlID09PSBjb25zdGFudHMuQ09MT1JUWVBFX1BBTEVUVEVfQ09MT1IgJiYgdGhpcy5fcGFsZXR0ZS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhbGV0dGUgbm90IGZvdW5kJyk7XG4gIH1cblxuICB0aGlzLmluZmxhdGVEYXRhKGRhdGEpO1xuICB2YXIgbGVmdE92ZXJMZW5ndGggPSBsZW5ndGggLSBkYXRhLmxlbmd0aDtcblxuICBpZiAobGVmdE92ZXJMZW5ndGggPiAwKSB7XG4gICAgdGhpcy5faGFuZGxlSURBVChsZWZ0T3Zlckxlbmd0aCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5faGFuZGxlQ2h1bmtFbmQoKTtcbiAgfVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5faGFuZGxlSUVORCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB0aGlzLnJlYWQobGVuZ3RoLCB0aGlzLl9wYXJzZUlFTkQuYmluZCh0aGlzKSk7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VJRU5EID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gIHRoaXMuX2NyYy53cml0ZShkYXRhKTtcblxuICB0aGlzLl9oYXNJRU5EID0gdHJ1ZTtcbiAgdGhpcy5faGFuZGxlQ2h1bmtFbmQoKTtcblxuICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgIHRoaXMuZmluaXNoZWQoKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlci1zeW5jJyk7XG52YXIgcGFjayA9IHJlcXVpcmUoJy4vcGFja2VyLXN5bmMnKTtcblxuXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9wdGlvbnMpIHtcblxuICByZXR1cm4gcGFyc2UoYnVmZmVyLCBvcHRpb25zIHx8IHt9KTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihwbmcsIG9wdGlvbnMpIHtcblxuICByZXR1cm4gcGFjayhwbmcsIG9wdGlvbnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXItYXN5bmMnKTtcbnZhciBQYWNrZXIgPSByZXF1aXJlKCcuL3BhY2tlci1hc3luYycpO1xudmFyIFBOR1N5bmMgPSByZXF1aXJlKCcuL3BuZy1zeW5jJyk7XG5cblxudmFyIFBORyA9IGV4cG9ydHMuUE5HID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXG4gIC8vIGNvZXJjZSBwaXhlbCBkaW1lbnNpb25zIHRvIGludGVnZXJzIChhbHNvIGNvZXJjZXMgdW5kZWZpbmVkIC0+IDApOlxuICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8IDA7XG4gIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfCAwO1xuXG4gIHRoaXMuZGF0YSA9IHRoaXMud2lkdGggPiAwICYmIHRoaXMuaGVpZ2h0ID4gMCA/XG4gICAgbmV3IEJ1ZmZlcig0ICogdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KSA6IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmRhdGEpIHtcbiAgICB0aGlzLmRhdGEuZmlsbCgwKTtcbiAgfVxuXG4gIHRoaXMuZ2FtbWEgPSAwO1xuICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgdGhpcy5fcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcblxuICB0aGlzLl9wYXJzZXIub24oJ2Vycm9yJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJykpO1xuICB0aGlzLl9wYXJzZXIub24oJ2Nsb3NlJywgdGhpcy5faGFuZGxlQ2xvc2UuYmluZCh0aGlzKSk7XG4gIHRoaXMuX3BhcnNlci5vbignbWV0YWRhdGEnLCB0aGlzLl9tZXRhZGF0YS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5fcGFyc2VyLm9uKCdnYW1tYScsIHRoaXMuX2dhbW1hLmJpbmQodGhpcykpO1xuICB0aGlzLl9wYXJzZXIub24oJ3BhcnNlZCcsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZW1pdCgncGFyc2VkJywgZGF0YSk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5fcGFja2VyID0gbmV3IFBhY2tlcihvcHRpb25zKTtcbiAgdGhpcy5fcGFja2VyLm9uKCdkYXRhJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2RhdGEnKSk7XG4gIHRoaXMuX3BhY2tlci5vbignZW5kJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2VuZCcpKTtcbiAgdGhpcy5fcGFyc2VyLm9uKCdjbG9zZScsIHRoaXMuX2hhbmRsZUNsb3NlLmJpbmQodGhpcykpO1xuICB0aGlzLl9wYWNrZXIub24oJ2Vycm9yJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJykpO1xuXG59O1xudXRpbC5pbmhlcml0cyhQTkcsIFN0cmVhbSk7XG5cblBORy5zeW5jID0gUE5HU3luYztcblxuUE5HLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCF0aGlzLmRhdGEgfHwgIXRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgJ05vIGRhdGEgcHJvdmlkZWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcGFja2VyLnBhY2sodGhpcy5kYXRhLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1tYSk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblBORy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHZhciBvblBhcnNlZCwgb25FcnJvcjtcblxuICAgIG9uUGFyc2VkID0gZnVuY3Rpb24ocGFyc2VkRGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcblxuICAgICAgdGhpcy5kYXRhID0gcGFyc2VkRGF0YTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIG9uRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3BhcnNlZCcsIG9uUGFyc2VkKTtcblxuICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm9uY2UoJ3BhcnNlZCcsIG9uUGFyc2VkKTtcbiAgICB0aGlzLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gIH1cblxuICB0aGlzLmVuZChkYXRhKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5QTkcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl9wYXJzZXIud3JpdGUoZGF0YSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuUE5HLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3BhcnNlci5lbmQoZGF0YSk7XG59O1xuXG5QTkcucHJvdG90eXBlLl9tZXRhZGF0YSA9IGZ1bmN0aW9uKG1ldGFkYXRhKSB7XG4gIHRoaXMud2lkdGggPSBtZXRhZGF0YS53aWR0aDtcbiAgdGhpcy5oZWlnaHQgPSBtZXRhZGF0YS5oZWlnaHQ7XG5cbiAgdGhpcy5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbn07XG5cblBORy5wcm90b3R5cGUuX2dhbW1hID0gZnVuY3Rpb24oZ2FtbWEpIHtcbiAgdGhpcy5nYW1tYSA9IGdhbW1hO1xufTtcblxuUE5HLnByb3RvdHlwZS5faGFuZGxlQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9wYXJzZXIud3JpdGFibGUgJiYgIXRoaXMuX3BhY2tlci5yZWFkYWJsZSkge1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgfVxufTtcblxuXG5QTkcuYml0Ymx0ID0gZnVuY3Rpb24oc3JjLCBkc3QsIHNyY1gsIHNyY1ksIHdpZHRoLCBoZWlnaHQsIGRlbHRhWCwgZGVsdGFZKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LXBhcmFtc1xuICAvLyBjb2VyY2UgcGl4ZWwgZGltZW5zaW9ucyB0byBpbnRlZ2VycyAoYWxzbyBjb2VyY2VzIHVuZGVmaW5lZCAtPiAwKTpcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgc3JjWCB8PSAwO1xuICBzcmNZIHw9IDA7XG4gIHdpZHRoIHw9IDA7XG4gIGhlaWdodCB8PSAwO1xuICBkZWx0YVggfD0gMDtcbiAgZGVsdGFZIHw9IDA7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICBpZiAoc3JjWCA+IHNyYy53aWR0aCB8fCBzcmNZID4gc3JjLmhlaWdodCB8fCBzcmNYICsgd2lkdGggPiBzcmMud2lkdGggfHwgc3JjWSArIGhlaWdodCA+IHNyYy5oZWlnaHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpdGJsdCByZWFkaW5nIG91dHNpZGUgaW1hZ2UnKTtcbiAgfVxuXG4gIGlmIChkZWx0YVggPiBkc3Qud2lkdGggfHwgZGVsdGFZID4gZHN0LmhlaWdodCB8fCBkZWx0YVggKyB3aWR0aCA+IGRzdC53aWR0aCB8fCBkZWx0YVkgKyBoZWlnaHQgPiBkc3QuaGVpZ2h0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaXRibHQgd3JpdGluZyBvdXRzaWRlIGltYWdlJyk7XG4gIH1cblxuICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgc3JjLmRhdGEuY29weShkc3QuZGF0YSxcbiAgICAgICgoZGVsdGFZICsgeSkgKiBkc3Qud2lkdGggKyBkZWx0YVgpIDw8IDIsXG4gICAgICAoKHNyY1kgKyB5KSAqIHNyYy53aWR0aCArIHNyY1gpIDw8IDIsXG4gICAgICAoKHNyY1kgKyB5KSAqIHNyYy53aWR0aCArIHNyY1ggKyB3aWR0aCkgPDwgMlxuICAgICk7XG4gIH1cbn07XG5cblxuUE5HLnByb3RvdHlwZS5iaXRibHQgPSBmdW5jdGlvbihkc3QsIHNyY1gsIHNyY1ksIHdpZHRoLCBoZWlnaHQsIGRlbHRhWCwgZGVsdGFZKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LXBhcmFtc1xuXG4gIFBORy5iaXRibHQodGhpcywgZHN0LCBzcmNYLCBzcmNZLCB3aWR0aCwgaGVpZ2h0LCBkZWx0YVgsIGRlbHRhWSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUE5HLmFkanVzdEdhbW1hID0gZnVuY3Rpb24oc3JjKSB7XG4gIGlmIChzcmMuZ2FtbWEpIHtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNyYy5oZWlnaHQ7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzcmMud2lkdGg7IHgrKykge1xuICAgICAgICB2YXIgaWR4ID0gKHNyYy53aWR0aCAqIHkgKyB4KSA8PCAyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZSA9IHNyYy5kYXRhW2lkeCArIGldIC8gMjU1O1xuICAgICAgICAgIHNhbXBsZSA9IE1hdGgucG93KHNhbXBsZSwgMSAvIDIuMiAvIHNyYy5nYW1tYSk7XG4gICAgICAgICAgc3JjLmRhdGFbaWR4ICsgaV0gPSBNYXRoLnJvdW5kKHNhbXBsZSAqIDI1NSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3JjLmdhbW1hID0gMDtcbiAgfVxufTtcblxuUE5HLnByb3RvdHlwZS5hZGp1c3RHYW1tYSA9IGZ1bmN0aW9uKCkge1xuICBQTkcuYWRqdXN0R2FtbWEodGhpcyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jykub2s7XG52YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIga01heExlbmd0aCA9IHJlcXVpcmUoJ2J1ZmZlcicpLmtNYXhMZW5ndGg7XG5cbmZ1bmN0aW9uIEluZmxhdGUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHtcbiAgICByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIH1cblxuICBpZiAob3B0cyAmJiBvcHRzLmNodW5rU2l6ZSA8IHpsaWIuWl9NSU5fQ0hVTkspIHtcbiAgICBvcHRzLmNodW5rU2l6ZSA9IHpsaWIuWl9NSU5fQ0hVTks7XG4gIH1cblxuICB6bGliLkluZmxhdGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAvLyBOb2RlIDggLS0+IDkgY29tcGF0aWJpbGl0eSBjaGVja1xuICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgPT09IHVuZGVmaW5lZCA/IHRoaXMuX291dE9mZnNldCA6IHRoaXMuX29mZnNldDtcbiAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyIHx8IHRoaXMuX291dEJ1ZmZlcjtcblxuICBpZiAob3B0cyAmJiBvcHRzLm1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gb3B0cy5tYXhMZW5ndGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5mbGF0ZShvcHRzKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZShvcHRzKTtcbn1cblxuZnVuY3Rpb24gX2Nsb3NlKGVuZ2luZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH1cblxuICAvLyBDYWxsZXIgbWF5IGludm9rZSAuY2xvc2UgYWZ0ZXIgYSB6bGliIGVycm9yICh3aGljaCB3aWxsIG51bGwgX2hhbmRsZSkuXG4gIGlmICghZW5naW5lLl9oYW5kbGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbmdpbmUuX2hhbmRsZS5jbG9zZSgpO1xuICBlbmdpbmUuX2hhbmRsZSA9IG51bGw7XG59XG5cbkluZmxhdGUucHJvdG90eXBlLl9wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbihjaHVuaywgZmx1c2hGbGFnLCBhc3luY0NiKSB7XG4gIGlmICh0eXBlb2YgYXN5bmNDYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB6bGliLkluZmxhdGUuX3Byb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGNodW5rLCBmbHVzaEZsYWcsIGFzeW5jQ2IpO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBhdmFpbEluQmVmb3JlID0gY2h1bmsgJiYgY2h1bmsubGVuZ3RoO1xuICB2YXIgYXZhaWxPdXRCZWZvcmUgPSB0aGlzLl9jaHVua1NpemUgLSB0aGlzLl9vZmZzZXQ7XG4gIHZhciBsZWZ0VG9JbmZsYXRlID0gdGhpcy5fbWF4TGVuZ3RoO1xuICB2YXIgaW5PZmYgPSAwO1xuXG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBucmVhZCA9IDA7XG5cbiAgdmFyIGVycm9yO1xuICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgIGVycm9yID0gZXJyO1xuICB9KTtcblxuICBmdW5jdGlvbiBoYW5kbGVDaHVuayhhdmFpbEluQWZ0ZXIsIGF2YWlsT3V0QWZ0ZXIpIHtcbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGF2ZSA9IGF2YWlsT3V0QmVmb3JlIC0gYXZhaWxPdXRBZnRlcjtcbiAgICBhc3NlcnQoaGF2ZSA+PSAwLCAnaGF2ZSBzaG91bGQgbm90IGdvIGRvd24nKTtcblxuICAgIGlmIChoYXZlID4gMCkge1xuICAgICAgdmFyIG91dCA9IHNlbGYuX2J1ZmZlci5zbGljZShzZWxmLl9vZmZzZXQsIHNlbGYuX29mZnNldCArIGhhdmUpO1xuICAgICAgc2VsZi5fb2Zmc2V0ICs9IGhhdmU7XG5cbiAgICAgIGlmIChvdXQubGVuZ3RoID4gbGVmdFRvSW5mbGF0ZSkge1xuICAgICAgICBvdXQgPSBvdXQuc2xpY2UoMCwgbGVmdFRvSW5mbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlcnMucHVzaChvdXQpO1xuICAgICAgbnJlYWQgKz0gb3V0Lmxlbmd0aDtcbiAgICAgIGxlZnRUb0luZmxhdGUgLT0gb3V0Lmxlbmd0aDtcblxuICAgICAgaWYgKGxlZnRUb0luZmxhdGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwIHx8IHNlbGYuX29mZnNldCA+PSBzZWxmLl9jaHVua1NpemUpIHtcbiAgICAgIGF2YWlsT3V0QmVmb3JlID0gc2VsZi5fY2h1bmtTaXplO1xuICAgICAgc2VsZi5fb2Zmc2V0ID0gMDtcbiAgICAgIHNlbGYuX2J1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzZWxmLl9jaHVua1NpemUpO1xuICAgIH1cblxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwKSB7XG4gICAgICBpbk9mZiArPSAoYXZhaWxJbkJlZm9yZSAtIGF2YWlsSW5BZnRlcik7XG4gICAgICBhdmFpbEluQmVmb3JlID0gYXZhaWxJbkFmdGVyO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhc3NlcnQodGhpcy5faGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICBkbyB7XG4gICAgdmFyIHJlcyA9IHRoaXMuX2hhbmRsZS53cml0ZVN5bmMoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLCAvLyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG4gICAgLy8gTm9kZSA4IC0tPiA5IGNvbXBhdGliaWxpdHkgY2hlY2tcbiAgICByZXMgPSByZXMgfHwgdGhpcy5fd3JpdGVTdGF0ZTtcbiAgfSB3aGlsZSAoIXRoaXMuX2hhZEVycm9yICYmIGhhbmRsZUNodW5rKHJlc1swXSwgcmVzWzFdKSk7XG5cbiAgaWYgKHRoaXMuX2hhZEVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZiAobnJlYWQgPj0ga01heExlbmd0aCkge1xuICAgIF9jbG9zZSh0aGlzKTtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IGNyZWF0ZSBmaW5hbCBCdWZmZXIuIEl0IHdvdWxkIGJlIGxhcmdlciB0aGFuIDB4JyArIGtNYXhMZW5ndGgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpO1xuICB9XG5cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICBfY2xvc2UodGhpcyk7XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgemxpYi5JbmZsYXRlKTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlclN5bmMoZW5naW5lLCBidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgfVxuICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuICB9XG5cbiAgdmFyIGZsdXNoRmxhZyA9IGVuZ2luZS5fZmluaXNoRmx1c2hGbGFnO1xuICBpZiAoZmx1c2hGbGFnID09IG51bGwpIHtcbiAgICBmbHVzaEZsYWcgPSB6bGliLlpfRklOSVNIO1xuICB9XG5cbiAgcmV0dXJuIGVuZ2luZS5fcHJvY2Vzc0NodW5rKGJ1ZmZlciwgZmx1c2hGbGFnKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVN5bmMoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5jcmVhdGVJbmZsYXRlID0gY3JlYXRlSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN5bmNSZWFkZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXG4gIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcbiAgdGhpcy5fcmVhZHMgPSBbXTtcbn07XG5cblN5bmNSZWFkZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihsZW5ndGgsIGNhbGxiYWNrKSB7XG5cbiAgdGhpcy5fcmVhZHMucHVzaCh7XG4gICAgbGVuZ3RoOiBNYXRoLmFicyhsZW5ndGgpLCAgLy8gaWYgbGVuZ3RoIDwgMCB0aGVuIGF0IG1vc3QgdGhpcyBsZW5ndGhcbiAgICBhbGxvd0xlc3M6IGxlbmd0aCA8IDAsXG4gICAgZnVuYzogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5TeW5jUmVhZGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oKSB7XG5cbiAgLy8gYXMgbG9uZyBhcyB0aGVyZSBpcyBhbnkgZGF0YSBhbmQgcmVhZCByZXF1ZXN0c1xuICB3aGlsZSAodGhpcy5fcmVhZHMubGVuZ3RoID4gMCAmJiB0aGlzLl9idWZmZXIubGVuZ3RoKSB7XG5cbiAgICB2YXIgcmVhZCA9IHRoaXMuX3JlYWRzWzBdO1xuXG4gICAgaWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggJiYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPj0gcmVhZC5sZW5ndGggfHwgcmVhZC5hbGxvd0xlc3MpKSB7XG5cbiAgICAgIC8vIG9rIHRoZXJlIGlzIGFueSBkYXRhIHNvIHRoYXQgd2UgY2FuIHNhdGlzZnkgdGhpcyByZXF1ZXN0XG4gICAgICB0aGlzLl9yZWFkcy5zaGlmdCgpOyAvLyA9PSByZWFkXG5cbiAgICAgIHZhciBidWYgPSB0aGlzLl9idWZmZXI7XG5cbiAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1Zi5zbGljZShyZWFkLmxlbmd0aCk7XG5cbiAgICAgIHJlYWQuZnVuYy5jYWxsKHRoaXMsIGJ1Zi5zbGljZSgwLCByZWFkLmxlbmd0aCkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gIH1cblxuICBpZiAodGhpcy5fcmVhZHMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ1RoZXJlIGFyZSBzb21lIHJlYWQgcmVxdWVzdHMgd2FpdG5nIG9uIGZpbmlzaGVkIHN0cmVhbScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndW5yZWNvZ25pc2VkIGNvbnRlbnQgYXQgZW5kIG9mIHN0cmVhbScpO1xuICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5hZGRMYXN0ID0gYWRkTGFzdDtcbmV4cG9ydHMuYWRkRmlyc3QgPSBhZGRGaXJzdDtcbmV4cG9ydHMucmVtb3ZlTGFzdCA9IHJlbW92ZUxhc3Q7XG5leHBvcnRzLnJlbW92ZUZpcnN0ID0gcmVtb3ZlRmlyc3Q7XG5leHBvcnRzLmluc2VydCA9IGluc2VydDtcbmV4cG9ydHMucmVtb3ZlQXQgPSByZW1vdmVBdDtcbmV4cG9ydHMucmVwbGFjZUF0ID0gcmVwbGFjZUF0O1xuZXhwb3J0cy5nZXRJbiA9IGdldEluO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLnNldEluID0gc2V0SW47XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbmV4cG9ydHMudXBkYXRlSW4gPSB1cGRhdGVJbjtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubWVyZ2VEZWVwID0gbWVyZ2VEZWVwO1xuZXhwb3J0cy5tZXJnZUluID0gbWVyZ2VJbjtcbmV4cG9ydHMub21pdCA9IG9taXQ7XG5leHBvcnRzLmFkZERlZmF1bHRzID0gYWRkRGVmYXVsdHM7XG5cblxuLyohXG4gKiBUaW1tXG4gKlxuICogSW1tdXRhYmlsaXR5IGhlbHBlcnMgd2l0aCBmYXN0IHJlYWRzIGFuZCBhY2NlcHRhYmxlIHdyaXRlcy5cbiAqXG4gKiBAY29weXJpZ2h0IEd1aWxsZXJtbyBHcmF1IFBhbmVhIDIwMTZcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbnZhciBJTlZBTElEX0FSR1MgPSAnSU5WQUxJRF9BUkdTJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vICMjIyBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbmZ1bmN0aW9uIHRocm93U3RyKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0FuZFN5bWJvbHMob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIHZhciBrZXlzID0gZ2V0S2V5c0FuZFN5bWJvbHMob2JqKTtcbiAgdmFyIG91dCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRvTWVyZ2UoZkFkZERlZmF1bHRzLCBmRGVlcCwgZmlyc3QpIHtcbiAgdmFyIG91dCA9IGZpcnN0O1xuICAhKG91dCAhPSBudWxsKSAmJiB0aHJvd1N0cihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gJ0F0IGxlYXN0IG9uZSBvYmplY3Qgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIG1lcmdlKCknIDogSU5WQUxJRF9BUkdTKTtcbiAgdmFyIGZDaGFuZ2VkID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcmVzdFtfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCByZXN0Lmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIgb2JqID0gcmVzdFtpZHhdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgY29udGludWU7XG4gICAgdmFyIGtleXMgPSBnZXRLZXlzQW5kU3ltYm9scyhvYmopO1xuICAgIGlmICgha2V5cy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgaWYgKGZBZGREZWZhdWx0cyAmJiBvdXRba2V5XSAhPT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgIHZhciBuZXh0VmFsID0gb2JqW2tleV07XG4gICAgICBpZiAoZkRlZXAgJiYgaXNPYmplY3Qob3V0W2tleV0pICYmIGlzT2JqZWN0KG5leHRWYWwpKSB7XG4gICAgICAgIG5leHRWYWwgPSBkb01lcmdlKGZBZGREZWZhdWx0cywgZkRlZXAsIG91dFtrZXldLCBuZXh0VmFsKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0VmFsID09PSB1bmRlZmluZWQgfHwgbmV4dFZhbCA9PT0gb3V0W2tleV0pIGNvbnRpbnVlO1xuICAgICAgaWYgKCFmQ2hhbmdlZCkge1xuICAgICAgICBmQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG91dCA9IGNsb25lKG91dCk7XG4gICAgICB9XG4gICAgICBvdXRba2V5XSA9IG5leHRWYWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yobyk7XG4gIHJldHVybiBvICE9IG51bGwgJiYgdHlwZSA9PT0gJ29iamVjdCc7XG59XG5cbi8vIF9kZWVwRnJlZXplID0gKG9iaikgLT5cbi8vICAgT2JqZWN0LmZyZWV6ZSBvYmpcbi8vICAgZm9yIGtleSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBvYmpcbi8vICAgICB2YWwgPSBvYmpba2V5XVxuLy8gICAgIGlmIGlzT2JqZWN0KHZhbCkgYW5kIG5vdCBPYmplY3QuaXNGcm96ZW4gdmFsXG4vLyAgICAgICBfZGVlcEZyZWV6ZSB2YWxcbi8vICAgb2JqXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAtLSAjIyMgQXJyYXlzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyAtLSAjIyMjIGFkZExhc3QoKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIGFuIGFwcGVuZGVkIGl0ZW0gb3IgaXRlbXMuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGBhZGRMYXN0PFQ+KGFycmF5OiBBcnJheTxUPiwgdmFsOiBBcnJheTxUPnxUKTogQXJyYXk8VD5gXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIGFyciA9IFsnYScsICdiJ11cbi8vIC0tIGFycjIgPSBhZGRMYXN0KGFyciwgJ2MnKVxuLy8gLS0gLy8gWydhJywgJ2InLCAnYyddXG4vLyAtLSBhcnIyID09PSBhcnJcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLSBhcnIzID0gYWRkTGFzdChhcnIsIFsnYycsICdkJ10pXG4vLyAtLSAvLyBbJ2EnLCAnYicsICdjJywgJ2QnXVxuLy8gLS0gYGBgXG4vLyBgYXJyYXkuY29uY2F0KHZhbClgIGFsc28gaGFuZGxlcyB0aGUgc2NhbGFyIGNhc2UsXG4vLyBidXQgaXMgYXBwYXJlbnRseSB2ZXJ5IHNsb3dcbmZ1bmN0aW9uIGFkZExhc3QoYXJyYXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSByZXR1cm4gYXJyYXkuY29uY2F0KHZhbCk7XG4gIHJldHVybiBhcnJheS5jb25jYXQoW3ZhbF0pO1xufVxuXG4vLyAtLSAjIyMjIGFkZEZpcnN0KClcbi8vIC0tIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCBhIHByZXBlbmRlZCBpdGVtIG9yIGl0ZW1zLlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgYWRkRmlyc3Q8VD4oYXJyYXk6IEFycmF5PFQ+LCB2YWw6IEFycmF5PFQ+fFQpOiBBcnJheTxUPmBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gYXJyID0gWydhJywgJ2InXVxuLy8gLS0gYXJyMiA9IGFkZEZpcnN0KGFyciwgJ2MnKVxuLy8gLS0gLy8gWydjJywgJ2EnLCAnYiddXG4vLyAtLSBhcnIyID09PSBhcnJcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLSBhcnIzID0gYWRkRmlyc3QoYXJyLCBbJ2MnLCAnZCddKVxuLy8gLS0gLy8gWydjJywgJ2QnLCAnYScsICdiJ11cbi8vIC0tIGBgYFxuZnVuY3Rpb24gYWRkRmlyc3QoYXJyYXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSByZXR1cm4gdmFsLmNvbmNhdChhcnJheSk7XG4gIHJldHVybiBbdmFsXS5jb25jYXQoYXJyYXkpO1xufVxuXG4vLyAtLSAjIyMjIHJlbW92ZUxhc3QoKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBhcnJheSByZW1vdmluZyB0aGUgbGFzdCBpdGVtLlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgcmVtb3ZlTGFzdDxUPihhcnJheTogQXJyYXk8VD4pOiBBcnJheTxUPmBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gYXJyID0gWydhJywgJ2InXVxuLy8gLS0gYXJyMiA9IHJlbW92ZUxhc3QoYXJyKVxuLy8gLS0gLy8gWydhJ11cbi8vIC0tIGFycjIgPT09IGFyclxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBhcnJheSBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIGFycjMgPSBbXVxuLy8gLS0gcmVtb3ZlTGFzdChhcnIzKSA9PT0gYXJyM1xuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5mdW5jdGlvbiByZW1vdmVMYXN0KGFycmF5KSB7XG4gIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gYXJyYXk7XG4gIHJldHVybiBhcnJheS5zbGljZSgwLCBhcnJheS5sZW5ndGggLSAxKTtcbn1cblxuLy8gLS0gIyMjIyByZW1vdmVGaXJzdCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IGFycmF5IHJlbW92aW5nIHRoZSBmaXJzdCBpdGVtLlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgcmVtb3ZlRmlyc3Q8VD4oYXJyYXk6IEFycmF5PFQ+KTogQXJyYXk8VD5gXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIGFyciA9IFsnYScsICdiJ11cbi8vIC0tIGFycjIgPSByZW1vdmVGaXJzdChhcnIpXG4vLyAtLSAvLyBbJ2InXVxuLy8gLS0gYXJyMiA9PT0gYXJyXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIGFycmF5IGlzIHJldHVybmVkIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzOlxuLy8gLS0gYXJyMyA9IFtdXG4vLyAtLSByZW1vdmVGaXJzdChhcnIzKSA9PT0gYXJyM1xuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5mdW5jdGlvbiByZW1vdmVGaXJzdChhcnJheSkge1xuICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIGFycmF5O1xuICByZXR1cm4gYXJyYXkuc2xpY2UoMSk7XG59XG5cbi8vIC0tICMjIyMgaW5zZXJ0KClcbi8vIC0tIFJldHVybnMgYSBuZXcgYXJyYXkgb2J0YWluZWQgYnkgaW5zZXJ0aW5nIGFuIGl0ZW0gb3IgaXRlbXNcbi8vIC0tIGF0IGEgc3BlY2lmaWVkIGluZGV4LlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgaW5zZXJ0PFQ+KGFycmF5OiBBcnJheTxUPiwgaWR4OiBudW1iZXIsIHZhbDogQXJyYXk8VD58VCk6IEFycmF5PFQ+YFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBhcnIgPSBbJ2EnLCAnYicsICdjJ11cbi8vIC0tIGFycjIgPSBpbnNlcnQoYXJyLCAxLCAnZCcpXG4vLyAtLSAvLyBbJ2EnLCAnZCcsICdiJywgJ2MnXVxuLy8gLS0gYXJyMiA9PT0gYXJyXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS0gaW5zZXJ0KGFyciwgMSwgWydkJywgJ2UnXSlcbi8vIC0tIC8vIFsnYScsICdkJywgJ2UnLCAnYicsICdjJ11cbi8vIC0tIGBgYFxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpZHgsIHZhbCkge1xuICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgaWR4KS5jb25jYXQoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pLmNvbmNhdChhcnJheS5zbGljZShpZHgpKTtcbn1cblxuLy8gLS0gIyMjIyByZW1vdmVBdCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IGFycmF5IG9idGFpbmVkIGJ5IHJlbW92aW5nIGFuIGl0ZW0gYXRcbi8vIC0tIGEgc3BlY2lmaWVkIGluZGV4LlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgcmVtb3ZlQXQ8VD4oYXJyYXk6IEFycmF5PFQ+LCBpZHg6IG51bWJlcik6IEFycmF5PFQ+YFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBhcnIgPSBbJ2EnLCAnYicsICdjJ11cbi8vIC0tIGFycjIgPSByZW1vdmVBdChhcnIsIDEpXG4vLyAtLSAvLyBbJ2EnLCAnYyddXG4vLyAtLSBhcnIyID09PSBhcnJcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLVxuLy8gLS0gLy8gVGhlIHNhbWUgYXJyYXkgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSByZW1vdmVBdChhcnIsIDQpID09PSBhcnJcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuZnVuY3Rpb24gcmVtb3ZlQXQoYXJyYXksIGlkeCkge1xuICBpZiAoaWR4ID49IGFycmF5Lmxlbmd0aCB8fCBpZHggPCAwKSByZXR1cm4gYXJyYXk7XG4gIHJldHVybiBhcnJheS5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnJheS5zbGljZShpZHggKyAxKSk7XG59XG5cbi8vIC0tICMjIyMgcmVwbGFjZUF0KClcbi8vIC0tIFJldHVybnMgYSBuZXcgYXJyYXkgb2J0YWluZWQgYnkgcmVwbGFjaW5nIGFuIGl0ZW0gYXRcbi8vIC0tIGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgcHJvdmlkZWQgaXRlbSBpcyB0aGUgc2FtZSBhc1xuLy8gLS0gKCpyZWZlcmVudGlhbGx5IGVxdWFsIHRvKikgdGhlIHByZXZpb3VzIGl0ZW0gYXQgdGhhdCBwb3NpdGlvbixcbi8vIC0tIHRoZSBvcmlnaW5hbCBhcnJheSBpcyByZXR1cm5lZC5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYHJlcGxhY2VBdDxUPihhcnJheTogQXJyYXk8VD4sIGlkeDogbnVtYmVyLCBuZXdJdGVtOiBUKTogQXJyYXk8VD5gXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIGFyciA9IFsnYScsICdiJywgJ2MnXVxuLy8gLS0gYXJyMiA9IHJlcGxhY2VBdChhcnIsIDEsICdkJylcbi8vIC0tIC8vIFsnYScsICdkJywgJ2MnXVxuLy8gLS0gYXJyMiA9PT0gYXJyXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIHJlcGxhY2VBdChhcnIsIDEsICdiJykgPT09IGFyclxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5mdW5jdGlvbiByZXBsYWNlQXQoYXJyYXksIGlkeCwgbmV3SXRlbSkge1xuICBpZiAoYXJyYXlbaWR4XSA9PT0gbmV3SXRlbSkgcmV0dXJuIGFycmF5O1xuICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5W2ldO1xuICB9XG4gIHJlc3VsdFtpZHhdID0gbmV3SXRlbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIC0tICMjIyBDb2xsZWN0aW9ucyAob2JqZWN0cyBhbmQgYXJyYXlzKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIC0tIFRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIHVzZWQgdGhyb3VnaG91dCB0aGlzIHNlY3Rpb25cbi8vIC0tIGBgYGpzXG4vLyAtLSB0eXBlIEFycmF5T3JPYmplY3QgPSBBcnJheTxhbnk+fE9iamVjdDtcbi8vIC0tIHR5cGUgS2V5ID0gbnVtYmVyfHN0cmluZztcbi8vIC0tIGBgYFxuXG4vLyAtLSAjIyMjIGdldEluKClcbi8vIC0tIFJldHVybnMgYSB2YWx1ZSBmcm9tIGFuIG9iamVjdCBhdCBhIGdpdmVuIHBhdGguIFdvcmtzIHdpdGhcbi8vIC0tIG5lc3RlZCBhcnJheXMgYW5kIG9iamVjdHMuIElmIHRoZSBwYXRoIGRvZXMgbm90IGV4aXN0LCBpdCByZXR1cm5zXG4vLyAtLSBgdW5kZWZpbmVkYC5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYGdldEluKG9iajogP0FycmF5T3JPYmplY3QsIHBhdGg6IEFycmF5PEtleT4pOiBhbnlgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIG9iaiA9IHsgYTogMSwgYjogMiwgZDogeyBkMTogMywgZDI6IDQgfSwgZTogWydhJywgJ2InLCAnYyddIH1cbi8vIC0tIGdldEluKG9iaiwgWydkJywgJ2QxJ10pXG4vLyAtLSAvLyAzXG4vLyAtLSBnZXRJbihvYmosIFsnZScsIDFdKVxuLy8gLS0gLy8gJ2InXG4vLyAtLSBgYGBcbmZ1bmN0aW9uIGdldEluKG9iaiwgcGF0aCkge1xuICAhQXJyYXkuaXNBcnJheShwYXRoKSAmJiB0aHJvd1N0cihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gJ0EgcGF0aCBhcnJheSBzaG91bGQgYmUgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIGdldEluKCknIDogSU5WQUxJRF9BUkdTKTtcbiAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgcHRyID0gb2JqO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpXTtcbiAgICBwdHIgPSBwdHIgIT0gbnVsbCA/IHB0cltrZXldIDogdW5kZWZpbmVkO1xuICAgIGlmIChwdHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHB0cjtcbiAgfVxuICByZXR1cm4gcHRyO1xufVxuXG4vLyAtLSAjIyMjIHNldCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGEgbW9kaWZpZWQgYXR0cmlidXRlLlxuLy8gLS0gSWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIHRoZSBzYW1lIGFzICgqcmVmZXJlbnRpYWxseSBlcXVhbCB0byopXG4vLyAtLSB0aGUgcHJldmlvdXMgdmFsdWUsIHRoZSBvcmlnaW5hbCBvYmplY3QgaXMgcmV0dXJuZWQuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGBzZXQ8VD4ob2JqOiA/VCwga2V5OiBLZXksIHZhbDogYW55KTogVGBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbi8vIC0tIG9iajIgPSBzZXQob2JqLCAnYicsIDUpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDUsIGM6IDMgfVxuLy8gLS0gb2JqMiA9PT0gb2JqXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIHNldChvYmosICdiJywgMikgPT09IG9ialxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICB2YXIgZmFsbGJhY2sgPSB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyA/IFtdIDoge307XG4gIHZhciBmaW5hbE9iaiA9IG9iaiA9PSBudWxsID8gZmFsbGJhY2sgOiBvYmo7XG4gIGlmIChmaW5hbE9ialtrZXldID09PSB2YWwpIHJldHVybiBmaW5hbE9iajtcbiAgdmFyIG9iajIgPSBjbG9uZShmaW5hbE9iaik7XG4gIG9iajJba2V5XSA9IHZhbDtcbiAgcmV0dXJuIG9iajI7XG59XG5cbi8vIC0tICMjIyMgc2V0SW4oKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBhIG1vZGlmaWVkICoqbmVzdGVkKiogYXR0cmlidXRlLlxuLy8gLS1cbi8vIC0tIE5vdGVzOlxuLy8gLS1cbi8vIC0tICogSWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIHRoZSBzYW1lIGFzICgqcmVmZXJlbnRpYWxseSBlcXVhbCB0byopXG4vLyAtLSB0aGUgcHJldmlvdXMgdmFsdWUsIHRoZSBvcmlnaW5hbCBvYmplY3QgaXMgcmV0dXJuZWQuXG4vLyAtLSAqIElmIHRoZSBwYXRoIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWQgYmVmb3JlIHNldHRpbmdcbi8vIC0tIHRoZSBuZXcgdmFsdWUuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGBzZXRJbjxUOiBBcnJheU9yT2JqZWN0PihvYmo6IFQsIHBhdGg6IEFycmF5PEtleT4sIHZhbDogYW55KTogVGBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqID0geyBhOiAxLCBiOiAyLCBkOiB7IGQxOiAzLCBkMjogNCB9LCBlOiB7IGUxOiAnZm9vJywgZTI6ICdiYXInIH0gfVxuLy8gLS0gb2JqMiA9IHNldEluKG9iaiwgWydkJywgJ2QxJ10sIDQpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDIsIGQ6IHsgZDE6IDQsIGQyOiA0IH0sIGU6IHsgZTE6ICdmb28nLCBlMjogJ2JhcicgfSB9XG4vLyAtLSBvYmoyID09PSBvYmpcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLSBvYmoyLmQgPT09IG9iai5kXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS0gb2JqMi5lID09PSBvYmouZVxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIG9iajMgPSBzZXRJbihvYmosIFsnZCcsICdkMSddLCAzKVxuLy8gLS0gLy8geyBhOiAxLCBiOiAyLCBkOiB7IGQxOiAzLCBkMjogNCB9LCBlOiB7IGUxOiAnZm9vJywgZTI6ICdiYXInIH0gfVxuLy8gLS0gb2JqMyA9PT0gb2JqXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBvYmozLmQgPT09IG9iai5kXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBvYmozLmUgPT09IG9iai5lXG4vLyAtLSAvLyB0cnVlXG4vLyAtLVxuLy8gLS0gLy8gLi4uIHVua25vd24gcGF0aHMgY3JlYXRlIGludGVybWVkaWF0ZSBrZXlzLiBOdW1lcmljIHNlZ21lbnRzIGFyZSB0cmVhdGVkIGFzIGFycmF5IGluZGljZXM6XG4vLyAtLSBzZXRJbih7IGE6IDMgfSwgWyd1bmtub3duJywgMCwgJ3BhdGgnXSwgNClcbi8vIC0tIC8vIHsgYTogMywgdW5rbm93bjogW3sgcGF0aDogNCB9XSB9XG4vLyAtLSBgYGBcbmZ1bmN0aW9uIGRvU2V0SW4ob2JqLCBwYXRoLCB2YWwsIGlkeCkge1xuICB2YXIgbmV3VmFsdWUgPSB2b2lkIDA7XG4gIHZhciBrZXkgPSBwYXRoW2lkeF07XG4gIGlmIChpZHggPT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgIG5ld1ZhbHVlID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXN0ZWRPYmogPSBpc09iamVjdChvYmopICYmIGlzT2JqZWN0KG9ialtrZXldKSA/IG9ialtrZXldIDogdHlwZW9mIHBhdGhbaWR4ICsgMV0gPT09ICdudW1iZXInID8gW10gOiB7fTtcbiAgICBuZXdWYWx1ZSA9IGRvU2V0SW4obmVzdGVkT2JqLCBwYXRoLCB2YWwsIGlkeCArIDEpO1xuICB9XG4gIHJldHVybiBzZXQob2JqLCBrZXksIG5ld1ZhbHVlKTtcbn1cblxuZnVuY3Rpb24gc2V0SW4ob2JqLCBwYXRoLCB2YWwpIHtcbiAgaWYgKCFwYXRoLmxlbmd0aCkgcmV0dXJuIHZhbDtcbiAgcmV0dXJuIGRvU2V0SW4ob2JqLCBwYXRoLCB2YWwsIDApO1xufVxuXG4vLyAtLSAjIyMjIHVwZGF0ZSgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGEgbW9kaWZpZWQgYXR0cmlidXRlLFxuLy8gLS0gY2FsY3VsYXRlZCB2aWEgYSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlLlxuLy8gLS0gSWYgdGhlIGNhbGN1bGF0ZWQgdmFsdWUgaXMgdGhlIHNhbWUgYXMgKCpyZWZlcmVudGlhbGx5IGVxdWFsIHRvKilcbi8vIC0tIHRoZSBwcmV2aW91cyB2YWx1ZSwgdGhlIG9yaWdpbmFsIG9iamVjdCBpcyByZXR1cm5lZC5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYHVwZGF0ZTxUOiBBcnJheU9yT2JqZWN0PihvYmo6IFQsIGtleTogS2V5LFxuLy8gLS0gZm5VcGRhdGU6IChwcmV2VmFsdWU6IGFueSkgPT4gYW55KTogVGBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbi8vIC0tIG9iajIgPSB1cGRhdGUob2JqLCAnYicsICh2YWwpID0+IHZhbCArIDEpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDMsIGM6IDMgfVxuLy8gLS0gb2JqMiA9PT0gb2JqXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIHVwZGF0ZShvYmosICdiJywgKHZhbCkgPT4gdmFsKSA9PT0gb2JqXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBgYGBcbmZ1bmN0aW9uIHVwZGF0ZShvYmosIGtleSwgZm5VcGRhdGUpIHtcbiAgdmFyIHByZXZWYWwgPSBvYmogPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9ialtrZXldO1xuICB2YXIgbmV4dFZhbCA9IGZuVXBkYXRlKHByZXZWYWwpO1xuICByZXR1cm4gc2V0KG9iaiwga2V5LCBuZXh0VmFsKTtcbn1cblxuLy8gLS0gIyMjIyB1cGRhdGVJbigpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGEgbW9kaWZpZWQgKipuZXN0ZWQqKiBhdHRyaWJ1dGUsXG4vLyAtLSBjYWxjdWxhdGVkIHZpYSBhIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWUuXG4vLyAtLSBJZiB0aGUgY2FsY3VsYXRlZCB2YWx1ZSBpcyB0aGUgc2FtZSBhcyAoKnJlZmVyZW50aWFsbHkgZXF1YWwgdG8qKVxuLy8gLS0gdGhlIHByZXZpb3VzIHZhbHVlLCB0aGUgb3JpZ2luYWwgb2JqZWN0IGlzIHJldHVybmVkLlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgdXBkYXRlSW48VDogQXJyYXlPck9iamVjdD4ob2JqOiBULCBwYXRoOiBBcnJheTxLZXk+LFxuLy8gLS0gZm5VcGRhdGU6IChwcmV2VmFsdWU6IGFueSkgPT4gYW55KTogVGBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqID0geyBhOiAxLCBkOiB7IGQxOiAzLCBkMjogNCB9IH1cbi8vIC0tIG9iajIgPSB1cGRhdGVJbihvYmosIFsnZCcsICdkMSddLCAodmFsKSA9PiB2YWwgKyAxKVxuLy8gLS0gLy8geyBhOiAxLCBkOiB7IGQxOiA0LCBkMjogNCB9IH1cbi8vIC0tIG9iajIgPT09IG9ialxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBvYmozID0gdXBkYXRlSW4ob2JqLCBbJ2QnLCAnZDEnXSwgKHZhbCkgPT4gdmFsKVxuLy8gLS0gLy8geyBhOiAxLCBkOiB7IGQxOiAzLCBkMjogNCB9IH1cbi8vIC0tIG9iajMgPT09IG9ialxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5mdW5jdGlvbiB1cGRhdGVJbihvYmosIHBhdGgsIGZuVXBkYXRlKSB7XG4gIHZhciBwcmV2VmFsID0gZ2V0SW4ob2JqLCBwYXRoKTtcbiAgdmFyIG5leHRWYWwgPSBmblVwZGF0ZShwcmV2VmFsKTtcbiAgcmV0dXJuIHNldEluKG9iaiwgcGF0aCwgbmV4dFZhbCk7XG59XG5cbi8vIC0tICMjIyMgbWVyZ2UoKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBvYmplY3QgYnVpbHQgYXMgZm9sbG93czogdGhlIG92ZXJsYXBwaW5nIGtleXMgZnJvbSB0aGVcbi8vIC0tIHNlY29uZCBvbmUgb3ZlcndyaXRlIHRoZSBjb3JyZXNwb25kaW5nIGVudHJpZXMgZnJvbSB0aGUgZmlyc3Qgb25lLlxuLy8gLS0gU2ltaWxhciB0byBgT2JqZWN0LmFzc2lnbigpYCwgYnV0IGltbXV0YWJsZS5cbi8vIC0tXG4vLyAtLSBVc2FnZTpcbi8vIC0tXG4vLyAtLSAqIGBtZXJnZShvYmoxOiBPYmplY3QsIG9iajI6ID9PYmplY3QpOiBPYmplY3RgXG4vLyAtLSAqIGBtZXJnZShvYmoxOiBPYmplY3QsIC4uLm9iamVjdHM6IEFycmF5PD9PYmplY3Q+KTogT2JqZWN0YFxuLy8gLS1cbi8vIC0tIFRoZSB1bm1vZGlmaWVkIGBvYmoxYCBpcyByZXR1cm5lZCBpZiBgb2JqMmAgZG9lcyBub3QgKnByb3ZpZGUgc29tZXRoaW5nXG4vLyAtLSBuZXcgdG8qIGBvYmoxYCwgaS5lLiBpZiBlaXRoZXIgb2YgdGhlIGZvbGxvd2luZ1xuLy8gLS0gY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbi8vIC0tXG4vLyAtLSAqIGBvYmoyYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGBcbi8vIC0tICogYG9iajJgIGlzIGFuIG9iamVjdCwgYnV0IGl0IGlzIGVtcHR5XG4vLyAtLSAqIEFsbCBhdHRyaWJ1dGVzIG9mIGBvYmoyYCBhcmUgYHVuZGVmaW5lZGBcbi8vIC0tICogQWxsIGF0dHJpYnV0ZXMgb2YgYG9iajJgIGFyZSByZWZlcmVudGlhbGx5IGVxdWFsIHRvIHRoZVxuLy8gLS0gICBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMgb2YgYG9iajFgXG4vLyAtLVxuLy8gLS0gTm90ZSB0aGF0IGB1bmRlZmluZWRgIGF0dHJpYnV0ZXMgaW4gYG9iajJgIGRvIG5vdCBtb2RpZnkgdGhlXG4vLyAtLSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMgaW4gYG9iajFgLlxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBvYmoxID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbi8vIC0tIG9iajIgPSB7IGM6IDQsIGQ6IDUgfVxuLy8gLS0gb2JqMyA9IG1lcmdlKG9iajEsIG9iajIpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDIsIGM6IDQsIGQ6IDUgfVxuLy8gLS0gb2JqMyA9PT0gb2JqMVxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBtZXJnZShvYmoxLCB7IGM6IDMgfSkgPT09IG9iajFcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuZnVuY3Rpb24gbWVyZ2UoYSwgYiwgYywgZCwgZSwgZikge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBBcnJheShfbGVuMiA+IDYgPyBfbGVuMiAtIDYgOiAwKSwgX2tleTIgPSA2OyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgcmVzdFtfa2V5MiAtIDZdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHJldHVybiByZXN0Lmxlbmd0aCA/IGRvTWVyZ2UuY2FsbC5hcHBseShkb01lcmdlLCBbbnVsbCwgZmFsc2UsIGZhbHNlLCBhLCBiLCBjLCBkLCBlLCBmXS5jb25jYXQocmVzdCkpIDogZG9NZXJnZShmYWxzZSwgZmFsc2UsIGEsIGIsIGMsIGQsIGUsIGYpO1xufVxuXG4vLyAtLSAjIyMjIG1lcmdlRGVlcCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IG9iamVjdCBidWlsdCBhcyBmb2xsb3dzOiB0aGUgb3ZlcmxhcHBpbmcga2V5cyBmcm9tIHRoZVxuLy8gLS0gc2Vjb25kIG9uZSBvdmVyd3JpdGUgdGhlIGNvcnJlc3BvbmRpbmcgZW50cmllcyBmcm9tIHRoZSBmaXJzdCBvbmUuXG4vLyAtLSBJZiBib3RoIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGVudHJpZXMgYXJlIG9iamVjdHMgdGhleSBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LlxuLy8gLS0gU2ltaWxhciB0byBgT2JqZWN0LmFzc2lnbigpYCwgYnV0IGltbXV0YWJsZSwgYW5kIGRlZXBseSBtZXJnaW5nLlxuLy8gLS1cbi8vIC0tIFVzYWdlOlxuLy8gLS1cbi8vIC0tICogYG1lcmdlRGVlcChvYmoxOiBPYmplY3QsIG9iajI6ID9PYmplY3QpOiBPYmplY3RgXG4vLyAtLSAqIGBtZXJnZURlZXAob2JqMTogT2JqZWN0LCAuLi5vYmplY3RzOiBBcnJheTw/T2JqZWN0Pik6IE9iamVjdGBcbi8vIC0tXG4vLyAtLSBUaGUgdW5tb2RpZmllZCBgb2JqMWAgaXMgcmV0dXJuZWQgaWYgYG9iajJgIGRvZXMgbm90ICpwcm92aWRlIHNvbWV0aGluZ1xuLy8gLS0gbmV3IHRvKiBgb2JqMWAsIGkuZS4gaWYgZWl0aGVyIG9mIHRoZSBmb2xsb3dpbmdcbi8vIC0tIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4vLyAtLVxuLy8gLS0gKiBgb2JqMmAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgXG4vLyAtLSAqIGBvYmoyYCBpcyBhbiBvYmplY3QsIGJ1dCBpdCBpcyBlbXB0eVxuLy8gLS0gKiBBbGwgYXR0cmlidXRlcyBvZiBgb2JqMmAgYXJlIGB1bmRlZmluZWRgXG4vLyAtLSAqIEFsbCBhdHRyaWJ1dGVzIG9mIGBvYmoyYCBhcmUgcmVmZXJlbnRpYWxseSBlcXVhbCB0byB0aGVcbi8vIC0tICAgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIG9mIGBvYmoxYFxuLy8gLS1cbi8vIC0tIE5vdGUgdGhhdCBgdW5kZWZpbmVkYCBhdHRyaWJ1dGVzIGluIGBvYmoyYCBkbyBub3QgbW9kaWZ5IHRoZVxuLy8gLS0gY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIGluIGBvYmoxYC5cbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqMSA9IHsgYTogMSwgYjogMiwgYzogeyBhOiAxIH0gfVxuLy8gLS0gb2JqMiA9IHsgYjogMywgYzogeyBiOiAyIH0gfVxuLy8gLS0gb2JqMyA9IG1lcmdlRGVlcChvYmoxLCBvYmoyKVxuLy8gLS0gLy8geyBhOiAxLCBiOiAzLCBjOiB7IGE6IDEsIGI6IDIgfSAgfVxuLy8gLS0gb2JqMyA9PT0gb2JqMVxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBtZXJnZURlZXAob2JqMSwgeyBjOiB7IGE6IDEgfSB9KSA9PT0gb2JqMVxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5mdW5jdGlvbiBtZXJnZURlZXAoYSwgYiwgYywgZCwgZSwgZikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBBcnJheShfbGVuMyA+IDYgPyBfbGVuMyAtIDYgOiAwKSwgX2tleTMgPSA2OyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgcmVzdFtfa2V5MyAtIDZdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiByZXN0Lmxlbmd0aCA/IGRvTWVyZ2UuY2FsbC5hcHBseShkb01lcmdlLCBbbnVsbCwgZmFsc2UsIHRydWUsIGEsIGIsIGMsIGQsIGUsIGZdLmNvbmNhdChyZXN0KSkgOiBkb01lcmdlKGZhbHNlLCB0cnVlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbn1cblxuLy8gLS0gIyMjIyBtZXJnZUluKClcbi8vIC0tIFNpbWlsYXIgdG8gYG1lcmdlKClgLCBidXQgbWVyZ2luZyB0aGUgdmFsdWUgYXQgYSBnaXZlbiBuZXN0ZWQgcGF0aC5cbi8vIC0tIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWQgdHlwZSBpcyB0aGUgc2FtZSBhcyB0aGF0IG9mIHRoZSBmaXJzdCBhcmd1bWVudC5cbi8vIC0tXG4vLyAtLSBVc2FnZTpcbi8vIC0tXG4vLyAtLSAqIGBtZXJnZUluPFQ6IEFycmF5T3JPYmplY3Q+KG9iajE6IFQsIHBhdGg6IEFycmF5PEtleT4sIG9iajI6ID9PYmplY3QpOiBUYFxuLy8gLS0gKiBgbWVyZ2VJbjxUOiBBcnJheU9yT2JqZWN0PihvYmoxOiBULCBwYXRoOiBBcnJheTxLZXk+LFxuLy8gLS0gLi4ub2JqZWN0czogQXJyYXk8P09iamVjdD4pOiBUYFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBvYmoxID0geyBhOiAxLCBkOiB7IGI6IHsgZDE6IDMsIGQyOiA0IH0gfSB9XG4vLyAtLSBvYmoyID0geyBkMzogNSB9XG4vLyAtLSBvYmozID0gbWVyZ2VJbihvYmoxLCBbJ2QnLCAnYiddLCBvYmoyKVxuLy8gLS0gLy8geyBhOiAxLCBkOiB7IGI6IHsgZDE6IDMsIGQyOiA0LCBkMzogNSB9IH0gfVxuLy8gLS0gb2JqMyA9PT0gb2JqMVxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBtZXJnZUluKG9iajEsIFsnZCcsICdiJ10sIHsgZDI6IDQgfSkgPT09IG9iajFcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuZnVuY3Rpb24gbWVyZ2VJbihhLCBwYXRoLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBwcmV2VmFsID0gZ2V0SW4oYSwgcGF0aCk7XG4gIGlmIChwcmV2VmFsID09IG51bGwpIHByZXZWYWwgPSB7fTtcbiAgdmFyIG5leHRWYWwgPSB2b2lkIDA7XG5cbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gQXJyYXkoX2xlbjQgPiA3ID8gX2xlbjQgLSA3IDogMCksIF9rZXk0ID0gNzsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIHJlc3RbX2tleTQgLSA3XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBpZiAocmVzdC5sZW5ndGgpIHtcbiAgICBuZXh0VmFsID0gZG9NZXJnZS5jYWxsLmFwcGx5KGRvTWVyZ2UsIFtudWxsLCBmYWxzZSwgZmFsc2UsIHByZXZWYWwsIGIsIGMsIGQsIGUsIGZdLmNvbmNhdChyZXN0KSk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dFZhbCA9IGRvTWVyZ2UoZmFsc2UsIGZhbHNlLCBwcmV2VmFsLCBiLCBjLCBkLCBlLCBmKTtcbiAgfVxuICByZXR1cm4gc2V0SW4oYSwgcGF0aCwgbmV4dFZhbCk7XG59XG5cbi8vIC0tICMjIyMgb21pdCgpXG4vLyAtLSBSZXR1cm5zIGFuIG9iamVjdCBleGNsdWRpbmcgb25lIG9yIHNldmVyYWwgYXR0cmlidXRlcy5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYG9taXQob2JqOiBPYmplY3QsIGF0dHJzOiBBcnJheTxzdHJpbmc+fHN0cmluZyk6IE9iamVjdGBcbi8vXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqID0geyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0IH1cbi8vIC0tIG9taXQob2JqLCAnYScpXG4vLyAtLSAvLyB7IGI6IDIsIGM6IDMsIGQ6IDQgfVxuLy8gLS0gb21pdChvYmosIFsnYicsICdjJ10pXG4vLyAtLSAvLyB7IGE6IDEsIGQ6IDQgfVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIG9taXQob2JqLCAneicpID09PSBvYmoxXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBgYGBcbmZ1bmN0aW9uIG9taXQob2JqLCBhdHRycykge1xuICB2YXIgb21pdExpc3QgPSBBcnJheS5pc0FycmF5KGF0dHJzKSA/IGF0dHJzIDogW2F0dHJzXTtcbiAgdmFyIGZEb1NvbWV0aGluZyA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9taXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBvbWl0TGlzdFtpXSkpIHtcbiAgICAgIGZEb1NvbWV0aGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFmRG9Tb21ldGhpbmcpIHJldHVybiBvYmo7XG4gIHZhciBvdXQgPSB7fTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzQW5kU3ltYm9scyhvYmopO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tfaV07XG4gICAgaWYgKG9taXRMaXN0LmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIC0tICMjIyMgYWRkRGVmYXVsdHMoKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBvYmplY3QgYnVpbHQgYXMgZm9sbG93czogYHVuZGVmaW5lZGAga2V5cyBpbiB0aGUgZmlyc3Qgb25lXG4vLyAtLSBhcmUgZmlsbGVkIGluIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzIGZyb20gdGhlIHNlY29uZCBvbmVcbi8vIC0tIChldmVuIGlmIHRoZXkgYXJlIGBudWxsYCkuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6XG4vLyAtLVxuLy8gLS0gKiBgYWRkRGVmYXVsdHMob2JqOiBPYmplY3QsIGRlZmF1bHRzOiBPYmplY3QpOiBPYmplY3RgXG4vLyAtLSAqIGBhZGREZWZhdWx0cyhvYmo6IE9iamVjdCwgLi4uZGVmYXVsdE9iamVjdHM6IEFycmF5PD9PYmplY3Q+KTogT2JqZWN0YFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBvYmoxID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbi8vIC0tIG9iajIgPSB7IGM6IDQsIGQ6IDUsIGU6IG51bGwgfVxuLy8gLS0gb2JqMyA9IGFkZERlZmF1bHRzKG9iajEsIG9iajIpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDIsIGM6IDMsIGQ6IDUsIGU6IG51bGwgfVxuLy8gLS0gb2JqMyA9PT0gb2JqMVxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBhZGREZWZhdWx0cyhvYmoxLCB7IGM6IDQgfSkgPT09IG9iajFcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuZnVuY3Rpb24gYWRkRGVmYXVsdHMoYSwgYiwgYywgZCwgZSwgZikge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBBcnJheShfbGVuNSA+IDYgPyBfbGVuNSAtIDYgOiAwKSwgX2tleTUgPSA2OyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgcmVzdFtfa2V5NSAtIDZdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiByZXN0Lmxlbmd0aCA/IGRvTWVyZ2UuY2FsbC5hcHBseShkb01lcmdlLCBbbnVsbCwgdHJ1ZSwgZmFsc2UsIGEsIGIsIGMsIGQsIGUsIGZdLmNvbmNhdChyZXN0KSkgOiBkb01lcmdlKHRydWUsIGZhbHNlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxudmFyIHRpbW0gPSB7XG4gIGNsb25lOiBjbG9uZSxcbiAgYWRkTGFzdDogYWRkTGFzdCxcbiAgYWRkRmlyc3Q6IGFkZEZpcnN0LFxuICByZW1vdmVMYXN0OiByZW1vdmVMYXN0LFxuICByZW1vdmVGaXJzdDogcmVtb3ZlRmlyc3QsXG4gIGluc2VydDogaW5zZXJ0LFxuICByZW1vdmVBdDogcmVtb3ZlQXQsXG4gIHJlcGxhY2VBdDogcmVwbGFjZUF0LFxuXG4gIGdldEluOiBnZXRJbixcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9iamVjdC1zaG9ydGhhbmRcbiAgc2V0OiBzZXQsIC8vIHNvIHRoYXQgZmxvdyBkb2Vzbid0IGNvbXBsYWluXG4gIHNldEluOiBzZXRJbixcbiAgdXBkYXRlOiB1cGRhdGUsXG4gIHVwZGF0ZUluOiB1cGRhdGVJbixcbiAgbWVyZ2U6IG1lcmdlLFxuICBtZXJnZURlZXA6IG1lcmdlRGVlcCxcbiAgbWVyZ2VJbjogbWVyZ2VJbixcbiAgb21pdDogb21pdCxcbiAgYWRkRGVmYXVsdHM6IGFkZERlZmF1bHRzXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB0aW1tO1xuIiwiLy8gVGlueUNvbG9yIHYxLjQuMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9UaW55Q29sb3Jcbi8vIEJyaWFuIEdyaW5zdGVhZCwgTUlUIExpY2Vuc2VcblxuKGZ1bmN0aW9uKE1hdGgpIHtcblxudmFyIHRyaW1MZWZ0ID0gL15cXHMrLyxcbiAgICB0cmltUmlnaHQgPSAvXFxzKyQvLFxuICAgIHRpbnlDb3VudGVyID0gMCxcbiAgICBtYXRoUm91bmQgPSBNYXRoLnJvdW5kLFxuICAgIG1hdGhNaW4gPSBNYXRoLm1pbixcbiAgICBtYXRoTWF4ID0gTWF0aC5tYXgsXG4gICAgbWF0aFJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG5mdW5jdGlvbiB0aW55Y29sb3IgKGNvbG9yLCBvcHRzKSB7XG5cbiAgICBjb2xvciA9IChjb2xvcikgPyBjb2xvciA6ICcnO1xuICAgIG9wdHMgPSBvcHRzIHx8IHsgfTtcblxuICAgIC8vIElmIGlucHV0IGlzIGFscmVhZHkgYSB0aW55Y29sb3IsIHJldHVybiBpdHNlbGZcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiB0aW55Y29sb3IpIHtcbiAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgY2FsbCB1c2luZyBuZXcgaW5zdGVhZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aW55Y29sb3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGlueWNvbG9yKGNvbG9yLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgcmdiID0gaW5wdXRUb1JHQihjb2xvcik7XG4gICAgdGhpcy5fb3JpZ2luYWxJbnB1dCA9IGNvbG9yLFxuICAgIHRoaXMuX3IgPSByZ2IucixcbiAgICB0aGlzLl9nID0gcmdiLmcsXG4gICAgdGhpcy5fYiA9IHJnYi5iLFxuICAgIHRoaXMuX2EgPSByZ2IuYSxcbiAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwLFxuICAgIHRoaXMuX2Zvcm1hdCA9IG9wdHMuZm9ybWF0IHx8IHJnYi5mb3JtYXQ7XG4gICAgdGhpcy5fZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XG5cbiAgICAvLyBEb24ndCBsZXQgdGhlIHJhbmdlIG9mIFswLDI1NV0gY29tZSBiYWNrIGluIFswLDFdLlxuICAgIC8vIFBvdGVudGlhbGx5IGxvc2UgYSBsaXR0bGUgYml0IG9mIHByZWNpc2lvbiBoZXJlLCBidXQgd2lsbCBmaXggaXNzdWVzIHdoZXJlXG4gICAgLy8gLjUgZ2V0cyBpbnRlcnByZXRlZCBhcyBoYWxmIG9mIHRoZSB0b3RhbCwgaW5zdGVhZCBvZiBoYWxmIG9mIDFcbiAgICAvLyBJZiBpdCB3YXMgc3VwcG9zZWQgdG8gYmUgMTI4LCB0aGlzIHdhcyBhbHJlYWR5IHRha2VuIGNhcmUgb2YgYnkgYGlucHV0VG9SZ2JgXG4gICAgaWYgKHRoaXMuX3IgPCAxKSB7IHRoaXMuX3IgPSBtYXRoUm91bmQodGhpcy5fcik7IH1cbiAgICBpZiAodGhpcy5fZyA8IDEpIHsgdGhpcy5fZyA9IG1hdGhSb3VuZCh0aGlzLl9nKTsgfVxuICAgIGlmICh0aGlzLl9iIDwgMSkgeyB0aGlzLl9iID0gbWF0aFJvdW5kKHRoaXMuX2IpOyB9XG5cbiAgICB0aGlzLl9vayA9IHJnYi5vaztcbiAgICB0aGlzLl90Y19pZCA9IHRpbnlDb3VudGVyKys7XG59XG5cbnRpbnljb2xvci5wcm90b3R5cGUgPSB7XG4gICAgaXNEYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnJpZ2h0bmVzcygpIDwgMTI4O1xuICAgIH0sXG4gICAgaXNMaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0RhcmsoKTtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2s7XG4gICAgfSxcbiAgICBnZXRPcmlnaW5hbElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbElucHV0O1xuICAgIH0sXG4gICAgZ2V0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcbiAgICB9LFxuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfSxcbiAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9BRVJUI2NvbG9yLWNvbnRyYXN0XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHJldHVybiAocmdiLnIgKiAyOTkgKyByZ2IuZyAqIDU4NyArIHJnYi5iICogMTE0KSAvIDEwMDA7XG4gICAgfSxcbiAgICBnZXRMdW1pbmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMudG9SZ2IoKTtcbiAgICAgICAgdmFyIFJzUkdCLCBHc1JHQiwgQnNSR0IsIFIsIEcsIEI7XG4gICAgICAgIFJzUkdCID0gcmdiLnIvMjU1O1xuICAgICAgICBHc1JHQiA9IHJnYi5nLzI1NTtcbiAgICAgICAgQnNSR0IgPSByZ2IuYi8yNTU7XG5cbiAgICAgICAgaWYgKFJzUkdCIDw9IDAuMDM5MjgpIHtSID0gUnNSR0IgLyAxMi45Mjt9IGVsc2Uge1IgPSBNYXRoLnBvdygoKFJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEdzUkdCIDw9IDAuMDM5MjgpIHtHID0gR3NSR0IgLyAxMi45Mjt9IGVsc2Uge0cgPSBNYXRoLnBvdygoKEdzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEJzUkdCIDw9IDAuMDM5MjgpIHtCID0gQnNSR0IgLyAxMi45Mjt9IGVsc2Uge0IgPSBNYXRoLnBvdygoKEJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgcmV0dXJuICgwLjIxMjYgKiBSKSArICgwLjcxNTIgKiBHKSArICgwLjA3MjIgKiBCKTtcbiAgICB9LFxuICAgIHNldEFscGhhOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hID0gYm91bmRBbHBoYSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9Ic3Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzdi5oICogMzYwLCBzOiBoc3YucywgdjogaHN2LnYsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHN2U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc3YuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHN2LnMgKiAxMDApLCB2ID0gbWF0aFJvdW5kKGhzdi52ICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzdihcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzdmEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgcmV0dXJuIHsgaDogaHNsLmggKiAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9Ic2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHZhciBoID0gbWF0aFJvdW5kKGhzbC5oICogMzYwKSwgcyA9IG1hdGhSb3VuZChoc2wucyAqIDEwMCksIGwgPSBtYXRoUm91bmQoaHNsLmwgKiAxMDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwiaHNsKFwiICArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUpXCIgOlxuICAgICAgICAgIFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUsIFwiKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvSGV4OiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCBhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4KGFsbG93M0NoYXIpO1xuICAgIH0sXG4gICAgdG9IZXg4OiBmdW5jdGlvbihhbGxvdzRDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JhVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSwgYWxsb3c0Q2hhcik7XG4gICAgfSxcbiAgICB0b0hleDhTdHJpbmc6IGZ1bmN0aW9uKGFsbG93NENoYXIpIHtcbiAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXg4KGFsbG93NENoYXIpO1xuICAgIH0sXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRoUm91bmQodGhpcy5fciksIGc6IG1hdGhSb3VuZCh0aGlzLl9nKSwgYjogbWF0aFJvdW5kKHRoaXMuX2IpLCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b1JnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKHRoaXMuX3IpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2cpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXCIpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgZzogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcInJnYihcIiAgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9iLCAyNTUpICogMTAwKSArIFwiJSlcIiA6XG4gICAgICAgICAgXCJyZ2JhKFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleE5hbWVzW3JnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRydWUpXSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHRvRmlsdGVyOiBmdW5jdGlvbihzZWNvbmRDb2xvcikge1xuICAgICAgICB2YXIgaGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XG4gICAgICAgIHZhciBzZWNvbmRIZXg4U3RyaW5nID0gaGV4OFN0cmluZztcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZSA9IHRoaXMuX2dyYWRpZW50VHlwZSA/IFwiR3JhZGllbnRUeXBlID0gMSwgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChzZWNvbmRDb2xvcikge1xuICAgICAgICAgICAgdmFyIHMgPSB0aW55Y29sb3Ioc2Vjb25kQ29sb3IpO1xuICAgICAgICAgICAgc2Vjb25kSGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgocy5fciwgcy5fZywgcy5fYiwgcy5fYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoXCIrZ3JhZGllbnRUeXBlK1wic3RhcnRDb2xvcnN0cj1cIitoZXg4U3RyaW5nK1wiLGVuZENvbG9yc3RyPVwiK3NlY29uZEhleDhTdHJpbmcrXCIpXCI7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBmb3JtYXRTZXQgPSAhIWZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuX2Zvcm1hdDtcblxuICAgICAgICB2YXIgZm9ybWF0dGVkU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNBbHBoYSA9IHRoaXMuX2EgPCAxICYmIHRoaXMuX2EgPj0gMDtcbiAgICAgICAgdmFyIG5lZWRzQWxwaGFGb3JtYXQgPSAhZm9ybWF0U2V0ICYmIGhhc0FscGhhICYmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIiB8fCBmb3JtYXQgPT09IFwiaGV4M1wiIHx8IGZvcm1hdCA9PT0gXCJoZXg0XCIgfHwgZm9ybWF0ID09PSBcImhleDhcIiB8fCBmb3JtYXQgPT09IFwibmFtZVwiKTtcblxuICAgICAgICBpZiAobmVlZHNBbHBoYUZvcm1hdCkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBcInRyYW5zcGFyZW50XCIsIGFsbCBvdGhlciBub24tYWxwaGEgZm9ybWF0c1xuICAgICAgICAgICAgLy8gd2lsbCByZXR1cm4gcmdiYSB3aGVuIHRoZXJlIGlzIHRyYW5zcGFyZW5jeS5cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwibmFtZVwiICYmIHRoaXMuX2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b05hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyZ2JcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicHJnYlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvUGVyY2VudGFnZVJnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4M1wiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4NFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4OFN0cmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDhcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhzbFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHNsU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc3ZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzdlN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZyB8fCB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aW55Y29sb3IodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5TW9kaWZpY2F0aW9uOiBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICB2YXIgY29sb3IgPSBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICAgICAgdGhpcy5fciA9IGNvbG9yLl9yO1xuICAgICAgICB0aGlzLl9nID0gY29sb3IuX2c7XG4gICAgICAgIHRoaXMuX2IgPSBjb2xvci5fYjtcbiAgICAgICAgdGhpcy5zZXRBbHBoYShjb2xvci5fYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbGlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihsaWdodGVuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgYnJpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oYnJpZ2h0ZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBkYXJrZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGFya2VuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihkZXNhdHVyYXRlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc2F0dXJhdGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBncmV5c2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZ3JleXNjYWxlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihzcGluLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlDb21iaW5hdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgIH0sXG4gICAgYW5hbG9nb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oYW5hbG9nb3VzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKGNvbXBsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtb25vY2hyb21hdGljOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24obW9ub2Nocm9tYXRpYywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNwbGl0Y29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHNwbGl0Y29tcGxlbWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRyaWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24odHJpYWQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0ZXRyYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0ZXRyYWQsIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcblxuLy8gSWYgaW5wdXQgaXMgYW4gb2JqZWN0LCBmb3JjZSAxIGludG8gXCIxLjBcIiB0byBoYW5kbGUgcmF0aW9zIHByb3Blcmx5XG4vLyBTdHJpbmcgaW5wdXQgcmVxdWlyZXMgXCIxLjBcIiBhcyBpbnB1dCwgc28gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgMVxudGlueWNvbG9yLmZyb21SYXRpbyA9IGZ1bmN0aW9uKGNvbG9yLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBuZXdDb2xvciA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb2xvcltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbG9yID0gbmV3Q29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG59O1xuXG4vLyBHaXZlbiBhIHN0cmluZyBvciBvYmplY3QsIGNvbnZlcnQgdGhhdCBpbnB1dCB0byBSR0Jcbi8vIFBvc3NpYmxlIHN0cmluZyBpbnB1dHM6XG4vL1xuLy8gICAgIFwicmVkXCJcbi8vICAgICBcIiNmMDBcIiBvciBcImYwMFwiXG4vLyAgICAgXCIjZmYwMDAwXCIgb3IgXCJmZjAwMDBcIlxuLy8gICAgIFwiI2ZmMDAwMDAwXCIgb3IgXCJmZjAwMDAwMFwiXG4vLyAgICAgXCJyZ2IgMjU1IDAgMFwiIG9yIFwicmdiICgyNTUsIDAsIDApXCJcbi8vICAgICBcInJnYiAxLjAgMCAwXCIgb3IgXCJyZ2IgKDEsIDAsIDApXCJcbi8vICAgICBcInJnYmEgKDI1NSwgMCwgMCwgMSlcIiBvciBcInJnYmEgMjU1LCAwLCAwLCAxXCJcbi8vICAgICBcInJnYmEgKDEuMCwgMCwgMCwgMSlcIiBvciBcInJnYmEgMS4wLCAwLCAwLCAxXCJcbi8vICAgICBcImhzbCgwLCAxMDAlLCA1MCUpXCIgb3IgXCJoc2wgMCAxMDAlIDUwJVwiXG4vLyAgICAgXCJoc2xhKDAsIDEwMCUsIDUwJSwgMSlcIiBvciBcImhzbGEgMCAxMDAlIDUwJSwgMVwiXG4vLyAgICAgXCJoc3YoMCwgMTAwJSwgMTAwJSlcIiBvciBcImhzdiAwIDEwMCUgMTAwJVwiXG4vL1xuZnVuY3Rpb24gaW5wdXRUb1JHQihjb2xvcikge1xuXG4gICAgdmFyIHJnYiA9IHsgcjogMCwgZzogMCwgYjogMCB9O1xuICAgIHZhciBhID0gMTtcbiAgICB2YXIgcyA9IG51bGw7XG4gICAgdmFyIHYgPSBudWxsO1xuICAgIHZhciBsID0gbnVsbDtcbiAgICB2YXIgb2sgPSBmYWxzZTtcbiAgICB2YXIgZm9ybWF0ID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29sb3IgPSBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLnIpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmcpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmIpKSB7XG4gICAgICAgICAgICByZ2IgPSByZ2JUb1JnYihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFN0cmluZyhjb2xvci5yKS5zdWJzdHIoLTEpID09PSBcIiVcIiA/IFwicHJnYlwiIDogXCJyZ2JcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci52KSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICB2ID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci52KTtcbiAgICAgICAgICAgIHJnYiA9IGhzdlRvUmdiKGNvbG9yLmgsIHMsIHYpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc3ZcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5sKSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICBsID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5sKTtcbiAgICAgICAgICAgIHJnYiA9IGhzbFRvUmdiKGNvbG9yLmgsIHMsIGwpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc2xcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShcImFcIikpIHtcbiAgICAgICAgICAgIGEgPSBjb2xvci5hO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYSA9IGJvdW5kQWxwaGEoYSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvazogb2ssXG4gICAgICAgIGZvcm1hdDogY29sb3IuZm9ybWF0IHx8IGZvcm1hdCxcbiAgICAgICAgcjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLnIsIDApKSxcbiAgICAgICAgZzogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmcsIDApKSxcbiAgICAgICAgYjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmIsIDApKSxcbiAgICAgICAgYTogYVxuICAgIH07XG59XG5cblxuLy8gQ29udmVyc2lvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGByZ2JUb0hzbGAsIGByZ2JUb0hzdmAsIGBoc2xUb1JnYmAsIGBoc3ZUb1JnYmAgbW9kaWZpZWQgZnJvbTpcbi8vIDxodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0PlxuXG4vLyBgcmdiVG9SZ2JgXG4vLyBIYW5kbGUgYm91bmRzIC8gcGVyY2VudGFnZSBjaGVja2luZyB0byBjb25mb3JtIHRvIENTUyBjb2xvciBzcGVjXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8+XG4vLyAqQXNzdW1lczoqIHIsIGcsIGIgaW4gWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIFswLCAyNTVdXG5mdW5jdGlvbiByZ2JUb1JnYihyLCBnLCBiKXtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBib3VuZDAxKHIsIDI1NSkgKiAyNTUsXG4gICAgICAgIGc6IGJvdW5kMDEoZywgMjU1KSAqIDI1NSxcbiAgICAgICAgYjogYm91bmQwMShiLCAyNTUpICogMjU1XG4gICAgfTtcbn1cblxuLy8gYHJnYlRvSHNsYFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC5cbi8vICpBc3N1bWVzOiogciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCBsIH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHNsKHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBoIC89IDY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaDogaCwgczogcywgbDogbCB9O1xufVxuXG4vLyBgaHNsVG9SZ2JgXG4vLyBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLlxuLy8gKkFzc3VtZXM6KiBoIGlzIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDM2MF0gYW5kIHMgYW5kIGwgYXJlIGNvbnRhaW5lZCBbMCwgMV0gb3IgWzAsIDEwMF1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICAgIHZhciByLCBnLCBiO1xuXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKTtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIGwgPSBib3VuZDAxKGwsIDEwMCk7XG5cbiAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICAgICAgaWYodCA8IDApIHQgKz0gMTtcbiAgICAgICAgaWYodCA+IDEpIHQgLT0gMTtcbiAgICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xuICAgICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBpZihzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYiAqIDI1NSB9O1xufVxuXG4vLyBgcmdiVG9Ic3ZgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCB2IH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHN2KHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIHYgPSBtYXg7XG5cbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIHY6IHYgfTtcbn1cblxuLy8gYGhzdlRvUmdiYFxuLy8gQ29udmVydHMgYW4gSFNWIGNvbG9yIHZhbHVlIHRvIFJHQi5cbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCB2IGFyZSBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAxMDBdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIHRoZSBzZXQgWzAsIDI1NV1cbiBmdW5jdGlvbiBoc3ZUb1JnYihoLCBzLCB2KSB7XG5cbiAgICBoID0gYm91bmQwMShoLCAzNjApICogNjtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIHYgPSBib3VuZDAxKHYsIDEwMCk7XG5cbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCksXG4gICAgICAgIGYgPSBoIC0gaSxcbiAgICAgICAgcCA9IHYgKiAoMSAtIHMpLFxuICAgICAgICBxID0gdiAqICgxIC0gZiAqIHMpLFxuICAgICAgICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpLFxuICAgICAgICBtb2QgPSBpICUgNixcbiAgICAgICAgciA9IFt2LCBxLCBwLCBwLCB0LCB2XVttb2RdLFxuICAgICAgICBnID0gW3QsIHYsIHYsIHEsIHAsIHBdW21vZF0sXG4gICAgICAgIGIgPSBbcCwgcCwgdCwgdiwgdiwgcV1bbW9kXTtcblxuICAgIHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfTtcbn1cblxuLy8gYHJnYlRvSGV4YFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIGhleFxuLy8gQXNzdW1lcyByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV1cbi8vIFJldHVybnMgYSAzIG9yIDYgY2hhcmFjdGVyIGhleFxuZnVuY3Rpb24gcmdiVG9IZXgociwgZywgYiwgYWxsb3czQ2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSAzIGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3czQ2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSkge1xuICAgICAgICByZXR1cm4gaGV4WzBdLmNoYXJBdCgwKSArIGhleFsxXS5jaGFyQXQoMCkgKyBoZXhbMl0uY2hhckF0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYHJnYmFUb0hleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgcGx1cyBhbHBoYSB0cmFuc3BhcmVuY3kgdG8gaGV4XG4vLyBBc3N1bWVzIHIsIGcsIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZFxuLy8gYSBpbiBbMCwgMV0uIFJldHVybnMgYSA0IG9yIDggY2hhcmFjdGVyIHJnYmEgaGV4XG5mdW5jdGlvbiByZ2JhVG9IZXgociwgZywgYiwgYSwgYWxsb3c0Q2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSA0IGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3c0Q2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSAmJiBoZXhbM10uY2hhckF0KDApID09IGhleFszXS5jaGFyQXQoMSkpIHtcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKSArIGhleFszXS5jaGFyQXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgcmdiYVRvQXJnYkhleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgdG8gYW4gQVJHQiBIZXg4IHN0cmluZ1xuLy8gUmFyZWx5IHVzZWQsIGJ1dCByZXF1aXJlZCBmb3IgXCJ0b0ZpbHRlcigpXCJcbmZ1bmN0aW9uIHJnYmFUb0FyZ2JIZXgociwgZywgYiwgYSkge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGBlcXVhbHNgXG4vLyBDYW4gYmUgY2FsbGVkIHdpdGggYW55IHRpbnljb2xvciBpbnB1dFxudGlueWNvbG9yLmVxdWFscyA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMikge1xuICAgIGlmICghY29sb3IxIHx8ICFjb2xvcjIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcjEpLnRvUmdiU3RyaW5nKCkgPT0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2JTdHJpbmcoKTtcbn07XG5cbnRpbnljb2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yLmZyb21SYXRpbyh7XG4gICAgICAgIHI6IG1hdGhSYW5kb20oKSxcbiAgICAgICAgZzogbWF0aFJhbmRvbSgpLFxuICAgICAgICBiOiBtYXRoUmFuZG9tKClcbiAgICB9KTtcbn07XG5cblxuLy8gTW9kaWZpY2F0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGxlc3MuanMgZm9yIHNvbWUgb2YgdGhlIGJhc2ljcyBoZXJlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaGVhZC9sZXNzLmpzL2Jsb2IvbWFzdGVyL2xpYi9sZXNzL2Z1bmN0aW9ucy5qcz5cblxuZnVuY3Rpb24gZGVzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wucyAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5zICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IGNsYW1wMDEoaHNsLnMpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gZ3JleXNjYWxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZGVzYXR1cmF0ZSgxMDApO1xufVxuXG5mdW5jdGlvbiBsaWdodGVuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIGJyaWdodGVuKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgcmdiID0gdGlueWNvbG9yKGNvbG9yKS50b1JnYigpO1xuICAgIHJnYi5yID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLnIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuZyA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5nIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmdiLmIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuYiAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJldHVybiB0aW55Y29sb3IocmdiKTtcbn1cblxuZnVuY3Rpb24gZGFya2VuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIFNwaW4gdGFrZXMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBhbW91bnQgd2l0aGluIFstMzYwLCAzNjBdIGluZGljYXRpbmcgdGhlIGNoYW5nZSBvZiBodWUuXG4vLyBWYWx1ZXMgb3V0c2lkZSBvZiB0aGlzIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbnRvIHRoaXMgcmFuZ2UuXG5mdW5jdGlvbiBzcGluKGNvbG9yLCBhbW91bnQpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQpICUgMzYwO1xuICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIENvbWJpbmF0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGFua3MgdG8galF1ZXJ5IHhDb2xvciBmb3Igc29tZSBvZiB0aGUgaWRlYXMgYmVoaW5kIHRoZXNlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2luZnVzaW9uL2pRdWVyeS14Y29sb3IvYmxvYi9tYXN0ZXIvanF1ZXJ5Lnhjb2xvci5qcz5cblxuZnVuY3Rpb24gY29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmggPSAoaHNsLmggKyAxODApICUgMzYwO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gdHJpYWQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxMjApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjQwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gdGV0cmFkKGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgOTApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTgwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI3MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHNwbGl0Y29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDcyKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjE2KSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBhbmFsb2dvdXMoY29sb3IsIHJlc3VsdHMsIHNsaWNlcykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XG4gICAgc2xpY2VzID0gc2xpY2VzIHx8IDMwO1xuXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgcGFydCA9IDM2MCAvIHNsaWNlcztcbiAgICB2YXIgcmV0ID0gW3Rpbnljb2xvcihjb2xvcildO1xuXG4gICAgZm9yIChoc2wuaCA9ICgoaHNsLmggLSAocGFydCAqIHJlc3VsdHMgPj4gMSkpICsgNzIwKSAlIDM2MDsgLS1yZXN1bHRzOyApIHtcbiAgICAgICAgaHNsLmggPSAoaHNsLmggKyBwYXJ0KSAlIDM2MDtcbiAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKGhzbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBtb25vY2hyb21hdGljKGNvbG9yLCByZXN1bHRzKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcbiAgICB2YXIgaHN2ID0gdGlueWNvbG9yKGNvbG9yKS50b0hzdigpO1xuICAgIHZhciBoID0gaHN2LmgsIHMgPSBoc3YucywgdiA9IGhzdi52O1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgbW9kaWZpY2F0aW9uID0gMSAvIHJlc3VsdHM7XG5cbiAgICB3aGlsZSAocmVzdWx0cy0tKSB7XG4gICAgICAgIHJldC5wdXNoKHRpbnljb2xvcih7IGg6IGgsIHM6IHMsIHY6IHZ9KSk7XG4gICAgICAgIHYgPSAodiArIG1vZGlmaWNhdGlvbikgJSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIFV0aWxpdHkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudGlueWNvbG9yLm1peCA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDUwKTtcblxuICAgIHZhciByZ2IxID0gdGlueWNvbG9yKGNvbG9yMSkudG9SZ2IoKTtcbiAgICB2YXIgcmdiMiA9IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiKCk7XG5cbiAgICB2YXIgcCA9IGFtb3VudCAvIDEwMDtcblxuICAgIHZhciByZ2JhID0ge1xuICAgICAgICByOiAoKHJnYjIuciAtIHJnYjEucikgKiBwKSArIHJnYjEucixcbiAgICAgICAgZzogKChyZ2IyLmcgLSByZ2IxLmcpICogcCkgKyByZ2IxLmcsXG4gICAgICAgIGI6ICgocmdiMi5iIC0gcmdiMS5iKSAqIHApICsgcmdiMS5iLFxuICAgICAgICBhOiAoKHJnYjIuYSAtIHJnYjEuYSkgKiBwKSArIHJnYjEuYVxuICAgIH07XG5cbiAgICByZXR1cm4gdGlueWNvbG9yKHJnYmEpO1xufTtcblxuXG4vLyBSZWFkYWJpbGl0eSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWYgKFdDQUcgVmVyc2lvbiAyKVxuXG4vLyBgY29udHJhc3RgXG4vLyBBbmFseXplIHRoZSAyIGNvbG9ycyBhbmQgcmV0dXJucyB0aGUgY29sb3IgY29udHJhc3QgZGVmaW5lZCBieSAoV0NBRyBWZXJzaW9uIDIpXG50aW55Y29sb3IucmVhZGFiaWxpdHkgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuICAgIHZhciBjMSA9IHRpbnljb2xvcihjb2xvcjEpO1xuICAgIHZhciBjMiA9IHRpbnljb2xvcihjb2xvcjIpO1xuICAgIHJldHVybiAoTWF0aC5tYXgoYzEuZ2V0THVtaW5hbmNlKCksYzIuZ2V0THVtaW5hbmNlKCkpKzAuMDUpIC8gKE1hdGgubWluKGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KTtcbn07XG5cbi8vIGBpc1JlYWRhYmxlYFxuLy8gRW5zdXJlIHRoYXQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciBjb21iaW5hdGlvbnMgbWVldCBXQ0FHMiBndWlkZWxpbmVzLlxuLy8gVGhlIHRoaXJkIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIE9iamVjdC5cbi8vICAgICAgdGhlICdsZXZlbCcgcHJvcGVydHkgc3RhdGVzICdBQScgb3IgJ0FBQScgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdBQSc7XG4vLyAgICAgIHRoZSAnc2l6ZScgcHJvcGVydHkgc3RhdGVzICdsYXJnZScgb3IgJ3NtYWxsJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ3NtYWxsJy5cbi8vIElmIHRoZSBlbnRpcmUgb2JqZWN0IGlzIGFic2VudCwgaXNSZWFkYWJsZSBkZWZhdWx0cyB0byB7bGV2ZWw6XCJBQVwiLHNpemU6XCJzbWFsbFwifS5cblxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIpID0+IGZhbHNlXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIse2xldmVsOlwiQUFcIixzaXplOlwibGFyZ2VcIn0pID0+IGZhbHNlXG50aW55Y29sb3IuaXNSZWFkYWJsZSA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCB3Y2FnMikge1xuICAgIHZhciByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShjb2xvcjEsIGNvbG9yMik7XG4gICAgdmFyIHdjYWcyUGFybXMsIG91dDtcblxuICAgIG91dCA9IGZhbHNlO1xuXG4gICAgd2NhZzJQYXJtcyA9IHZhbGlkYXRlV0NBRzJQYXJtcyh3Y2FnMik7XG4gICAgc3dpdGNoICh3Y2FnMlBhcm1zLmxldmVsICsgd2NhZzJQYXJtcy5zaXplKSB7XG4gICAgICAgIGNhc2UgXCJBQXNtYWxsXCI6XG4gICAgICAgIGNhc2UgXCJBQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQWxhcmdlXCI6XG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQUFzbWFsbFwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuXG59O1xuXG4vLyBgbW9zdFJlYWRhYmxlYFxuLy8gR2l2ZW4gYSBiYXNlIGNvbG9yIGFuZCBhIGxpc3Qgb2YgcG9zc2libGUgZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kXG4vLyBjb2xvcnMgZm9yIHRoYXQgYmFzZSwgcmV0dXJucyB0aGUgbW9zdCByZWFkYWJsZSBjb2xvci5cbi8vIE9wdGlvbmFsbHkgcmV0dXJucyBCbGFjayBvciBXaGl0ZSBpZiB0aGUgbW9zdCByZWFkYWJsZSBjb2xvciBpcyB1bnJlYWRhYmxlLlxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjMTIzXCIsIFtcIiMxMjRcIiwgXCIjMTI1XCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6ZmFsc2V9KS50b0hleFN0cmluZygpOyAvLyBcIiMxMTIyNTVcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWV9KS50b0hleFN0cmluZygpOyAgLy8gXCIjZmZmZmZmXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcImxhcmdlXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmYWYzZjNcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiNhODAxNWFcIiwgW1wiI2ZhZjNmM1wiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWUsbGV2ZWw6XCJBQUFcIixzaXplOlwic21hbGxcIn0pLnRvSGV4U3RyaW5nKCk7IC8vIFwiI2ZmZmZmZlwiXG50aW55Y29sb3IubW9zdFJlYWRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9yLCBjb2xvckxpc3QsIGFyZ3MpIHtcbiAgICB2YXIgYmVzdENvbG9yID0gbnVsbDtcbiAgICB2YXIgYmVzdFNjb3JlID0gMDtcbiAgICB2YXIgcmVhZGFiaWxpdHk7XG4gICAgdmFyIGluY2x1ZGVGYWxsYmFja0NvbG9ycywgbGV2ZWwsIHNpemUgO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGluY2x1ZGVGYWxsYmFja0NvbG9ycyA9IGFyZ3MuaW5jbHVkZUZhbGxiYWNrQ29sb3JzIDtcbiAgICBsZXZlbCA9IGFyZ3MubGV2ZWw7XG4gICAgc2l6ZSA9IGFyZ3Muc2l6ZTtcblxuICAgIGZvciAodmFyIGk9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5KGJhc2VDb2xvciwgY29sb3JMaXN0W2ldKTtcbiAgICAgICAgaWYgKHJlYWRhYmlsaXR5ID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSByZWFkYWJpbGl0eTtcbiAgICAgICAgICAgIGJlc3RDb2xvciA9IHRpbnljb2xvcihjb2xvckxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbnljb2xvci5pc1JlYWRhYmxlKGJhc2VDb2xvciwgYmVzdENvbG9yLCB7XCJsZXZlbFwiOmxldmVsLFwic2l6ZVwiOnNpemV9KSB8fCAhaW5jbHVkZUZhbGxiYWNrQ29sb3JzKSB7XG4gICAgICAgIHJldHVybiBiZXN0Q29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycz1mYWxzZTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvci5tb3N0UmVhZGFibGUoYmFzZUNvbG9yLFtcIiNmZmZcIiwgXCIjMDAwXCJdLGFyZ3MpO1xuICAgIH1cbn07XG5cblxuLy8gQmlnIExpc3Qgb2YgQ29sb3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3I+XG52YXIgbmFtZXMgPSB0aW55Y29sb3IubmFtZXMgPSB7XG4gICAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuICAgIGFudGlxdWV3aGl0ZTogXCJmYWViZDdcIixcbiAgICBhcXVhOiBcIjBmZlwiLFxuICAgIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG4gICAgYXp1cmU6IFwiZjBmZmZmXCIsXG4gICAgYmVpZ2U6IFwiZjVmNWRjXCIsXG4gICAgYmlzcXVlOiBcImZmZTRjNFwiLFxuICAgIGJsYWNrOiBcIjAwMFwiLFxuICAgIGJsYW5jaGVkYWxtb25kOiBcImZmZWJjZFwiLFxuICAgIGJsdWU6IFwiMDBmXCIsXG4gICAgYmx1ZXZpb2xldDogXCI4YTJiZTJcIixcbiAgICBicm93bjogXCJhNTJhMmFcIixcbiAgICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gICAgYnVybnRzaWVubmE6IFwiZWE3ZTVkXCIsXG4gICAgY2FkZXRibHVlOiBcIjVmOWVhMFwiLFxuICAgIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG4gICAgY2hvY29sYXRlOiBcImQyNjkxZVwiLFxuICAgIGNvcmFsOiBcImZmN2Y1MFwiLFxuICAgIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuICAgIGNvcm5zaWxrOiBcImZmZjhkY1wiLFxuICAgIGNyaW1zb246IFwiZGMxNDNjXCIsXG4gICAgY3lhbjogXCIwZmZcIixcbiAgICBkYXJrYmx1ZTogXCIwMDAwOGJcIixcbiAgICBkYXJrY3lhbjogXCIwMDhiOGJcIixcbiAgICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuICAgIGRhcmtncmF5OiBcImE5YTlhOVwiLFxuICAgIGRhcmtncmVlbjogXCIwMDY0MDBcIixcbiAgICBkYXJrZ3JleTogXCJhOWE5YTlcIixcbiAgICBkYXJra2hha2k6IFwiYmRiNzZiXCIsXG4gICAgZGFya21hZ2VudGE6IFwiOGIwMDhiXCIsXG4gICAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG4gICAgZGFya29yYW5nZTogXCJmZjhjMDBcIixcbiAgICBkYXJrb3JjaGlkOiBcIjk5MzJjY1wiLFxuICAgIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG4gICAgZGFya3NhbG1vbjogXCJlOTk2N2FcIixcbiAgICBkYXJrc2VhZ3JlZW46IFwiOGZiYzhmXCIsXG4gICAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcbiAgICBkYXJrc2xhdGVncmF5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFwiMmY0ZjRmXCIsXG4gICAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcbiAgICBkYXJrdmlvbGV0OiBcIjk0MDBkM1wiLFxuICAgIGRlZXBwaW5rOiBcImZmMTQ5M1wiLFxuICAgIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuICAgIGRpbWdyYXk6IFwiNjk2OTY5XCIsXG4gICAgZGltZ3JleTogXCI2OTY5NjlcIixcbiAgICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuICAgIGZpcmVicmljazogXCJiMjIyMjJcIixcbiAgICBmbG9yYWx3aGl0ZTogXCJmZmZhZjBcIixcbiAgICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcbiAgICBmdWNoc2lhOiBcImYwZlwiLFxuICAgIGdhaW5zYm9ybzogXCJkY2RjZGNcIixcbiAgICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuICAgIGdvbGQ6IFwiZmZkNzAwXCIsXG4gICAgZ29sZGVucm9kOiBcImRhYTUyMFwiLFxuICAgIGdyYXk6IFwiODA4MDgwXCIsXG4gICAgZ3JlZW46IFwiMDA4MDAwXCIsXG4gICAgZ3JlZW55ZWxsb3c6IFwiYWRmZjJmXCIsXG4gICAgZ3JleTogXCI4MDgwODBcIixcbiAgICBob25leWRldzogXCJmMGZmZjBcIixcbiAgICBob3RwaW5rOiBcImZmNjliNFwiLFxuICAgIGluZGlhbnJlZDogXCJjZDVjNWNcIixcbiAgICBpbmRpZ286IFwiNGIwMDgyXCIsXG4gICAgaXZvcnk6IFwiZmZmZmYwXCIsXG4gICAga2hha2k6IFwiZjBlNjhjXCIsXG4gICAgbGF2ZW5kZXI6IFwiZTZlNmZhXCIsXG4gICAgbGF2ZW5kZXJibHVzaDogXCJmZmYwZjVcIixcbiAgICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG4gICAgbGVtb25jaGlmZm9uOiBcImZmZmFjZFwiLFxuICAgIGxpZ2h0Ymx1ZTogXCJhZGQ4ZTZcIixcbiAgICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuICAgIGxpZ2h0Y3lhbjogXCJlMGZmZmZcIixcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCJmYWZhZDJcIixcbiAgICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRncmVlbjogXCI5MGVlOTBcIixcbiAgICBsaWdodGdyZXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuICAgIGxpZ2h0c2FsbW9uOiBcImZmYTA3YVwiLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFwiMjBiMmFhXCIsXG4gICAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuICAgIGxpZ2h0eWVsbG93OiBcImZmZmZlMFwiLFxuICAgIGxpbWU6IFwiMGYwXCIsXG4gICAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuICAgIGxpbmVuOiBcImZhZjBlNlwiLFxuICAgIG1hZ2VudGE6IFwiZjBmXCIsXG4gICAgbWFyb29uOiBcIjgwMDAwMFwiLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFwiNjZjZGFhXCIsXG4gICAgbWVkaXVtYmx1ZTogXCIwMDAwY2RcIixcbiAgICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG4gICAgbWVkaXVtcHVycGxlOiBcIjkzNzBkYlwiLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBcIjNjYjM3MVwiLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogXCIwMGZhOWFcIixcbiAgICBtZWRpdW10dXJxdW9pc2U6IFwiNDhkMWNjXCIsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuICAgIG1pZG5pZ2h0Ymx1ZTogXCIxOTE5NzBcIixcbiAgICBtaW50Y3JlYW06IFwiZjVmZmZhXCIsXG4gICAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuICAgIG1vY2Nhc2luOiBcImZmZTRiNVwiLFxuICAgIG5hdmFqb3doaXRlOiBcImZmZGVhZFwiLFxuICAgIG5hdnk6IFwiMDAwMDgwXCIsXG4gICAgb2xkbGFjZTogXCJmZGY1ZTZcIixcbiAgICBvbGl2ZTogXCI4MDgwMDBcIixcbiAgICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG4gICAgb3JhbmdlOiBcImZmYTUwMFwiLFxuICAgIG9yYW5nZXJlZDogXCJmZjQ1MDBcIixcbiAgICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG4gICAgcGFsZWdvbGRlbnJvZDogXCJlZWU4YWFcIixcbiAgICBwYWxlZ3JlZW46IFwiOThmYjk4XCIsXG4gICAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcbiAgICBwYWxldmlvbGV0cmVkOiBcImRiNzA5M1wiLFxuICAgIHBhcGF5YXdoaXA6IFwiZmZlZmQ1XCIsXG4gICAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuICAgIHBlcnU6IFwiY2Q4NTNmXCIsXG4gICAgcGluazogXCJmZmMwY2JcIixcbiAgICBwbHVtOiBcImRkYTBkZFwiLFxuICAgIHBvd2RlcmJsdWU6IFwiYjBlMGU2XCIsXG4gICAgcHVycGxlOiBcIjgwMDA4MFwiLFxuICAgIHJlYmVjY2FwdXJwbGU6IFwiNjYzMzk5XCIsXG4gICAgcmVkOiBcImYwMFwiLFxuICAgIHJvc3licm93bjogXCJiYzhmOGZcIixcbiAgICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG4gICAgc2FkZGxlYnJvd246IFwiOGI0NTEzXCIsXG4gICAgc2FsbW9uOiBcImZhODA3MlwiLFxuICAgIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG4gICAgc2VhZ3JlZW46IFwiMmU4YjU3XCIsXG4gICAgc2Vhc2hlbGw6IFwiZmZmNWVlXCIsXG4gICAgc2llbm5hOiBcImEwNTIyZFwiLFxuICAgIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgICBza3libHVlOiBcIjg3Y2VlYlwiLFxuICAgIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcbiAgICBzbGF0ZWdyYXk6IFwiNzA4MDkwXCIsXG4gICAgc2xhdGVncmV5OiBcIjcwODA5MFwiLFxuICAgIHNub3c6IFwiZmZmYWZhXCIsXG4gICAgc3ByaW5nZ3JlZW46IFwiMDBmZjdmXCIsXG4gICAgc3RlZWxibHVlOiBcIjQ2ODJiNFwiLFxuICAgIHRhbjogXCJkMmI0OGNcIixcbiAgICB0ZWFsOiBcIjAwODA4MFwiLFxuICAgIHRoaXN0bGU6IFwiZDhiZmQ4XCIsXG4gICAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICAgIHR1cnF1b2lzZTogXCI0MGUwZDBcIixcbiAgICB2aW9sZXQ6IFwiZWU4MmVlXCIsXG4gICAgd2hlYXQ6IFwiZjVkZWIzXCIsXG4gICAgd2hpdGU6IFwiZmZmXCIsXG4gICAgd2hpdGVzbW9rZTogXCJmNWY1ZjVcIixcbiAgICB5ZWxsb3c6IFwiZmYwXCIsXG4gICAgeWVsbG93Z3JlZW46IFwiOWFjZDMyXCJcbn07XG5cbi8vIE1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgY29sb3JzIHZpYSBgaGV4TmFtZXNbaGV4XWBcbnZhciBoZXhOYW1lcyA9IHRpbnljb2xvci5oZXhOYW1lcyA9IGZsaXAobmFtZXMpO1xuXG5cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tXG5cbi8vIGB7ICduYW1lMSc6ICd2YWwxJyB9YCBiZWNvbWVzIGB7ICd2YWwxJzogJ25hbWUxJyB9YFxuZnVuY3Rpb24gZmxpcChvKSB7XG4gICAgdmFyIGZsaXBwZWQgPSB7IH07XG4gICAgZm9yICh2YXIgaSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBmbGlwcGVkW29baV1dID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZDtcbn1cblxuLy8gUmV0dXJuIGEgdmFsaWQgYWxwaGEgdmFsdWUgWzAsMV0gd2l0aCBhbGwgaW52YWxpZCB2YWx1ZXMgYmVpbmcgc2V0IHRvIDFcbmZ1bmN0aW9uIGJvdW5kQWxwaGEoYSkge1xuICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG4vLyBUYWtlIGlucHV0IGZyb20gWzAsIG5dIGFuZCByZXR1cm4gaXQgYXMgWzAsIDFdXG5mdW5jdGlvbiBib3VuZDAxKG4sIG1heCkge1xuICAgIGlmIChpc09uZVBvaW50WmVybyhuKSkgeyBuID0gXCIxMDAlXCI7IH1cblxuICAgIHZhciBwcm9jZXNzUGVyY2VudCA9IGlzUGVyY2VudGFnZShuKTtcbiAgICBuID0gbWF0aE1pbihtYXgsIG1hdGhNYXgoMCwgcGFyc2VGbG9hdChuKSkpO1xuXG4gICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IHBlcmNlbnRhZ2UgaW50byBudW1iZXJcbiAgICBpZiAocHJvY2Vzc1BlcmNlbnQpIHtcbiAgICAgICAgbiA9IHBhcnNlSW50KG4gKiBtYXgsIDEwKSAvIDEwMDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzXG4gICAgaWYgKChNYXRoLmFicyhuIC0gbWF4KSA8IDAuMDAwMDAxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gWzAsIDFdIHJhbmdlIGlmIGl0IGlzbid0IGFscmVhZHlcbiAgICByZXR1cm4gKG4gJSBtYXgpIC8gcGFyc2VGbG9hdChtYXgpO1xufVxuXG4vLyBGb3JjZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbmZ1bmN0aW9uIGNsYW1wMDEodmFsKSB7XG4gICAgcmV0dXJuIG1hdGhNaW4oMSwgbWF0aE1heCgwLCB2YWwpKTtcbn1cblxuLy8gUGFyc2UgYSBiYXNlLTE2IGhleCB2YWx1ZSBpbnRvIGEgYmFzZS0xMCBpbnRlZ2VyXG5mdW5jdGlvbiBwYXJzZUludEZyb21IZXgodmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTYpO1xufVxuXG4vLyBOZWVkIHRvIGhhbmRsZSAxLjAgYXMgMTAwJSwgc2luY2Ugb25jZSBpdCBpcyBhIG51bWJlciwgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGl0IGFuZCAxXG4vLyA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDIyMDcyL2phdmFzY3JpcHQtaG93LXRvLWRldGVjdC1udW1iZXItYXMtYS1kZWNpbWFsLWluY2x1ZGluZy0xLTA+XG5mdW5jdGlvbiBpc09uZVBvaW50WmVybyhuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCcuJykgIT0gLTEgJiYgcGFyc2VGbG9hdChuKSA9PT0gMTtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIHN0cmluZyBwYXNzZWQgaW4gaXMgYSBwZXJjZW50YWdlXG5mdW5jdGlvbiBpc1BlcmNlbnRhZ2Uobikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiAmJiBuLmluZGV4T2YoJyUnKSAhPSAtMTtcbn1cblxuLy8gRm9yY2UgYSBoZXggdmFsdWUgdG8gaGF2ZSAyIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBhZDIoYykge1xuICAgIHJldHVybiBjLmxlbmd0aCA9PSAxID8gJzAnICsgYyA6ICcnICsgYztcbn1cblxuLy8gUmVwbGFjZSBhIGRlY2ltYWwgd2l0aCBpdCdzIHBlcmNlbnRhZ2UgdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnRUb1BlcmNlbnRhZ2Uobikge1xuICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgbiA9IChuICogMTAwKSArIFwiJVwiO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG4vLyBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gYSBoZXggdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnREZWNpbWFsVG9IZXgoZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZCkgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIENvbnZlcnRzIGEgaGV4IHZhbHVlIHRvIGEgZGVjaW1hbFxuZnVuY3Rpb24gY29udmVydEhleFRvRGVjaW1hbChoKSB7XG4gICAgcmV0dXJuIChwYXJzZUludEZyb21IZXgoaCkgLyAyNTUpO1xufVxuXG52YXIgbWF0Y2hlcnMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI2ludGVnZXJzPlxuICAgIHZhciBDU1NfSU5URUdFUiA9IFwiWy1cXFxcK10/XFxcXGQrJT9cIjtcblxuICAgIC8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXZhbHVlcy8jbnVtYmVyLXZhbHVlPlxuICAgIHZhciBDU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG5cbiAgICAvLyBBbGxvdyBwb3NpdGl2ZS9uZWdhdGl2ZSBpbnRlZ2VyL251bWJlci4gIERvbid0IGNhcHR1cmUgdGhlIGVpdGhlci9vciwganVzdCB0aGUgZW50aXJlIG91dGNvbWUuXG4gICAgdmFyIENTU19VTklUID0gXCIoPzpcIiArIENTU19OVU1CRVIgKyBcIil8KD86XCIgKyBDU1NfSU5URUdFUiArIFwiKVwiO1xuXG4gICAgLy8gQWN0dWFsIG1hdGNoaW5nLlxuICAgIC8vIFBhcmVudGhlc2VzIGFuZCBjb21tYXMgYXJlIG9wdGlvbmFsLCBidXQgbm90IHJlcXVpcmVkLlxuICAgIC8vIFdoaXRlc3BhY2UgY2FuIHRha2UgdGhlIHBsYWNlIG9mIGNvbW1hcyBvciBvcGVuaW5nIHBhcmVuXG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0gzID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0g0ID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBDU1NfVU5JVDogbmV3IFJlZ0V4cChDU1NfVU5JVCksXG4gICAgICAgIHJnYjogbmV3IFJlZ0V4cChcInJnYlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICByZ2JhOiBuZXcgUmVnRXhwKFwicmdiYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoc2w6IG5ldyBSZWdFeHAoXCJoc2xcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgaHNsYTogbmV3IFJlZ0V4cChcImhzbGFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaHN2OiBuZXcgUmVnRXhwKFwiaHN2XCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIGhzdmE6IG5ldyBSZWdFeHAoXCJoc3ZhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhleDM6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICAgICAgaGV4NjogL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLFxuICAgICAgICBoZXg0OiAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICBoZXg4OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvXG4gICAgfTtcbn0pKCk7XG5cbi8vIGBpc1ZhbGlkQ1NTVW5pdGBcbi8vIFRha2UgaW4gYSBzaW5nbGUgc3RyaW5nIC8gbnVtYmVyIGFuZCBjaGVjayB0byBzZWUgaWYgaXQgbG9va3MgbGlrZSBhIENTUyB1bml0XG4vLyAoc2VlIGBtYXRjaGVyc2AgYWJvdmUgZm9yIGRlZmluaXRpb24pLlxuZnVuY3Rpb24gaXNWYWxpZENTU1VuaXQoY29sb3IpIHtcbiAgICByZXR1cm4gISFtYXRjaGVycy5DU1NfVU5JVC5leGVjKGNvbG9yKTtcbn1cblxuLy8gYHN0cmluZ0lucHV0VG9PYmplY3RgXG4vLyBQZXJtaXNzaXZlIHN0cmluZyBwYXJzaW5nLiAgVGFrZSBpbiBhIG51bWJlciBvZiBmb3JtYXRzLCBhbmQgb3V0cHV0IGFuIG9iamVjdFxuLy8gYmFzZWQgb24gZGV0ZWN0ZWQgZm9ybWF0LiAgUmV0dXJucyBgeyByLCBnLCBiIH1gIG9yIGB7IGgsIHMsIGwgfWAgb3IgYHsgaCwgcywgdn1gXG5mdW5jdGlvbiBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKSB7XG5cbiAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UodHJpbUxlZnQsJycpLnJlcGxhY2UodHJpbVJpZ2h0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZWQgPSBmYWxzZTtcbiAgICBpZiAobmFtZXNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZXNbY29sb3JdO1xuICAgICAgICBuYW1lZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yID09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogMCwgZzogMCwgYjogMCwgYTogMCwgZm9ybWF0OiBcIm5hbWVcIiB9O1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtYXRjaCBzdHJpbmcgaW5wdXQgdXNpbmcgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAvLyBLZWVwIG1vc3Qgb2YgdGhlIG51bWJlciBib3VuZGluZyBvdXQgb2YgdGhpcyBmdW5jdGlvbiAtIGRvbid0IHdvcnJ5IGFib3V0IFswLDFdIG9yIFswLDEwMF0gb3IgWzAsMzYwXVxuICAgIC8vIEp1c3QgcmV0dXJuIGFuIG9iamVjdCBhbmQgbGV0IHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBoYW5kbGUgdGhhdC5cbiAgICAvLyBUaGlzIHdheSB0aGUgcmVzdWx0IHdpbGwgYmUgdGhlIHNhbWUgd2hldGhlciB0aGUgdGlueWNvbG9yIGlzIGluaXRpYWxpemVkIHdpdGggc3RyaW5nIG9yIG9iamVjdC5cbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2YS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSksXG4gICAgICAgICAgICBhOiBjb252ZXJ0SGV4VG9EZWNpbWFsKG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10gKyAnJyArIG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0gKyAnJyArIG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgJycgKyBtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0gKyAnJyArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXQ0FHMlBhcm1zKHBhcm1zKSB7XG4gICAgLy8gcmV0dXJuIHZhbGlkIFdDQUcyIHBhcm1zIGZvciBpc1JlYWRhYmxlLlxuICAgIC8vIElmIGlucHV0IHBhcm1zIGFyZSBpbnZhbGlkLCByZXR1cm4ge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn1cbiAgICB2YXIgbGV2ZWwsIHNpemU7XG4gICAgcGFybXMgPSBwYXJtcyB8fCB7XCJsZXZlbFwiOlwiQUFcIiwgXCJzaXplXCI6XCJzbWFsbFwifTtcbiAgICBsZXZlbCA9IChwYXJtcy5sZXZlbCB8fCBcIkFBXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgc2l6ZSA9IChwYXJtcy5zaXplIHx8IFwic21hbGxcIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGV2ZWwgIT09IFwiQUFcIiAmJiBsZXZlbCAhPT0gXCJBQUFcIikge1xuICAgICAgICBsZXZlbCA9IFwiQUFcIjtcbiAgICB9XG4gICAgaWYgKHNpemUgIT09IFwic21hbGxcIiAmJiBzaXplICE9PSBcImxhcmdlXCIpIHtcbiAgICAgICAgc2l6ZSA9IFwic21hbGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcImxldmVsXCI6bGV2ZWwsIFwic2l6ZVwiOnNpemV9O1xufVxuXG4vLyBOb2RlOiBFeHBvcnQgZnVuY3Rpb25cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW55Y29sb3I7XG59XG4vLyBBTUQvcmVxdWlyZWpzOiBEZWZpbmUgdGhlIG1vZHVsZVxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtyZXR1cm4gdGlueWNvbG9yO30pO1xufVxuLy8gQnJvd3NlcjogRXhwb3NlIHRvIHdpbmRvd1xuZWxzZSB7XG4gICAgd2luZG93LnRpbnljb2xvciA9IHRpbnljb2xvcjtcbn1cblxufSkoTWF0aCk7XG4iLCJcblxuXG5cbjsoZnVuY3Rpb24oKXtcbnZhciBVVElGID0ge307XG5cbi8vIE1ha2UgYXZhaWxhYmxlIGZvciBpbXBvcnQgYnkgYHJlcXVpcmUoKWBcbmlmICh0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIHttb2R1bGUuZXhwb3J0cyA9IFVUSUY7fVxuZWxzZSB7c2VsZi5VVElGID0gVVRJRjt9XG5cbnZhciBwYWtvO1xuaWYgKHR5cGVvZiByZXF1aXJlID09IFwiZnVuY3Rpb25cIikge3Bha28gPSByZXF1aXJlKFwicGFrb1wiKTt9XG5lbHNlIHtwYWtvID0gc2VsZi5wYWtvO31cblxuZnVuY3Rpb24gbG9nKCkgeyBpZiAodHlwZW9mIHByb2Nlc3M9PVwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlY9PVwiZGV2ZWxvcG1lbnRcIikgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTsgIH1cblxuKGZ1bmN0aW9uKFVUSUYsIHBha28pe1xuXHRcbi8vIEZvbGxvd2luZyBsaW5lcyBhZGQgYSBKUEVHIGRlY29kZXIgIHRvIFVUSUYuSnBlZ0RlY29kZXJcbihmdW5jdGlvbigpe3ZhciBWPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGcpe3JldHVybiB0eXBlb2YgZ306ZnVuY3Rpb24oZyl7cmV0dXJuIGcmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJmcuY29uc3RydWN0b3I9PT1TeW1ib2wmJmchPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGd9LEQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBnKGcpe3RoaXMubWVzc2FnZT1cIkpQRUcgZXJyb3I6IFwiK2d9Zy5wcm90b3R5cGU9RXJyb3IoKTtnLnByb3RvdHlwZS5uYW1lPVwiSnBlZ0Vycm9yXCI7cmV0dXJuIGcuY29uc3RydWN0b3I9Z30oKSxQPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhnLEQpe3RoaXMubWVzc2FnZT1nO3RoaXMuZz1EfWcucHJvdG90eXBlPUVycm9yKCk7Zy5wcm90b3R5cGUubmFtZT1cIkROTE1hcmtlckVycm9yXCI7cmV0dXJuIGcuY29uc3RydWN0b3I9Z30oKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBnKCl7dGhpcy5NPVxubnVsbDt0aGlzLkI9LTF9ZnVuY3Rpb24gVyhhLGQpe2Zvcih2YXIgZj0wLGU9W10sYixCLGs9MTY7MDxrJiYhYVtrLTFdOylrLS07ZS5wdXNoKHtjaGlsZHJlbjpbXSxpbmRleDowfSk7dmFyIGw9ZVswXSxyO2ZvcihiPTA7YjxrO2IrKyl7Zm9yKEI9MDtCPGFbYl07QisrKXtsPWUucG9wKCk7Zm9yKGwuY2hpbGRyZW5bbC5pbmRleF09ZFtmXTswPGwuaW5kZXg7KWw9ZS5wb3AoKTtsLmluZGV4Kys7Zm9yKGUucHVzaChsKTtlLmxlbmd0aDw9YjspZS5wdXNoKHI9e2NoaWxkcmVuOltdLGluZGV4OjB9KSxsLmNoaWxkcmVuW2wuaW5kZXhdPXIuY2hpbGRyZW4sbD1yO2YrK31iKzE8ayYmKGUucHVzaChyPXtjaGlsZHJlbjpbXSxpbmRleDowfSksbC5jaGlsZHJlbltsLmluZGV4XT1yLmNoaWxkcmVuLGw9cil9cmV0dXJuIGVbMF0uY2hpbGRyZW59ZnVuY3Rpb24gWChhLGQsZixlLGIsQixrLGwscil7ZnVuY3Rpb24gbigpe2lmKDA8eClyZXR1cm4geC0tLHo+PngmMTt6PWFbZCsrXTtpZigyNTU9PT1cbnope3ZhciBjPWFbZCsrXTtpZihjKXtpZigyMjA9PT1jJiZnKXtkKz0yO3ZhciBiPWFbZCsrXTw8OHxhW2QrK107aWYoMDxiJiZiIT09Zi5nKXRocm93IG5ldyBQKFwiRm91bmQgRE5MIG1hcmtlciAoMHhGRkRDKSB3aGlsZSBwYXJzaW5nIHNjYW4gZGF0YVwiLGIpO310aHJvdyBuZXcgRChcInVuZXhwZWN0ZWQgbWFya2VyIFwiKyh6PDw4fGMpLnRvU3RyaW5nKDE2KSk7fX14PTc7cmV0dXJuIHo+Pj43fWZ1bmN0aW9uIHEoYSl7Zm9yKDs7KXthPWFbbigpXTtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpcmV0dXJuIGE7aWYoXCJvYmplY3RcIiE9PShcInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpWKGEpKSl0aHJvdyBuZXcgRChcImludmFsaWQgaHVmZm1hbiBzZXF1ZW5jZVwiKTt9fWZ1bmN0aW9uIGgoYSl7Zm9yKHZhciBjPTA7MDxhOyljPWM8PDF8bigpLGEtLTtyZXR1cm4gY31mdW5jdGlvbiBjKGEpe2lmKDE9PT1hKXJldHVybiAxPT09bigpPzE6LTE7dmFyIGM9aChhKTtyZXR1cm4gYz49XG4xPDxhLTE/YzpjKygtMTw8YSkrMX1mdW5jdGlvbiBDKGEsYil7dmFyIGQ9cShhLkQpO2Q9MD09PWQ/MDpjKGQpO2EuYVtiXT1hLm0rPWQ7Zm9yKGQ9MTs2ND5kOyl7dmFyIGg9cShhLm8pLGs9aCYxNTtoPj49NDtpZigwPT09ayl7aWYoMTU+aClicmVhaztkKz0xNn1lbHNlIGQrPWgsYS5hW2IrSltkXV09YyhrKSxkKyt9fWZ1bmN0aW9uIHcoYSxkKXt2YXIgYj1xKGEuRCk7Yj0wPT09Yj8wOmMoYik8PHI7YS5hW2RdPWEubSs9Yn1mdW5jdGlvbiBwKGEsYyl7YS5hW2NdfD1uKCk8PHJ9ZnVuY3Rpb24gbShhLGIpe2lmKDA8QSlBLS07ZWxzZSBmb3IodmFyIGQ9QjtkPD1rOyl7dmFyIGU9cShhLm8pLGY9ZSYxNTtlPj49NDtpZigwPT09Zil7aWYoMTU+ZSl7QT1oKGUpKygxPDxlKS0xO2JyZWFrfWQrPTE2fWVsc2UgZCs9ZSxhLmFbYitKW2RdXT1jKGYpKigxPDxyKSxkKyt9fWZ1bmN0aW9uIHQoYSxkKXtmb3IodmFyIGI9QixlPTAsZjtiPD1rOyl7Zj1kK0pbYl07dmFyIGw9MD5hLmFbZl0/XG4tMToxO3N3aXRjaChFKXtjYXNlIDA6ZT1xKGEubyk7Zj1lJjE1O2U+Pj00O2lmKDA9PT1mKTE1PmU/KEE9aChlKSsoMTw8ZSksRT00KTooZT0xNixFPTEpO2Vsc2V7aWYoMSE9PWYpdGhyb3cgbmV3IEQoXCJpbnZhbGlkIEFDbiBlbmNvZGluZ1wiKTtRPWMoZik7RT1lPzI6M31jb250aW51ZTtjYXNlIDE6Y2FzZSAyOmEuYVtmXT9hLmFbZl0rPWwqKG4oKTw8cik6KGUtLSwwPT09ZSYmKEU9Mj09PUU/MzowKSk7YnJlYWs7Y2FzZSAzOmEuYVtmXT9hLmFbZl0rPWwqKG4oKTw8cik6KGEuYVtmXT1RPDxyLEU9MCk7YnJlYWs7Y2FzZSA0OmEuYVtmXSYmKGEuYVtmXSs9bCoobigpPDxyKSl9YisrfTQ9PT1FJiYoQS0tLDA9PT1BJiYoRT0wKSl9dmFyIGc9OTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbOV0/YXJndW1lbnRzWzldOiExLHU9Zi5QLHY9ZCx6PTAseD0wLEE9MCxFPTAsUSxLPWUubGVuZ3RoLEYsTCxNLEk7dmFyIFI9Zi5TPzA9PT1CPzA9PT1sP3c6cDowPT09bD9cbm06dDpDO3ZhciBHPTA7dmFyIE89MT09PUs/ZVswXS5jKmVbMF0ubDp1KmYuTztmb3IodmFyIFMsVDtHPE87KXt2YXIgVT1iP01hdGgubWluKE8tRyxiKTpPO2ZvcihGPTA7RjxLO0YrKyllW0ZdLm09MDtBPTA7aWYoMT09PUspe3ZhciB5PWVbMF07Zm9yKEk9MDtJPFU7SSsrKVIoeSw2NCooKHkuYysxKSooRy95LmN8MCkrRyV5LmMpKSxHKyt9ZWxzZSBmb3IoST0wO0k8VTtJKyspe2ZvcihGPTA7RjxLO0YrKylmb3IoeT1lW0ZdLFM9eS5oLFQ9eS5qLEw9MDtMPFQ7TCsrKWZvcihNPTA7TTxTO00rKylSKHksNjQqKCh5LmMrMSkqKChHL3V8MCkqeS5qK0wpKyhHJXUqeS5oK00pKSk7RysrfXg9MDsoeT1OKGEsZCkpJiZ5LmYmJigoMCxfdXRpbC53YXJuKShcImRlY29kZVNjYW4gLSB1bmV4cGVjdGVkIE1DVSBkYXRhLCBjdXJyZW50IG1hcmtlciBpczogXCIreS5mKSxkPXkub2Zmc2V0KTt5PXkmJnkuRjtpZigheXx8NjUyODA+PXkpdGhyb3cgbmV3IEQoXCJtYXJrZXIgd2FzIG5vdCBmb3VuZFwiKTtcbmlmKDY1NDg4PD15JiY2NTQ5NT49eSlkKz0yO2Vsc2UgYnJlYWt9KHk9TihhLGQpKSYmeS5mJiYoKDAsX3V0aWwud2FybikoXCJkZWNvZGVTY2FuIC0gdW5leHBlY3RlZCBTY2FuIGRhdGEsIGN1cnJlbnQgbWFya2VyIGlzOiBcIit5LmYpLGQ9eS5vZmZzZXQpO3JldHVybiBkLXZ9ZnVuY3Rpb24gWShhLGQpe2Zvcih2YXIgZj1kLmMsZT1kLmwsYj1uZXcgSW50MTZBcnJheSg2NCksQj0wO0I8ZTtCKyspZm9yKHZhciBrPTA7azxmO2srKyl7dmFyIGw9NjQqKChkLmMrMSkqQitrKSxyPWIsbj1kLkcscT1kLmE7aWYoIW4pdGhyb3cgbmV3IEQoXCJtaXNzaW5nIHJlcXVpcmVkIFF1YW50aXphdGlvbiBUYWJsZS5cIik7Zm9yKHZhciBoPTA7NjQ+aDtoKz04KXt2YXIgYz1xW2wraF07dmFyIEM9cVtsK2grMV07dmFyIHc9cVtsK2grMl07dmFyIHA9cVtsK2grM107dmFyIG09cVtsK2grNF07dmFyIHQ9cVtsK2grNV07dmFyIGc9cVtsK2grNl07dmFyIHU9cVtsK2grN107Yyo9bltoXTtpZigwPT09KEN8XG53fHB8bXx0fGd8dSkpYz01NzkzKmMrNTEyPj4xMCxyW2hdPWMscltoKzFdPWMscltoKzJdPWMscltoKzNdPWMscltoKzRdPWMscltoKzVdPWMscltoKzZdPWMscltoKzddPWM7ZWxzZXtDKj1uW2grMV07dyo9bltoKzJdO3AqPW5baCszXTttKj1uW2grNF07dCo9bltoKzVdO2cqPW5baCs2XTt1Kj1uW2grN107dmFyIHY9NTc5MypjKzEyOD4+ODt2YXIgej01NzkzKm0rMTI4Pj44O3ZhciB4PXc7dmFyIEE9ZzttPTI4OTYqKEMtdSkrMTI4Pj44O3U9Mjg5NiooQyt1KSsxMjg+Pjg7cDw8PTQ7dDw8PTQ7dj12K3orMT4+MTt6PXYtejtjPTM3ODQqeCsxNTY3KkErMTI4Pj44O3g9MTU2Nyp4LTM3ODQqQSsxMjg+Pjg7QT1jO209bSt0KzE+PjE7dD1tLXQ7dT11K3ArMT4+MTtwPXUtcDt2PXYrQSsxPj4xO0E9di1BO3o9eit4KzE+PjE7eD16LXg7Yz0yMjc2Km0rMzQwNip1KzIwNDg+PjEyO209MzQwNiptLTIyNzYqdSsyMDQ4Pj4xMjt1PWM7Yz03OTkqcCs0MDE3KnQrMjA0OD4+MTI7cD00MDE3KlxucC03OTkqdCsyMDQ4Pj4xMjt0PWM7cltoXT12K3U7cltoKzddPXYtdTtyW2grMV09eit0O3JbaCs2XT16LXQ7cltoKzJdPXgrcDtyW2grNV09eC1wO3JbaCszXT1BK207cltoKzRdPUEtbX19Zm9yKG49MDs4Pm47KytuKWM9cltuXSxDPXJbbis4XSx3PXJbbisxNl0scD1yW24rMjRdLG09cltuKzMyXSx0PXJbbis0MF0sZz1yW24rNDhdLHU9cltuKzU2XSwwPT09KEN8d3xwfG18dHxnfHUpPyhjPTU3OTMqYys4MTkyPj4xNCxjPS0yMDQwPmM/MDoyMDI0PD1jPzI1NTpjKzIwNTY+PjQscVtsK25dPWMscVtsK24rOF09YyxxW2wrbisxNl09YyxxW2wrbisyNF09YyxxW2wrbiszMl09YyxxW2wrbis0MF09YyxxW2wrbis0OF09YyxxW2wrbis1Nl09Yyk6KHY9NTc5MypjKzIwNDg+PjEyLHo9NTc5MyptKzIwNDg+PjEyLHg9dyxBPWcsbT0yODk2KihDLXUpKzIwNDg+PjEyLHU9Mjg5NiooQyt1KSsyMDQ4Pj4xMix2PSh2K3orMT4+MSkrNDExMix6PXYteixjPTM3ODQqeCsxNTY3KkErMjA0OD4+XG4xMix4PTE1NjcqeC0zNzg0KkErMjA0OD4+MTIsQT1jLG09bSt0KzE+PjEsdD1tLXQsdT11K3ArMT4+MSxwPXUtcCx2PXYrQSsxPj4xLEE9di1BLHo9eit4KzE+PjEseD16LXgsYz0yMjc2Km0rMzQwNip1KzIwNDg+PjEyLG09MzQwNiptLTIyNzYqdSsyMDQ4Pj4xMix1PWMsYz03OTkqcCs0MDE3KnQrMjA0OD4+MTIscD00MDE3KnAtNzk5KnQrMjA0OD4+MTIsdD1jLGM9dit1LHU9di11LEM9eit0LGc9ei10LHc9eCtwLHQ9eC1wLHA9QSttLG09QS1tLGM9MTY+Yz8wOjQwODA8PWM/MjU1OmM+PjQsQz0xNj5DPzA6NDA4MDw9Qz8yNTU6Qz4+NCx3PTE2Pnc/MDo0MDgwPD13PzI1NTp3Pj40LHA9MTY+cD8wOjQwODA8PXA/MjU1OnA+PjQsbT0xNj5tPzA6NDA4MDw9bT8yNTU6bT4+NCx0PTE2PnQ/MDo0MDgwPD10PzI1NTp0Pj40LGc9MTY+Zz8wOjQwODA8PWc/MjU1Omc+PjQsdT0xNj51PzA6NDA4MDw9dT8yNTU6dT4+NCxxW2wrbl09YyxxW2wrbis4XT1DLHFbbCtuKzE2XT13LHFbbCtuKzI0XT1cbnAscVtsK24rMzJdPW0scVtsK24rNDBdPXQscVtsK24rNDhdPWcscVtsK24rNTZdPXUpfXJldHVybiBkLmF9ZnVuY3Rpb24gTihhLGQpe3ZhciBmPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpkLGU9YS5sZW5ndGgtMTtmPWY8ZD9mOmQ7aWYoZD49ZSlyZXR1cm4gbnVsbDt2YXIgYj1hW2RdPDw4fGFbZCsxXTtpZig2NTQ3Mjw9YiYmNjU1MzQ+PWIpcmV0dXJue2Y6bnVsbCxGOmIsb2Zmc2V0OmR9O2Zvcih2YXIgQj1hW2ZdPDw4fGFbZisxXTshKDY1NDcyPD1CJiY2NTUzND49Qik7KXtpZigrK2Y+PWUpcmV0dXJuIG51bGw7Qj1hW2ZdPDw4fGFbZisxXX1yZXR1cm57ZjpiLnRvU3RyaW5nKDE2KSxGOkIsb2Zmc2V0OmZ9fXZhciBKPW5ldyBVaW50OEFycmF5KFswLDEsOCwxNiw5LDIsMywxMCwxNywyNCwzMiwyNSwxOCwxMSw0LDUsMTIsMTksMjYsMzMsNDAsNDgsNDEsMzQsMjcsMjAsMTMsNiw3LDE0LDIxLDI4LDM1LDQyLDQ5LDU2LFxuNTcsNTAsNDMsMzYsMjksMjIsMTUsMjMsMzAsMzcsNDQsNTEsNTgsNTksNTIsNDUsMzgsMzEsMzksNDYsNTMsNjAsNjEsNTQsNDcsNTUsNjIsNjNdKTtnLnByb3RvdHlwZT17cGFyc2U6ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZCgpe3ZhciBkPWFba108PDh8YVtrKzFdO2srPTI7cmV0dXJuIGR9ZnVuY3Rpb24gZigpe3ZhciBiPWQoKTtiPWsrYi0yO3ZhciBjPU4oYSxiLGspO2MmJmMuZiYmKCgwLF91dGlsLndhcm4pKFwicmVhZERhdGFCbG9jayAtIGluY29ycmVjdCBsZW5ndGgsIGN1cnJlbnQgbWFya2VyIGlzOiBcIitjLmYpLGI9Yy5vZmZzZXQpO2I9YS5zdWJhcnJheShrLGIpO2srPWIubGVuZ3RoO3JldHVybiBifWZ1bmN0aW9uIGUoYSl7Zm9yKHZhciBiPU1hdGguY2VpbChhLnYvOC9hLnMpLGM9TWF0aC5jZWlsKGEuZy84L2EudSksZD0wO2Q8YS5iLmxlbmd0aDtkKyspe3Y9YS5iW2RdO3ZhciBlPU1hdGguY2VpbChNYXRoLmNlaWwoYS52LzgpKnYuaC9hLnMpLGY9TWF0aC5jZWlsKE1hdGguY2VpbChhLmcvXG44KSp2LmovYS51KTt2LmE9bmV3IEludDE2QXJyYXkoNjQqYyp2LmoqKGIqdi5oKzEpKTt2LmM9ZTt2Lmw9Zn1hLlA9YjthLk89Y312YXIgYj0oMTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9KS5OLEI9dm9pZCAwPT09Yj9udWxsOmIsaz0wLGw9bnVsbCxyPTA7Yj1bXTt2YXIgbj1bXSxxPVtdLGg9ZCgpO2lmKDY1NDk2IT09aCl0aHJvdyBuZXcgRChcIlNPSSBub3QgZm91bmRcIik7Zm9yKGg9ZCgpOzY1NDk3IT09aDspe3N3aXRjaChoKXtjYXNlIDY1NTA0OmNhc2UgNjU1MDU6Y2FzZSA2NTUwNjpjYXNlIDY1NTA3OmNhc2UgNjU1MDg6Y2FzZSA2NTUwOTpjYXNlIDY1NTEwOmNhc2UgNjU1MTE6Y2FzZSA2NTUxMjpjYXNlIDY1NTEzOmNhc2UgNjU1MTQ6Y2FzZSA2NTUxNTpjYXNlIDY1NTE2OmNhc2UgNjU1MTc6Y2FzZSA2NTUxODpjYXNlIDY1NTE5OmNhc2UgNjU1MzQ6dmFyIGM9ZigpOzY1NTE4PT09aCYmNjU9PT1jWzBdJiYxMDA9PT1cbmNbMV0mJjExMT09PWNbMl0mJjk4PT09Y1szXSYmMTAxPT09Y1s0XSYmKGw9e3ZlcnNpb246Y1s1XTw8OHxjWzZdLFk6Y1s3XTw8OHxjWzhdLFo6Y1s5XTw8OHxjWzEwXSxXOmNbMTFdfSk7YnJlYWs7Y2FzZSA2NTQ5OTpoPWQoKStrLTI7Zm9yKHZhciBnO2s8aDspe3ZhciB3PWFbaysrXSxwPW5ldyBVaW50MTZBcnJheSg2NCk7aWYoMD09PXc+PjQpZm9yKGM9MDs2ND5jO2MrKylnPUpbY10scFtnXT1hW2srK107ZWxzZSBpZigxPT09dz4+NClmb3IoYz0wOzY0PmM7YysrKWc9SltjXSxwW2ddPWQoKTtlbHNlIHRocm93IG5ldyBEKFwiRFFUIC0gaW52YWxpZCB0YWJsZSBzcGVjXCIpO2JbdyYxNV09cH1icmVhaztjYXNlIDY1NDcyOmNhc2UgNjU0NzM6Y2FzZSA2NTQ3NDppZihtKXRocm93IG5ldyBEKFwiT25seSBzaW5nbGUgZnJhbWUgSlBFR3Mgc3VwcG9ydGVkXCIpO2QoKTt2YXIgbT17fTttLlg9NjU0NzM9PT1oO20uUz02NTQ3ND09PWg7bS5wcmVjaXNpb249YVtrKytdO2g9ZCgpO20uZz1cbkJ8fGg7bS52PWQoKTttLmI9W107bS5DPXt9O2M9YVtrKytdO2ZvcihoPXA9dz0wO2g8YztoKyspe2c9YVtrXTt2YXIgdD1hW2srMV0+PjQ7dmFyIEg9YVtrKzFdJjE1O3c8dCYmKHc9dCk7cDxIJiYocD1IKTt0PW0uYi5wdXNoKHtoOnQsajpILFQ6YVtrKzJdLEc6bnVsbH0pO20uQ1tnXT10LTE7ays9M31tLnM9dzttLnU9cDtlKG0pO2JyZWFrO2Nhc2UgNjU0NzY6Zz1kKCk7Zm9yKGg9MjtoPGc7KXt3PWFbaysrXTtwPW5ldyBVaW50OEFycmF5KDE2KTtmb3IoYz10PTA7MTY+YztjKyssaysrKXQrPXBbY109YVtrXTtIPW5ldyBVaW50OEFycmF5KHQpO2ZvcihjPTA7Yzx0O2MrKyxrKyspSFtjXT1hW2tdO2grPTE3K3Q7KDA9PT13Pj40P3E6bilbdyYxNV09VyhwLEgpfWJyZWFrO2Nhc2UgNjU1MDE6ZCgpO3ZhciB1PWQoKTticmVhaztjYXNlIDY1NDk4OmM9MT09PSsrciYmIUI7ZCgpO3c9YVtrKytdO2c9W107Zm9yKGg9MDtoPHc7aCsrKXtwPW0uQ1thW2srK11dO3ZhciB2PW0uYltwXTtcbnA9YVtrKytdO3YuRD1xW3A+PjRdO3Yubz1uW3AmMTVdO2cucHVzaCh2KX1oPWFbaysrXTt3PWFbaysrXTtwPWFbaysrXTt0cnl7dmFyIHo9WChhLGssbSxnLHUsaCx3LHA+PjQscCYxNSxjKTtrKz16fWNhdGNoKHgpe2lmKHggaW5zdGFuY2VvZiBQKXJldHVybigwLF91dGlsLndhcm4pKCdBdHRlbXB0aW5nIHRvIHJlLXBhcnNlIEpQRUcgaW1hZ2UgdXNpbmcgXCJzY2FuTGluZXNcIiBwYXJhbWV0ZXIgZm91bmQgaW4gRE5MIG1hcmtlciAoMHhGRkRDKSBzZWdtZW50LicpLHRoaXMucGFyc2UoYSx7Tjp4Lmd9KTt0aHJvdyB4O31icmVhaztjYXNlIDY1NTAwOmsrPTQ7YnJlYWs7Y2FzZSA2NTUzNToyNTUhPT1hW2tdJiZrLS07YnJlYWs7ZGVmYXVsdDppZigyNTU9PT1hW2stM10mJjE5Mjw9YVtrLTJdJiYyNTQ+PWFbay0yXSlrLT0zO2Vsc2UgaWYoKGM9TihhLGstMikpJiZjLmYpKDAsX3V0aWwud2FybikoXCJKcGVnSW1hZ2UucGFyc2UgLSB1bmV4cGVjdGVkIGRhdGEsIGN1cnJlbnQgbWFya2VyIGlzOiBcIitcbmMuZiksaz1jLm9mZnNldDtlbHNlIHRocm93IG5ldyBEKFwidW5rbm93biBtYXJrZXIgXCIraC50b1N0cmluZygxNikpO31oPWQoKX10aGlzLndpZHRoPW0udjt0aGlzLmhlaWdodD1tLmc7dGhpcy5BPWw7dGhpcy5iPVtdO2ZvcihoPTA7aDxtLmIubGVuZ3RoO2grKyl7dj1tLmJbaF07aWYodT1iW3YuVF0pdi5HPXU7dGhpcy5iLnB1c2goe1I6WShtLHYpLFU6di5oL20ucyxWOnYuai9tLnUsYzp2LmMsbDp2Lmx9KX10aGlzLmk9dGhpcy5iLmxlbmd0aH0sTDpmdW5jdGlvbihhLGQpe3ZhciBmPXRoaXMud2lkdGgvYSxlPXRoaXMuaGVpZ2h0L2QsYixnLGs9dGhpcy5iLmxlbmd0aCxsPWEqZCprLHI9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGwpLG49bmV3IFVpbnQzMkFycmF5KGEpO2ZvcihnPTA7ZzxrO2crKyl7dmFyIHE9dGhpcy5iW2ddO3ZhciBoPXEuVSpmO3ZhciBjPXEuViplO3ZhciBDPWc7dmFyIHc9cS5SO3ZhciBwPXEuYysxPDwzO2ZvcihiPTA7YjxhO2IrKylxPTB8YipoLG5bYl09XG4ocSY0Mjk0OTY3Mjg4KTw8M3xxJjc7Zm9yKGg9MDtoPGQ7aCsrKWZvcihxPTB8aCpjLHE9cCoocSY0Mjk0OTY3Mjg4KXwocSY3KTw8MyxiPTA7YjxhO2IrKylyW0NdPXdbcStuW2JdXSxDKz1rfWlmKGU9dGhpcy5NKWZvcihnPTA7ZzxsOylmb3IoZj1xPTA7cTxrO3ErKyxnKyssZis9MilyW2ddPShyW2ddKmVbZl0+PjgpK2VbZisxXTtyZXR1cm4gcn0sdzpmdW5jdGlvbigpe3JldHVybiB0aGlzLkE/ISF0aGlzLkEuVzozPT09dGhpcy5pPzA9PT10aGlzLkI/ITE6ITA6MT09PXRoaXMuQj8hMDohMX0sSTpmdW5jdGlvbihhKXtmb3IodmFyIGQsZixlLGI9MCxnPWEubGVuZ3RoO2I8ZztiKz0zKWQ9YVtiXSxmPWFbYisxXSxlPWFbYisyXSxhW2JdPWQtMTc5LjQ1NisxLjQwMiplLGFbYisxXT1kKzEzNS40NTktLjM0NCpmLS43MTQqZSxhW2IrMl09ZC0yMjYuODE2KzEuNzcyKmY7cmV0dXJuIGF9LEs6ZnVuY3Rpb24oYSl7Zm9yKHZhciBkLGYsZSxiLGc9MCxrPTAsbD1hLmxlbmd0aDtrPGw7ays9XG40KWQ9YVtrXSxmPWFbaysxXSxlPWFbaysyXSxiPWFbayszXSxhW2crK109LTEyMi42NzE5NTQwNjg5NCtmKigtNi42MDYzNTY2OTQyMDM2NEUtNSpmKzQuMzcxMzA0NzU5MjYyMzJFLTQqZS01LjQwODA2MTAwNjQ1OTlFLTUqZCs0Ljg0NDk3OTcxMjAyODFFLTQqYi0uMTU0MzYyMTUxODcxMTI2KStlKigtOS41Nzk2NDM3ODQ0NTc3M0UtNCplKzguMTcwNzY5MTEzNDY2MjVFLTQqZC0uMDA0NzcyNzE0MDU0MDg3NDcqYisxLjUzMzgwMjUzMjIxNzM0KStkKig5LjYxMjUwMTg0MTMwNjg4RS00KmQtLjAwMjY2MjU3MzMyMjgzOTMzKmIrLjQ4MzU3MDg4NDUxMjY1KStiKigtMy4zNjE5NzE3NzYxODM5NEUtNCpiKy40ODQ3OTE1NjE0OTA3NzYpLGFbZysrXT0xMDcuMjY4MDM5Mzk3NzI0K2YqKDIuMTk5MjcxMDQ1MjU3NDFFLTUqZi02LjQwOTkyMDE4Mjk3OTQ1RS00KmUrNi41OTM5NzAwMTI0NTU3N0UtNCpkKzQuMjYxMDU2NTI5Mzg4MzdFLTQqYi0uMTc2NDkxNzkyNDYyODc1KStlKigtNy43ODI2OTk0MTUxMzY4M0UtNCpcbmUrLjAwMTMwODcyMjYxNDA4Mjc1KmQrNy43MDQ4MjYzMTgwMTEzMkUtNCpiLS4xNTEwNTE0OTI3NzU1NjIpK2QqKC4wMDEyNjkzNTM2ODExNDg0MypkLS4wMDI2NTA5MDE4OTAxMDg5OCpiKy4yNTgwMjkxMDIwNjg0NSkrYiooLTMuMTg5MTMxMTc1ODgzMjhFLTQqYi0uMjEzNzQyNDAwMzIzNjY1KSxhW2crK109LTIwLjgxMDAxMjU0Njk0NytmKigtNS43MDExNTE5Njk3MzY3N0UtNCpmLTIuNjM0MDkwNTEwMDQ1ODlFLTUqZSsuMDAyMDc0MTA4ODExNTAxMipkLS4wMDI4ODI2MDIzNjg1MzQ0MipiKy44MTQyNzI5NjgzNTkyOTUpK2UqKC0xLjUzNDk2MDU3NDQwOTc1RS01KmUtMS4zMjY4OTA0Mzk2MTQ0NkUtNCpkKzUuNjA4MzM2OTEyNDI4MTJFLTQqYi0uMTk1MTUyMDI3NTM0MDQ5KStkKiguMDAxNzQ0MTgxMzI5Mjc1ODIqZC0uMDAyNTUyNDMzMjE0MzkzNDcqYisuMTE2OTM1MDIwNDY1MTQ1KStiKigtMy40MzUzMTk5NjUxMDU1NUUtNCpiKy4yNDE2NTI2MDIzMjQwNyk7cmV0dXJuIGEuc3ViYXJyYXkoMCxcbmcpfSxKOmZ1bmN0aW9uKGEpe2Zvcih2YXIgZCxmLGUsYj0wLGc9YS5sZW5ndGg7YjxnO2IrPTQpZD1hW2JdLGY9YVtiKzFdLGU9YVtiKzJdLGFbYl09NDM0LjQ1Ni1kLTEuNDAyKmUsYVtiKzFdPTExOS41NDEtZCsuMzQ0KmYrLjcxNCplLGFbYisyXT00ODEuODE2LWQtMS43NzIqZjtyZXR1cm4gYX0sSDpmdW5jdGlvbihhKXtmb3IodmFyIGQsZixlLGIsZz0wLGs9MS8yNTUsbD0wLHI9YS5sZW5ndGg7bDxyO2wrPTQpZD1hW2xdKmssZj1hW2wrMV0qayxlPWFbbCsyXSprLGI9YVtsKzNdKmssYVtnKytdPTI1NStkKigtNC4zODczMzIzODQ2MDk5ODgqZCs1NC40ODYxNTE5NDE4OTE3NipmKzE4LjgyMjkwNTAyMTY1MzAyKmUrMjEyLjI1NjYyNDUxNjM5NTg1KmItMjg1LjIzMzEwMjYxMzcwMDQpK2YqKDEuNzE0OTc2MzQ3NzM2MjEzNCpmLTUuNjA5NjczNjkwNDA0NzMxNSplLTE3Ljg3Mzg3MDg2MTQxNTQ0NCpiLTUuNDk3MDA2NDI3MTk2MzY2KStlKigtMi41MjE3MzQwMTMxNjgzMDMzKlxuZS0yMS4yNDg5MjMzMzczNTMwNzMqYisxNy41MTE5MjcwODQxODEzKS1iKigyMS44NjEyMjE0NzQ2MzYwNSpiKzE4OS40ODE4MDgzNTkyMjc0NyksYVtnKytdPTI1NStkKig4Ljg0MTA0MTQyMjAzNjE0OSpkKzYwLjExODAyNzA0NTU5NzM2NipmKzYuODcxNDI1NTkyMDQ5MDA3KmUrMzEuMTU5MTAwMTMwMDU1OTIyKmItNzkuMjk3MDg0NDgxNjU0OCkrZiooLTE1LjMxMDM2MTMwNjk2NzgxNypmKzE3LjU3NTI1MTI2MTEwOTQ4MiplKzEzMS4zNTI1MDkxMjQ5Mzk3NipiLTE5MC45NDUzMzAyNTg4OTUxKStlKig0LjQ0NDMzOTEwMjg1MjczOSplKzkuODYzMjg2MTQ5MzQwNSpiLTI0Ljg2NzQxNTgyNTU1ODc4KS1iKigyMC43MzczMjU0NzExODEwMzQqYisxODcuODA0NTM3MDk3MTk1NzgpLGFbZysrXT0yNTUrZCooLjg4NDI1MjI0MzAwMDMyOTYqZCs4LjA3ODY3NzUwMzExMjkyOCpmKzMwLjg5OTc4MzA5NzAzNzI5KmUtLjIzODgzMjM4Njg5MTc4OTM0KmItMTQuMTgzNTc2Nzk5NjczMjg2KStcbmYqKDEwLjQ5NTkzMjczNDMyMDcyKmYrNjMuMDIzNzg0OTQ3NTQwNTIqZSs1MC42MDY5NTc2NTYzNjA3MzQqYi0xMTIuMjM4ODQyNTM3MTkyNDgpK2UqKC4wMzI5NjA0MTExNDg3MzIxNyplKzExNS42MDM4NDQ0OTY0NjY0MSpiLTE5My41ODIwOTM1Njg2MTUwNSktYiooMjIuMzM4MTY4MDczMDk4ODYqYisxODAuMTI2MTM5NzQ3MDgzNjcpO3JldHVybiBhLnN1YmFycmF5KDAsZyl9LGdldERhdGE6ZnVuY3Rpb24oYSxkLGYpe2lmKDQ8dGhpcy5pKXRocm93IG5ldyBEKFwiVW5zdXBwb3J0ZWQgY29sb3IgbW9kZVwiKTthPXRoaXMuTChhLGQpO2lmKDE9PT10aGlzLmkmJmYpe2Y9YS5sZW5ndGg7ZD1uZXcgVWludDhDbGFtcGVkQXJyYXkoMypmKTtmb3IodmFyIGU9MCxiPTA7YjxmO2IrKyl7dmFyIGc9YVtiXTtkW2UrK109ZztkW2UrK109ZztkW2UrK109Z31yZXR1cm4gZH1pZigzPT09dGhpcy5pJiZ0aGlzLncoKSlyZXR1cm4gdGhpcy5JKGEpO2lmKDQ9PT10aGlzLmkpe2lmKHRoaXMudygpKXJldHVybiBmP1xudGhpcy5LKGEpOnRoaXMuSihhKTtpZihmKXJldHVybiB0aGlzLkgoYSl9cmV0dXJuIGF9fTsgVVRJRi5KcGVnRGVjb2Rlcj1nfSkoKX0pKCk7XG5cbi8vVVRJRi5KcGVnRGVjb2RlciA9IHdpbmRvdy5KcGVnRGVjb2RlcjtcblxuVVRJRi5lbmNvZGVJbWFnZSA9IGZ1bmN0aW9uKHJnYmEsIHcsIGgsIG1ldGFkYXRhKVxue1xuXHR2YXIgaWRmID0geyBcInQyNTZcIjpbd10sIFwidDI1N1wiOltoXSwgXCJ0MjU4XCI6WzgsOCw4LDhdLCBcInQyNTlcIjpbMV0sIFwidDI2MlwiOlsyXSwgXCJ0MjczXCI6WzEwMDBdLCAvLyBzdHJpcHMgb2Zmc2V0XG5cdFx0XHRcdFwidDI3N1wiOls0XSwgXCJ0Mjc4XCI6W2hdLCAvKiByb3dzIHBlciBzdHJpcCAqLyAgICAgICAgICBcInQyNzlcIjpbdypoKjRdLCAvLyBzdHJpcCBieXRlIGNvdW50c1xuXHRcdFx0XHRcInQyODJcIjpbMV0sIFwidDI4M1wiOlsxXSwgXCJ0Mjg0XCI6WzFdLCBcInQyODZcIjpbMF0sIFwidDI4N1wiOlswXSwgXCJ0Mjk2XCI6WzFdLCBcInQzMDVcIjogW1wiUGhvdG9wZWEgKFVUSUYuanMpXCJdLCBcInQzMzhcIjpbMV1cblx0XHR9O1xuXHRpZiAobWV0YWRhdGEpIGZvciAodmFyIGkgaW4gbWV0YWRhdGEpIGlkZltpXSA9IG1ldGFkYXRhW2ldO1xuXHRcblx0dmFyIHByZnggPSBuZXcgVWludDhBcnJheShVVElGLmVuY29kZShbaWRmXSkpO1xuXHR2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkocmdiYSk7XG5cdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoMTAwMCt3KmgqNCk7XG5cdGZvcih2YXIgaT0wOyBpPHByZngubGVuZ3RoOyBpKyspIGRhdGFbaV0gPSBwcmZ4W2ldO1xuXHRmb3IodmFyIGk9MDsgaTxpbWcgLmxlbmd0aDsgaSsrKSBkYXRhWzEwMDAraV0gPSBpbWdbaV07XG5cdHJldHVybiBkYXRhLmJ1ZmZlcjtcbn1cblxuVVRJRi5lbmNvZGUgPSBmdW5jdGlvbihpZmRzKVxue1xuXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KDIwMDAwKSwgb2Zmc2V0ID0gNCwgYmluID0gVVRJRi5fYmluQkU7XG5cdGRhdGFbMF09Nzc7ICBkYXRhWzFdPTc3OyAgZGF0YVszXT00MjtcblxuXHR2YXIgaWZkbyA9IDg7XG5cdGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBpZmRvKTsgIG9mZnNldCs9NDtcblx0Zm9yKHZhciBpPTA7IGk8aWZkcy5sZW5ndGg7IGkrKylcblx0e1xuXHRcdHZhciBub2ZmcyA9IFVUSUYuX3dyaXRlSUZEKGJpbiwgZGF0YSwgaWZkbywgaWZkc1tpXSk7XG5cdFx0aWZkbyA9IG5vZmZzWzFdO1xuXHRcdGlmKGk8aWZkcy5sZW5ndGgtMSkgYmluLndyaXRlVWludChkYXRhLCBub2Zmc1swXSwgaWZkbyk7XG5cdH1cblx0cmV0dXJuIGRhdGEuc2xpY2UoMCwgaWZkbykuYnVmZmVyO1xufVxuLy9VVElGLmVuY29kZS5fd3JpdGVJRkRcblxuVVRJRi5kZWNvZGUgPSBmdW5jdGlvbihidWZmKVxue1xuXHRVVElGLmRlY29kZS5fZGVjb2RlRzMuYWxsb3cyRCA9IG51bGw7XG5cdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiksIG9mZnNldCA9IDA7XG5cblx0dmFyIGlkID0gVVRJRi5fYmluQkUucmVhZEFTQ0lJKGRhdGEsIG9mZnNldCwgMik7ICBvZmZzZXQrPTI7XG5cdHZhciBiaW4gPSBpZD09XCJJSVwiID8gVVRJRi5fYmluTEUgOiBVVElGLl9iaW5CRTtcblx0dmFyIG51bSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cblx0dmFyIGlmZG8gPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9NDtcblx0dmFyIGlmZHMgPSBbXTtcblx0d2hpbGUodHJ1ZSlcblx0e1xuXHRcdHZhciBub2ZmID0gVVRJRi5fcmVhZElGRChiaW4sIGRhdGEsIGlmZG8sIGlmZHMpO1xuXHRcdC8vdmFyIGlmZCA9IGlmZHNbaWZkcy5sZW5ndGgtMV07ICAgaWYoaWZkW1widDM0NjY1XCJdKSB7ICBpZmQuZXhpZklGRCA9IFtdOyAgVVRJRi5fcmVhZElGRChiaW4sIGRhdGEsIGlmZFtcInQzNDY2NVwiXVswXSwgaWZkLmV4aWZJRkQpOyAgfVxuXHRcdGlmZG8gPSBiaW4ucmVhZFVpbnQoZGF0YSwgbm9mZik7XG5cdFx0aWYoaWZkbz09MCkgYnJlYWs7XG5cdH1cblx0cmV0dXJuIGlmZHM7XG59XG5cblVUSUYuZGVjb2RlSW1hZ2VzID0gZnVuY3Rpb24oYnVmZiwgaWZkcylcbntcblx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmKTtcblx0dmFyIGlkID0gVVRJRi5fYmluQkUucmVhZEFTQ0lJKGRhdGEsIDAsIDIpO1xuXG5cdGZvcih2YXIgaWk9MDsgaWk8aWZkcy5sZW5ndGg7IGlpKyspXG5cdHtcblx0XHR2YXIgaW1nID0gaWZkc1tpaV07XG5cdFx0aWYoaW1nW1widDI1NlwiXT09bnVsbCkgY29udGludWU7XHQvLyBFWElGIGZpbGVzIGRvbid0IGhhdmUgVElGRiB0YWdzXG5cdFx0aW1nLmlzTEUgPSBpZD09XCJJSVwiO1xuXHRcdGltZy53aWR0aCAgPSBpbWdbXCJ0MjU2XCJdWzBdOyAgLy9kZWxldGUgaW1nW1widDI1NlwiXTtcblx0XHRpbWcuaGVpZ2h0ID0gaW1nW1widDI1N1wiXVswXTsgIC8vZGVsZXRlIGltZ1tcInQyNTdcIl07XG5cblx0XHR2YXIgY21wciAgID0gaW1nW1widDI1OVwiXSA/IGltZ1tcInQyNTlcIl1bMF0gOiAxOyAgLy9kZWxldGUgaW1nW1widDI1OVwiXTtcblx0XHR2YXIgZm8gPSBpbWdbXCJ0MjY2XCJdID8gaW1nW1widDI2NlwiXVswXSA6IDE7ICAvL2RlbGV0ZSBpbWdbXCJ0MjY2XCJdO1xuXHRcdGlmKGltZ1tcInQyODRcIl0gJiYgaW1nW1widDI4NFwiXVswXT09MikgbG9nKFwiUGxhbmFyQ29uZmlndXJhdGlvbiAyIHNob3VsZCBub3QgYmUgdXNlZCFcIik7XG5cblx0XHR2YXIgYmlwcCA9IChpbWdbXCJ0MjU4XCJdP01hdGgubWluKDMyLGltZ1tcInQyNThcIl1bMF0pOjEpICogKGltZ1tcInQyNzdcIl0/aW1nW1widDI3N1wiXVswXToxKTsgIC8vIGJpdHMgcGVyIHBpeGVsXG5cdFx0dmFyIGJpcGwgPSBNYXRoLmNlaWwoaW1nLndpZHRoKmJpcHAvOCkqODtcblx0XHR2YXIgc29mZiA9IGltZ1tcInQyNzNcIl07ICBpZihzb2ZmPT1udWxsKSBzb2ZmID0gaW1nW1widDMyNFwiXTtcblx0XHR2YXIgYmNudCA9IGltZ1tcInQyNzlcIl07ICBpZihjbXByPT0xICYmIHNvZmYubGVuZ3RoPT0xKSBiY250ID0gW2ltZy5oZWlnaHQqKGJpcGw+Pj4zKV07ICBpZihiY250PT1udWxsKSBiY250ID0gaW1nW1widDMyNVwiXTtcblx0XHR2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShpbWcuaGVpZ2h0KihiaXBsPj4+MykpLCBiaWxlbiA9IDA7XG5cblx0XHRpZihpbWdbXCJ0MzIyXCJdIT1udWxsKSAvLyB0aWxlZFxuXHRcdHtcblx0XHRcdHZhciB0dyA9IGltZ1tcInQzMjJcIl1bMF0sIHRoID0gaW1nW1widDMyM1wiXVswXTtcblx0XHRcdHZhciB0eCA9IE1hdGguZmxvb3IoKGltZy53aWR0aCAgKyB0dyAtIDEpIC8gdHcpO1xuXHRcdFx0dmFyIHR5ID0gTWF0aC5mbG9vcigoaW1nLmhlaWdodCArIHRoIC0gMSkgLyB0aCk7XG5cdFx0XHR2YXIgdGJ1ZmYgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodHcqdGgqYmlwcC84KXwwKTtcblx0XHRcdGZvcih2YXIgeT0wOyB5PHR5OyB5KyspXG5cdFx0XHRcdGZvcih2YXIgeD0wOyB4PHR4OyB4KyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgaSA9IHkqdHgreDsgIGZvcih2YXIgaj0wOyBqPHRidWZmLmxlbmd0aDsgaisrKSB0YnVmZltqXT0wO1xuXHRcdFx0XHRcdFVUSUYuZGVjb2RlLl9kZWNvbXByZXNzKGltZywgZGF0YSwgc29mZltpXSwgYmNudFtpXSwgY21wciwgdGJ1ZmYsIDAsIGZvKTtcblx0XHRcdFx0XHQvLyBNaWdodCBiZSByZXF1aXJlZCBmb3IgNyB0b28uIE5lZWQgdG8gY2hlY2tcblx0XHRcdFx0XHRpZiAoY21wcj09NikgYnl0ZXMgPSB0YnVmZjtcblx0XHRcdFx0XHRlbHNlIFVUSUYuX2NvcHlUaWxlKHRidWZmLCBNYXRoLmNlaWwodHcqYmlwcC84KXwwLCB0aCwgYnl0ZXMsIE1hdGguY2VpbChpbWcud2lkdGgqYmlwcC84KXwwLCBpbWcuaGVpZ2h0LCBNYXRoLmNlaWwoeCp0dypiaXBwLzgpfDAsIHkqdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRiaWxlbiA9IGJ5dGVzLmxlbmd0aCo4O1xuXHRcdH1cblx0XHRlbHNlXHQvLyBzdHJpcHBlZFxuXHRcdHtcblx0XHRcdHZhciBycHMgPSBpbWdbXCJ0Mjc4XCJdID8gaW1nW1widDI3OFwiXVswXSA6IGltZy5oZWlnaHQ7ICAgcnBzID0gTWF0aC5taW4ocnBzLCBpbWcuaGVpZ2h0KTtcblx0XHRcdGZvcih2YXIgaT0wOyBpPHNvZmYubGVuZ3RoOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdFVUSUYuZGVjb2RlLl9kZWNvbXByZXNzKGltZywgZGF0YSwgc29mZltpXSwgYmNudFtpXSwgY21wciwgYnl0ZXMsIE1hdGguY2VpbChiaWxlbi84KXwwLCBmbyk7XG5cdFx0XHRcdGJpbGVuICs9IGJpcGwgKiBycHM7XG5cdFx0XHR9XG5cdFx0XHRiaWxlbiA9IE1hdGgubWluKGJpbGVuLCBieXRlcy5sZW5ndGgqOCk7XG5cdFx0fVxuXHRcdGltZy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCAwLCBNYXRoLmNlaWwoYmlsZW4vOCl8MCk7XG5cdH1cbn1cblxuVVRJRi5kZWNvZGUuX2RlY29tcHJlc3MgPSBmdW5jdGlvbihpbWcsIGRhdGEsIG9mZiwgbGVuLCBjbXByLCB0Z3QsIHRvZmYsIGZvKSAgLy8gZmlsbCBvcmRlclxue1xuXHQvL2NvbnNvbGUubG9nKFwiY29tcHJlc3Npb25cIiwgY21wcik7XG5cdGlmKGZhbHNlKSB7fVxuXHRlbHNlIGlmKGNtcHI9PTEpIGZvcih2YXIgaj0wOyBqPGxlbjsgaisrKSB0Z3RbdG9mZitqXSA9IGRhdGFbb2ZmK2pdO1xuXHRlbHNlIGlmKGNtcHI9PTMpIFVUSUYuZGVjb2RlLl9kZWNvZGVHMyAoZGF0YSwgb2ZmLCBsZW4sIHRndCwgdG9mZiwgaW1nLndpZHRoLCBmbyk7XG5cdGVsc2UgaWYoY21wcj09NCkgVVRJRi5kZWNvZGUuX2RlY29kZUc0IChkYXRhLCBvZmYsIGxlbiwgdGd0LCB0b2ZmLCBpbWcud2lkdGgsIGZvKTtcblx0ZWxzZSBpZihjbXByPT01KSBVVElGLmRlY29kZS5fZGVjb2RlTFpXKGRhdGEsIG9mZiwgdGd0LCB0b2ZmKTtcblx0ZWxzZSBpZihjbXByPT02KSBVVElGLmRlY29kZS5fZGVjb2RlT2xkSlBFRyhpbWcsIGRhdGEsIG9mZiwgbGVuLCB0Z3QsIHRvZmYpO1xuXHRlbHNlIGlmKGNtcHI9PTcpIFVUSUYuZGVjb2RlLl9kZWNvZGVOZXdKUEVHKGltZywgZGF0YSwgb2ZmLCBsZW4sIHRndCwgdG9mZik7XG5cdGVsc2UgaWYoY21wcj09OCkgeyAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLG9mZixsZW4pOyAgdmFyIGJpbiA9IHBha29bXCJpbmZsYXRlXCJdKHNyYyk7ICBmb3IodmFyIGk9MDsgaTxiaW4ubGVuZ3RoOyBpKyspIHRndFt0b2ZmK2ldPWJpbltpXTsgIH1cblx0ZWxzZSBpZihjbXByPT0zMjc3MykgVVRJRi5kZWNvZGUuX2RlY29kZVBhY2tCaXRzKGRhdGEsIG9mZiwgbGVuLCB0Z3QsIHRvZmYpO1xuXHRlbHNlIGlmKGNtcHI9PTMyODA5KSBVVElGLmRlY29kZS5fZGVjb2RlVGh1bmRlciAoZGF0YSwgb2ZmLCBsZW4sIHRndCwgdG9mZik7XG5cdC8vZWxzZSBpZihjbXByPT0zNDcxMykgVVRJRi5kZWNvZGUuX2RlY29kZU5pa29uICAgKGRhdGEsIG9mZiwgbGVuLCB0Z3QsIHRvZmYpO1xuXHRlbHNlIGxvZyhcIlVua25vd24gY29tcHJlc3Npb25cIiwgY21wcik7XG5cblx0aWYoaW1nW1widDMxN1wiXSAmJiBpbWdbXCJ0MzE3XCJdWzBdPT0yKVxuXHR7XG5cdFx0dmFyIG5vYyA9IChpbWdbXCJ0Mjc3XCJdP2ltZ1tcInQyNzdcIl1bMF06MSksIGggPSAoaW1nW1widDI3OFwiXSA/IGltZ1tcInQyNzhcIl1bMF0gOiBpbWcuaGVpZ2h0KSwgYnByID0gaW1nLndpZHRoKm5vYztcblx0XHQvL2xvZyhub2MpO1xuXHRcdGZvcih2YXIgeT0wOyB5PGg7IHkrKylcblx0XHR7XG5cdFx0XHR2YXIgbnRvZmYgPSB0b2ZmK3kqYnByO1xuXHRcdFx0aWYobm9jPT0zKSBmb3IodmFyIGo9ICAzOyBqPGJwcjsgais9Mylcblx0XHRcdHtcblx0XHRcdFx0dGd0W250b2ZmK2ogIF0gPSAodGd0W250b2ZmK2ogIF0gKyB0Z3RbbnRvZmYrai0zXSkmMjU1O1xuXHRcdFx0XHR0Z3RbbnRvZmYraisxXSA9ICh0Z3RbbnRvZmYraisxXSArIHRndFtudG9mZitqLTJdKSYyNTU7XG5cdFx0XHRcdHRndFtudG9mZitqKzJdID0gKHRndFtudG9mZitqKzJdICsgdGd0W250b2ZmK2otMV0pJjI1NTtcblx0XHRcdH1cblx0XHRcdGVsc2UgZm9yKHZhciBqPW5vYzsgajxicHI7IGorKykgdGd0W250b2ZmK2pdID0gKHRndFtudG9mZitqXSArIHRndFtudG9mZitqLW5vY10pJjI1NTtcblx0XHR9XG5cdH1cbn1cblxuVVRJRi5kZWNvZGUuX2RlY29kZU5pa29uID0gZnVuY3Rpb24oZGF0YSwgb2ZmLCBsZW4sIHRndCwgdG9mZilcbntcblx0dmFyIG5pa29uX3RyZWUgPSBbXG4gICAgWyAwLDEsNSwxLDEsMSwxLDEsMSwyLDAsMCwwLDAsMCwwLFx0LyogMTItYml0IGxvc3N5ICovXG4gICAgICA1LDQsMyw2LDIsNywxLDAsOCw5LDExLDEwLDEyIF0sXG4gICAgWyAwLDEsNSwxLDEsMSwxLDEsMSwyLDAsMCwwLDAsMCwwLFx0LyogMTItYml0IGxvc3N5IGFmdGVyIHNwbGl0ICovXG4gICAgICAweDM5LDB4NWEsMHgzOCwweDI3LDB4MTYsNSw0LDMsMiwxLDAsMTEsMTIsMTIgXSxcbiAgICBbIDAsMSw0LDIsMywxLDIsMCwwLDAsMCwwLDAsMCwwLDAsICAvKiAxMi1iaXQgbG9zc2xlc3MgKi9cbiAgICAgIDUsNCw2LDMsNywyLDgsMSw5LDAsMTAsMTEsMTIgXSxcbiAgICBbIDAsMSw0LDMsMSwxLDEsMSwxLDIsMCwwLDAsMCwwLDAsXHQvKiAxNC1iaXQgbG9zc3kgKi9cbiAgICAgIDUsNiw0LDcsOCwzLDksMiwxLDAsMTAsMTEsMTIsMTMsMTQgXSxcbiAgICBbIDAsMSw1LDEsMSwxLDEsMSwxLDEsMiwwLDAsMCwwLDAsXHQvKiAxNC1iaXQgbG9zc3kgYWZ0ZXIgc3BsaXQgKi9cbiAgICAgIDgsMHg1YywweDRiLDB4M2EsMHgyOSw3LDYsNSw0LDMsMiwxLDAsMTMsMTQgXSxcbiAgICBbIDAsMSw0LDIsMiwzLDEsMiwwLDAsMCwwLDAsMCwwLDAsXHQvKiAxNC1iaXQgbG9zc2xlc3MgKi9cbiAgICAgIDcsNiw4LDUsOSw0LDEwLDMsMTEsMTIsMiwwLDEsMTMsMTQgXSBdO1xuXG5cdC8vc3RydWN0IGRlY29kZSAqZGluZGV4O1xuXHR2YXIgdmVyMCwgdmVyMSwgdnByZWQsIGhwcmVkLCBjc2l6ZTtcblx0dmFyIGksIG1pbiwgbWF4LCBzdGVwPTAsIGh1ZmY9MCwgc3BsaXQ9MCwgcm93LCBjb2wsIGxlbiwgc2hsLCBkaWZmO1xuXG5cdGxvZyhkYXRhLnNsaWNlKG9mZixvZmYrMTAwKSk7XG5cdHZlcjAgPSBkYXRhW29mZl07ICBvZmYrKztcblx0dmVyMSA9IGRhdGFbb2ZmXTsgIG9mZisrO1xuXHRsb2codmVyMC50b1N0cmluZygxNiksIHZlcjEudG9TdHJpbmcoMTYpLCBsZW4pO1xufVxuXG5VVElGLmRlY29kZS5fZGVjb2RlTmV3SlBFRyA9IGZ1bmN0aW9uKGltZywgZGF0YSwgb2ZmLCBsZW4sIHRndCwgdG9mZilcbntcblx0dmFyIHRhYmxlcyA9IGltZ1tcInQzNDdcIl0sIHRsZW4gPSB0YWJsZXMgPyB0YWJsZXMubGVuZ3RoIDogMCwgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRsZW4gKyBsZW4pO1xuXHRcblx0aWYgKHRhYmxlcylcblx0e1xuXHRcdHZhciBTT0kgPSAyMTYsIEVPSSA9IDIxNywgYm9mZiA9IDA7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPCh0bGVuLTEpOyBpKyspXG5cdFx0e1xuXHRcdFx0Ly8gU2tpcCBFT0kgbWFya2VyIGZyb20gSlBFR1RhYmxlc1xuXHRcdFx0aWYgKHRhYmxlc1tpXT09MjU1ICYmIHRhYmxlc1tpKzFdPT1FT0kpIGJyZWFrO1xuXHRcdFx0YnVmZltib2ZmKytdID0gdGFibGVzW2ldO1xuXHRcdH1cblxuXHRcdC8vIFNraXAgU09JIG1hcmtlciBmcm9tIGRhdGFcblx0XHR2YXIgYnl0ZTEgPSBkYXRhW29mZl0sIGJ5dGUyID0gZGF0YVtvZmYgKyAxXTtcblx0XHRpZiAoYnl0ZTEhPTI1NSB8fCBieXRlMiE9U09JKVxuXHRcdHtcblx0XHRcdGJ1ZmZbYm9mZisrXSA9IGJ5dGUxO1xuXHRcdFx0YnVmZltib2ZmKytdID0gYnl0ZTI7XG5cdFx0fVxuXHRcdGZvciAodmFyIGk9MjsgaTxsZW47IGkrKykgYnVmZltib2ZmKytdID0gZGF0YVtvZmYraV07XG5cdH1cblx0ZWxzZSBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIGJ1ZmZbaV0gPSBkYXRhW29mZitpXTtcblxuXHRpZihpbWdbXCJ0MjYyXCJdPT0zMjgwMykgLy8gbG9zc2xlc3MgSlBFRyAodXNlZCBpbiBETkcgZmlsZXMpIGlzIG5vdCBhdmFpbGFibGUgaW4gSnBlZ0RlY29kZXIuXG5cdHtcblx0XHR2YXIgYnBzID0gaW1nW1widDI1OFwiXVswXSwgZGNkciA9IG5ldyBMb3NzbGVzc0pwZWdEZWNvZGVyKCk7XG5cdFx0dmFyIG91dCA9IGRjZHIuZGVjb2RlKGJ1ZmYpLCBvbGVuPW91dC5sZW5ndGg7XG5cblx0XHRpZihmYWxzZSkge31cblx0XHRlbHNlIGlmKGJwcz09MTYpIGZvcih2YXIgaT0wOyBpPG9sZW47IGkrKykgeyAgdGd0W3RvZmYrK10gPSAob3V0W2ldJjI1NSk7ICB0Z3RbdG9mZisrXSA9IChvdXRbaV0+Pj44KTsgIH1cblx0XHRlbHNlIGlmKGJwcz09MTIpIGZvcih2YXIgaT0wOyBpPG9sZW47IGkrPTIpIHsgIHRndFt0b2ZmKytdID0gKG91dFtpXT4+PjQpOyAgdGd0W3RvZmYrK10gPSAoKG91dFtpXTw8NCl8KG91dFtpKzFdPj4+OCkpJjI1NTsgIHRndFt0b2ZmKytdID0gb3V0W2krMV0mMjU1OyAgfVxuXHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYml0IGRlcHRoIFwiK2Jwcyk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0dmFyIHBhcnNlciA9IG5ldyBVVElGLkpwZWdEZWNvZGVyKCk7ICBwYXJzZXIucGFyc2UoYnVmZik7XG5cdFx0dmFyIGRlY29kZWQgPSBwYXJzZXIuZ2V0RGF0YShwYXJzZXIud2lkdGgsIHBhcnNlci5oZWlnaHQpO1xuXHRcdGZvciAodmFyIGk9MDsgaTxkZWNvZGVkLmxlbmd0aDsgaSsrKSB0Z3RbdG9mZiArIGldID0gZGVjb2RlZFtpXTtcblx0fVxuXG5cdC8vIFBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gaXMgNiAoWUNiQ3IpIGZvciBKUEVHLCBidXQgYWZ0ZXIgZGVjb2Rpbmcgd2UgcG9wdWxhdGUgZGF0YSBpblxuXHQvLyBSR0IgZm9ybWF0LCBzbyB1cGRhdGluZyB0aGUgdGFnIHZhbHVlXG5cdGlmKGltZ1tcInQyNjJcIl1bMF0gPT0gNikgIGltZ1tcInQyNjJcIl1bMF0gPSAyO1xufVxuXG5VVElGLmRlY29kZS5fZGVjb2RlT2xkSlBFR0luaXQgPSBmdW5jdGlvbihpbWcsIGRhdGEsIG9mZiwgbGVuKVxue1xuXHR2YXIgU09JID0gMjE2LCBFT0kgPSAyMTcsIERRVCA9IDIxOSwgREhUID0gMTk2LCBEUkkgPSAyMjEsIFNPRjAgPSAxOTIsIFNPUyA9IDIxODtcblx0dmFyIGpvZmYgPSAwLCBzb2ZmID0gMCwgdGFibGVzLCBzb3NNYXJrZXIsIGlzVGlsZWQgPSBmYWxzZSwgaSwgaiwgaztcblx0dmFyIGpwZ0ljaGdGbXQgICAgPSBpbWdbXCJ0NTEzXCJdLCBqaWZvZmYgPSBqcGdJY2hnRm10ID8ganBnSWNoZ0ZtdFswXSA6IDA7XG5cdHZhciBqcGdJY2hnRm10TGVuID0gaW1nW1widDUxNFwiXSwgamlmbGVuID0ganBnSWNoZ0ZtdExlbiA/IGpwZ0ljaGdGbXRMZW5bMF0gOiAwO1xuXHR2YXIgc29mZlRhZyAgICAgICA9IGltZ1tcInQzMjRcIl0gfHwgaW1nW1widDI3M1wiXSB8fCBqcGdJY2hnRm10O1xuXHR2YXIgeWNiY3JzcyAgICAgICA9IGltZ1tcInQ1MzBcIl0sIHNzeCA9IDAsIHNzeSA9IDA7XG5cdHZhciBzcHAgICAgICAgICAgID0gaW1nW1widDI3N1wiXT9pbWdbXCJ0Mjc3XCJdWzBdOjE7XG5cdHZhciBqcGdyZXNpbnQgICAgID0gaW1nW1widDUxNVwiXTtcblxuXHRpZihzb2ZmVGFnKVxuXHR7XG5cdFx0c29mZiA9IHNvZmZUYWdbMF07XG5cdFx0aXNUaWxlZCA9IChzb2ZmVGFnLmxlbmd0aCA+IDEpO1xuXHR9XG5cblx0aWYoIWlzVGlsZWQpXG5cdHtcblx0XHRpZihkYXRhW29mZl09PTI1NSAmJiBkYXRhW29mZisxXT09U09JKSByZXR1cm4geyBqcGVnT2Zmc2V0OiBvZmYgfTtcblx0XHRpZihqcGdJY2hnRm10IT1udWxsKVxuXHRcdHtcblx0XHRcdGlmKGRhdGFbb2ZmK2ppZm9mZl09PTI1NSAmJiBkYXRhW29mZitqaWZvZmYrMV09PVNPSSkgam9mZiA9IG9mZitqaWZvZmY7XG5cdFx0XHRlbHNlIGxvZyhcIkpQRUdJbnRlcmNoYW5nZUZvcm1hdCBkb2VzIG5vdCBwb2ludCB0byBTT0lcIik7XG5cblx0XHRcdGlmKGpwZ0ljaGdGbXRMZW49PW51bGwpIGxvZyhcIkpQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aCBmaWVsZCBpcyBtaXNzaW5nXCIpO1xuXHRcdFx0ZWxzZSBpZihqaWZvZmYgPj0gc29mZiB8fCAoamlmb2ZmK2ppZmxlbikgPD0gc29mZikgbG9nKFwiSlBFR0ludGVyY2hhbmdlRm9ybWF0TGVuZ3RoIGZpZWxkIHZhbHVlIGlzIGludmFsaWRcIik7XG5cblx0XHRcdGlmKGpvZmYgIT0gbnVsbCkgcmV0dXJuIHsganBlZ09mZnNldDogam9mZiB9O1xuXHRcdH1cblx0fVxuXG5cdGlmKHljYmNyc3MhPW51bGwpIHsgIHNzeCA9IHljYmNyc3NbMF07ICBzc3kgPSB5Y2JjcnNzWzFdOyAgfVxuXG5cdGlmKGpwZ0ljaGdGbXQhPW51bGwpXG5cdFx0aWYoanBnSWNoZ0ZtdExlbiE9bnVsbClcblx0XHRcdGlmKGppZmxlbiA+PSAyICYmIChqaWZvZmYramlmbGVuKSA8PSBzb2ZmKVxuXHRcdFx0e1xuXHRcdFx0XHRpZihkYXRhW29mZitqaWZvZmYramlmbGVuLTJdPT0yNTUgJiYgZGF0YVtvZmYramlmb2ZmK2ppZmxlbi0xXT09U09JKSB0YWJsZXMgPSBuZXcgVWludDhBcnJheShqaWZsZW4tMik7XG5cdFx0XHRcdGVsc2UgdGFibGVzID0gbmV3IFVpbnQ4QXJyYXkoamlmbGVuKTtcblxuXHRcdFx0XHRmb3IoaT0wOyBpPHRhYmxlcy5sZW5ndGg7IGkrKykgdGFibGVzW2ldID0gZGF0YVtvZmYramlmb2ZmK2ldO1xuXHRcdFx0XHRsb2coXCJJbmNvcnJlY3QgSlBFRyBpbnRlcmNoYW5nZSBmb3JtYXQ6IHVzaW5nIEpQRUdJbnRlcmNoYW5nZUZvcm1hdCBvZmZzZXQgdG8gZGVyaXZlIHRhYmxlc1wiKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgbG9nKFwiSlBFR0ludGVyY2hhbmdlRm9ybWF0K0pQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aCA+IG9mZnNldCB0byBmaXJzdCBzdHJpcCBvciB0aWxlXCIpO1xuXG5cdGlmKHRhYmxlcyA9PSBudWxsKVxuXHR7XG5cdFx0dmFyIG9vZmYgPSAwLCBvdXQgPSBbXTtcblx0XHRvdXRbb29mZisrXSA9IDI1NTsgb3V0W29vZmYrK10gPSBTT0k7XG5cblx0XHR2YXIgcXRhYmxlcyA9IGltZ1tcInQ1MTlcIl07XG5cdFx0aWYocXRhYmxlcz09bnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiSlBFR1FUYWJsZXMgdGFnIGlzIG1pc3NpbmdcIik7XG5cdFx0Zm9yKGk9MDsgaTxxdGFibGVzLmxlbmd0aDsgaSsrKVxuXHRcdHtcblx0XHRcdG91dFtvb2ZmKytdID0gMjU1OyBvdXRbb29mZisrXSA9IERRVDsgb3V0W29vZmYrK10gPSAwOyBvdXRbb29mZisrXSA9IDY3OyBvdXRbb29mZisrXSA9IGk7XG5cdFx0XHRmb3Ioaj0wOyBqPDY0OyBqKyspIG91dFtvb2ZmKytdID0gZGF0YVtvZmYrcXRhYmxlc1tpXStqXTtcblx0XHR9XG5cblx0XHRmb3Ioaz0wOyBrPDI7IGsrKylcblx0XHR7XG5cdFx0XHR2YXIgaHRhYmxlcyA9IGltZ1soayA9PSAwKSA/IFwidDUyMFwiIDogXCJ0NTIxXCJdO1xuXHRcdFx0aWYoaHRhYmxlcz09bnVsbCkgdGhyb3cgbmV3IEVycm9yKCgoayA9PSAwKSA/IFwiSlBFR0RDVGFibGVzXCIgOiBcIkpQRUdBQ1RhYmxlc1wiKSArIFwiIHRhZyBpcyBtaXNzaW5nXCIpO1xuXHRcdFx0Zm9yKGk9MDsgaTxodGFibGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRvdXRbb29mZisrXSA9IDI1NTsgb3V0W29vZmYrK10gPSBESFQ7XG5cdFx0XHRcdC8vb3V0W29vZmYrK10gPSAwOyBvdXRbb29mZisrXSA9IDY3OyBvdXRbb29mZisrXSA9IGk7XG5cdFx0XHRcdHZhciBuYyA9IDE5O1xuXHRcdFx0XHRmb3Ioaj0wOyBqPDE2OyBqKyspIG5jICs9IGRhdGFbb2ZmK2h0YWJsZXNbaV0ral07XG5cblx0XHRcdFx0b3V0W29vZmYrK10gPSAobmMgPj4+IDgpOyBvdXRbb29mZisrXSA9IG5jICYgMjU1O1xuXHRcdFx0XHRvdXRbb29mZisrXSA9IChpIHwgKGsgPDwgNCkpO1xuXHRcdFx0XHRmb3Ioaj0wOyBqPDE2OyBqKyspIG91dFtvb2ZmKytdID0gZGF0YVtvZmYraHRhYmxlc1tpXStqXTtcblx0XHRcdFx0Zm9yKGo9MDsgajxuYzsgaisrKSBvdXRbb29mZisrXSA9IGRhdGFbb2ZmK2h0YWJsZXNbaV0rMTYral07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b3V0W29vZmYrK10gPSAyNTU7IG91dFtvb2ZmKytdID0gU09GMDtcblx0XHRvdXRbb29mZisrXSA9IDA7ICBvdXRbb29mZisrXSA9IDggKyAzKnNwcDsgIG91dFtvb2ZmKytdID0gODtcblx0XHRvdXRbb29mZisrXSA9IChpbWcuaGVpZ2h0ID4+PiA4KSAmIDI1NTsgIG91dFtvb2ZmKytdID0gaW1nLmhlaWdodCAmIDI1NTtcblx0XHRvdXRbb29mZisrXSA9IChpbWcud2lkdGggID4+PiA4KSAmIDI1NTsgIG91dFtvb2ZmKytdID0gaW1nLndpZHRoICAmIDI1NTtcblx0XHRvdXRbb29mZisrXSA9IHNwcDtcblx0XHRpZihzcHA9PTEpIHsgIG91dFtvb2ZmKytdID0gMTsgIG91dFtvb2ZmKytdID0gMTc7ICBvdXRbb29mZisrXSA9IDA7ICB9XG5cdFx0ZWxzZSBmb3IoaT0wOyBpPDM7IGkrKylcblx0XHR7XG5cdFx0XHRvdXRbb29mZisrXSA9IGkgKyAxO1xuXHRcdFx0b3V0W29vZmYrK10gPSAoaSAhPSAwKSA/IDE3IDogKCgoc3N4ICYgMTUpIDw8IDQpIHwgKHNzeSAmIDE1KSk7XG5cdFx0XHRvdXRbb29mZisrXSA9IGk7XG5cdFx0fVxuXG5cdFx0aWYoanBncmVzaW50IT1udWxsICYmIGpwZ3Jlc2ludFswXSE9MClcblx0XHR7XG5cdFx0XHRvdXRbb29mZisrXSA9IDI1NTsgIG91dFtvb2ZmKytdID0gRFJJOyAgb3V0W29vZmYrK10gPSAwOyAgb3V0W29vZmYrK10gPSA0O1xuXHRcdFx0b3V0W29vZmYrK10gPSAoanBncmVzaW50WzBdID4+PiA4KSAmIDI1NTtcblx0XHRcdG91dFtvb2ZmKytdID0ganBncmVzaW50WzBdICYgMjU1O1xuXHRcdH1cblxuXHRcdHRhYmxlcyA9IG5ldyBVaW50OEFycmF5KG91dCk7XG5cdH1cblxuXHR2YXIgc29mcG9zID0gLTE7XG5cdGkgPSAwO1xuXHR3aGlsZShpIDwgKHRhYmxlcy5sZW5ndGggLSAxKSkge1xuXHRcdGlmKHRhYmxlc1tpXT09MjU1ICYmIHRhYmxlc1tpKzFdPT1TT0YwKSB7ICBzb2Zwb3MgPSBpOyBicmVhazsgIH1cblx0XHRpKys7XG5cdH1cblxuXHRpZihzb2Zwb3MgPT0gLTEpXG5cdHtcblx0XHR2YXIgdG1wdGFiID0gbmV3IFVpbnQ4QXJyYXkodGFibGVzLmxlbmd0aCArIDEwICsgMypzcHApO1xuXHRcdHRtcHRhYi5zZXQodGFibGVzKTtcblx0XHR2YXIgdG1wb2ZmID0gdGFibGVzLmxlbmd0aDtcblx0XHRzb2Zwb3MgPSB0YWJsZXMubGVuZ3RoO1xuXHRcdHRhYmxlcyA9IHRtcHRhYjtcblxuXHRcdHRhYmxlc1t0bXBvZmYrK10gPSAyNTU7IHRhYmxlc1t0bXBvZmYrK10gPSBTT0YwO1xuXHRcdHRhYmxlc1t0bXBvZmYrK10gPSAwOyAgdGFibGVzW3RtcG9mZisrXSA9IDggKyAzKnNwcDsgIHRhYmxlc1t0bXBvZmYrK10gPSA4O1xuXHRcdHRhYmxlc1t0bXBvZmYrK10gPSAoaW1nLmhlaWdodCA+Pj4gOCkgJiAyNTU7ICB0YWJsZXNbdG1wb2ZmKytdID0gaW1nLmhlaWdodCAmIDI1NTtcblx0XHR0YWJsZXNbdG1wb2ZmKytdID0gKGltZy53aWR0aCAgPj4+IDgpICYgMjU1OyAgdGFibGVzW3RtcG9mZisrXSA9IGltZy53aWR0aCAgJiAyNTU7XG5cdFx0dGFibGVzW3RtcG9mZisrXSA9IHNwcDtcblx0XHRpZihzcHA9PTEpIHsgIHRhYmxlc1t0bXBvZmYrK10gPSAxOyAgdGFibGVzW3RtcG9mZisrXSA9IDE3OyAgdGFibGVzW3RtcG9mZisrXSA9IDA7ICB9XG5cdFx0ZWxzZSBmb3IoaT0wOyBpPDM7IGkrKylcblx0XHR7XG5cdFx0XHR0YWJsZXNbdG1wb2ZmKytdID0gaSArIDE7XG5cdFx0XHR0YWJsZXNbdG1wb2ZmKytdID0gKGkgIT0gMCkgPyAxNyA6ICgoKHNzeCAmIDE1KSA8PCA0KSB8IChzc3kgJiAxNSkpO1xuXHRcdFx0dGFibGVzW3RtcG9mZisrXSA9IGk7XG5cdFx0fVxuXHR9XG5cblx0aWYoZGF0YVtzb2ZmXT09MjU1ICYmIGRhdGFbc29mZisxXT09U09TKVxuXHR7XG5cdFx0dmFyIHNvc2xlbiA9IChkYXRhW3NvZmYrMl08PDgpIHwgZGF0YVtzb2ZmKzNdO1xuXHRcdHNvc01hcmtlciA9IG5ldyBVaW50OEFycmF5KHNvc2xlbisyKTtcblx0XHRzb3NNYXJrZXJbMF0gPSBkYXRhW3NvZmZdOyAgc29zTWFya2VyWzFdID0gZGF0YVtzb2ZmKzFdOyBzb3NNYXJrZXJbMl0gPSBkYXRhW3NvZmYrMl07ICBzb3NNYXJrZXJbM10gPSBkYXRhW3NvZmYrM107XG5cdFx0Zm9yKGk9MDsgaTwoc29zbGVuLTIpOyBpKyspIHNvc01hcmtlcltpKzRdID0gZGF0YVtzb2ZmK2krNF07XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0c29zTWFya2VyID0gbmV3IFVpbnQ4QXJyYXkoMiArIDYgKyAyKnNwcCk7XG5cdFx0dmFyIHNvc29mZiA9IDA7XG5cdFx0c29zTWFya2VyW3Nvc29mZisrXSA9IDI1NTsgIHNvc01hcmtlcltzb3NvZmYrK10gPSBTT1M7XG5cdFx0c29zTWFya2VyW3Nvc29mZisrXSA9IDA7ICBzb3NNYXJrZXJbc29zb2ZmKytdID0gNiArIDIqc3BwOyAgc29zTWFya2VyW3Nvc29mZisrXSA9IHNwcDtcblx0XHRpZihzcHA9PTEpIHsgIHNvc01hcmtlcltzb3NvZmYrK10gPSAxOyAgc29zTWFya2VyW3Nvc29mZisrXSA9IDA7ICB9XG5cdFx0ZWxzZSBmb3IoaT0wOyBpPDM7IGkrKylcblx0XHR7XG5cdFx0XHRzb3NNYXJrZXJbc29zb2ZmKytdID0gaSsxOyAgc29zTWFya2VyW3Nvc29mZisrXSA9IChpIDw8IDQpIHwgaTtcblx0XHR9XG5cdFx0c29zTWFya2VyW3Nvc29mZisrXSA9IDA7ICBzb3NNYXJrZXJbc29zb2ZmKytdID0gNjM7ICBzb3NNYXJrZXJbc29zb2ZmKytdID0gMDtcblx0fVxuXG5cdHJldHVybiB7IGpwZWdPZmZzZXQ6IG9mZiwgdGFibGVzOiB0YWJsZXMsIHNvc01hcmtlcjogc29zTWFya2VyLCBzb2ZQb3NpdGlvbjogc29mcG9zIH07XG59XG5cblVUSUYuZGVjb2RlLl9kZWNvZGVPbGRKUEVHID0gZnVuY3Rpb24oaW1nLCBkYXRhLCBvZmYsIGxlbiwgdGd0LCB0b2ZmKVxue1xuXHR2YXIgaSwgZGxlbiwgdGxlbiwgYnVmZiwgYnVmZm9mZjtcblx0dmFyIGpwZWdEYXRhID0gVVRJRi5kZWNvZGUuX2RlY29kZU9sZEpQRUdJbml0KGltZywgZGF0YSwgb2ZmLCBsZW4pO1xuXG5cdGlmKGpwZWdEYXRhLmpwZWdPZmZzZXQhPW51bGwpXG5cdHtcblx0XHRkbGVuID0gb2ZmK2xlbi1qcGVnRGF0YS5qcGVnT2Zmc2V0O1xuXHRcdGJ1ZmYgPSBuZXcgVWludDhBcnJheShkbGVuKTtcblx0XHRmb3IoaT0wOyBpPGRsZW47IGkrKykgYnVmZltpXSA9IGRhdGFbanBlZ0RhdGEuanBlZ09mZnNldCtpXTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHR0bGVuID0ganBlZ0RhdGEudGFibGVzLmxlbmd0aDtcblx0XHRidWZmID0gbmV3IFVpbnQ4QXJyYXkodGxlbiArIGpwZWdEYXRhLnNvc01hcmtlci5sZW5ndGggKyBsZW4gKyAyKTtcblx0XHRidWZmLnNldChqcGVnRGF0YS50YWJsZXMpO1xuXHRcdGJ1ZmZvZmYgPSB0bGVuO1xuXG5cdFx0YnVmZltqcGVnRGF0YS5zb2ZQb3NpdGlvbis1XSA9IChpbWcuaGVpZ2h0ID4+PiA4KSAmIDI1NTsgIGJ1ZmZbanBlZ0RhdGEuc29mUG9zaXRpb24rNl0gPSBpbWcuaGVpZ2h0ICYgMjU1O1xuXHRcdGJ1ZmZbanBlZ0RhdGEuc29mUG9zaXRpb24rN10gPSAoaW1nLndpZHRoICA+Pj4gOCkgJiAyNTU7ICBidWZmW2pwZWdEYXRhLnNvZlBvc2l0aW9uKzhdID0gaW1nLndpZHRoICAmIDI1NTtcblxuXHRcdGlmKGRhdGFbb2ZmXSE9MjU1IHx8IGRhdGFbb2ZmKzFdIT1TT1MpXG5cdFx0e1xuXHRcdFx0YnVmZi5zZXQoanBlZ0RhdGEuc29zTWFya2VyLCBidWZvZmYpO1xuXHRcdFx0YnVmb2ZmICs9IHNvc01hcmtlci5sZW5ndGg7XG5cdFx0fVxuXHRcdGZvcihpPTA7IGk8bGVuOyBpKyspIGJ1ZmZbYnVmb2ZmKytdID0gZGF0YVtvZmYraV07XG5cdFx0YnVmZltidWZvZmYrK10gPSAyNTU7ICBidWZmW2J1Zm9mZisrXSA9IEVPSTtcblx0fVxuXG5cdHZhciBwYXJzZXIgPSBuZXcgVVRJRi5KcGVnRGVjb2RlcigpOyAgcGFyc2VyLnBhcnNlKGJ1ZmYpO1xuXHR2YXIgZGVjb2RlZCA9IHBhcnNlci5nZXREYXRhKHBhcnNlci53aWR0aCwgcGFyc2VyLmhlaWdodCk7XG5cdGZvciAodmFyIGk9MDsgaTxkZWNvZGVkLmxlbmd0aDsgaSsrKSB0Z3RbdG9mZiArIGldID0gZGVjb2RlZFtpXTtcblxuXHQvLyBQaG90b21ldHJpY0ludGVycHJldGF0aW9uIGlzIDYgKFlDYkNyKSBmb3IgSlBFRywgYnV0IGFmdGVyIGRlY29kaW5nIHdlIHBvcHVsYXRlIGRhdGEgaW5cblx0Ly8gUkdCIGZvcm1hdCwgc28gdXBkYXRpbmcgdGhlIHRhZyB2YWx1ZVxuXHRpZihpbWdbXCJ0MjYyXCJdWzBdID09IDYpICBpbWdbXCJ0MjYyXCJdWzBdID0gMjtcbn1cblxuVVRJRi5kZWNvZGUuX2RlY29kZVBhY2tCaXRzID0gZnVuY3Rpb24oZGF0YSwgb2ZmLCBsZW4sIHRndCwgdG9mZilcbntcblx0dmFyIHNhID0gbmV3IEludDhBcnJheShkYXRhLmJ1ZmZlciksIHRhID0gbmV3IEludDhBcnJheSh0Z3QuYnVmZmVyKSwgbGltID0gb2ZmK2xlbjtcblx0d2hpbGUob2ZmPGxpbSlcblx0e1xuXHRcdHZhciBuID0gc2Fbb2ZmXTsgIG9mZisrO1xuXHRcdGlmKG4+PTAgICYmIG48MTI4KSAgICBmb3IodmFyIGk9MDsgaTwgbisxOyBpKyspIHsgIHRhW3RvZmZdPXNhW29mZl07ICB0b2ZmKys7ICBvZmYrKzsgICB9XG5cdFx0aWYobj49LTEyNyAmJiBuPDApIHsgIGZvcih2YXIgaT0wOyBpPC1uKzE7IGkrKykgeyAgdGFbdG9mZl09c2Fbb2ZmXTsgIHRvZmYrKzsgICAgICAgICAgIH0gIG9mZisrOyAgfVxuXHR9XG59XG5cblVUSUYuZGVjb2RlLl9kZWNvZGVUaHVuZGVyID0gZnVuY3Rpb24oZGF0YSwgb2ZmLCBsZW4sIHRndCwgdG9mZilcbntcblx0dmFyIGQyID0gWyAwLCAxLCAwLCAtMSBdLCAgZDMgPSBbIDAsIDEsIDIsIDMsIDAsIC0zLCAtMiwgLTEgXTtcblx0dmFyIGxpbSA9IG9mZitsZW4sIHFvZmYgPSB0b2ZmKjIsIHB4ID0gMDtcblx0d2hpbGUob2ZmPGxpbSlcblx0e1xuXHRcdHZhciBiID0gZGF0YVtvZmZdLCBtc2sgPSAoYj4+PjYpLCBuID0gKGImNjMpOyAgb2ZmKys7XG5cdFx0aWYobXNrPT0zKSB7IHB4PShuJjE1KTsgIHRndFtxb2ZmPj4+MV0gfD0gKHB4PDwoNCooMS1xb2ZmJjEpKSk7ICBxb2ZmKys7ICAgfVxuXHRcdGlmKG1zaz09MCkgZm9yKHZhciBpPTA7IGk8bjsgaSsrKSB7ICB0Z3RbcW9mZj4+PjFdIHw9IChweDw8KDQqKDEtcW9mZiYxKSkpOyAgcW9mZisrOyAgIH1cblx0XHRpZihtc2s9PTIpIGZvcih2YXIgaT0wOyBpPDI7IGkrKykgeyAgdmFyIGQ9KG4+Pj4oMyooMS1pKSkpJjc7ICBpZihkIT00KSB7IHB4Kz1kM1tkXTsgIHRndFtxb2ZmPj4+MV0gfD0gKHB4PDwoNCooMS1xb2ZmJjEpKSk7ICBxb2ZmKys7IH0gIH1cblx0XHRpZihtc2s9PTEpIGZvcih2YXIgaT0wOyBpPDM7IGkrKykgeyAgdmFyIGQ9KG4+Pj4oMiooMi1pKSkpJjM7ICBpZihkIT0yKSB7IHB4Kz1kMltkXTsgIHRndFtxb2ZmPj4+MV0gfD0gKHB4PDwoNCooMS1xb2ZmJjEpKSk7ICBxb2ZmKys7IH0gIH1cblx0fVxufVxuXG5VVElGLmRlY29kZS5fZG1hcCA9IHsgXCIxXCI6MCxcIjAxMVwiOjEsXCIwMDAwMTFcIjoyLFwiMDAwMDAxMVwiOjMsIFwiMDEwXCI6LTEsXCIwMDAwMTBcIjotMixcIjAwMDAwMTBcIjotMyAgfTtcblVUSUYuZGVjb2RlLl9sZW5zID0gKCBmdW5jdGlvbigpXG57XG5cdHZhciBhZGRLZXlzID0gZnVuY3Rpb24obGVucywgYXJyLCBpMCwgaW5jKSB7ICBmb3IodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIGxlbnNbYXJyW2ldXSA9IGkwICsgaSppbmM7ICB9XG5cblx0dmFyIHRlcm1XID0gXCIwMDExMDEwMSwwMDAxMTEsMDExMSwxMDAwLDEwMTEsMTEwMCwxMTEwLDExMTEsMTAwMTEsMTAxMDAsMDAxMTEsMDEwMDAsMDAxMDAwLDAwMDAxMSwxMTAxMDAsMTEwMTAxLFwiIC8vIDE1XG5cdCsgXCIxMDEwMTAsMTAxMDExLDAxMDAxMTEsMDAwMTEwMCwwMDAxMDAwLDAwMTAxMTEsMDAwMDAxMSwwMDAwMTAwLDAxMDEwMDAsMDEwMTAxMSwwMDEwMDExLDAxMDAxMDAsMDAxMTAwMCwwMDAwMDAxMCwwMDAwMDAxMSwwMDAxMTAxMCxcIiAvLyAzMVxuXHQrIFwiMDAwMTEwMTEsMDAwMTAwMTAsMDAwMTAwMTEsMDAwMTAxMDAsMDAwMTAxMDEsMDAwMTAxMTAsMDAwMTAxMTEsMDAxMDEwMDAsMDAxMDEwMDEsMDAxMDEwMTAsMDAxMDEwMTEsMDAxMDExMDAsMDAxMDExMDEsMDAwMDAxMDAsMDAwMDAxMDEsMDAwMDEwMTAsXCIgLy8gNDdcblx0KyBcIjAwMDAxMDExLDAxMDEwMDEwLDAxMDEwMDExLDAxMDEwMTAwLDAxMDEwMTAxLDAwMTAwMTAwLDAwMTAwMTAxLDAxMDExMDAwLDAxMDExMDAxLDAxMDExMDEwLDAxMDExMDExLDAxMDAxMDEwLDAxMDAxMDExLDAwMTEwMDEwLDAwMTEwMDExLDAwMTEwMTAwXCI7XG5cblx0dmFyIHRlcm1CID0gXCIwMDAwMTEwMTExLDAxMCwxMSwxMCwwMTEsMDAxMSwwMDEwLDAwMDExLDAwMDEwMSwwMDAxMDAsMDAwMDEwMCwwMDAwMTAxLDAwMDAxMTEsMDAwMDAxMDAsMDAwMDAxMTEsMDAwMDExMDAwLFwiIC8vIDE1XG5cdCsgXCIwMDAwMDEwMTExLDAwMDAwMTEwMDAsMDAwMDAwMTAwMCwwMDAwMTEwMDExMSwwMDAwMTEwMTAwMCwwMDAwMTEwMTEwMCwwMDAwMDExMDExMSwwMDAwMDEwMTAwMCwwMDAwMDAxMDExMSwwMDAwMDAxMTAwMCwwMDAwMTEwMDEwMTAsMDAwMDExMDAxMDExLDAwMDAxMTAwMTEwMCwwMDAwMTEwMDExMDEsMDAwMDAxMTAxMDAwLDAwMDAwMTEwMTAwMSxcIiAvLyAzMVxuXHQrIFwiMDAwMDAxMTAxMDEwLDAwMDAwMTEwMTAxMSwwMDAwMTEwMTAwMTAsMDAwMDExMDEwMDExLDAwMDAxMTAxMDEwMCwwMDAwMTEwMTAxMDEsMDAwMDExMDEwMTEwLDAwMDAxMTAxMDExMSwwMDAwMDExMDExMDAsMDAwMDAxMTAxMTAxLDAwMDAxMTAxMTAxMCwwMDAwMTEwMTEwMTEsMDAwMDAxMDEwMTAwLDAwMDAwMTAxMDEwMSwwMDAwMDEwMTAxMTAsMDAwMDAxMDEwMTExLFwiIC8vIDQ3XG5cdCsgXCIwMDAwMDExMDAxMDAsMDAwMDAxMTAwMTAxLDAwMDAwMTAxMDAxMCwwMDAwMDEwMTAwMTEsMDAwMDAwMTAwMTAwLDAwMDAwMDExMDExMSwwMDAwMDAxMTEwMDAsMDAwMDAwMTAwMTExLDAwMDAwMDEwMTAwMCwwMDAwMDEwMTEwMDAsMDAwMDAxMDExMDAxLDAwMDAwMDEwMTAxMSwwMDAwMDAxMDExMDAsMDAwMDAxMDExMDEwLDAwMDAwMTEwMDExMCwwMDAwMDExMDAxMTFcIjtcblxuXHR2YXIgbWFrZVcgPSBcIjExMDExLDEwMDEwLDAxMDExMSwwMTEwMTExLDAwMTEwMTEwLDAwMTEwMTExLDAxMTAwMTAwLDAxMTAwMTAxLDAxMTAxMDAwLDAxMTAwMTExLDAxMTAwMTEwMCwwMTEwMDExMDEsMDExMDEwMDEwLDAxMTAxMDAxMSwwMTEwMTAxMDAsMDExMDEwMTAxLDAxMTAxMDExMCxcIlxuXHQrIFwiMDExMDEwMTExLDAxMTAxMTAwMCwwMTEwMTEwMDEsMDExMDExMDEwLDAxMTAxMTAxMSwwMTAwMTEwMDAsMDEwMDExMDAxLDAxMDAxMTAxMCwwMTEwMDAsMDEwMDExMDExXCI7XG5cblx0dmFyIG1ha2VCID0gXCIwMDAwMDAxMTExLDAwMDAxMTAwMTAwMCwwMDAwMTEwMDEwMDEsMDAwMDAxMDExMDExLDAwMDAwMDExMDAxMSwwMDAwMDAxMTAxMDAsMDAwMDAwMTEwMTAxLDAwMDAwMDExMDExMDAsMDAwMDAwMTEwMTEwMSwwMDAwMDAxMDAxMDEwLDAwMDAwMDEwMDEwMTEsMDAwMDAwMTAwMTEwMCxcIlxuXHQrIFwiMDAwMDAwMTAwMTEwMSwwMDAwMDAxMTEwMDEwLDAwMDAwMDExMTAwMTEsMDAwMDAwMTExMDEwMCwwMDAwMDAxMTEwMTAxLDAwMDAwMDExMTAxMTAsMDAwMDAwMTExMDExMSwwMDAwMDAxMDEwMDEwLDAwMDAwMDEwMTAwMTEsMDAwMDAwMTAxMDEwMCwwMDAwMDAxMDEwMTAxLDAwMDAwMDEwMTEwMTAsXCJcblx0KyBcIjAwMDAwMDEwMTEwMTEsMDAwMDAwMTEwMDEwMCwwMDAwMDAxMTAwMTAxXCI7XG5cblx0dmFyIG1ha2VBID0gXCIwMDAwMDAwMTAwMCwwMDAwMDAwMTEwMCwwMDAwMDAwMTEwMSwwMDAwMDAwMTAwMTAsMDAwMDAwMDEwMDExLDAwMDAwMDAxMDEwMCwwMDAwMDAwMTAxMDEsMDAwMDAwMDEwMTEwLDAwMDAwMDAxMDExMSwwMDAwMDAwMTExMDAsMDAwMDAwMDExMTAxLDAwMDAwMDAxMTExMCwwMDAwMDAwMTExMTFcIjtcblxuXHR0ZXJtVyA9IHRlcm1XLnNwbGl0KFwiLFwiKTsgIHRlcm1CID0gdGVybUIuc3BsaXQoXCIsXCIpOyAgbWFrZVcgPSBtYWtlVy5zcGxpdChcIixcIik7ICBtYWtlQiA9IG1ha2VCLnNwbGl0KFwiLFwiKTsgIG1ha2VBID0gbWFrZUEuc3BsaXQoXCIsXCIpO1xuXG5cdHZhciBsZW5zVyA9IHt9LCBsZW5zQiA9IHt9O1xuXHRhZGRLZXlzKGxlbnNXLCB0ZXJtVywgMCwgMSk7ICBhZGRLZXlzKGxlbnNXLCBtYWtlVywgNjQsNjQpOyAgYWRkS2V5cyhsZW5zVywgbWFrZUEsIDE3OTIsNjQpO1xuXHRhZGRLZXlzKGxlbnNCLCB0ZXJtQiwgMCwgMSk7ICBhZGRLZXlzKGxlbnNCLCBtYWtlQiwgNjQsNjQpOyAgYWRkS2V5cyhsZW5zQiwgbWFrZUEsIDE3OTIsNjQpO1xuXHRyZXR1cm4gW2xlbnNXLCBsZW5zQl07XG59ICkoKTtcblxuVVRJRi5kZWNvZGUuX2RlY29kZUc0ID0gZnVuY3Rpb24oZGF0YSwgb2ZmLCBzbGVuLCB0Z3QsIHRvZmYsIHcsIGZvKVxue1xuXHR2YXIgVSA9IFVUSUYuZGVjb2RlLCBib2ZmPW9mZjw8MywgbGVuPTAsIHdyZD1cIlwiO1x0Ly8gcHJldmlvdXMgc3RhcnRzIHdpdGggMVxuXHR2YXIgbGluZT1bXSwgcGxpbmU9W107ICBmb3IodmFyIGk9MDsgaTx3OyBpKyspIHBsaW5lLnB1c2goMCk7ICBwbGluZT1VLl9tYWtlRGlmZihwbGluZSk7XG5cdHZhciBhMD0wLCBhMT0wLCBhMj0wLCBiMT0wLCBiMj0wLCBjbHI9MDtcblx0dmFyIHk9MCwgbW9kZT1cIlwiLCB0b1JlYWQ9MDtcblx0dmFyIGJpcGwgPSBNYXRoLmNlaWwody84KSo4O1xuXG5cdHdoaWxlKChib2ZmPj4+Myk8b2ZmK3NsZW4pXG5cdHtcblx0XHRiMSA9IFUuX2ZpbmREaWZmKHBsaW5lLCBhMCsoYTA9PTA/MDoxKSwgMS1jbHIpLCBiMiA9IFUuX2ZpbmREaWZmKHBsaW5lLCBiMSwgY2xyKTtcdC8vIGNvdWxkIGJlIHByZWNvbXB1dGVkXG5cdFx0dmFyIGJpdCA9MDtcblx0XHRpZihmbz09MSkgYml0ID0gKGRhdGFbYm9mZj4+PjNdPj4+KDctKGJvZmYmNykpKSYxO1xuXHRcdGlmKGZvPT0yKSBiaXQgPSAoZGF0YVtib2ZmPj4+M10+Pj4oICAoYm9mZiY3KSkpJjE7XG5cdFx0Ym9mZisrOyAgd3JkKz1iaXQ7XG5cdFx0aWYobW9kZT09XCJIXCIpXG5cdFx0e1xuXHRcdFx0aWYoVS5fbGVuc1tjbHJdW3dyZF0hPW51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBkbD1VLl9sZW5zW2Nscl1bd3JkXTsgIHdyZD1cIlwiOyAgbGVuKz1kbDtcblx0XHRcdFx0aWYoZGw8NjQpIHsgIFUuX2FkZE50aW1lcyhsaW5lLGxlbixjbHIpOyAgYTArPWxlbjsgIGNscj0xLWNscjsgIGxlbj0wOyAgdG9SZWFkLS07ICBpZih0b1JlYWQ9PTApIG1vZGU9XCJcIjsgIH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGlmKHdyZD09XCIwMDAxXCIpICB7ICB3cmQ9XCJcIjsgIFUuX2FkZE50aW1lcyhsaW5lLGIyLWEwLGNscik7ICBhMD1iMjsgICB9XG5cdFx0XHRpZih3cmQ9PVwiMDAxXCIgKSAgeyAgd3JkPVwiXCI7ICBtb2RlPVwiSFwiOyAgdG9SZWFkPTI7ICB9XG5cdFx0XHRpZihVLl9kbWFwW3dyZF0hPW51bGwpIHsgIGExID0gYjErVS5fZG1hcFt3cmRdOyAgVS5fYWRkTnRpbWVzKGxpbmUsIGExLWEwLCBjbHIpOyAgYTA9YTE7ICB3cmQ9XCJcIjsgIGNscj0xLWNscjsgIH1cblx0XHR9XG5cdFx0aWYobGluZS5sZW5ndGg9PXcgJiYgbW9kZT09XCJcIilcblx0XHR7XG5cdFx0XHRVLl93cml0ZUJpdHMobGluZSwgdGd0LCB0b2ZmKjgreSpiaXBsKTtcblx0XHRcdGNscj0wOyAgeSsrOyAgYTA9MDtcblx0XHRcdHBsaW5lPVUuX21ha2VEaWZmKGxpbmUpOyAgbGluZT1bXTtcblx0XHR9XG5cdFx0Ly9pZih3cmQubGVuZ3RoPjE1MCkgeyAgbG9nKHdyZCk7ICBicmVhazsgIHRocm93IFwiZVwiOyAgfVxuXHR9XG59XG5cblVUSUYuZGVjb2RlLl9maW5kRGlmZiA9IGZ1bmN0aW9uKGxpbmUsIHgsIGNscikgeyAgZm9yKHZhciBpPTA7IGk8bGluZS5sZW5ndGg7IGkrPTIpIGlmKGxpbmVbaV0+PXggJiYgbGluZVtpKzFdPT1jbHIpICByZXR1cm4gbGluZVtpXTsgIH1cblxuVVRJRi5kZWNvZGUuX21ha2VEaWZmID0gZnVuY3Rpb24obGluZSlcbntcblx0dmFyIG91dCA9IFtdOyAgaWYobGluZVswXT09MSkgb3V0LnB1c2goMCwxKTtcblx0Zm9yKHZhciBpPTE7IGk8bGluZS5sZW5ndGg7IGkrKykgaWYobGluZVtpLTFdIT1saW5lW2ldKSBvdXQucHVzaChpLCBsaW5lW2ldKTtcblx0b3V0LnB1c2gobGluZS5sZW5ndGgsMCxsaW5lLmxlbmd0aCwxKTsgIHJldHVybiBvdXQ7XG59XG5cblVUSUYuZGVjb2RlLl9kZWNvZGVHMyA9IGZ1bmN0aW9uKGRhdGEsIG9mZiwgc2xlbiwgdGd0LCB0b2ZmLCB3LCBmbylcbntcblx0dmFyIFUgPSBVVElGLmRlY29kZSwgYm9mZj1vZmY8PDMsIGxlbj0wLCB3cmQ9XCJcIjtcblx0dmFyIGxpbmU9W10sIHBsaW5lPVtdOyAgZm9yKHZhciBpPTA7IGk8dzsgaSsrKSBsaW5lLnB1c2goMCk7XG5cdHZhciBhMD0wLCBhMT0wLCBhMj0wLCBiMT0wLCBiMj0wLCBjbHI9MDtcblx0dmFyIHk9LTEsIG1vZGU9XCJcIiwgdG9SZWFkPTAsIGlzMUQ9ZmFsc2U7XG5cdHZhciBiaXBsID0gTWF0aC5jZWlsKHcvOCkqODtcblx0d2hpbGUoKGJvZmY+Pj4zKTxvZmYrc2xlbilcblx0e1xuXHRcdGIxID0gVS5fZmluZERpZmYocGxpbmUsIGEwKyhhMD09MD8wOjEpLCAxLWNsciksIGIyID0gVS5fZmluZERpZmYocGxpbmUsIGIxLCBjbHIpO1x0Ly8gY291bGQgYmUgcHJlY29tcHV0ZWRcblx0XHR2YXIgYml0ID0wO1xuXHRcdGlmKGZvPT0xKSBiaXQgPSAoZGF0YVtib2ZmPj4+M10+Pj4oNy0oYm9mZiY3KSkpJjE7XG5cdFx0aWYoZm89PTIpIGJpdCA9IChkYXRhW2JvZmY+Pj4zXT4+PiggIChib2ZmJjcpKSkmMTtcblx0XHRib2ZmKys7ICB3cmQrPWJpdDtcblxuXHRcdGlmKGlzMUQpXG5cdFx0e1xuXHRcdFx0aWYoVS5fbGVuc1tjbHJdW3dyZF0hPW51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBkbD1VLl9sZW5zW2Nscl1bd3JkXTsgIHdyZD1cIlwiOyAgbGVuKz1kbDtcblx0XHRcdFx0aWYoZGw8NjQpIHsgIFUuX2FkZE50aW1lcyhsaW5lLGxlbixjbHIpOyAgY2xyPTEtY2xyOyAgbGVuPTA7ICB9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRpZihtb2RlPT1cIkhcIilcblx0XHRcdHtcblx0XHRcdFx0aWYoVS5fbGVuc1tjbHJdW3dyZF0hPW51bGwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgZGw9VS5fbGVuc1tjbHJdW3dyZF07ICB3cmQ9XCJcIjsgIGxlbis9ZGw7XG5cdFx0XHRcdFx0aWYoZGw8NjQpIHsgIFUuX2FkZE50aW1lcyhsaW5lLGxlbixjbHIpOyAgYTArPWxlbjsgIGNscj0xLWNscjsgIGxlbj0wOyAgdG9SZWFkLS07ICBpZih0b1JlYWQ9PTApIG1vZGU9XCJcIjsgIH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRpZih3cmQ9PVwiMDAwMVwiKSAgeyAgd3JkPVwiXCI7ICBVLl9hZGROdGltZXMobGluZSxiMi1hMCxjbHIpOyAgYTA9YjI7ICAgfVxuXHRcdFx0XHRpZih3cmQ9PVwiMDAxXCIgKSAgeyAgd3JkPVwiXCI7ICBtb2RlPVwiSFwiOyAgdG9SZWFkPTI7ICB9XG5cdFx0XHRcdGlmKFUuX2RtYXBbd3JkXSE9bnVsbCkgeyAgYTEgPSBiMStVLl9kbWFwW3dyZF07ICBVLl9hZGROdGltZXMobGluZSwgYTEtYTAsIGNscik7ICBhMD1hMTsgIHdyZD1cIlwiOyAgY2xyPTEtY2xyOyAgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZih3cmQuZW5kc1dpdGgoXCIwMDAwMDAwMDAwMDFcIikpIC8vIG5lZWRlZCBmb3Igc29tZSBmaWxlc1xuXHRcdHtcblx0XHRcdGlmKHk+PTApIFUuX3dyaXRlQml0cyhsaW5lLCB0Z3QsIHRvZmYqOCt5KmJpcGwpO1xuXHRcdFx0aWYoZm89PTEpIGlzMUQgPSAoKGRhdGFbYm9mZj4+PjNdPj4+KDctKGJvZmYmNykpKSYxKT09MTtcblx0XHRcdGlmKGZvPT0yKSBpczFEID0gKChkYXRhW2JvZmY+Pj4zXT4+PiggIChib2ZmJjcpKSkmMSk9PTE7XG5cdFx0XHRib2ZmKys7XG5cdFx0XHRpZihVLl9kZWNvZGVHMy5hbGxvdzJEPT1udWxsKSBVLl9kZWNvZGVHMy5hbGxvdzJEPWlzMUQ7XG5cdFx0XHRpZighVS5fZGVjb2RlRzMuYWxsb3cyRCkgeyAgaXMxRCA9IHRydWU7ICBib2ZmLS07ICB9XG5cdFx0XHQvL2xvZyhcIkVPTFwiLHksIFwibmV4dCAxRDpcIiwgaXMxRCk7XG5cdFx0XHR3cmQ9XCJcIjsgIGNscj0wOyAgeSsrOyAgYTA9MDtcblx0XHRcdHBsaW5lPVUuX21ha2VEaWZmKGxpbmUpOyAgbGluZT1bXTtcblx0XHR9XG5cdH1cblx0aWYobGluZS5sZW5ndGg9PXcpIFUuX3dyaXRlQml0cyhsaW5lLCB0Z3QsIHRvZmYqOCt5KmJpcGwpO1xufVxuXG5VVElGLmRlY29kZS5fYWRkTnRpbWVzID0gZnVuY3Rpb24oYXJyLCBuLCB2YWwpIHsgIGZvcih2YXIgaT0wOyBpPG47IGkrKykgYXJyLnB1c2godmFsKTsgIH1cblxuVVRJRi5kZWNvZGUuX3dyaXRlQml0cyA9IGZ1bmN0aW9uKGJpdHMsIHRndCwgYm9mZilcbntcblx0Zm9yKHZhciBpPTA7IGk8Yml0cy5sZW5ndGg7IGkrKykgdGd0Wyhib2ZmK2kpPj4+M10gfD0gKGJpdHNbaV08PCg3LSgoYm9mZitpKSY3KSkpO1xufVxuXG5VVElGLmRlY29kZS5fZGVjb2RlTFpXID0gZnVuY3Rpb24oZGF0YSwgb2ZmLCB0Z3QsIHRvZmYpXG57XG5cdGlmKFVUSUYuZGVjb2RlLl9sendUYWI9PW51bGwpXG5cdHtcblx0XHR2YXIgdGI9bmV3IFVpbnQzMkFycmF5KDB4ZmZmZiksIHRuPW5ldyBVaW50MTZBcnJheSgweGZmZmYpLCBjaHI9bmV3IFVpbnQ4QXJyYXkoMmU2KTtcblx0XHRmb3IodmFyIGk9MDsgaTwyNTY7IGkrKykgeyBjaHJbaTw8Ml09aTsgIHRiW2ldPWk8PDI7ICB0bltpXT0xOyAgfVxuXHRcdFVUSUYuZGVjb2RlLl9sendUYWIgPSBbdGIsdG4sY2hyXTtcblx0fVxuXHR2YXIgY29weSA9IFVUSUYuZGVjb2RlLl9jb3B5RGF0YTtcblx0dmFyIHRhYiA9IFVUSUYuZGVjb2RlLl9sendUYWJbMF0sIHRsbj1VVElGLmRlY29kZS5fbHp3VGFiWzFdLCBjaHI9VVRJRi5kZWNvZGUuX2x6d1RhYlsyXSwgdG90bCA9IDI1OCwgY2hybCA9IDI1ODw8Mjtcblx0dmFyIGJpdHMgPSA5LCBib2ZmID0gb2ZmPDwzOyAgLy8gb2Zmc2V0IGluIGJpdHNcblxuXHR2YXIgQ2xlYXJDb2RlID0gMjU2LCBFb2lDb2RlID0gMjU3O1xuXHR2YXIgdiA9IDAsIENvZGUgPSAwLCBPbGRDb2RlID0gMDtcblx0d2hpbGUodHJ1ZSlcblx0e1xuXHRcdHYgPSAoZGF0YVtib2ZmPj4+M108PDE2KSB8IChkYXRhWyhib2ZmKzgpPj4+M108PDgpIHwgZGF0YVsoYm9mZisxNik+Pj4zXTtcblx0XHRDb2RlID0gKCB2Pj4oMjQtKGJvZmYmNyktYml0cykgKSAgICAmICAgKCgxPDxiaXRzKS0xKTsgIGJvZmYrPWJpdHM7XG5cblx0XHRpZihDb2RlPT1Fb2lDb2RlKSBicmVhaztcblx0XHRpZihDb2RlPT1DbGVhckNvZGUpXG5cdFx0e1xuXHRcdFx0Yml0cz05OyAgdG90bCA9IDI1ODsgIGNocmwgPSAyNTg8PDI7XG5cblx0XHRcdHYgPSAoZGF0YVtib2ZmPj4+M108PDE2KSB8IChkYXRhWyhib2ZmKzgpPj4+M108PDgpIHwgZGF0YVsoYm9mZisxNik+Pj4zXTtcblx0XHRcdENvZGUgPSAoIHY+PigyNC0oYm9mZiY3KS1iaXRzKSApICAgICYgICAoKDE8PGJpdHMpLTEpOyAgYm9mZis9Yml0cztcblx0XHRcdGlmKENvZGU9PUVvaUNvZGUpIGJyZWFrO1xuXHRcdFx0dGd0W3RvZmZdPUNvZGU7ICB0b2ZmKys7XG5cdFx0fVxuXHRcdGVsc2UgaWYoQ29kZTx0b3RsKVxuXHRcdHtcblx0XHRcdHZhciBjZCA9IHRhYltDb2RlXSwgY2wgPSB0bG5bQ29kZV07XG5cdFx0XHRjb3B5KGNocixjZCx0Z3QsdG9mZixjbCk7ICB0b2ZmICs9IGNsO1xuXG5cdFx0XHRpZihPbGRDb2RlPj10b3RsKSB7ICB0YWJbdG90bF0gPSBjaHJsOyAgY2hyW3RhYlt0b3RsXV0gPSBjZFswXTsgIHRsblt0b3RsXT0xOyAgY2hybD0oY2hybCsxKzMpJn4weDAzOyAgdG90bCsrOyAgfVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0YWJbdG90bF0gPSBjaHJsO1xuXHRcdFx0XHR2YXIgbml0ID0gdGFiW09sZENvZGVdLCBuaWwgPSB0bG5bT2xkQ29kZV07XG5cdFx0XHRcdGNvcHkoY2hyLG5pdCxjaHIsY2hybCxuaWwpO1xuXHRcdFx0XHRjaHJbY2hybCtuaWxdPWNocltjZF07ICBuaWwrKztcblx0XHRcdFx0dGxuW3RvdGxdPW5pbDsgIHRvdGwrKztcblxuXHRcdFx0XHRjaHJsPShjaHJsK25pbCszKSZ+MHgwMztcblx0XHRcdH1cblx0XHRcdGlmKHRvdGwrMT09KDE8PGJpdHMpKSBiaXRzKys7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRpZihPbGRDb2RlPj10b3RsKSB7ICB0YWJbdG90bF0gPSBjaHJsOyAgdGxuW3RvdGxdPTA7ICB0b3RsKys7ICB9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRhYlt0b3RsXSA9IGNocmw7XG5cdFx0XHRcdHZhciBuaXQgPSB0YWJbT2xkQ29kZV0sIG5pbCA9IHRsbltPbGRDb2RlXTtcblx0XHRcdFx0Y29weShjaHIsbml0LGNocixjaHJsLG5pbCk7XG5cdFx0XHRcdGNocltjaHJsK25pbF09Y2hyW2NocmxdOyAgbmlsKys7XG5cdFx0XHRcdHRsblt0b3RsXT1uaWw7ICB0b3RsKys7XG5cblx0XHRcdFx0Y29weShjaHIsY2hybCx0Z3QsdG9mZixuaWwpOyAgdG9mZiArPSBuaWw7XG5cdFx0XHRcdGNocmw9KGNocmwrbmlsKzMpJn4weDAzO1xuXHRcdFx0fVxuXHRcdFx0aWYodG90bCsxPT0oMTw8Yml0cykpIGJpdHMrKztcblx0XHR9XG5cdFx0T2xkQ29kZSA9IENvZGU7XG5cdH1cbn1cblxuVVRJRi5kZWNvZGUuX2NvcHlEYXRhID0gZnVuY3Rpb24ocyxzbyx0LHRvLGwpIHsgIGZvcih2YXIgaT0wO2k8bDtpKz00KSB7ICB0W3RvK2ldPXNbc28raV07ICB0W3RvK2krMV09c1tzbytpKzFdOyAgdFt0bytpKzJdPXNbc28raSsyXTsgIHRbdG8raSszXT1zW3NvK2krM107ICB9ICB9XG5cblVUSUYudGFncyA9IHsyNTQ6XCJOZXdTdWJmaWxlVHlwZVwiLDI1NTpcIlN1YmZpbGVUeXBlXCIsMjU2OlwiSW1hZ2VXaWR0aFwiLDI1NzpcIkltYWdlTGVuZ3RoXCIsMjU4OlwiQml0c1BlclNhbXBsZVwiLDI1OTpcIkNvbXByZXNzaW9uXCIsMjYyOlwiUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvblwiLDI2NjpcIkZpbGxPcmRlclwiLFxuXHRcdFx0MjY5OlwiRG9jdW1lbnROYW1lXCIsMjcwOlwiSW1hZ2VEZXNjcmlwdGlvblwiLDI3MTpcIk1ha2VcIiwyNzI6XCJNb2RlbFwiLDI3MzpcIlN0cmlwT2Zmc2V0XCIsMjc0OlwiT3JpZW50YXRpb25cIiwyNzc6XCJTYW1wbGVzUGVyUGl4ZWxcIiwyNzg6XCJSb3dzUGVyU3RyaXBcIixcblx0XHRcdDI3OTpcIlN0cmlwQnl0ZUNvdW50c1wiLDI4MDpcIk1pblNhbXBsZVZhbHVlXCIsMjgxOlwiTWF4U2FtcGxlVmFsdWVcIiwyODI6XCJYUmVzb2x1dGlvblwiLDI4MzpcIllSZXNvbHV0aW9uXCIsMjg0OlwiUGxhbmFyQ29uZmlndXJhdGlvblwiLDI4NTpcIlBhZ2VOYW1lXCIsXG5cdFx0XHQyODY6XCJYUG9zaXRpb25cIiwyODc6XCJZUG9zaXRpb25cIixcblx0XHRcdDI5MjpcIlQ0T3B0aW9uc1wiLDI5NjpcIlJlc29sdXRpb25Vbml0XCIsMjk3OlwiUGFnZU51bWJlclwiLDMwNTpcIlNvZnR3YXJlXCIsMzA2OlwiRGF0ZVRpbWVcIixcblx0XHRcdDMxNTpcIkFydGlzdFwiLDMxNjpcIkhvc3RDb21wdXRlclwiLDMxNzpcIlByZWRpY3RvclwiLDMxODpcIldoaXRlUG9pbnRcIiwzMTk6XCJQcmltYXJ5Q2hyb21hdGljaXRpZXNcIiwzMjA6XCJDb2xvck1hcFwiLFxuXHRcdFx0MzIxOlwiSGFsZnRvbmVIaW50c1wiLDMyMjpcIlRpbGVXaWR0aFwiLFxuXHRcdFx0MzIzOlwiVGlsZUxlbmd0aFwiLDMyNDpcIlRpbGVPZmZzZXRcIiwzMjU6XCJUaWxlQnl0ZUNvdW50c1wiLDMzMDpcIlN1YklGRHNcIiwzMzY6XCJEb3RSYW5nZVwiLDMzODpcIkV4dHJhU2FtcGxlXCIsMzM5OlwiU2FtcGxlRm9ybWF0XCIsIDM0NzpcIkpQRUdUYWJsZXNcIixcblx0XHRcdDUxMjpcIkpQRUdQcm9jXCIsNTEzOlwiSlBFR0ludGVyY2hhbmdlRm9ybWF0XCIsNTE0OlwiSlBFR0ludGVyY2hhbmdlRm9ybWF0TGVuZ3RoXCIsNTE5OlwiSlBFR1FUYWJsZXNcIiw1MjA6XCJKUEVHRENUYWJsZXNcIiw1MjE6XCJKUEVHQUNUYWJsZXNcIixcblx0XHRcdDUyOTpcIllDYkNyQ29lZmZpY2llbnRzXCIsNTMwOlwiWUNiQ3JTdWJTYW1wbGluZ1wiLDUzMTpcIllDYkNyUG9zaXRpb25pbmdcIiw1MzI6XCJSZWZlcmVuY2VCbGFja1doaXRlXCIsNzAwOlwiWE1QXCIsXG5cdFx0XHQzMzQyMTpcIkNGQVJlcGVhdFBhdHRlcm5EaW1cIiwzMzQyMjpcIkNGQVBhdHRlcm5cIiwzMzQzMjpcIkNvcHlyaWdodFwiLDMzNDM0OlwiRXhwb3N1cmVUaW1lXCIsMzM0Mzc6XCJGTnVtYmVyXCIsMzM3MjM6XCJJUFRDL05BQVwiLDM0Mzc3OlwiUGhvdG9zaG9wXCIsXG5cdFx0XHQzNDY2NTpcIkV4aWZJRkRcIiwzNDY3NTpcIklDQyBQcm9maWxlXCIsMzQ4NTA6XCJFeHBvc3VyZVByb2dyYW1cIiwzNDg1MzpcIkdQU0luZm9cIiwzNDg1NTpcIklTT1NwZWVkUmF0aW5nc1wiLDM0ODU4OlwiVGltZVpvbmVPZmZzZXRcIiwzNDg1OTpcIlNlbGZUaW1lTW9kZVwiLFxuXHRcdFx0MzY4Njc6XCJEYXRlVGltZU9yaWdpbmFsXCIsMzY4Njg6XCJEYXRlVGltZURpZ2l0aXplZFwiLFxuXHRcdFx0MzczNzc6XCJTaHV0dGVyU3BlZWRWYWx1ZVwiLDM3Mzc4OlwiQXBlcnR1cmVWYWx1ZVwiLDM3MzgwOlwiRXhwb3N1cmVCaWFzVmFsdWVcIiwzNzM4MzpcIk1ldGVyaW5nTW9kZVwiLDM3Mzg1OlwiRmxhc2hcIiwzNzM4NjpcIkZvY2FsTGVuZ3RoXCIsXG5cdFx0XHQzNzM5MDpcIkZvY2FsUGxhbmVYUmVzb2x1dGlvblwiLDM3MzkxOlwiRm9jYWxQbGFuZVlSZXNvbHV0aW9uXCIsMzczOTI6XCJGb2NhbFBsYW5lUmVzb2x1dGlvblVuaXRcIiwzNzM5MzpcIkltYWdlTnVtYmVyXCIsMzczOTg6XCJUSUZGL0VQU3RhbmRhcmRJRFwiLDM3Mzk5OlwiU2Vuc2luZ01ldGhvZFwiLFxuXHRcdFx0Mzc1MDA6XCJNYWtlck5vdGVcIiwzNzUxMDpcIlVzZXJDb21tZW50XCIsMzc3MjQ6XCJJbWFnZVNvdXJjZURhdGFcIixcblx0XHRcdDQwMDkyOlwiWFBDb21tZW50XCIsNDAwOTQ6XCJYUEtleXdvcmRzXCIsXG5cdFx0XHQ0MDk2MTpcIkNvbG9yU3BhY2VcIiw0MDk2MjpcIlBpeGVsWERpbWVuc2lvblwiLDQwOTYzOlwiUGl4ZWxYRGltZW5zaW9uXCIsNDE0ODY6XCJGb2NhbFBsYW5lWFJlc29sdXRpb25cIiw0MTQ4NzpcIkZvY2FsUGxhbmVZUmVzb2x1dGlvblwiLDQxNDg4OlwiRm9jYWxQbGFuZVJlc29sdXRpb25Vbml0XCIsXG5cdFx0XHQ0MTk4NTpcIkN1c3RvbVJlbmRlcmVkXCIsNDE5ODY6XCJFeHBvc3VyZU1vZGVcIiw0MTk4NzpcIldoaXRlQmFsYW5jZVwiLDQxOTkwOlwiU2NlbmVDYXB0dXJlVHlwZVwiLFxuXHRcdFx0NTA3MDY6XCJETkdWZXJzaW9uXCIsNTA3MDc6XCJETkdCYWNrd2FyZFZlcnNpb25cIiw1MDcwODpcIlVuaXF1ZUNhbWVyYU1vZGVsXCIsNTA3MDk6XCJMb2NhbGl6ZWRDYW1lcmFNb2RlbFwiLDUwNzEwOlwiQ0ZBUGxhbmVDb2xvclwiLFxuXHRcdFx0NTA3MTE6XCJDRkFMYXlvdXRcIiw1MDcxMjpcIkxpbmVhcml6YXRpb25UYWJsZVwiLDUwNzEzOlwiQmxhY2tMZXZlbFJlcGVhdERpbVwiLDUwNzE0OlwiQmxhY2tMZXZlbFwiLDUwNzE2OlwiQmxhY2tMZXZlbERlbHRhVlwiLDUwNzE3OlwiV2hpdGVMZXZlbFwiLFxuXHRcdFx0NTA3MTg6XCJEZWZhdWx0U2NhbGVcIiw1MDcxOTpcIkRlZmF1bHRDcm9wT3JpZ2luXCIsXG5cdFx0XHQ1MDcyMDpcIkRlZmF1bHRDcm9wU2l6ZVwiLDUwNzMzOlwiQmF5ZXJHcmVlblNwbGl0XCIsNTA3Mzg6XCJBbnRpQWxpYXNTdHJlbmd0aFwiLFxuXHRcdFx0NTA3MjE6XCJDb2xvck1hdHJpeDFcIiw1MDcyMjpcIkNvbG9yTWF0cml4MlwiLDUwNzIzOlwiQ2FtZXJhQ2FsaWJyYXRpb24xXCIsNTA3MjQ6XCJDYW1lcmFDYWxpYnJhdGlvbjJcIiw1MDcyNzpcIkFuYWxvZ0JhbGFuY2VcIiw1MDcyODpcIkFzU2hvdE5ldXRyYWxcIixcblx0XHRcdDUwNzMwOlwiQmFzZWxpbmVFeHBvc3VyZVwiLDUwNzMxOlwiQmFzZWxpbmVOb2lzZVwiLDUwNzMyOlwiQmFzZWxpbmVTaGFycG5lc3NcIiw1MDczNDpcIkxpbmVhclJlc3BvbnNlTGltaXRcIiw1MDczNTpcIkNhbWVyYVNlcmlhbE51bWJlclwiLDUwNzM2OlwiTGVuc0luZm9cIiw1MDczOTpcIlNoYWRvd1NjYWxlXCIsXG5cdFx0XHQ1MDc0MDpcIkROR1ByaXZhdGVEYXRhXCIsNTA3NDE6XCJNYWtlck5vdGVTYWZldHlcIiw1MDc3ODpcIkNhbGlicmF0aW9uSWxsdW1pbmFudDFcIiw1MDc3OTpcIkNhbGlicmF0aW9uSWxsdW1pbmFudDJcIiw1MDc4MDpcIkJlc3RRdWFsaXR5U2NhbGVcIixcblx0XHRcdDUwNzgxOlwiUmF3RGF0YVVuaXF1ZUlEXCIsNTA4Mjc6XCJPcmlnaW5hbFJhd0ZpbGVOYW1lXCIsNTA4Mjk6XCJBY3RpdmVBcmVhXCIsNTA4MzA6XCJNYXNrZWRBcmVhc1wiLDUwOTMxOlwiQ2FtZXJhQ2FsaWJyYXRpb25TaWduYXR1cmVcIiw1MDkzMjpcIlByb2ZpbGVDYWxpYnJhdGlvblNpZ25hdHVyZVwiLFxuXHRcdFx0NTA5MzU6XCJOb2lzZVJlZHVjdGlvbkFwcGxpZWRcIiw1MDkzNjpcIlByb2ZpbGVOYW1lXCIsNTA5Mzc6XCJQcm9maWxlSHVlU2F0TWFwRGltc1wiLDUwOTM4OlwiUHJvZmlsZUh1ZVNhdE1hcERhdGExXCIsNTA5Mzk6XCJQcm9maWxlSHVlU2F0TWFwRGF0YTJcIixcblx0XHRcdDUwOTQwOlwiUHJvZmlsZVRvbmVDdXJ2ZVwiLDUwOTQxOlwiUHJvZmlsZUVtYmVkUG9saWN5XCIsNTA5NDI6XCJQcm9maWxlQ29weXJpZ2h0XCIsXG5cdFx0XHQ1MDk2NDpcIkZvcndhcmRNYXRyaXgxXCIsNTA5NjU6XCJGb3J3YXJkTWF0cml4MlwiLDUwOTY2OlwiUHJldmlld0FwcGxpY2F0aW9uTmFtZVwiLDUwOTY3OlwiUHJldmlld0FwcGxpY2F0aW9uVmVyc2lvblwiLDUwOTY5OlwiUHJldmlld1NldHRpbmdzRGlnZXN0XCIsXG5cdFx0XHQ1MDk3MDpcIlByZXZpZXdDb2xvclNwYWNlXCIsNTA5NzE6XCJQcmV2aWV3RGF0ZVRpbWVcIiw1MDk3MjpcIlJhd0ltYWdlRGlnZXN0XCIsXG5cdFx0XHQ1MTAwODpcIk9wY29kZUxpc3QxXCIsNTEwMDk6XCJPcGNvZGVMaXN0MlwiLDUxMDIyOlwiT3Bjb2RlTGlzdDNcIiw1MTA0MTpcIk5vaXNlUHJvZmlsZVwiLDUxMDg5OlwiT3JpZ2luYWxEZWZhdWx0RmluYWxTaXplXCIsXG5cdFx0XHQ1MTA5MDpcIk9yaWdpbmFsQmVzdFF1YWxpdHlGaW5hbFNpemVcIiw1MTA5MTpcIk9yaWdpbmFsRGVmYXVsdENyb3BTaXplXCIsNTExMjU6XCJEZWZhdWx0VXNlckNyb3BcIn07XG5cblVUSUYudHR5cGVzID0geyAgMjU2OjMsMjU3OjMsMjU4OjMsICAgMjU5OjMsIDI2MjozLCAgMjczOjQsICAyNzQ6MywgMjc3OjMsMjc4OjQsMjc5OjQsIDI4Mjo1LCAyODM6NSwgMjg0OjMsIDI4Njo1LDI4Nzo1LCAyOTY6MywgMzA1OjIsIDMwNjoyLCAzMzg6MywgNTEzOjQsIDUxNDo0LCAzNDY2NTo0ICB9O1xuXG5VVElGLl9yZWFkSUZEID0gZnVuY3Rpb24oYmluLCBkYXRhLCBvZmZzZXQsIGlmZHMpXG57XG5cdHZhciBjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHR2YXIgaWZkID0ge307ICBpZmRzLnB1c2goaWZkKTtcblxuXHQvL2xvZyhcIj4+Pi0tLS0tLS0tLS0tLS0tLS1cIik7XG5cdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKVxuXHR7XG5cdFx0dmFyIHRhZyAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgICBvZmZzZXQrPTI7XG5cdFx0dmFyIHR5cGUgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgICBvZmZzZXQrPTI7XG5cdFx0dmFyIG51bSAgPSBiaW4ucmVhZFVpbnQgIChkYXRhLCBvZmZzZXQpOyAgICBvZmZzZXQrPTQ7XG5cdFx0dmFyIHZvZmYgPSBiaW4ucmVhZFVpbnQgIChkYXRhLCBvZmZzZXQpOyAgICBvZmZzZXQrPTQ7XG5cblx0XHR2YXIgYXJyID0gW107XG5cdFx0aWZkW1widFwiK3RhZ10gPSBhcnI7XG5cdFx0Ly9pZmRbXCJ0XCIrdGFnK1wiLVwiK1VUSUYudGFnc1t0YWddXSA9IGFycjtcblx0XHRpZih0eXBlPT0gMSB8fCB0eXBlPT03KSB7ICBmb3IodmFyIGo9MDsgajxudW07IGorKykgYXJyLnB1c2goZGF0YVsobnVtPDUgPyBvZmZzZXQtNCA6IHZvZmYpK2pdKTsgfVxuXHRcdGlmKHR5cGU9PSAyKSB7ICBhcnIucHVzaCggYmluLnJlYWRBU0NJSShkYXRhLCAobnVtPDUgPyBvZmZzZXQtNCA6IHZvZmYpLCBudW0tMSkgKTsgIH1cblx0XHRpZih0eXBlPT0gMykgeyAgZm9yKHZhciBqPTA7IGo8bnVtOyBqKyspIGFyci5wdXNoKGJpbi5yZWFkVXNob3J0KGRhdGEsIChudW08MyA/IG9mZnNldC00IDogdm9mZikrMipqKSk7ICB9XG5cdFx0aWYodHlwZT09IDQpIHsgIGZvcih2YXIgaj0wOyBqPG51bTsgaisrKSBhcnIucHVzaChiaW4ucmVhZFVpbnQgIChkYXRhLCAobnVtPDIgPyBvZmZzZXQtNCA6IHZvZmYpKzQqaikpOyAgfVxuXHRcdGlmKHR5cGU9PSA1KSB7ICBmb3IodmFyIGo9MDsgajxudW07IGorKykgYXJyLnB1c2goYmluLnJlYWRVaW50ICAoZGF0YSwgdm9mZitqKjgpIC8gYmluLnJlYWRVaW50KGRhdGEsdm9mZitqKjgrNCkpOyAgfVxuXHRcdGlmKHR5cGU9PSA4KSB7ICBmb3IodmFyIGo9MDsgajxudW07IGorKykgYXJyLnB1c2goYmluLnJlYWRTaG9ydCAoZGF0YSwgKG51bTwzID8gb2Zmc2V0LTQgOiB2b2ZmKSsyKmopKTsgIH1cblx0XHRpZih0eXBlPT0gOSkgeyAgZm9yKHZhciBqPTA7IGo8bnVtOyBqKyspIGFyci5wdXNoKGJpbi5yZWFkSW50ICAgKGRhdGEsIChudW08MiA/IG9mZnNldC00IDogdm9mZikrNCpqKSk7ICB9XG5cdFx0aWYodHlwZT09MTApIHsgIGZvcih2YXIgaj0wOyBqPG51bTsgaisrKSBhcnIucHVzaChiaW4ucmVhZEludCAgIChkYXRhLCB2b2ZmK2oqOCkgLyBiaW4ucmVhZEludCAoZGF0YSx2b2ZmK2oqOCs0KSk7ICB9XG5cdFx0aWYodHlwZT09MTEpIHsgIGZvcih2YXIgaj0wOyBqPG51bTsgaisrKSBhcnIucHVzaChiaW4ucmVhZEZsb2F0IChkYXRhLCB2b2ZmK2oqNCkpOyAgfVxuXHRcdGlmKHR5cGU9PTEyKSB7ICBmb3IodmFyIGo9MDsgajxudW07IGorKykgYXJyLnB1c2goYmluLnJlYWREb3VibGUoZGF0YSwgdm9mZitqKjgpKTsgIH1cblx0XHRpZihudW0hPTAgJiYgYXJyLmxlbmd0aD09MCkgbG9nKFwidW5rbm93biBUSUZGIHRhZyB0eXBlOiBcIiwgdHlwZSwgXCJudW06XCIsbnVtKTtcblx0XHQvL2xvZyh0YWcsIHR5cGUsIFVUSUYudGFnc1t0YWddLCBhcnIpO1xuXHRcdGlmKHRhZz09MzMwKSBmb3IodmFyIGo9MDsgajxudW07IGorKykgVVRJRi5fcmVhZElGRChiaW4sIGRhdGEsIGFycltqXSwgaWZkcyk7XG5cdFx0Ly9pZih0YWc9PTM0NjY1KSBVVElGLl9yZWFkSUZEKGJpbiwgZGF0YSwgYXJyWzBdLCBpZmRzKTtcblx0fVxuXHQvL2xvZyhcIjw8PC0tLS0tLS0tLS0tLS0tLVwiKTtcblx0cmV0dXJuIG9mZnNldDtcbn1cblxuVVRJRi5fd3JpdGVJRkQgPSBmdW5jdGlvbihiaW4sIGRhdGEsIG9mZnNldCwgaWZkKVxue1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGlmZCk7XG5cdGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIGtleXMubGVuZ3RoKTsgIG9mZnNldCs9MjtcblxuXHR2YXIgZW9mZiA9IG9mZnNldCArIGtleXMubGVuZ3RoKjEyICsgNDtcblxuXHRmb3IodmFyIGtpPTA7IGtpPGtleXMubGVuZ3RoOyBraSsrKVxuXHR7XG5cdFx0dmFyIGtleSA9IGtleXNba2ldO1xuXHRcdHZhciB0YWcgPSBwYXJzZUludChrZXkuc2xpY2UoMSkpLCB0eXBlID0gVVRJRi50dHlwZXNbdGFnXTsgIGlmKHR5cGU9PW51bGwpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZSBvZiB0YWc6IFwiK3RhZyk7XG5cdFx0dmFyIHZhbCA9IGlmZFtrZXldOyAgaWYodHlwZT09MikgdmFsPXZhbFswXStcIlxcdTAwMDBcIjsgIHZhciBudW0gPSB2YWwubGVuZ3RoO1xuXHRcdGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIHRhZyApOyAgb2Zmc2V0Kz0yO1xuXHRcdGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIHR5cGUpOyAgb2Zmc2V0Kz0yO1xuXHRcdGJpbi53cml0ZVVpbnQgIChkYXRhLCBvZmZzZXQsIG51bSApOyAgb2Zmc2V0Kz00O1xuXG5cdFx0dmFyIGRsZW4gPSBbLTEsIDEsIDEsIDIsIDQsIDgsIDAsIDAsIDAsIDAsIDAsIDAsIDhdW3R5cGVdICogbnVtO1xuXHRcdHZhciB0b2ZmID0gb2Zmc2V0O1xuXHRcdGlmKGRsZW4+NCkgeyAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIGVvZmYpOyAgdG9mZj1lb2ZmOyAgfVxuXG5cdFx0aWYodHlwZT09MikgeyAgYmluLndyaXRlQVNDSUkoZGF0YSwgdG9mZiwgdmFsKTsgICB9XG5cdFx0aWYodHlwZT09MykgeyAgZm9yKHZhciBpPTA7IGk8bnVtOyBpKyspIGJpbi53cml0ZVVzaG9ydChkYXRhLCB0b2ZmKzIqaSwgdmFsW2ldKTsgICAgfVxuXHRcdGlmKHR5cGU9PTQpIHsgIGZvcih2YXIgaT0wOyBpPG51bTsgaSsrKSBiaW4ud3JpdGVVaW50ICAoZGF0YSwgdG9mZis0KmksIHZhbFtpXSk7ICAgIH1cblx0XHRpZih0eXBlPT01KSB7ICBmb3IodmFyIGk9MDsgaTxudW07IGkrKykgeyAgYmluLndyaXRlVWludChkYXRhLCB0b2ZmKzgqaSwgTWF0aC5yb3VuZCh2YWxbaV0qMTAwMDApKTsgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZis4KmkrNCwgMTAwMDApOyAgfSAgIH1cblx0XHRpZiAodHlwZSA9PSAxMikgeyAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykgYmluLndyaXRlRG91YmxlKGRhdGEsIHRvZmYgKyA4ICogaSwgdmFsW2ldKTsgfVxuXG5cdFx0aWYoZGxlbj40KSB7ICBkbGVuICs9IChkbGVuJjEpOyAgZW9mZiArPSBkbGVuOyAgfVxuXHRcdG9mZnNldCArPSA0O1xuXHR9XG5cdHJldHVybiBbb2Zmc2V0LCBlb2ZmXTtcbn1cblxuVVRJRi50b1JHQkE4ID0gZnVuY3Rpb24ob3V0KVxue1xuXHR2YXIgdyA9IG91dC53aWR0aCwgaCA9IG91dC5oZWlnaHQsIGFyZWEgPSB3KmgsIHFhcmVhID0gYXJlYSo0LCBkYXRhID0gb3V0LmRhdGE7XG5cdHZhciBpbWcgPSBuZXcgVWludDhBcnJheShhcmVhKjQpO1xuXHQvLyAwOiBXaGl0ZUlzWmVybywgMTogQmxhY2tJc1plcm8sIDI6IFJHQiwgMzogUGFsZXR0ZSBjb2xvciwgNDogVHJhbnNwYXJlbmN5IG1hc2ssIDU6IENNWUtcblx0dmFyIGludHAgPSBvdXRbXCJ0MjYyXCJdWzBdLCBicHMgPSAob3V0W1widDI1OFwiXT9NYXRoLm1pbigzMixvdXRbXCJ0MjU4XCJdWzBdKToxKSwgaXNMRSA9IG91dC5pc0xFID8gMSA6IDA7XG5cdC8vbG9nKFwiaW50ZXJwcmV0YXRpb246IFwiLCBpbnRwLCBcImJwc1wiLCBicHMsIG91dCk7XG5cdGlmKGZhbHNlKSB7fVxuXHRlbHNlIGlmKGludHA9PTApXG5cdHtcblx0XHR2YXIgYnBsID0gTWF0aC5jZWlsKGJwcyp3LzgpO1xuXHRcdGZvcih2YXIgeT0wOyB5PGg7IHkrKykge1xuXHRcdFx0dmFyIG9mZiA9IHkqYnBsLCBpbyA9IHkqdztcblx0XHRcdGlmKGJwcz09IDEpIGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyAgdmFyIHFpPShpbytpKTw8MiwgcHg9KChkYXRhW29mZisoaT4+MyldKT4+KDctICAoaSY3KSkpJiAxOyAgaW1nW3FpXT1pbWdbcWkrMV09aW1nW3FpKzJdPSggMS1weCkqMjU1OyAgaW1nW3FpKzNdPTI1NTsgICAgfVxuXHRcdFx0aWYoYnBzPT0gNCkgZm9yKHZhciBpPTA7IGk8dzsgaSsrKSB7ICB2YXIgcWk9KGlvK2kpPDwyLCBweD0oKGRhdGFbb2ZmKyhpPj4xKV0pPj4oNC00KihpJjEpKSkmMTU7ICBpbWdbcWldPWltZ1txaSsxXT1pbWdbcWkrMl09KDE1LXB4KSogMTc7ICBpbWdbcWkrM109MjU1OyAgICB9XG5cdFx0XHRpZihicHM9PSA4KSBmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgIHZhciBxaT0oaW8raSk8PDIsIHB4PWRhdGFbb2ZmK2ldOyAgaW1nW3FpXT1pbWdbcWkrMV09aW1nW3FpKzJdPTI1NS1weDsgIGltZ1txaSszXT0yNTU7ICAgIH1cblx0XHR9XG5cdH1cblx0ZWxzZSBpZihpbnRwPT0xKVxuXHR7XG5cdFx0dmFyIGJwbCA9IE1hdGguY2VpbChicHMqdy84KTtcblx0XHRmb3IodmFyIHk9MDsgeTxoOyB5KyspIHtcblx0XHRcdHZhciBvZmYgPSB5KmJwbCwgaW8gPSB5Knc7XG5cdFx0XHRpZihicHM9PSAxKSBmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgIHZhciBxaT0oaW8raSk8PDIsIHB4PSgoZGF0YVtvZmYrKGk+PjMpXSk+Pig3LSAgKGkmNykpKSYxOyAgIGltZ1txaV09aW1nW3FpKzFdPWltZ1txaSsyXT0ocHgpKjI1NTsgIGltZ1txaSszXT0yNTU7ICAgIH1cblx0XHRcdGlmKGJwcz09IDIpIGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyAgdmFyIHFpPShpbytpKTw8MiwgcHg9KChkYXRhW29mZisoaT4+MildKT4+KDYtMiooaSYzKSkpJjM7ICAgaW1nW3FpXT1pbWdbcWkrMV09aW1nW3FpKzJdPShweCkqIDg1OyAgaW1nW3FpKzNdPTI1NTsgICAgfVxuXHRcdFx0aWYoYnBzPT0gOCkgZm9yKHZhciBpPTA7IGk8dzsgaSsrKSB7ICB2YXIgcWk9KGlvK2kpPDwyLCBweD1kYXRhW29mZitpXTsgIGltZ1txaV09aW1nW3FpKzFdPWltZ1txaSsyXT0gICAgcHg7ICBpbWdbcWkrM109MjU1OyAgICB9XG5cdFx0XHRpZihicHM9PTE2KSBmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgIHZhciBxaT0oaW8raSk8PDIsIHB4PWRhdGFbb2ZmKygyKmkraXNMRSldOyAgaW1nW3FpXT1pbWdbcWkrMV09aW1nW3FpKzJdPSBNYXRoLm1pbigyNTUscHgpOyAgaW1nW3FpKzNdPTI1NTsgICAgfSAvLyBsYWRvZ2EudGlmXG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYoaW50cD09Milcblx0e1xuXHRcdGlmKGJwcz09IDgpIC8vIHRoaXMgbmVlZHMgdG8gYmUgc2ltcGxpZmllZCAuLi4gaG93IG1hbnkgY2hhbm5lbHMgYXJlIHRoZXJlPz8/XG5cdFx0e1xuXHRcdFx0aWYob3V0W1widDMzOFwiXSlcblx0XHRcdHtcblx0XHRcdFx0IGlmKG91dFtcInQzMzhcIl1bMF0+MCkgZm9yKHZhciBpPTA7IGk8cWFyZWE7IGkrKykgaW1nW2ldID0gZGF0YVtpXTtcdC8vIHNvbWV0aW1lcyB0MzM4IGlzIDEgb3IgMiBpbiBjYXNlIG9mIEFscGhhXG5cdFx0XHRcdCBlbHNlICBmb3IodmFyIGk9MDsgaTxxYXJlYTsgaSs9NCkgeyAgaW1nW2ldID0gZGF0YVtpXTsgIGltZ1tpKzFdID0gZGF0YVtpKzFdOyAgaW1nW2krMl0gPSBkYXRhW2krMl07ICBpbWdbaSszXSA9IDI1NTsgIH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dmFyIHNtcGxzID0gb3V0W1widDI1OFwiXT9vdXRbXCJ0MjU4XCJdLmxlbmd0aCA6IDM7XG5cdFx0XHRcdGlmKHNtcGxzPT00KSBmb3IodmFyIGk9MDsgaTxxYXJlYTsgaSsrKSBpbWdbaV0gPSBkYXRhW2ldO1xuXHRcdFx0XHRpZihzbXBscz09MykgZm9yKHZhciBpPTA7IGk8IGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIHRpPWkqMzsgIGltZ1txaV09ZGF0YVt0aV07ICBpbWdbcWkrMV09ZGF0YVt0aSsxXTsgIGltZ1txaSsyXT1kYXRhW3RpKzJdOyAgaW1nW3FpKzNdPTI1NTsgICAgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlICAvLyAzeCAxNi1iaXQgY2hhbm5lbFxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgcWk9aTw8MiwgdGk9aSo2OyAgaW1nW3FpXT1kYXRhW3RpXTsgIGltZ1txaSsxXT1kYXRhW3RpKzJdOyAgaW1nW3FpKzJdPWRhdGFbdGkrNF07ICBpbWdbcWkrM109MjU1OyAgICB9XG5cdH1cblx0ZWxzZSBpZihpbnRwPT0zKVxuXHR7XG5cdFx0dmFyIG1hcCA9IG91dFtcInQzMjBcIl07XG5cdFx0Zm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgcWk9aTw8MiwgbWk9ZGF0YVtpXTsgIGltZ1txaV09KG1hcFttaV0+PjgpOyAgaW1nW3FpKzFdPShtYXBbMjU2K21pXT4+OCk7ICBpbWdbcWkrMl09KG1hcFs1MTIrbWldPj44KTsgIGltZ1txaSszXT0yNTU7ICAgIH1cblx0fVxuXHRlbHNlIGlmKGludHA9PTUpIFxuXHR7XG5cdFx0dmFyIHNtcGxzID0gb3V0W1widDI1OFwiXT9vdXRbXCJ0MjU4XCJdLmxlbmd0aCA6IDQ7XG5cdFx0dmFyIGdvdEFscGhhID0gc21wbHM+NCA/IDEgOiAwO1xuXHRcdGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykge1xuXHRcdFx0dmFyIHFpPWk8PDIsIHNpPWkqc21wbHM7ICB2YXIgQz0yNTUtZGF0YVtzaV0sIE09MjU1LWRhdGFbc2krMV0sIFk9MjU1LWRhdGFbc2krMl0sIEs9KDI1NS1kYXRhW3NpKzNdKSooMS8yNTUpO1xuXHRcdFx0aW1nW3FpXT1+fihDKksrMC41KTsgIGltZ1txaSsxXT1+fihNKksrMC41KTsgIGltZ1txaSsyXT1+fihZKksrMC41KTsgIGltZ1txaSszXT0yNTUqKDEtZ290QWxwaGEpK2RhdGFbc2krNF0qZ290QWxwaGE7XG5cdFx0fVxuXHR9XG5cdGVsc2UgbG9nKFwiVW5rbm93biBQaG90b21ldHJpYyBpbnRlcnByZXRhdGlvbjogXCIraW50cCk7XG5cdHJldHVybiBpbWc7XG59XG5cblVUSUYucmVwbGFjZUlNRyA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGltZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImltZ1wiKTtcblx0Zm9yICh2YXIgaT0wOyBpPGltZ3MubGVuZ3RoOyBpKyspXG5cdHtcblx0XHR2YXIgaW1nPWltZ3NbaV0sIHNyYz1pbWcuZ2V0QXR0cmlidXRlKFwic3JjXCIpOyAgaWYoc3JjPT1udWxsKSBjb250aW51ZTtcblx0XHR2YXIgc3VmZj1zcmMuc3BsaXQoXCIuXCIpLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYoc3VmZiE9XCJ0aWZcIiAmJiBzdWZmIT1cInRpZmZcIikgY29udGludWU7XG5cdFx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOyAgVVRJRi5feGhycy5wdXNoKHhocik7ICBVVElGLl9pbWdzLnB1c2goaW1nKTtcblx0XHR4aHIub3BlbihcIkdFVFwiLCBzcmMpOyAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblx0XHR4aHIub25sb2FkID0gVVRJRi5faW1nTG9hZGVkOyAgIHhoci5zZW5kKCk7XG5cdH1cbn1cblxuVVRJRi5feGhycyA9IFtdOyAgVVRJRi5faW1ncyA9IFtdO1xuVVRJRi5faW1nTG9hZGVkID0gZnVuY3Rpb24oZSlcbntcblx0dmFyIGJ1ZmYgPSBlLnRhcmdldC5yZXNwb25zZTtcblx0dmFyIGlmZHMgPSBVVElGLmRlY29kZShidWZmKSwgcGFnZSA9IGlmZHNbMF07ICBVVElGLmRlY29kZUltYWdlcyhidWZmLCBpZmRzKTtcblx0dmFyIHJnYmEgPSBVVElGLnRvUkdCQTgocGFnZSksIHc9cGFnZS53aWR0aCwgaD1wYWdlLmhlaWdodDtcblx0dmFyIGluZCA9IFVUSUYuX3hocnMuaW5kZXhPZihlLnRhcmdldCksIGltZyA9IFVUSUYuX2ltZ3NbaW5kXTtcblx0VVRJRi5feGhycy5zcGxpY2UoaW5kLDEpOyAgVVRJRi5faW1ncy5zcGxpY2UoaW5kLDEpO1xuXHR2YXIgY252ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTsgIGNudi53aWR0aD13OyAgY252LmhlaWdodD1oO1xuXHR2YXIgY3R4ID0gY252LmdldENvbnRleHQoXCIyZFwiKSwgaW1nZCA9IGN0eC5jcmVhdGVJbWFnZURhdGEodyxoKTtcblx0Zm9yKHZhciBpPTA7IGk8cmdiYS5sZW5ndGg7IGkrKykgaW1nZC5kYXRhW2ldPXJnYmFbaV07ICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nZCwwLDApO1xuXHR2YXIgYXR0ciA9IFtcInN0eWxlXCIsXCJjbGFzc1wiLFwiaWRcIl07XG5cdGZvcih2YXIgaT0wOyBpPGF0dHIubGVuZ3RoOyBpKyspIGNudi5zZXRBdHRyaWJ1dGUoYXR0cltpXSwgaW1nLmdldEF0dHJpYnV0ZShhdHRyW2ldKSk7XG5cdGltZy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbnYsaW1nKTtcbn1cblxuXG5VVElGLl9iaW5CRSA9XG57XG5cdG5leHRaZXJvICAgOiBmdW5jdGlvbihkYXRhLCBvKSB7ICB3aGlsZShkYXRhW29dIT0wKSBvKys7ICByZXR1cm4gbzsgIH0sXG5cdHJlYWRVc2hvcnQgOiBmdW5jdGlvbihidWZmLCBwKSB7ICByZXR1cm4gKGJ1ZmZbcF08PCA4KSB8ICBidWZmW3ArMV07ICB9LFxuXHRyZWFkU2hvcnQgIDogZnVuY3Rpb24oYnVmZiwgcCkgeyAgdmFyIGE9VVRJRi5fYmluQkUudWk4OyAgYVswXT1idWZmW3ArMV07ICBhWzFdPWJ1ZmZbcCswXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVVRJRi5fYmluQkUuIGkxNlswXTsgIH0sXG5cdHJlYWRJbnQgICAgOiBmdW5jdGlvbihidWZmLCBwKSB7ICB2YXIgYT1VVElGLl9iaW5CRS51aTg7ICBhWzBdPWJ1ZmZbcCszXTsgIGFbMV09YnVmZltwKzJdOyAgYVsyXT1idWZmW3ArMV07ICBhWzNdPWJ1ZmZbcCswXTsgIHJldHVybiBVVElGLl9iaW5CRS4gaTMyWzBdOyAgfSxcblx0cmVhZFVpbnQgICA6IGZ1bmN0aW9uKGJ1ZmYsIHApIHsgIHZhciBhPVVUSUYuX2JpbkJFLnVpODsgIGFbMF09YnVmZltwKzNdOyAgYVsxXT1idWZmW3ArMl07ICBhWzJdPWJ1ZmZbcCsxXTsgIGFbM109YnVmZltwKzBdOyAgcmV0dXJuIFVUSUYuX2JpbkJFLnVpMzJbMF07ICB9LFxuXHRyZWFkQVNDSUkgIDogZnVuY3Rpb24oYnVmZiwgcCwgbCkgeyAgdmFyIHMgPSBcIlwiOyAgIGZvcih2YXIgaT0wOyBpPGw7IGkrKykgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZbcCtpXSk7ICAgcmV0dXJuIHM7IH0sXG5cdHJlYWRGbG9hdCAgOiBmdW5jdGlvbihidWZmLCBwKSB7ICB2YXIgYT1VVElGLl9iaW5CRS51aTg7ICBmb3IodmFyIGk9MDtpPDQ7aSsrKSBhW2ldPWJ1ZmZbcCszLWldOyAgcmV0dXJuIFVUSUYuX2JpbkJFLmZsMzJbMF07ICB9LFxuXHRyZWFkRG91YmxlIDogZnVuY3Rpb24oYnVmZiwgcCkgeyAgdmFyIGE9VVRJRi5fYmluQkUudWk4OyAgZm9yKHZhciBpPTA7aTw4O2krKykgYVtpXT1idWZmW3ArNy1pXTsgIHJldHVybiBVVElGLl9iaW5CRS5mbDY0WzBdOyAgfSxcblxuXHR3cml0ZVVzaG9ydDogZnVuY3Rpb24oYnVmZiwgcCwgbikgeyAgYnVmZltwXSA9IChuPj4gOCkmMjU1OyAgYnVmZltwKzFdID0gIG4mMjU1OyAgfSxcblx0d3JpdGVVaW50ICA6IGZ1bmN0aW9uKGJ1ZmYsIHAsIG4pIHsgIGJ1ZmZbcF0gPSAobj4+MjQpJjI1NTsgIGJ1ZmZbcCsxXSA9IChuPj4xNikmMjU1OyAgYnVmZltwKzJdID0gKG4+PjgpJjI1NTsgIGJ1ZmZbcCszXSA9IChuPj4wKSYyNTU7ICB9LFxuXHR3cml0ZUFTQ0lJIDogZnVuY3Rpb24oYnVmZiwgcCwgcykgeyAgZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspICBidWZmW3AraV0gPSBzLmNoYXJDb2RlQXQoaSk7ICB9LFxuXHR3cml0ZURvdWJsZTogZnVuY3Rpb24oYnVmZiwgcCwgbilcblx0e1xuXHRcdFVUSUYuX2JpbkJFLmZsNjRbMF0gPSBuO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBidWZmW3AgKyBpXSA9IFVUSUYuX2JpbkJFLnVpOFs3IC0gaV07XG5cdH1cbn1cblVUSUYuX2JpbkJFLnVpOCAgPSBuZXcgVWludDhBcnJheSAgKDgpO1xuVVRJRi5fYmluQkUuaTE2ICA9IG5ldyBJbnQxNkFycmF5ICAoVVRJRi5fYmluQkUudWk4LmJ1ZmZlcik7XG5VVElGLl9iaW5CRS5pMzIgID0gbmV3IEludDMyQXJyYXkgIChVVElGLl9iaW5CRS51aTguYnVmZmVyKTtcblVUSUYuX2JpbkJFLnVpMzIgPSBuZXcgVWludDMyQXJyYXkgKFVUSUYuX2JpbkJFLnVpOC5idWZmZXIpO1xuVVRJRi5fYmluQkUuZmwzMiA9IG5ldyBGbG9hdDMyQXJyYXkoVVRJRi5fYmluQkUudWk4LmJ1ZmZlcik7XG5VVElGLl9iaW5CRS5mbDY0ID0gbmV3IEZsb2F0NjRBcnJheShVVElGLl9iaW5CRS51aTguYnVmZmVyKTtcblxuVVRJRi5fYmluTEUgPVxue1xuXHRuZXh0WmVybyAgIDogVVRJRi5fYmluQkUubmV4dFplcm8sXG5cdHJlYWRVc2hvcnQgOiBmdW5jdGlvbihidWZmLCBwKSB7ICByZXR1cm4gKGJ1ZmZbcCsxXTw8IDgpIHwgIGJ1ZmZbcF07ICB9LFxuXHRyZWFkU2hvcnQgIDogZnVuY3Rpb24oYnVmZiwgcCkgeyAgdmFyIGE9VVRJRi5fYmluQkUudWk4OyAgYVswXT1idWZmW3ArMF07ICBhWzFdPWJ1ZmZbcCsxXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVVRJRi5fYmluQkUuIGkxNlswXTsgIH0sXG5cdHJlYWRJbnQgICAgOiBmdW5jdGlvbihidWZmLCBwKSB7ICB2YXIgYT1VVElGLl9iaW5CRS51aTg7ICBhWzBdPWJ1ZmZbcCswXTsgIGFbMV09YnVmZltwKzFdOyAgYVsyXT1idWZmW3ArMl07ICBhWzNdPWJ1ZmZbcCszXTsgIHJldHVybiBVVElGLl9iaW5CRS4gaTMyWzBdOyAgfSxcblx0cmVhZFVpbnQgICA6IGZ1bmN0aW9uKGJ1ZmYsIHApIHsgIHZhciBhPVVUSUYuX2JpbkJFLnVpODsgIGFbMF09YnVmZltwKzBdOyAgYVsxXT1idWZmW3ArMV07ICBhWzJdPWJ1ZmZbcCsyXTsgIGFbM109YnVmZltwKzNdOyAgcmV0dXJuIFVUSUYuX2JpbkJFLnVpMzJbMF07ICB9LFxuXHRyZWFkQVNDSUkgIDogVVRJRi5fYmluQkUucmVhZEFTQ0lJLFxuXHRyZWFkRmxvYXQgIDogZnVuY3Rpb24oYnVmZiwgcCkgeyAgdmFyIGE9VVRJRi5fYmluQkUudWk4OyAgZm9yKHZhciBpPTA7aTw0O2krKykgYVtpXT1idWZmW3ArICBpXTsgIHJldHVybiBVVElGLl9iaW5CRS5mbDMyWzBdOyAgfSxcblx0cmVhZERvdWJsZSA6IGZ1bmN0aW9uKGJ1ZmYsIHApIHsgIHZhciBhPVVUSUYuX2JpbkJFLnVpODsgIGZvcih2YXIgaT0wO2k8ODtpKyspIGFbaV09YnVmZltwKyAgaV07ICByZXR1cm4gVVRJRi5fYmluQkUuZmw2NFswXTsgIH1cbn1cblVUSUYuX2NvcHlUaWxlID0gZnVuY3Rpb24odGIsIHR3LCB0aCwgYiwgdywgaCwgeG9mZiwgeW9mZilcbntcblx0Ly9sb2coXCJjb3B5VGlsZVwiLCB0dywgdGgsICB3LCBoLCB4b2ZmLCB5b2ZmKTtcblx0dmFyIHhsaW0gPSBNYXRoLm1pbih0dywgdy14b2ZmKTtcblx0dmFyIHlsaW0gPSBNYXRoLm1pbih0aCwgaC15b2ZmKTtcblx0Zm9yKHZhciB5PTA7IHk8eWxpbTsgeSsrKVxuXHR7XG5cdFx0dmFyIHRvZiA9ICh5b2ZmK3kpKncreG9mZjtcblx0XHR2YXIgc29mID0geSp0dztcblx0XHRmb3IodmFyIHg9MDsgeDx4bGltOyB4KyspIGJbdG9mK3hdID0gdGJbc29mK3hdO1xuXHR9XG59XG5cblxufSkoVVRJRiwgcGFrbyk7XG59KSgpOyIsImltcG9ydCBleHByZXNzIGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnZXhwcmVzcy1zZXNzaW9uJztcbmNvbnN0IFBPUlQgPSBwcm9jZXNzLmVudi5QT1JUIHx8IDc3Nzc7XG5pbXBvcnQgYm9keVBhcnNlciBmcm9tICdib2R5LXBhcnNlcic7XG5cbmltcG9ydCBtb2RlbHMgZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuL3JvdXRlcyc7XG5pbXBvcnQgeyBleGFtcGxlQ29tcHV0YXRpb24gfSBmcm9tICcuL2hlbHBlcnMnO1xuXG4vLyBtaWRkbGV3YXJlIC0gYmVmb3JlIHlvdSBldmVuIGhpdCB0aGUgcm91dGVzIGl0IHdpbGwgcnVuIHRoZXNlIGZpcnN0XG5cbi8vIGV4cHJlc3MuanNvbigpO1xuLy8gZXhwcmVzcy51cmxlbmNvZGVkKHsgZXh0ZW5kZWQ6IGZhbHNlIH0pO1xuXG5jb25zdCBhcHAgPSBleHByZXNzKCk7XG5cbmFwcC51c2UoYm9keVBhcnNlci5qc29uKCkpO1xuYXBwLnVzZShib2R5UGFyc2VyLnVybGVuY29kZWQoe1xuICAgIGV4dGVuZGVkOiB0cnVlXG4gIH0pKTtcblxuLy8gcGFzcyB2YXJpYWJsZXMgdGhyb3VnaCBvdXIgYXBwbGljYXRpb24gdGhyb3VnaCB0aGlzIG1pZGRsZXdhcmUgdG8gYWxsIHJlcXVlc3RzXG5hcHAudXNlKChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAvLyBpbiBoZWxwZXJzIGNhbiBldmVuIGRvIHNvbWV0aGluZyBsaWtlIGV4cG9ydHMubW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7IHRoZW4geW91IGNhbiB1c2UgaXQgbGlrZSBoZWxwZXJzLm1vbWVudCgpXG4gIHJlcy5sb2NhbHMudmFyRXZlcnlUaGluZ05lZWRzID0gJ3JlcXVpcmVkIGZ1bmN0aW9uIG9yIGNvbXB1dGF0aW9uIG9yIGV2ZW4gc3RyaW5nJztcbiAgcmVzLmxvY2Fscy5oZWxwZXJzID0gZXhhbXBsZUNvbXB1dGF0aW9uO1xuICByZXMubG9jYWxzLmhlbHBlcnNSdW4gPSBleGFtcGxlQ29tcHV0YXRpb24oJ2Jyb3duJyk7XG4gIC8vIHdpbGwgbm90IGdvIHRvIHRoZSBuZXh0IGN1c3RvbSBtaWRkbGV3YXJlIHdpdGhvdXQgbmV4dFxuICBuZXh0KCk7XG59KTtcblxuLy9zZXR0aW5nIG1pZGRsZXdhcmVcbi8vIHNlcnZpbmcgc3RhdGljIGZpbGVzIG91dCBvZiB0aGUgc3JjIGZvbGRlclxuYXBwLnVzZShleHByZXNzLnN0YXRpYyhgJHtfX2Rpcm5hbWV9Ly4uL2Rpc3RgKSk7IC8vU2VydmVzIHJlc291cmNlcyBmcm9tIHB1YmxpYyBmb2xkZXJcbi8vIHNldHMgdXAgcm91dGluZ1xuYXBwLnVzZShyb3V0ZXIpO1xuXG4vLyBwYXNzcG9ydCBzdHJhdCBBZnRlciByb3V0aW5nXG5pbXBvcnQgJy4vY29uZmlnL3Bhc3Nwb3J0JztcblxuYXBwLnVzZShzZXNzaW9uKHtcbiAgICBzZWNyZXQ6ICdwYXNzcG9ydC10dXRvcmlhbCcsXG4gICAgY29va2llOiB7XG4gICAgICAgIG1heEFnZTogNjAwMDBcbiAgICB9LFxuICAgIHJlc2F2ZTogZmFsc2UsXG4gICAgc2F2ZVVuaW5pdGlhbGl6ZWQ6IGZhbHNlXG59KSk7XG5cbm1vZGVscy5zZXF1ZWxpemUuc3luYyh7IGZvcmNlOiBmYWxzZSB9KS50aGVuKCgpID0+IHtcbiAgICBhcHAubGlzdGVuKFBPUlQsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflKUgb24gcG9ydCAke1BPUlR9YCk7XG4gICAgfSk7XG59KTtcblxuY29uc3QgdGhpbmcgPSByZXF1aXJlKCcuL2NvbmZpZy9wYXNzcG9ydCcpO1xuXG4vLyBtb2RlbHMuc2VxdWVsaXplLnN5bmMoeyBmb3JjZTogZmFsc2UgfSlcbi8vICAgICAudGhlbigoKSA9PiByZXF1aXJlKCcuL2NvbmZpZy9wYXNzcG9ydCcpKVxuLy8gICAgIC50aGVuKCgpID0+IHtcbi8vICAgICAgICAgY29uc3Qgc2VydmVyID0gYXBwLmxpc3RlbihQT1JULCAoKSA9PiB7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UpSBvbiBwb3J0ICR7UE9SVH1gKTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgfSlcbi8vICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKCdmdWNrYXJ5JywgZXJyKSk7XG4iLCJpbXBvcnQgU2VxdWVsaXplIGZyb20gJ3NlcXVlbGl6ZSc7XG5pbXBvcnQgcGFzc3BvcnQgZnJvbSAncGFzc3BvcnQnO1xuaW1wb3J0IExvY2FsU3RyYXRlZ3kgZnJvbSAncGFzc3BvcnQtbG9jYWwnO1xuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xuY29uc3QgY29uZmlnID0gcmVxdWlyZShfX2Rpcm5hbWUgKyAnLy4uL2NvbmZpZy9jb25maWcuanNvbicpW2Vudl07XG5cbi8vIGNvbnN0IHsgZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VxdWVsaXplQ29uZmlnIH0gPSBjb25maWc7XG4vLyBjb25zdCBzZXF1ZWxpemUgPSBuZXcgU2VxdWVsaXplKGRhdGFiYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQsIHNlcXVlbGl6ZUNvbmZpZyk7XG5pbXBvcnQgVXNlcnMgZnJvbSAnLi4vbW9kZWxzL3VzZXInO1xuXG4vLyBjb25zb2xlLmxvZygn8J+NjiBVc2VyJywgVXNlcnMpO1xuLy8gY29uc29sZS5sb2coJ/CfjY4gc2VxdWVsaXplJywgc2VxdWVsaXplKTtcbi8vIGNvbnNvbGUubG9nKCfwn42PJywgU2VxdWVsaXplLm1vZGVsKTtcblxuLy8gY29uc3QgVXNlcnMgPSBzZXF1ZWxpemUubW9kZWwoJ1VzZXInKTtcblxucGFzc3BvcnQudXNlKG5ldyBMb2NhbFN0cmF0ZWd5KHtcbiAgdXNlcm5hbWVGaWVsZDogJ3VzZXJbZW1haWxdJyxcbiAgcGFzc3dvcmRGaWVsZDogJ3VzZXJbcGFzc3dvcmRdJ1xufSwgKGVtYWlsLCBwYXNzd29yZCwgZG9uZSkgPT4ge1xuICBVc2Vycy5maW5kT25lKHsgZW1haWwgfSlcbiAgICAudGhlbih1c2VyID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCd1c2VyIC0tPicsIHVzZXIpXG4gICAgICBpZiAoIXVzZXIgfHwgIXVzZXIudmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCkpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgZmFsc2UsIHsgZXJyb3JzOiB7J2VtYWlsIG9yIHBhc3N3b3JkJzogJ2lzIGludmFsaWQnfSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb25lKG51bGwsIHVzZXIpO1xuICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZygn4p2MIHBhc3Nwb3J0IGZhaWxlZCcpKTtcbn0pKTtcblxuY29uc29sZS5sb2coJ+KaviBwYXNzcG9ydCBoaXQnKTtcblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXNzcG9ydCwgdXNlcikge1xuXG4vLyAgIHZhciBVc2VyID0gdXNlcjtcbi8vICAgY29uc29sZS5sb2coJ3VzZXInLCB1c2VyKVxuLy8gICB2YXIgTG9jYWxTdHJhdGVneSA9IHJlcXVpcmUoJ3Bhc3Nwb3J0LWxvY2FsJykuU3RyYXRlZ3k7XG5cbi8vIHBhc3Nwb3J0LnVzZShuZXcgTG9jYWxTdHJhdGVneSh7XG4vLyAgIHVzZXJuYW1lRmllbGQ6ICd1c2VyW2VtYWlsXScsXG4vLyAgIHBhc3N3b3JkRmllbGQ6ICd1c2VyW3Bhc3N3b3JkXSdcbi8vIH0sIChlbWFpbCwgcGFzc3dvcmQsIGRvbmUpID0+IHtcbi8vICAgVXNlcnMuZmluZE9uZSh7IGVtYWlsIH0pXG4vLyAgICAgLnRoZW4odXNlciA9PiB7XG4vLyAgICAgICBpZiAoIXVzZXIgfHwgIXVzZXIudmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCkpIHtcbi8vICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgZmFsc2UsIHsgZXJyb3JzOiB7ICdlbWFpbCBvciBwYXNzd29yZCc6ICdpcyBpbnZhbGlkJ30gfSk7XG4vLyAgICAgICB9XG5cbi8vICAgICAgIHJldHVybiBkb25lKG51bGwsIHVzZXIpO1xuLy8gICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZygn4p2MIHBhc3Nwb3J0IGZhaWxlZCcpKTtcbi8vIH0pKTtcblxuLy8gfVxuIiwiLy8gZXhwb3J0cyBpcyBsaWtlIGEgZ2xvYmFsIHZhcmliYWJsZSBhbnkgYW55dGhpbmcgb24gZXhwb3J0cyB3aWxsIGJlIGltcG9ydGFibGUgaW4gYW5vdGhlciBmaWxlXG5cbmV4cG9ydCBjb25zdCBob21lcGFnZUV4YW1wbGUgPSAocmVxLCByZXMpID0+IHJlcy5zZW5kKCd3b3JraW5ndG9ueicpO1xuXG5leHBvcnQgY29uc3QgbG9nVGhlTmFtZSA9IChyZXEsIHJlcykgPT4ge1xuICBjb25zdCByZXZlcnNlZE5hbWUgPSBbLi4ucmVxLnBhcmFtcy5wYXJhbU5hbWVdLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgcmVzLnNlbmQocmV2ZXJzZWROYW1lKTtcbn07XG4iLCIvLyBtaWRkbGV3YXJlIHJ1bnMgYWZ0ZXIgcmVxdWVzdCBidXQgYmVmb3JlIHRoZSByZXNwb25zZVxuaW1wb3J0IGp3dCBmcm9tICdleHByZXNzLWp3dCc7XG5cbmNvbnN0IGdldFRva2Vuc0Zyb21IZWFkZXJzID0gcmVxID0+IHtcbiAgY29uc29sZS5sb2coJ/CfkrB0b2tlbiBmdW5jIHJhbicsIHJlcS5ib2R5KVxuICBjb25zdCB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbiB9IH0gPSByZXE7XG5cbiAgaWYgKGF1dGhvcml6YXRpb24gJiYgYXV0aG9yaXphdGlvbi5zcGxpdCgnICcpWzBdID09PSAnVG9rZW4nKSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb24uc3BsaXQoJyAnKVsxXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IGF1dGggPSB7XG4gIHJlcXVpcmVkOiBqd3Qoe1xuICAgIHNlY3JldDogJ3NlY3JldCcsXG4gICAgdXNlclByb3BlcnR5OiAncGF5bG9hZCcsXG4gICAgZ2V0VG9rZW46IGdldFRva2Vuc0Zyb21IZWFkZXJzXG4gIH0pLFxuICBvcHRpb25hbDogand0KHtcbiAgICBzZWNyZXQ6ICdzZWNyZXQnLFxuICAgIHVzZXJQcm9wZXJ0eTogJ3BheWxvYWQnLFxuICAgIGdldFRva2VuOiBnZXRUb2tlbnNGcm9tSGVhZGVycyxcbiAgICBjcmVkZW50aWFsc1JlcXVpcmVkOiBmYWxzZVxuICB9KVxufTtcblxuZXhwb3J0IGNvbnN0IG15TWlkZGxld2FyZSA9IChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICByZXEud29ya1RvRG8gPSAnYic7XG4gIGNvbnNvbGUubG9nKCfwn5C2IGJpaGhoaGgnKTtcbiAgbmV4dCgpO1xufVxuIiwiaW1wb3J0IHsgT3AgfSBmcm9tICdzZXF1ZWxpemUnO1xuLy8gaW1wb3J0IFNlcXVlbGl6ZSBmcm9tICdzZXF1ZWxpemUnO1xuaW1wb3J0IHBhc3Nwb3J0IGZyb20gJ3Bhc3Nwb3J0JztcbmltcG9ydCBNb2RlbHMgZnJvbSAnLi4vbW9kZWxzJ1xuXG5jb25zdCB7IFVzZXIgfSA9IE1vZGVscztcblxuZXhwb3J0IGNvbnN0IG5ld01vZGVsID0gKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gIGNvbnN0IHsgYm9keTogeyB1c2VyIH0gfSA9IHJlcTsgLy8gYnJvd3NlciB2ZXJzaW9uXG5cbiAgLy8gY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQgfSA9IHJlcS5ib2R5OyAvLyBwb3N0bWFuXG4gIC8vIGNvbnN0IHVzZXIgPSB7IGVtYWlsOiBlbWFpbCwgcGFzc3dvcmQ6IHBhc3N3b3JkIH07ICAvLyBwb3N0bWFuXG5cbiAgaWYoIXVzZXIuZW1haWwpIHtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MjIpLmpzb24oe1xuICAgICAgZXJyb3JzOiB7XG4gICAgICAgIGVtYWlsOiAnaXMgcmVxdWlyZWQnLFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYoIXVzZXIucGFzc3dvcmQpIHtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MjIpLmpzb24oe1xuICAgICAgZXJyb3JzOiB7XG4gICAgICAgIHBhc3N3b3JkOiAnaXMgcmVxdWlyZWQnLFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICB3aGVyZToge1xuICAgICAgLi4udXNlclxuICAgIH0sXG4gICAgLy8gZGVmYXVsdHM6IHtcbiAgICAvLyAgICAgZW1haWw6ICdUZWNobmljYWwgTGVhZCBKYXZhU2NyaXB0JyxcbiAgICAvLyAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZCdcbiAgICAvLyAgIH1cbiAgfTtcblxuICByZXR1cm4gVXNlclxuICAgIC5maW5kT3JDcmVhdGUob3B0aW9ucylcbiAgICAuc3ByZWFkKCh1c2VyLCBjcmVhdGVkKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygn8J+alycsXG4gICAgICAgIHVzZXIuZ2V0KHtcbiAgICAgICAgICBwbGFpbjogdHJ1ZVxuICAgICAgICB9KSlcblxuICAgICAgY3JlYXRlZFxuICAgICAgICA/IGNvbnNvbGUubG9nKCdyb3V0ZSB0byBoZXJlJylcbiAgICAgICAgOiBjb25zb2xlLmxvZygncmV0dXJuIG9yIHRocm93IGVycm9yJyk7XG5cblxuICAgIH0pXG4gICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZygnZXJyJywgZXJyKSk7XG59XG5cbmV4cG9ydCBjb25zdCBhY3RpdmF0ZVBhc3Nwb3J0VmFsaWRhdGVVc2VyID0gKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gIGNvbnN0IHsgYm9keTogeyB1c2VyIH0gfSA9IHJlcTtcblxuICBpZighdXNlci5lbWFpbCkge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQyMikuanNvbih7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgZW1haWw6ICdpcyByZXF1aXJlZCdcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpZighdXNlci5wYXNzd29yZCkge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQyMikuanNvbih7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgcGFzc3dvcmQ6ICdpcyByZXF1aXJlZCcsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhc3Nwb3J0LmF1dGhlbnRpY2F0ZSgnbG9jYWwnLCB7IHNlc3Npb246IGZhbHNlIH0sIChlcnIsIHBhc3Nwb3J0VXNlciwgaW5mbykgPT4ge1xuICAgIGlmKGVycikge1xuICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICB9XG5cbiAgICBpZihwYXNzcG9ydFVzZXIpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBwYXNzcG9ydFVzZXI7XG4gICAgICB1c2VyLnRva2VuID0gcGFzc3BvcnRVc2VyLmdlbmVyYXRlSldUKCk7XG5cbiAgICAgIHJldHVybiByZXMuanNvbih7IHVzZXI6IHVzZXIudG9BdXRoSlNPTigpIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0dXMoNDAwKS5pbmZvO1xuICB9KShyZXEsIHJlcywgbmV4dCk7XG59XG5cbmV4cG9ydCBjb25zdCBsb2dnZWRJbk9ubHkgPSAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgY29uc3QgeyBwYXlsb2FkOiB7IGlkIH0gfSA9IHJlcTtcblxuICByZXR1cm4gVXNlci5maW5kQnlJZChpZClcbiAgICAudGhlbigodXNlcikgPT4ge1xuICAgICAgaWYoIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zZW5kU3RhdHVzKDQwMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXMuanNvbih7IHVzZXI6IHVzZXIudG9BdXRoSlNPTigpIH0pO1xuICAgIH0pO1xufSIsImltcG9ydCBmcyBmcm9tIFwiZnNcIjtcblxuLy8gZXhwb3J0cy5hZGRTdG9yZSA9IChyZXEsIHJlcykgPT4ge1xuLy8gICByZXMud3JpdGVIZWFkKDIwMCwgeyAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCd9KTtcbi8vICAgZnMucmVhZEZpbGUoJy4vc3JjL2luZGV4Lmh0bWwnLCAoZXJyLCBkYXRhKSA9PiB7XG4vLyAgICAgZXJyXG4vLyAgICAgICA/IHJlcy5zZW5kKCdmaWxlIG5vdCBmb3VuZCcpXG4vLyAgICAgICA6IHJlcy53cml0ZShkYXRhKTtcbi8vICAgICByZXMuZW5kKCk7XG4vLyAgIH0pO1xuLy8gfTtcblxuZXhwb3J0IGNvbnN0IGFkZFN0b3JlID0gKHJlcSwgcmVzKSA9PiB7XG4gIHJlcy5zZW5kRmlsZSgnaW5kZXguaHRtbCcsIHtcbiAgICByb290OiAnLi9kaXN0J1xuICB9KTtcbn07XG4iLCJpbXBvcnQgbXVsdGVyIGZyb20gJ211bHRlcic7XG5pbXBvcnQgamltcCBmcm9tICdqaW1wJztcbmltcG9ydCB1dWlkIGZyb20gJ3V1aWQnO1xuXG5jb25zdCBtdWx0ZXJPcHRpb25zID0ge1xuICBzdG9yYWdlOiBtdWx0ZXIubWVtb3J5U3RvcmFnZSgpLFxuICBmaWxlRmlsdGVyKHJlcSwgZmlsZSwgbmV4dCkge1xuICAgICAgLy8gY2FudCB0cnVzdCBmaWxlIGV4dGVuc2lvbnMsIGV2ZXJ5IHNpbmdsZSBmaWxlIGhhcyBhIG1pbWVUeXBlXG4gICAgICBjb25zdCBpc1Bob3RvID0gZmlsZS5taW1ldHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKTtcbiAgICAgIHJldHVybiBpc1Bob3RvID8gbmV4dChudWxsLCB0cnVlKSA6IG5leHQoeyBtZXNzYWdlOiBgdGhhdCBmaWxlIHR5cGUgaXNudCBhbGxvd2VkYCB9LCBmYWxzZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGxvYWQgPSBtdWx0ZXIobXVsdGVyT3B0aW9ucykuc2luZ2xlKCdwaG90bycpOyAvLyBjYWxscyBuZXh0IGF1dG9tYXRpY2FsbHlcblxuZXhwb3J0IGNvbnN0IHJlc2l6ZSA9IGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICBjb25zb2xlLmxvZygncmVzaXplIGhpdCEhIScpO1xuICAvLyBtdWx0ZXIgd2lsbCBwdWwgZmlsZSBlb24gcmVxIElGIGl0IGV4aXN0XG4gIHJldHVybiAhcmVxLmZpbGUgPyBuZXh0KCkgOiAneHgnO1xufTsiLCIvLyBleHBvcnRzLmV4YW1wbGVDb21wdXRhdGlvbiA9IChsYXN0TmFtZSkgPT4gbGFzdE5hbWUgPyBgJHtsYXN0TmFtZX0tamVua2luc2AgOiAnbm9Kb2UtamVua2lucyc7XG4vLyBjb25zdCBleGFtcGxlQ29tcHV0YXRpb24gPSAobGFzdE5hbWUpID0+IGxhc3ROYW1lID8gYCR7bGFzdE5hbWV9LWplbmtpbnNgIDogJ25vSm9lLWplbmtpbnMnO1xuZXhwb3J0IGZ1bmN0aW9uIGV4YW1wbGVDb21wdXRhdGlvbiAobGFzdE5hbWUpIHsgcmV0dXJuIGxhc3ROYW1lID8gYCR7bGFzdE5hbWV9LWplbmtpbnNgIDogJ25vSm9lLWplbmtpbnMnIH07XG5cbi8vIGV4cG9ydCBkZWZhdWx0IGV4YW1wbGVDb21wdXRhdGlvbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCBTZXF1ZWxpemUgZnJvbSAnc2VxdWVsaXplJztcbmNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShfX2ZpbGVuYW1lKTtcbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XG5jb25zdCBjb25maWcgPSByZXF1aXJlKF9fZGlybmFtZSArICcvLi4vY29uZmlnL2NvbmZpZy5qc29uJylbZW52XTtcblxuLy8gY29uc3QgZGIgPSB7fTtcblxuLy8gY29uc29sZS5sb2coJ/CfkLYnLCBjb25maWcuZGF0YWJhc2UsIGNvbmZpZy51c2VybmFtZSwgY29uZmlnLnBhc3N3b3JkLCBjb25maWcpXG5cbmNvbnN0IHsgZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VxdWVsaXplQ29uZmlnIH0gPSBjb25maWc7XG5cbmNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VxdWVsaXplQ29uZmlnKTtcblxuc2VxdWVsaXplXG4gIC5hdXRoZW50aWNhdGUoKVxuICAudGhlbigoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ+KchSBEYXRhYmFzZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgfSlcbiAgLmNhdGNoKGVyciA9PiB7XG4gICAgY29uc29sZS5lcnJvcign77iP4p2MIFVuYWJsZSB0byBjb25uZWN0IHRvIHRoZSBkYXRhYmFzZTonLCBlcnIpO1xuICB9KTtcblxuXG5jb25zdCBkYiA9IHt9O1xuXG5mc1xuICAgIC5yZWFkZGlyU3luYyhfX2Rpcm5hbWUpXG4gICAgLmZpbHRlcihmaWxlID0+IGZpbGUuaW5kZXhPZignLicpICE9PSAwICYmIGZpbGUgIT09ICdpbmRleC5qcycpXG4gICAgLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gc2VxdWVsaXplLmltcG9ydChwYXRoLmpvaW4oX19kaXJuYW1lLCBmaWxlKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5eS77iPIGRiIG1vZGVscycsIG1vZGVsLm5hbWUpO1xuICAgICAgICBkYlttb2RlbC5uYW1lXSA9IG1vZGVsO1xuICAgIH0pO1xuXG4vLyBjb25zb2xlLmxvZygnc2VxdWVsaXplIC0tPicsIHNlcXVlbGl6ZS5tb2RlbCk7XG4vLyBjb25zb2xlLmxvZygn8J+NnicsIFNlcXVlbGl6ZSlcblxuT2JqZWN0LmtleXMoZGIpLmZvckVhY2gobW9kZWxOYW1lID0+IHtcbiAgICBpZiAoJ2Fzc29jaWF0ZScgaW4gZGJbbW9kZWxOYW1lXSkge1xuICAgICAgICBkYlttb2RlbE5hbWVdLmFzc29jaWF0ZShkYik7XG4gICAgfVxufSk7XG5cbmRiLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbmRiLlNlcXVlbGl6ZSA9IFNlcXVlbGl6ZTtcblxuZXhwb3J0IGRlZmF1bHQgZGI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHNlcXVlbGl6ZSwgRGF0YVR5cGVzKSB7XG4gIGNvbnN0IFVzZXIgPSBzZXF1ZWxpemUuZGVmaW5lKCdVc2VyJywge1xuICAgIGVtYWlsOiBEYXRhVHlwZXMuU1RSSU5HLFxuICAgIGhhc2g6IERhdGFUeXBlcy5TVFJJTkcsXG4gICAgc2FsdDogRGF0YVR5cGVzLlNUUklORyxcbiAgICBwYXNzd29yZDogRGF0YVR5cGVzLlNUUklORyxcbiAgICBuYW1lOiBEYXRhVHlwZXMuU1RSSU5HLFxuICAgIGFnZTogRGF0YVR5cGVzLklOVEVHRVIsXG4gICAgZnJpZW5kczogRGF0YVR5cGVzLkVOVU0oJ2FsaWNlJywgJ2RvdWcnKSxcbiAgICBwb3B1bGFyOiBEYXRhVHlwZXMuQk9PTEVBTlxuICB9LFxuICB7XG4gICAgdGFibGVOYW1lOiAndXNlcicsXG4gICAgdGltZXN0YW1wczogdHJ1ZSxcbiAgfSk7XG5cbiAgLy8gPz8/PyBkb2VzbnQgcmV0dXJuIGFueXRoaW5nXG4gIFVzZXIuc2V0UGFzc3dvcmQgPSBmdW5jdGlvbihwYXNzd29yZCkge1xuICAgIHRoaXMuc2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpO1xuICAgIHRoaXMuaGFzaCA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCB0aGlzLnNhbHQsIDEwMDAwLCA1MTIsICdzaGE1MTInKTtcbiAgICBjb25zb2xlLmxvZygn8J+ngicsIHRoaXMuc2FsdCwgJ/CfjLbvuI8nLCB0aGlzLmhhc2gpO1xuICB9O1xuXG4gIFVzZXIudmFsaWRhdGVQYXNzd29yZCA9IGZ1bmN0aW9uKHBhc3N3b3JkKSB7XG4gICAgY29uc3QgaGFzaCA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCB0aGlzLnNhbHQsIDEwMDAwLCA1MTIsICdzaGE1MTInKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc29sZS5sb2coJ/CfjaAgaGFzaCcsIGhhc2gpO1xuICAgIHJldHVybiB0aGlzLmhhc2ggPSBoYXNoOyAvLyA8PT09PT0gdHJpcGxlIGVxdWFscyBtYXliZT9cbiAgfVxuXG4gIFVzZXIuZ2VuZXJhdGVKV1QgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgZXhwaXJhdGlvbkRhdGUgPSBuZXcgRGF0ZSh0b2RheSk7XG4gICAgZXhwaXJhdGlvbkRhdGUuc2V0RGF0ZSh0b2RheS5nZXREYXRlKCkgKiA2MCk7XG4gICAgY29uc29sZS5sb2coJ/Cfk4YgdG9kYXksIGV4cHJhdGlvbicsIHRvZGF5LCBleHBpcmF0aW9uRGF0ZSwgeHBpcmF0aW9uRGF0ZS5zZXREYXRlKHRvZGF5LmdldERhdGUoKSAqIDYwKSk7XG4gICAgY29uc29sZS5sb2coJ/CfjJ8nLCBwYXJzZUludChleHBpcmF0aW9uRGF0ZS5nZXRUaW1lKCkgLyAxMDAwLCAxMCkpO1xuXG4gICAgcmV0dXJuIGp3dC5zaWduKHtcbiAgICAgIGVtYWlsOiB0aGlzLmVtYWlsLFxuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgZXhwOiBwYXJzZUludChleHBpcmF0aW9uRGF0ZS5nZXRUaW1lKCkgLyAxMDAwLCAxMClcbiAgICB9LCAnc2VjcmV0Jyk7XG4gIH1cblxuICBVc2VyLnRvQXV0aEpTT04gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBqd3QgPSB0aGlzLmdlbmVyYXRlSldUKCk7XG4gICAgY29uc29sZS5sb2coJ3RoaXMuX2lkLCB0aGlzLmVtYWlsLCBqd3QnLCB0aGlzLl9pZCwgdGhpcy5lbWFpbCwgand0KTtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiB0aGlzLl9pZCxcbiAgICAgIGVtYWlsOiB0aGlzLmVtYWlsLFxuICAgICAgdG9rZW46IGp3dFxuICAgIH07XG4gIH1cblxuICAvLyBhZGQgYW4gYXNzb2NpYXRpb24gbGF0ZXJcbiAgVXNlci5hc3NvY2lhdGUgPSBmdW5jdGlvbihtb2RlbHMpIHtcbiAgICAvLyBhc3NvY2lhdGlvbnMgY2FuIGJlIGRlZmluZWQgaGVyZVxuICAgIC8vIFVzZXIuYmVsb25nc1RvKG1vZGVscy5UYXNrcywge1xuICAgIC8vICAgICAvLyBhczogJ2xhc3RVc2VyQWN0aW9uJyxcbiAgICAvLyAgICAgLy8gZm9yZWlnbktleTogJ2xhc3RfdXNlcl9hY3Rpb24nLFxuICAgIC8vICAgICAvLyBvbkRlbGV0ZTogJ2Nhc2NhZGUnLFxuICAgIC8vICAgICAvLyBob29rczogJ3RydWUnLFxuICAgIC8vICAgfVxuICAgIC8vICk7XG4gIH07XG4gIHJldHVybiBVc2VyO1xufTtcbiIsImltcG9ydCBleHByZXNzIGZyb20gJ2V4cHJlc3MnO1xuY29uc3Qgcm91dGVyID0gZXhwcmVzcy5Sb3V0ZXIoKTtcblxuaW1wb3J0IHsgbG9nVGhlTmFtZSwgaG9tZXBhZ2VFeGFtcGxlIH0gZnJvbSAnLi4vY29udHJvbGxlcnMvZXhhbXBsZUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgYWRkU3RvcmUgfSBmcm9tICcuLi9jb250cm9sbGVycy9zdG9yZUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgbmV3TW9kZWwsIGFjdGl2YXRlUGFzc3BvcnRWYWxpZGF0ZVVzZXIsIGxvZ2dlZEluT25seSB9IGZyb20gJy4uL2NvbnRyb2xsZXJzL25vZGVBdXRoQ29udHJvbGxlcic7XG5cbmltcG9ydCB7IHVwbG9hZCwgcmVzaXplIH0gZnJvbSAnLi4vY29udHJvbGxlcnMvdXBsb2FkJztcblxuaW1wb3J0IHsgbXlNaWRkbGV3YXJlLCBhdXRoIH0gZnJvbSAnLi4vY29udHJvbGxlcnMvbWlkZGxld2FyZUNvbnRyb2xsZXInO1xuXG4vLyByb3V0ZXIudXNlKCcvYXBpJywgcmVxdWlyZSgnLi9hcGknKSk7IC8vIGF1dGggd29ya3Mgbm93IHdlIG5lZWQgdG8gY3JlYXRlIGNvbnRyb2xsZXJzIGZvciBsb2dnaW5nIGluIGF1dGggb3B0aW5hbCBhbmQgYXV0aCByZXF1aXJlZCBmb3Igc3R1ZmYgeW91IHNob3VsZCBiZSBsb2dnZWQgaW4gZm9yXG5cbi8vIHJvdXRlci5wb3N0KCcvaG9tZScsIG5ld01vZGVsKTtcblxucm91dGVyLnBvc3QoJy91cGxvYWQnLCB1cGxvYWQsIHJlc2l6ZSwgYWRkU3RvcmUpOztcblxucm91dGVyLnBvc3QoJy9ob21lJywgYXV0aC5vcHRpb25hbCwgbmV3TW9kZWwpO1xuXG5yb3V0ZXIucG9zdCgnL2xvZ2luJywgYXV0aC5vcHRpb25hbCwgYWN0aXZhdGVQYXNzcG9ydFZhbGlkYXRlVXNlcik7XG5cbnJvdXRlci5wb3N0KCcvY3VycmVudCcsIGF1dGgucmVxdWlyZWQsIGxvZ2dlZEluT25seSk7XG5cbnJvdXRlci5nZXQoJy9sb2d0aGVuYW1lLzpwYXJhbU5hbWUnLCBsb2dUaGVOYW1lKTtcblxucm91dGVyLmdldCgnL2FkZCcsIGFkZFN0b3JlKTtcblxuLy8gKiogcm91dGUgc3BlY2lmaWMgbWlkZGxld2FyZVxucm91dGVyLmdldCgnLycsIG15TWlkZGxld2FyZSwgaG9tZXBhZ2VFeGFtcGxlKTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJvZHktcGFyc2VyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV4cHJlc3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXhwcmVzcy1qd3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXhwcmVzcy1zZXNzaW9uXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwianNvbndlYnRva2VuXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1pbWVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibWtkaXJwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm11bHRlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYWtvXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhc3Nwb3J0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhc3Nwb3J0LWxvY2FsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic2VxdWVsaXplXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dWlkXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInhtbDJqc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6bGliXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=